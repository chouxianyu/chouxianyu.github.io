<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-11.4模型无关的局部解释(LIME)]]></title>
    <url>%2F2021%2F04%2F24%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-11-4%E6%A8%A1%E5%9E%8B%E6%97%A0%E5%85%B3%E7%9A%84%E5%B1%80%E9%83%A8%E8%A7%A3%E9%87%8A-LIME%2F</url>
    <content type="text"><![CDATA[模型无关的局部解释（Local Interpretable Model-Agnostic Explanations，LIME）指使用一个Interpretable Model拟合一个Uninterpretable Model的局部，比如使用Linear Model或者Decision Tree模拟Neural Network。 具体来讲，对于局部范围内的相同输入，我们希望两个模型的输出尽可能接近。这里要重点强调局部范围的概念，因为实际上Linear Model并不能模拟整个Neural Network但却可以模拟其中的一个Local Region，这也是LIME可行的原因。 案例：使用Linear Model拟合Neural Network 定位：确定需要解释的data point(下图5个蓝点中最中间的蓝点) 取样：在上一步确定的data point周围sample获得更多的data point(下图5个蓝点) sample的范围需要根据情况调整，一般范围小则拟合得更准确 sample的方法不同，结果也会不同 拟合：使用Linear Model模拟上一步确定的data point及其对应的Neural Network输出 解释：对Linear Model进行解释，进而解释Neural Network的局部 案例：LIME For Image Classification如何将LIME应用到Image Classification呢？假设有一张图片被分类为frog，下面只讲一些关键点。 如何进行sample？ 首先可以将图片分成多个segment：$\{s_1,s_2,\dots,s_n\}$，随机去除其中的一些segment就可以得到该图片“周围”的一些图片 将LIME应用于图片时，一般要进行Feature Extraction，那如何做呢？ 使用$x_i$表示图片中的每个segment是否被删除，其中$i=1,…,n$，若$x_i$为1则表示该segment被删除，否则表示该segment未被删除 如何解释Linear Model？ 设Linear Model为$y=w_1x_1+..+w_nx_n$，$w_i$的值有以下3种情况 $w_i\approx 0$表示$s_i$对分类为frog没有影响； $w_i&gt; 0$表示$s_i$对分类为frog具有正面影响，即这个segment使得模型倾向于将图片分类为frog $w_i&lt;0$表示$s_i$对分类为frog具有负面影响，即这个segment使得模型倾向于认为该图片不是frog类别 Tree Regularization理论上可以用无深度限制的Decision Tree拟合完整的Neural Network，但Decision Tree的深度不可能没有限制，因此在使用Decision Tree拟合Neural Network时需要对Decision Tree的复杂度进行约束。 设Neural Network的参数为$\theta$、Decision Tree的参数为$T_\theta$，使用Decision Tree的平均深度表示其参数$T_\theta$的复杂度$O(T_\theta)$。在使用Decision Tree拟合Neural Network时，不仅要使两者输出相近还要使$O(T_\theta)$最小化，因此优化目标为$\theta^*=arg\ {\rm min}\ L(\theta) + \lambda O(T_\theta)$。 因此我们在训练神经网络时就可以使用Tree Regularization使得训练出的神经网络更具有可解释性，$O(T_\theta)$不能微分，解决方法详见《Beyond Sparsity: Tree Regularization of Deep Models for Interpretability》。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>ExplainableAI</tag>
        <tag>LIME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-11.3Explainable AI(Global Explanation)]]></title>
    <url>%2F2021%2F04%2F23%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-11-3Explainable-AI-Global-Explanation%2F</url>
    <content type="text"><![CDATA[假定在图片分类任务中，Global Explanation要求机器说明它认为一个类别(比如“cat”)是什么样子，而非针对一张图片进行解释。 Activation maximization在李宏毅机器学习课程笔记-7.2CNN学到了什么一文中，我们已讲过Activation maximization，不再复述，这里讲一些相关的新知识。 在Activation maximization的MNIST手写数字识别案例中，我们观察到机器学习到的数字在人类看来完全就是噪音，由此可以想到：将机器认为是数字(或其它事物)的内容作为噪声添加到其它数据中，也许这样就可以实现Attack。 在使用Activation maximization观察模型学习到的内容时，我们可能需要使用大量Regularization(保证“可解释性”)以及暴调超参数，详见《Understanding Neural Networks Through Deep Visualization》。 “Regularization” From Generator除了使用人工设置的Regularization来告诉机器什么是一张正常的输出(比如image)，还可以使用Generator进行Regularization。 Image Generator的输入是一个低维向量$z$，其输出为一张图片$x$，即$x=G(z)$。通常这个低维向量$z$是从某个已知的distribution(比如高斯分布、正态分布)中sample出来的，我们可以收集很多图片并使用GAN或者VAE训练这个Generator。 那如何使用Image Generator生成对图片的限制呢？以图片分类为例，将Generator输出的图片$x$输入到Image Classifier中得到输出分类结果$y_i$，目标是找到一个$z^$使得图片$x$属于对应类别$i$的可能性$y_i$最大，即$z^=arg \ max y_i$。得到$z^$之后将其输入至Image Generator就可以得到一个图片$x$。如果通过$x^=arg \ max y_i$直接得到图片呢，则不能保证结果的“可解释性”，因而需要对结果进行“可解释性”的约束，上述过程中Generator的作用就是对图片进行约束以确保生成的图片$x$是“可解释”的。 注：在进行$z^*=arg \ max y_i$时，Image Generator和Classifier的参数是不参与本次训练的。 那使用Generator能得到什么样的结果呢？结果挺好的，详见《Plug &amp; Play Generative Networks: Conditional Iterative Generation of Images in Latent Space》。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>ExplainableAI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-11.2Explainable AI(Local Explanation)]]></title>
    <url>%2F2021%2F04%2F22%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-11-2Explainable-AI-Local-Explanation%2F</url>
    <content type="text"><![CDATA[假定在图片分类任务中有一张图片，Local Explanation则要求机器说明为什么它认为这张图片是某个类别(比如“cat”)。 Explainable AI(Local Explanation)的目标是，知道每个component对于最终结果的重要性。我们可以通过remove或者modify其中一个component，看decision会有什么变化。 基于梯度判断Component重要性假设输入是$x$，它有很多component $\{x_1,x_2,\dots,x_N\}$组成。如果输入是image，则component一般是pixel、segment或patch等；如果输入是text，则component一般是word。对于图片，我们可以在图片上“放置”一个灰块以覆盖图像的一小部分，观察其对结果的影响，见《Visualizing and Understanding Convolutional Networks》。注：component的选取、remove或者modify也是需要研究的。 还有另一种方法是，输入为$\{x_1,…,x_n\}$，对某个pixel $x_n$加上$\Delta x$，用$\frac{\Delta y}{\Delta x}$来表示扰动$\Delta x$对结果$y$的影响，即通过$\frac{\partial y_k}{\partial x_n}$的绝对值表示某个pixel对$y_k$的影响，见《Deep Inside Convolutional Networks: Visualising Image Classification Models and Saliency Maps》。 还有很多其它基于梯度来判断Component重要性的方法： Grad-CAM SmoothGrad Layer-wise Relevance Propagation(LRP) Redistribute the output, Backward propagation until reaching input Guided Backpropagation 梯度饱和基于梯度来判断component重要性的方法也存在着局限性：梯度饱和(Gradient Saturation)和Noisy Gradient。 考虑$\frac{\partial大象}{\partial鼻子长度}$，可知在一定范围内，鼻子越长，则判定为大象的概率就越大，但随着鼻子长度增加到一定数值后，鼻子长度对于判定大象的影响几乎为0，这时就出现了梯度饱和，如下图所示。 那如何解决梯度饱和的问题呢？解决方法就是Global Explanation，可以参考Integrated gradient和DeepLIFT。 相对于梯度饱和，另外一个问题就是Noisy Gradient，即Gradient变化非常大，解决方法是SmoothGrad（在计算梯度时添加噪声以扰动生成多个样本，并计算平均梯度） Attack Interpretation向输入中加入一些细微的噪声，这样并不影响视觉效果和模型的输出，但这样可以攻击explanation，如下图所示，详见《Interpretation of Neural Networks is Fragile》。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>ExplainableAI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-11.1Explainable AI引言]]></title>
    <url>%2F2021%2F04%2F21%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-11-1Explainable-AI%E5%BC%95%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Explainable AI是什么我们希望，机器不仅要知道“是什么”还要知道“为什么”，或者说机器不仅要给出答案还要给出explanation。 Explanation可以分为两类： Local Explanation 假定在图片分类任务中有一张图片，要求机器说明为什么它认为这张图片是某个类别(比如“cat”)。 Global Explanation 假定在图片分类任务中，要求机器说明它认为一个类别(比如“cat”)是什么样子，而非针对一张图片进行解释。 Explainable AI有什么用在使用机器挑选简历时，我们需要知道机器为什么选择某份简历(性别?还是实力)。 在使用机器判定罪犯是否可以假释时，我们需要知道机器为什么判定是或否(实证?还是肤色)。 在使用机器判定是否给某人贷款时，我们需要知道机器为什么判定是或否。 通过Explainable AI，我们可以知道模型学到了什么从而进行模型诊断，对模型进行改进和调整。我们不仅只关注模型在数据集上的精确度，还需要进行模型诊断，因为有可能精确度很高但实际上机器什么都没学到。 Explainable AI是否有必要李宏毅老师认为Explainable AI的目标并非完全理解模型是如何work的，而是为了让人感到comfortable。 因为深度学习是一个黑盒所以有些人认为深度学习不可信，这有些因噎废食。人脑等很多事物对现在的人类来讲都也还是黑盒，完全理解模型的work机理不是必要的，因为某些东西是黑盒就不使用它也不行。 Explainable AI其实就是为了使老板、客户、自己等感到comfortable，甚至对不同人也应该有不同的解释。 Interpretable VS Powerful决策树既是interpretable又是powerful的，但当分支特别多的时候决策树的表现也会很差，这时可以使用Random Forest或者XGBoost，但它们虽然powerful但不interpretable。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>ExplainableAI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-10.4基于Smoothness假设的半监督学习]]></title>
    <url>%2F2021%2F04%2F19%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-10-4%E5%9F%BA%E4%BA%8ESmoothness%E5%81%87%E8%AE%BE%E7%9A%84%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Smoothness假设Smoothness假设的定义基于Smoothness假设的半监督学习的基本思路是“近朱者赤近墨者黑”，即相似的$x$具有相同的$\hat y$，其具体定义为： $x$的分布不平均，在某些地方(high density region)很集中，在某些地方很分散 如果$x^1$和$x^2$在一个high density region中距离非常近，则$x^1$和$x^2$通过1个high density path相连、$\hat y^1=\hat y^2$。 举一个例子，如下图所示，$x^1,x^2,x^3$是3个样本，如果单纯地看它们之间的相似度，显然$x^2$和$x^3$更接近一些。但对于smoothness assumption来说，$x^1$和$x^2$是位于同一个high density region中，它们之间有high density path；而$x^2$与$x^3$之间则是“断开”的，没有high density path，因此$x^1$与$x^2$更“像”。 手写数字识别举例再举一个手写数字识别和人脸识别的例子，如下图所示，最左侧的2、最右侧的2和最右侧的3，从pixel角度来看明显是最右侧的2和3更加相似(尽管两者并非是同一个数字)，但如果考虑最左侧的2朝着最右侧的2的演化过程，可以发现产生了一种“间接相似性”(high density path)。根据Smoothness假设，由于这6个2之间存在间接的相似而这6个2和最右侧的3之间不存在high density path，因此这6个2是彼此相似的；而最右侧的3和这6个2是不相似的。 文章分类举例假设对天文学(astronomy)和旅行(travel)的文章进行分类，它们有各自的专属词汇，此时如果unlabeled data与label data的词汇是相同或重合(overlap)的，那么就很容易分类；但真实情况中unlabeled data和labeled data之间可能没有任何重复的word，因为世界上的词汇太多了，sparse的分布中overlap难以发生。 但如果unlabeled data足够多，就会以一种相似传递的形式，建立起文档之间相似的桥梁。 cluster and then label如何实现基于Smoothness假设的半监督学习呢？在具体实现上，最简单的方式是cluster and then label。 cluster and then label就是先把所有样本(包括有标签样本和无标签样本)分成几个cluster，然后根据每个cluster中各类别有标签样本的数量确定该cluster中所有样本的label，然后进一步用这些cluster学习得到分类器。 这种方法不一定会得到好的结果，因为该方法有个前提是我们能够把同类别的样本分到同一个cluster，而这并不容易。对图像分类来说，如果仅仅依据pixel-wise相似度来划分cluster，得到的结果一般都会很差。所以为了满足这个前提，我们需要设计较好的方法来描述一张图片(比如使用Deep Autoencoder提取图片特征feature)，以保证cluster时能够将同类别的样本分到同一个cluster。 Graph-based Approachhigh density path如何实现基于Smoothness假设的半监督学习呢？我们可以将每个样本视为图中的1个点，通过图来表示connected by a high density path。Graph-based方法的基本思路是图中的有标注样本会影响与它们邻近的无标注样本并在图中产生“间接相似性”，即使某些无标注样本没有直接与有标注样本相连也仍然可以被判定为相似。如果想要让这种方法生效，收集到的数据一定要足够多，否则可能导致无法形成path、失去了information的传递效果。 如何建立一张图有时候点之间的边是比较好建立的(比如网页超链接、论文引用)，有时候需要我们自行建立点之间的边。图的好坏对最终结果的影响是非常关键的，但如何建图是一件heuristic的事情，需要我们凭经验和直觉来做，建图步骤如下： 定义两个样本$x^i,x^j$之间的相似度计算方法$s(x^i,x^j)$ 如果是基于pixel-wise的相似度，那结果可能比较差，建议使用更好的方法(比如使用Autoencoder提取图片特征，并基于提取到的特征计算相似度)。 推荐使用的相似度计算方法为高斯径向基函数(Gaussian Radial Basis Function)：$s(x^i,x^j)=exp(-\gamma||x^i-x^j||^2)$，其中$x^i,x^j$均为vector。经验上来说exp(exponential)通常是可以帮助提升性能的，因为它使得仅当$x^i,x^j$非常接近时similarity才会大、只要距离稍微远一点similarity就会迅速变小，也就是使用exponential可以做到只有非常近的两个点才能相连、稍微远一点就无法相连的效果。 建立点和点之间的边 k-Nearest Neighbor(K近邻算法) 在特征空间中，如果一个样本附近的k个最近样本的大多数属于某一类别，则该样本也属于这个类别 e-Neighborhood 设置点和点之间边的权重 一条边的权重应该和该边两个顶点的相似度成比例 如何定量地评估一个图符合Smoothness假设的程度那如何定量地评估一个图符合Smoothness假设的程度呢？ 如上图所示，我们定义1个图的Smoothness为$S=\frac{1}{2}\sum_{i,j}w_{i,j}(y^i-y^j)^2$并希望它越小越好，其中$i,j$为所有样本点的索引、$x^i$表示样本的特征、$y^j$表示样本的标注(有可能是伪标签)、$w_{i,j}$是2个样本之间边的权重、$\frac{1}{2}$只是为了方便计算。 上式Smoothness定义还可以表示为$S=y^TLy$，其中$y$是1个(R+U)-dim的vector：$y=[\dots,y^i,\dots,y^j,\dots]^T$、$L$是1个(R+U)×(R+U)的矩阵(名字叫做Graph Laplacian)。 Graph Laplacian的定义为$L=D-W$，其中$W_{i,j}$为2个样本点之间边的权重，把$W$每行元素之和放在该行对应的对角线上其它元素值为0即可得到$D$，如上图所示。在图神经网络(Spectral-based Convolution)中，有关于Graph Laplacian的介绍。 如何训练Smoothness定义$S=y^TLy$中$y$是模型的输出(预测得到的类别)，它是取决于模型参数的，因此训练时仅需在有标注数据的损失函数上加上Smoothness即可：$L=\sum_{x^r}C(y^r,\hat y^r)+\lambda S$，其中$\lambda S$可以被视为正则项。 由上可知，训练目标为： 有标注数据的交叉熵越小越好，即模型的输出与标注越接近越好 所有数据的Smoothness越小越好，即不管是有标注数据还是无标注数据，模型输出都要符合Smoothness Assumption的假设 注：训练时可以不仅仅要求整个模型的输出层要smooth，还可以对模型中任意一个隐藏层加上smooth的限制。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>半监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-10.3基于Low-density Separation假设的半监督学习]]></title>
    <url>%2F2021%2F04%2F18%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-10-3%E5%9F%BA%E4%BA%8ELow-density-Separation%E5%81%87%E8%AE%BE%E7%9A%84%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[按照“非黑即白”的思路，假设类别之间的boundary周围的data是很少的，即假设不同类别数据之间应该有1个很明显的boundary。 Self-training最简单的基于Low-density Separation假设的半监督学习是Self-training。 使用有标签的数据训练1个模型$f^*$，模型类型和训练方式没有限制，神经网络、深或浅、其它机器学习方法等等都可以 使用模型$f^$生成未标注数据的伪标签(Pseudo-label)，即$y^u=f^(x^u)$ 取出一部分未标注数据将它们添加到有标签数据中，然后回到步骤1 如何选择未标注数据仍然是一个open question，可以自行设计策略，比如给每个样本一个置信度。 Self-training和生成模型中的半监督学习(见上1篇文章)还挺像的，它们的区别在于： Self-training使用hard label，即假定某个无标签样本一定属于某个类别(“非黑即白”) 生成模型使用soft label，即假定某个无标签样本有一定概率属于某类别(也可以理解为一个样本可以按照后验概率划分成多个部分，不同部分属于不同类别) Self-training使用了hard label，它并不适用于regression。 生成模型使用了soft label，它生成的伪标签在分类任务中是没有用的。因为把某个无标签样本(通过soft label生成伪标签)丢进模型重新训练模型，模型参数根本不会发生变化。 实际上，low-density separation就是通过hard label来提升分类效果的方法。 Entropy-based Regularization该方法是Self-training的进阶版。 Self-training中使用的hard label还是有些武断和激进，Entropy-based Regularization对此进行了改进。 在使用神经网络进行分类时，$y^u=f^_{\theta^}(x^u)$，其中$y_u$是1个one-hot编码。现在我们并不限制其必须是某个类别，而是将其看做1个分布，我们希望这个分布越集中越好(“非黑即白”)，因为分布越集中时它的含义就是样本$x^u$属于某类别的概率很大属于其它类别的概率很小。 我们可以使用Entropy评估分布$y^u$的集中程度$E(y^u)=-\sum_{m=1}^5y_m^uln(y_m^u)$，假设是5分类，其值越小则表示分布$y^u$越集中。 无监督分类的目标为有标签数据分类正确、无标签数据分类结果集中，所以损失函数则为$L=\sum_{x^r}C(y^r,\hat y^r)+\lambda\sum_{x^u}E(y^u)$，其中第1项为有标签数据的交叉熵损失、第2项为无标签数据的entropy、$\lambda$表示无标签数据的损失权重，因为式中第2项的作用类似于regularization，所以该方法被称为Entropy-based Regularization。 Semi-supervised SVMSVM为两个类别的数据找到一个boundary，该boundary与两个类别的margin最大、分类错误最小。 Semi-supervised SVM穷举所有无标签数据的类别并进行计算，最终选择与两个类别的margin最大、分类错误最小的boundary。 在数据量大的时候，Semi-supervised SVM难以穷举出所有情况，但还有一种求近似解的方法，其大致思路是初始化一些label，然后每次尝试改动1个样本的label并判断是否更优，如果更优则改变该样本的label，具体见Transductive Inference for Text Classification using Support Vector Machines。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>半监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-10.2生成模型中的半监督学习]]></title>
    <url>%2F2021%2F04%2F17%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-10-2%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[生成模型中的半监督学习：Semi-supervised Learning for Generative Model 有监督生成模型有监督生成模型：Supervised Generative Model 如下图所示，在有监督生成模型中，得到$P(C_1),P(C_2),\mu^1,\mu^2,\Sigma$后，就可以计算出$x$属于类别$C_i$的概率$P(C_i|x)$。 半监督生成模型半监督生成模型：Semi-supervised Generative Model 基于有监督生成模型，当有了无标签数据之后(下图中绿色圆点)，我们会明显发现有监督生成模型中的$P(C_1),P(C_2),\mu^1,\mu^2,\Sigma$并不够正确，比如2个类别的分布应该接近于下图中虚线圆圈、先验概率$P(C_1)$应该小于$P(C_2)$，所以应该使用无标签数据重新估计$P(C_1),P(C_2),\mu^1,\mu^2,\Sigma$。 直观理解具体来讲，按照以下步骤进行计算： 初始化参数：$\theta=\{P(C_1),P(C_2),\mu^1,\mu^2,\Sigma\}$ 可以随机初始化，也可以用有标签数据估算 通过$\theta$计算每个样本$x^u$属于类别$C_i$的概率$P_\theta(C_i|x^u)$ 更新参数$\theta$（其实重点就是如何同时利用有标签数据和无标签数据实现半监督） $P(C_1)=\frac{N_1+\sum_{x^u}P(C_1|x^u)}{N}$，其中$N$是所有样本的数量、$N_1$是属于类别$C_1$的样本的数量。 $\mu^1=\frac{1}{N_1}\sum_{x^r\in C_1}x^r+\frac{1}{\sum_{x^u}P(C_1|x^u)}\sum_{x^u}P(C_1|x^u)x^u$，其中$x^r,x^u$分别指有标签的样本和无标签的样本 同理可知其它参数的计算和更新方法 返回第2步 理论上，上述步骤是可以收敛的，但参数$\theta$的初始化值会影响结果。其实上面的第2步是EM算法中的E，第3步是EM算法中的M。 理论推导$\theta=\{P(C_1),P(C_2),\mu^1,\mu^2,\Sigma\}$ Maximum likelihood with labelled data 使得$logL(\theta)=\sum_{x^r}logP_\theta(x^r, \hat y^r)$最大(有一个Closed-form solution)，其中每个有标注样本$x^r$的$P_\theta(x^r,\hat y^r)=P_\theta(x^r|\hat y^r)P(\hat y^r)$。 Maximum likelihood with labelled &amp; unlabeled data 使得$logL(\theta)=\sum_{x^r}logP_\theta(x^r, \hat y^r)+\sum_{x^u}logP_\theta(x^u)$最大(该式并不是凹函数，所以需要迭代求解)，其中每个无标注样本$x^u$的$P_\theta(x^u)=P_\theta(x^u|C_1)P(C_1)+P_\theta(x^u|C_2)P(C_2)$ Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>半监督学习</tag>
        <tag>概率生成模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-10.1半监督学习简介]]></title>
    <url>%2F2021%2F04%2F16%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-10-1%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[有监督学习(Supervised Learning)训练集数据为$\{ (x^r,\ \hat y^r) \}_{r=1}^R$，其中每组数据包括算法的输入与输出(标签)。 半监督学习(Semi-supervised Learning)训练集数据为$\{ (x^r,\ \hat y^r) \}_{r=1}^R+\{ x^u\}_{u=R+1}^{U+R}$，即其中部分数据有标签而大量数据没有标签($U&gt;&gt;R$)。 半监督学习可以分为以下2种情况 Transductive Learning unlabeled data is the testing data，只使用testing data中的feature，并没有使用testing data中的label，所以并没有cheating。 适用于已知testing data的情况，比如kaggle比赛。 Inductive Learning unlabeled data is not the testing data，完全不使用testing data。 适用于testing data未知的情况，这是大多数情况。 为什么需要半监督学习其实缺的并不是数据，缺少的是有标签的数据。利用这些大量的没有标签的数据进行学习，这是非常有价值的。 为什么半监督学习有用The distribution of the unlabeled data tell us something：无标注数据的分布可以告诉我们一些东西 半监督学习往往伴随着假设，而该假设的合理与否决定了结果的好坏程度。如上图所示，在猫狗图片分类中一只狗被认为是一只猫，这很可能是由于这2张图片的背景都是绿色，因此假设的合理性至关重要。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>半监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-9.6基于RNN和PyTorch的文本情感分类]]></title>
    <url>%2F2021%2F04%2F15%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-9-6%E5%9F%BA%E4%BA%8ERNN%E5%92%8CPyTorch%E7%9A%84%E6%96%87%E6%9C%AC%E6%83%85%E6%84%9F%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[本文为作者学习李宏毅机器学习课程时参照样例完成homework4的记录。 全部课程PPT、数据和代码下载链接： 链接：https://pan.baidu.com/s/1n_N7aoaNxxwqO03EmV5Bjg 提取码：tpmc 代码仓库：https://github.com/chouxianyu/LHY_ML2020_Codes 任务描述 通过RNN实现文本情感分类(Text Sentiment Classification)。 数据集描述 输入是1个句子，输出是0(负面)或1(正面)。 训练集：标注数据20万，无标注数据120万 测试集：20万(无标注) 数据格式 training_label.txt：label +++$+++ sentence，其中+++$+++只是分隔符 training_nolabel.txt：每一行就是一个句子，没有label testing_data.txt： 数据预处理 一个句子(sentence)中有多个word，我们需要通过Word Embedding(我的其它文章里有介绍)用一个vector表示一个word， 然后使用RNN得到一个表示该sentence的vector。 半监督学习 这里使用一种半监督学习方法：Self-Training(我的其它文章里有介绍)。使用有标签数据训练好模型，然后对无标签数据进行预测，并根据预测结果对无标签数据进行标注(“伪标签”)并继续训练模型 第三方库 使用Python第三方库gensim实现word2vec模型，以进行Word Embedding。 代码 https://github.com/chouxianyu/LHY_ML2020_Codes/tree/master/hw4_RNN Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>PyTorch</tag>
        <tag>循环神经网络</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-9.5详解基于LSTM的RNN]]></title>
    <url>%2F2021%2F04%2F14%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-9-5%E8%AF%A6%E8%A7%A3%E5%9F%BA%E4%BA%8ELSTM%E7%9A%84RNN%2F</url>
    <content type="text"><![CDATA[1层LSTM神经元的架构根据上述内容，你可能看不出LSTM与RNN有什么关系，接下来具体介绍LSTM在RNN中的应用。 假设我们现在有一些LSTM（下图中白色部分）作为神经元，每个LSTM的memory cell里都存了一个scalar值（下图中红框中内容），把这些scalar连接起来就组成了1个vector $c^{t-1}$，即关于上个input（时间点为t-1）的memory。 在时间点t，输入为1个vector $x^t$，它会经过4个线性的transform得到$z^f,z^i,z,z^o$，$z^f,z^i,z,z^o$这4个vector的dimension数量和LSTM神经元的数量相等，这4个vector的1个dimension即为1个LSTM神经元的输入（4个vector的第1个dimension为第1个LSTM神经元的输入）。 1个LSTM神经元的运算方法下图是单个LSTM神经元的运算方法，其4个input分别是$z$、$z^i$、$z^f$和$z^o$的其中1维（1维为1个神经元的输入）。每个LSTM神经元的input是各不相同的，但它们可以共同运算。 1个LSTM神经元的运算方法如下图所示。 $f(z^f)$与上一个时间点的memory $c^{t-1}$对应的cell值相乘，加上$g(z)$与$f(z^i)$的乘积，得到该时刻该cell中的值$c^t$，最终再乘以output gate的信号$f(z^o)$，得到输出$y^t$。 1个LSTM神经元在相邻时刻时的运算方法 上图是同1个LSTM神经元在2个相邻时刻的运算方法，其中与前文描述略有不同的是，这里还需要把当前时刻该神经元的输出$y^t$以及该神经元中cell保存的值$c^t$（peephole）都连接到下一时刻的输入上。因此在$t+1$时刻，神经元不只是考虑当前的输入$x^{t+1}$，还要看前一时刻该神经元的输出$h^t$和cell保存值$c^t$。 如何考虑结合$t+1$时刻的输入$x^{t+1}$和上一时刻该神经元的信息$h^t,c^t$呢？====&gt;把$x^{t+1}$、$h^t$和$c^t$这3个vector并在一起，乘上4个不同的转换矩阵，得到该神经元$t+1$时刻的4个输入$z$、$z^i$、$z^f$、$z^o$。 多层LSTM在相邻时刻的运算方法 上图中左边一列的2个LSTM代表2层LSTM，右边一列的2个LSTM则代表它们在下一时刻的状态。即横向是时间轴，纵向是层轴。 虽然看起来很复杂，感觉不一定work，但LSTM在RNN中已成为了标准做法。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>循环神经网络</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-9.4LSTM入门]]></title>
    <url>%2F2021%2F04%2F13%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-9-4LSTM%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[LSTM即Long Short-term Memory。 基本概念前几篇文章提到的RNN都比较简单，可以任意读写memory，没有进一步对memory进行管理。现在常用的memory管理方式是LSTM。正如其名，LSTM是比较长的短期记忆，-是在short和term之间。前几篇提到的RNN在有新的输入时都会更新memory，这样的memory是非常短期的，而LSTM中可以有更久之前的memory。 如上图所示，LSTM中有3个gate、4个输入(3个gate控制信号和1个想要写入memory cell的值)和1个输出： input gate：当某个neuron的输出想要被写进memory cell，它要先经过input gate。如果input gate是关闭的，则任何内容都无法被写入。input gate的关闭与否、什么时候开闭是由神经网络学习到的。 output gate：output gate决定了外界是否可以从memory cell中读取数据。当output gate关闭的时候，memory里面的内容无法被读取。output gate的关闭与否、什么时候开闭也是由神经网络学习到的。 forget gate：forget gate决定什么时候需要把memory cell里存放的内容忘掉，什么时候要保存。这也是由神经网络学习到的。 LSTM计算式下图展示了LSTM的计算式。 $z$是想要被存到memory cell里的值 $z_i$是input gate的控制信号 $z_o$是output gate的控制信号 $z_f$是forget gate的控制信号 $a$是综合上述4个输入得到的输出值 $z$、$z_i$、$z_o$和$z_f$通过激活函数分别得到$g(z)$、$f(z_i)$、$f(z_o)$和$f(z_f)$，其中$z_i$、$z_o$和$z_f$的激活函数$f()$一般会选sigmoid函数，因为其输出在0~1之间，可表示gate的开启程度。 令$g(z)$与$f(z_i)$相乘得到$g(z)f(z_i)$，然后把原先存放在memory cell中的$c$与$f(z_f)$相乘得到$cf(z_f)$，两者相加得到存在memory cell中的新值$c’=g(z)f(z_i)+cf(z_f)$。 若$f(z_i)=0$，则相当于并不使用输入$z$更新memory；若$f(z_i)=1$，则相当于直接输入$g(z)$。 若$f(z_f)=1$，则不忘记memory cell中的原值$c$；若$f(z_f)=0$，则原值$c$将被遗忘清除。 可以看出，forget gate的逻辑与直觉是相反的，该控制信号打开表示记得原值，关闭却表示遗忘。这个gate取名为remember gate更好些。 此后，$c’$通过激活函数得到$h(c’)$，与output gate的$f(z_o)$相乘，得到输出$a=h(c’)f(z_o)$。 Apply LSTM to NN上述的LSTM应该如何应用于神经网络呢？其实直接把LSTM作为1个神经元就可以了。假设输入层有2个标量输入$x_1,x_2$，隐藏层中有2个神经元，每个神经元输出1个标量，则其结构如下图所示。 标量输入$x_1,x_2$乘以4个参数得到4个值，这4个值作为LSTM的4个input。 在普通的神经元中，1个input对应1个output；而在LSTM中4个input才产生1个output，并且所有的input都是不相同的。 LSTM所需要的参数量是普通NN的4倍。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>循环神经网络</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-9.3RNN的应用]]></title>
    <url>%2F2021%2F04%2F12%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-9-3RNN%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在Slot Filling中，输入是1个word vector，输出是每个word的label，输入和输出是等长的。 然而，RNN还可以实现多对1、多对多… Many to OneMany to One：输入是1个vector sequence，输出是1个vector Sentiment Analysis 输入1篇文章或1句话等（1个vector sequence），输出其情感倾向（分类或者回归，比如超好、好、普通、差、超差、[-1,1]）。 Key Term Extraction 输入是1篇文章等，输出是几个关键词。 Many to ManyMany to Many：输入和输出都是sequence，但输出更短 比如Speech Recognition。输入是1段声音信号，每隔1小段时间（通常很短，比如0.01秒）就用1个vector表示，输出是1段文字。因此输入是1个vector sequence，而输出是1个charactor sequence，并且输入序列要比输出序列短。 如果仍然使用Slot Filling的方法，就只能做到输入的每个vector对应输出1个character，输入1句“好棒”的语音后可能输出文字“好好棒棒棒”，但其实应该输出文字“好棒”。我们可以通过Trimming去除输出中相同的character，但语音“好棒”和语音“好棒棒”是不同的，应该如何区分呢？可以用CTC(Connectionist Temporal Classification)，其基本思路是可以在输出中填充NULL，最终输出时删除NULL即可。 如上图所示，输入中vector的数量多于label中character的数量，那CTC应该怎么训练呢？答案是假设所有的可能性都是对的。 Many to ManySequence to Sequence Learning with Neural Networks：输入和输出都是sequence，但两者长度不确定。 以机器翻译为例，RNN要将英文的word sequence翻译成中文的character sequence（并不知道哪个sequence更长或更短）。 如上图所示，假设RNN的输入“machine learning”，在2个时间点分别输入”machine”和”learning”，在最后1个时间点时memory中就存储了整个word sequence的信息。接下来让RNN输出，得到“机”，然后把“机”当做input（这1步有很多极技巧，这里省略），并读取memory中的信息，就会输出“器”，以此类推，RNN会一直输出但不知道什么时候停止。那怎么让RNN停止输出呢？可以添加1个symbol===标志停止，当RNN输出这个symbol时就停止输出。 Seq2Seq for Syntatic ParsingGrammar as a Foreign Langauage： 输入为1个word sequence，输出1个语法树（可以用sequence表示）。 Seq2Seq Auto-encoder for Text如果用bag-of-word来表示1段文本，就容易丢失word之间的联系和语序上的信息。比如“白血球消灭了感染病”和“感染病消灭了白血球”这2段文本语义完全相反但bag-of-word是相同的。 A Hierarchical Neural Autoencoder for Paragraphs and Documents：可以使用Seq2Seq Autoencoder，在考虑语序的情况下把文章编码成vector，只需要将RNN作为编码器和解码器即可。 如上图所示，word sequence输入RNN后被编码成embedded vector，然后再通过另1个RNN解码，如果解码后能得到一模一样的句子，则编码得到的vector就表示了这个word sequence中最重要的信息。 如上图所示，这个过程可以是分层的（hierarchical），可以将每1个sentence编码成1个vector然后将它们加起来得到表示整个document的vector，然后再通过它产生多个setence的vector，然后将多个setence的vector解码得到word sequence。这是1个4层的LSTM（word sequence-sentence sequence-document-sentence sequence-word sequence）。 Seq2Seq Auto-encoder比较容易得到文法的编码，而Skip Thought（输入1个句子，输出其下1句）更容易得到语义的意思。 Seq2Seq Auto-encoder for SpeechAudio Word2Vec: Unsupervised Learning of Audio Segment Representations using Sequence-to-sequence Autoencoder Seq2Seq Auto-encoder还可以用在语音上，它可以把1个audio segment(word-level)编码成1个fixed-length vector。这有什么用处呢？它可以基于语音之间的相似度做语音搜索。 那如何基于语音之间的相似度做语音搜索呢？如上图所示，假如有1个语音的database，可将其划分为audio segments（长度可变），然后使用Seq2Seq Auto-encoder将其编码为1个fixed-length vector。对于1段需要搜索的语音，通过Seq2Seq Auto-encoder将其编码成1个fixed-length vector，计算其与database中audio segments的vector的相似度。 那如何把1个audio segment编码成1个fixed-length vector呢？如上图所示，首先把audio segment转换为acoustic feature sequence，然后输入至RNN。该RNN作为Encoder，在最后1个时间点其memory中的值就代表整个acoustic feature sequence，这就是我们想要的vector。但是只有这个作为Encoder的RNN我们没有办法训练，所以还要训练1个作为Decoder的RNN。该RNN作为Decoder，以Encoder在最后1个时间点时memory中的vector为输入，然后输出1个acoustic feature sequence，训练目标是输出的acoustic feature sequence和输入的acoustic feature sequence越接近越好。由此可知，该例中Encoder和Decoder是要同时训练的。 Attention-based Model 專家發現，小兒失憶現象是由於動物的大腦在神經新生的過程中，處於不斷重組的狀態，為減少太多訊息的干擾，會不斷清除舊記憶，從而增加對新事物的學習能力。年幼小鼠的記憶保留能力所以低下，乃因其高度活躍的神經再生所致，而成年小鼠保留記憶能力的增加，也由於其大腦相對成熟，海馬體的神經再生活力已經下降。腦科學家既然可以抑制年幼小鼠海馬體的高度活躍神經再生活力，又可刺激成年小鼠海馬體增加其神經再生活力。 ——————引自http://henrylo1605.blogspot.com/2015/05/blog-post_56.html 现在除了RNN之外，Attention-based Model也用到了memory的思想。机器也可以有记忆，神经网络通过操控读/写头去读/写信息，这个就是Neural Turing Machine。 Reading ComprehensionAttention-based Model常常用在Reading Comprehension上，让机器读1篇document，再把每个setence变成代表语义的vector，接下来让用户向机器提问，神经网络就会去调用读写头，取出memory中与查询语句相关的信息，综合处理之后，可以给出正确的回答。 Visual Question AnsweringSpeech Question Answering Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>循环神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-9.2如何训练RNN]]></title>
    <url>%2F2021%2F04%2F11%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-9-2%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83RNN%2F</url>
    <content type="text"><![CDATA[RNN的损失函数仍然以Slot Filling为例，如下图所示。 对于1个word$x^i$，RNN输出1个one-hot编码的vector $y^i$，求$y^i$和对应label的交叉熵损失（Cross Entropy Loss），将多个word的loss求和即为RNN的损失函数。需要注意的是不能打乱word的语序，$x^{i+1}$要紧接着$x^i$输入。 确定RNN的损失函数后，RNN的训练其实也是用的梯度下降。训练前馈神经网络时我们使用有效的反向传播算法，为了方便地训练RNN，我们使用BPTT。基于BP，BPTT(Backpropagation Through Time)考虑了时间维度的信息。 RNN的Error SurfaceRNN的Error Surface如下图所示，其中$z$轴代表loss，$x$轴和$y$轴代表两个参数$w_1$和$w_2$。可以看出，RNN的Error Surface在某些地方非常平坦，在某些地方又非常的陡峭。这样的Error Surface导致在训练RNN时loss剧烈变化。 问题出现的原因既然RNN的Error Surface中有这么平滑的地方，那会不会是sigmoid激活函数造成的梯度消失呢？原因并不是sigmoid，如果是的话，那换成ReLU就可以，但把sigmoid换成ReLU之后，效果反而更差了。那到底为什么会有非常陡峭和非常平滑的地方呢？ 如上图所示，假设某RNN只含1个神经元，并且该神经元是Linear的，input和output的weight都是1，没有bias，memory传递的weight是$w$，输入序列为[1, 0, 0, 0, …, 0]，所以$y^{1000}=w^{999}$。 现在我们考虑loss关于参数$w$的梯度，当$w:\ 1\ =&gt;\ 1.01$时，可知$y^{1000}:\ 1\ =&gt;\ 20000$，此时梯度很大；当$w:\ 0.99\ =&gt;\ 0.01$时，可知$y^{1000}$几乎没有变化，此时梯度很小。 从该例中可知，RNN的Error Surface中的“悬崖”出现的原因是，关于memory的参数$w$的作用随着时间增加不断增强，导致RNN出现梯度消失或梯度爆炸的问题。 处理方法如何解决RNN梯度消失或梯度爆炸的问题？可以通过Clipping进行处理，Clipping的效果是使梯度不超过某个阈值，即当梯度即将超过某个阈值（比如15）时，就将梯度赋值为该阈值。 LSTM有什么更好的方法可以解决RNN的Error Surface中的问题呢？LSTM就是使用最广泛的技巧，它可以“删除”Error Surface中比较平坦的部分，也就解决了梯度消失的问题，但它无法解决梯度爆炸的问题。正因如此，训练LSTM时需要将学习率调得特别小。 LSTM为什么可以解决RNN中梯度消失的问题呢，因为RNN和LSTM对memory的处理是不同的（LSTM有forget gate）。在RNN中，每个时间点memory中的旧值都会被新值覆盖，导致参数$w$对memory的影响每次都被清除，进而引发梯度消失。在LSTM中，每个时间点memory里的旧值会乘以$f(g(f))$再与新值相加，只有在forget gate被关闭时参数$w$对memory的影响才会被清除，在forget gate被打开时参数$w$对memory的影响就会通过累加得到保留，因此不会出现梯度消失的问题。 LSTM在1997年被提出，第1版的LSTM被提出就是为了解决梯度消失的问题，但这1版本是没有forget gate的，forget gate是后来才加上去的。也有1种说法是，在训练LSTM时需要给forget gate特别大的bias，以确保forget gate在多数情况下是开启的。 GRU（Gated Recurrent Unit, Cho, EMNLP’14）GRU比LSTM更简单，GRU只有2个gate，因此需要更少的参数量、鲁棒性更好、更不容易过拟合。GRU的基本思路是“旧的不去，新的不来”，GRU把input和forget gate联动起来，当forget gate把memory中的值清空时，input gate才会打开然后放入新的值。 Clockwise RNN（Jan Koutnik, JMLR’14）SCRN（Structrally Constrained Recurrent Network, Tomas Mikolov, ICLR’15）Vanilla RNN Initialized with Identity Matrix + ReLU（Quoc V.Le, arXiv’15） Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>循环神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-9.1循环神经网络RNN入门]]></title>
    <url>%2F2021%2F04%2F10%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-9-1%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Slot Filling比如在订票系统中，输入“Arrive Taipei on November 2nd”这样一个序列，我们设置几个slot(槽位)，希望算法能够将关键词“Taipei”放入Destination这个slot，将”November”和”2nd”放入到达时间Time of Arrival这个slot，而“Arrive”和“on”不属于任何slot。那这个算法如何实现呢？ Slot Filling with FNN可以用Feedforward Neural Network实现Slot Filling吗？可以，下面介绍这种FNN的输入和输出，但其存在问题。 输入是一个word（比如“Taipei”）并用vector来表示它；输出是1个probablity distribution，表示输入的word属于各个slot的概率。 如何用vector表示1个word呢？方法有很多。比如1-of-N Encoding(又名one-hot Encoding)，如下图所示。设定1个lexicon(词汇表)，那vector的size就和lexicon的size相同，vector中的每个维度对应lexicon中的word，vector中word对应的维度的值为1、其它维度的值为0。 如下图所示，只有1-of-N Encoding还不够，一些word不在lexicon中，对此我们需要在lexicon中添加1个”other“。除了1-of-N Encoding，还可以通过word hashing。可以用1个26×26×26的vector表示1个word，该vector中每个元素代表1个3字母序列。比如”apple”包括”app”、”ppl”、”ple”。 使用FNN实现Slot Filling时会存在一个问题：假如有2个句子“Arrive Taipei on November 2nd”和“Leave Taipei on November 2nd”，在处理这2个句子时FNN会先处理“arrive”和“leave”这2个词汇然后再处理“Taipei”。这时FNN没有办法区分出“Taipei”是出发地还是目的地，而我们希望算法在处理序列时是有“记忆力”的（即在处理“Taipei”时，它还记得“Leave”或“Arrive”），于是RNN诞生了。 Recurrent Neural Network如下图所示，将每1个隐藏层的输出保存在memory中，网络不仅考虑了input，还要考虑memory中的数据（merory中的数据是需要有初值的，比如0）。 因为RNN会考虑memory中存储的临时值，而不同输入产生的临时值不一定相同，所以改变输入序列中元素的顺序会导致最终输出结果的改变（Changing the sequence order will change the output）。 Slot Filling with RNN如下图所示，以“Arrive Taipei on November 2nd” 这个word sequence为例，将“Arrive”的vector$x^1$输入到RNN，隐藏层生成$a^1$，根据$a^1$生成$y^1$，表示“arrive”属于每个slot的概率，其中$a^1$会被存储到memory中；将“Taipei”的vector$x^2$输入到RNN，此时隐藏层同时考虑$x^2$和memory中的$a^1$生成$a^2$，根据$a^2$生成$y^2$，表示“Taipei”属于某个slot的概率，此时再把$a^2$存到memory中；以此类推根据$x_3$和$a_2$生成$a_3$进而得到$y^3$…… RNN的变体Elman Network &amp; Jordan NetworkRNN也有不同的变形。Elman Network是把隐藏层的输出存到memory中，而Jordan Network是把输出层的输出保存到memory中。由于隐藏层没有明确的训练目标，而整个NN具有明确的目标，因此Jordan Network的表现会更好一些。 Bidirectional RNN如下图所示，RNN可以是双向的。训练2个方向的RNN，1个从前往后读取序列，1个从后往前读取序列，然后使用2个RNN的隐藏层得到最后的输出层。这样的好处是，输出层的感受野更大，因为RNN在得到$y^{t+1}$的时候，它不只看了从句首$x^1$开始到$x^{t+1}$的数据，还看了从句尾$x^{n}$一直到$x^{t+1}$的输入，这就相当于RNN是在看过整个句子之后才计算每个word属于哪个slot的概率。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>循环神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-8.2图神经网络(Spatial-based Convolution)]]></title>
    <url>%2F2021%2F04%2F05%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-8-2%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-Spatial-based-Convolution%2F</url>
    <content type="text"><![CDATA[术语（Terminology） Aggregation Aggregation是Convolution在GNN中的推广。Aggregation就是在某一个layer中用某node及其neighbor的feature得到下一个layer中该node的feature。 Readout Readout有点像是全连接在GNN中的推广。Readout就是汇总整个图的信息，最终得到一个特征来表示这整个图（Graph Representation）。 NN4G(Neural Network for Graph)论文链接：https://ieeexplore.ieee.org/document/4773279 输入层 假如是一个化学分子，输入层的图中的结点就是一个原子。不同原子有不同的特征， 其特征可以是任何和原子相关的化学特征，所以需要embedding（将高维特征映射到低维特征），做完embedding也就得到了隐藏层$h^0$。 隐藏层$h^0$ 如何做embedding呢？让原特征乘以embedding matrix就得到隐藏层$h^0$。如下图所示，以1个结点为例，输入层中结点$v_3$的特征是$x_3$，该结点embedding时的计算式为$h^0_3=\bar w_0\cdot x_3$。embedding后就得到了隐藏层$h^0$，然后再对隐藏层$h^0$进行Aggregation就得到了隐藏层$h^1$。 隐藏层$h^1$ 如何做Aggregation呢？如下图所示，以1个结点为例，在隐藏层$h^0$中，结点$h^0_3$和$h^0_0,h^0_2,h^0_4$3个结点相邻，则Aggregation时计算式为$h^1_3=\hat w_{1,0}(h^0_0+h^0_2+h^0_4)+\bar w_1\cdot x_3$。经过多次Aggregation，最后需要Readout。 Readout 如何做Readout呢？如下图所示，假设有3个隐藏层，那Readout的计算式为$y=MEAN(h^0)+MEAN(h^1)+MEAN(h^2)$。 DCNN(Diffusion-Convolution Neural Network)论文链接：https://arxiv.org/abs/1511.02136 输入层 假如我们有1个和上例中（NN4G）一样的输入图。 隐藏层$h^0$ 如下图所示，从输入层到隐藏层$h^0$的计算式为$h^0_3=w^0_3MEAN(d(3,\cdot)=1)$，其中$d(3,\cdot)=1$表示所有与结点$x_3$距离为1的输入层结点的特征。 隐藏层$h^1$ 如下图所示，从隐藏层$h^0$到隐藏层$h^1$的计算式为$h^1_3=w^1_3MEAN(d(3,\cdot)=2)$，其中$d(3,\cdot)=2$表示所有与结点$x_3$距离为2的输入层结点的特征。 以此类推，叠加k个隐藏层后就可以获取各结点k范围内的信息。如下图所示，令1个隐藏层中多个结点的特征形成矩阵（1行是1个结点的特征），多个隐藏层的特征就形成多个通道$H^0,H^1,\dots,H^k$。 Node features 如何表达整个图的特征呢？如下图所示，将每个通道的特征flatten，然后再乘以参数$w$得到$y_1$即可。 也有其它做法，ICLR2018中DGC(Diffusion Graph Convolution)不是flatten，而是相加，如下图所示。 MoNET(Mixture Model Networks)NN4G、DCNN都是将邻居结点的特征直接相加，并没有考虑各个邻居结点特征的重要性，而MoNET考虑了这个问题。 论文链接：https://arxiv.org/abs/1611.08402 MoNET定义了结点距离的概念，基于结点距离表示各个邻居结点特征的重要性然后对各个邻居结点进行加权求和，而不是简单地取均值或求和。 如下图所示，假如我们有和上例一样的输入图，隐藏层$h^0$中结点$v_3$的特征为$h^0_3$，结点$v_3$和结点$v_0$的距离为$u_{3,0}$。 定义结点$x,y$的距离$u(x,y)=(\frac{1}{\sqrt{deg(x)}},\frac{1}{\sqrt{deg(y)}})^T$，其中$deg(x)$表示结点$x$的度（degree，度是连接到每个节点的边的数量）。 GraphSAGESAmple and aggreGatE(GraphSAGE)，在transductive和inductive setting上都能work。 论文链接：https://arxiv.org/abs/1706.02216 GraphSAGE的Aggregation除了mean，还有max pooling和LSTM。LSTM用来处理序列数据，但图中结点的邻居并没有序列关系，但如果每次在邻居中随机取样出不同顺序，那也许可以忽略顺序学习到顺序无关的信息。 GAT(Graph Attention Networks)论文链接：https://arxiv.org/abs/1710.10903 GAT不只是做加权求和（weighted sum），而其中的weight是通过学习得到的，方法就是对邻居做attention。 假如我们有1个和上例中（NN4G）一样的输入图。在做aggregation时，我们通过函数$f$计算各个邻居结点$v_0,v_2,v_4$对结点$v_3$的重要性，然后做加权求和。 GIN(Graph Isomorphism Network)这篇论文偏理论，证明出有些方法是work的，有些是不会work的。 比如提取特征时不要用mean或max（在一些情况下会fail），要用sum，如下图所示。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>图神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-7.4基于CNN和PyTorch的食物图片分类]]></title>
    <url>%2F2021%2F04%2F05%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-7-4%E5%9F%BA%E4%BA%8ECNN%E5%92%8CPyTorch%E7%9A%84%E9%A3%9F%E7%89%A9%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[本文为作者学习李宏毅机器学习课程时参照样例完成homework3的记录。 全部课程PPT、数据和代码下载链接： 链接：https://pan.baidu.com/s/1n_N7aoaNxxwqO03EmV5Bjg 提取码：tpmc 代码仓库：https://github.com/chouxianyu/LHY_ML2020_Codes 任务描述 通过CNN实现食物图片分类，数据集已提供 数据集描述 11个图片类别，训练集中有9866张图片，验证集中有3430张图片，测试集中有3347张图片。 训练集和验证集中图片命名格式为类别_编号.jpg，编号不重要。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import osimport cv2import timeimport torchimport torch.nn as nnfrom torch.nn.modules.activation import ReLUfrom torch.nn.modules.batchnorm import BatchNorm2dfrom torch.nn.modules.pooling import MaxPool1d, MaxPool2dfrom torch.utils.data import DataLoader, Datasetimport torchvision.transforms as transformsimport numpy as np"""加载数据"""def read_files(dir_path): # 读取文件夹中的所有图片 filenames = sorted(os.listdir(dir_path)) x = np.zeros((len(filenames), 128, 128, 3), dtype=np.uint8) # (N,H,W,C) y = np.zeros((len(filenames)), dtype=np.uint8) for i, filename in enumerate(filenames): img = cv2.imread(os.path.join(dir_path, filename)) x[i, : , :] = cv2.resize(img, (128, 128)) y[i] = int(filename.split("_")[0]) return x, ytrain_x, train_y = read_files("./data/training")val_x, val_y = read_files("./data/validation")print("Data Loaded")print("Size of training data : %d" % len(train_x))print("Size of validation data : %d" % len(val_x))"""数据变换（训练时进行数据增强）"""train_transform = transforms.Compose([ transforms.ToPILImage(mode=None), # 将图片格式转换成PIL格式 transforms.RandomHorizontalFlip(p=0.5), # 随机水平翻转 transforms.RandomRotation(15), # 随机旋转图片 transforms.ToTensor(), # 转换成torch中的tensor并将值normalize到[0.0,1.0]])val_transform = transforms.Compose([ transforms.ToPILImage(), transforms.ToTensor()])"""加载数据"""class ImgDataset(Dataset): def __init__(self, x, y=None, transform=None): self.x = x self.y = y if y is not None: self.y = torch.LongTensor(y) self.transform = transform def __len__(self): return len(self.x) def __getitem__(self, index): X = self.x[index] if self.transform is not None: X = self.transform(X) if self.y is not None: Y = self.y[index] return X, Y return Xbatch_size = 4train_set = ImgDataset(train_x, train_y, train_transform)val_set = ImgDataset(val_x, val_y, val_transform)train_loader = DataLoader(train_set, batch_size=batch_size, shuffle=True)val_loader = DataLoader(val_set, batch_size=batch_size, shuffle=False)"""定义模型"""class Model(nn.Module): def __init__(self): super(Model, self).__init__() # torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride, padding) # torch.nn.MaxPool2d(kernel_size, stride, padding) self.cnn = nn.Sequential( nn.Conv2d(3, 64, 3, 1, 1), # [64, 128, 128] nn.BatchNorm2d(64), nn.ReLU(), nn.MaxPool2d(2, 2, 0), # [64, 64, 64] nn.Conv2d(64, 128, 3, 1, 1), # [128, 64, 64] nn.BatchNorm2d(128), nn.ReLU(), nn.MaxPool2d(2, 2, 0), # [128, 32, 32] nn.Conv2d(128, 256, 3, 1, 1), # [256, 32, 32] nn.BatchNorm2d(256), nn.ReLU(), nn.MaxPool2d(2, 2, 0), # [256, 16, 16] nn.Conv2d(256, 512, 3, 1, 1), # [512, 16, 16] nn.BatchNorm2d(512), nn.ReLU(), nn.MaxPool2d(2, 2, 0), # [512, 8, 8] nn.Conv2d(512, 512, 3, 1, 1), # [512, 8, 8] nn.BatchNorm2d(512), nn.ReLU(), nn.MaxPool2d(2, 2, 0), # [512, 4, 4] ) self.fc = nn.Sequential( nn.Linear(512*4*4, 1024), nn.ReLU(), nn.Linear(1024, 512), nn.ReLU(), nn.Linear(512, 11) ) def forward(self, x): x = self.cnn(x) x = x.view(x.size()[0], -1) # torch.nn只支持mini-batches而不支持单个sample，第1个维度是mini-batch中图片（特征）的索引，即将每张图片都展开 return self.fc(x)"""训练并测试模型"""model = Model() # model = Model().cuda()criterion = nn.CrossEntropyLoss()optimizer = torch.optim.Adam(model.parameters(), lr=0.001)epochs = 30for epoch in range(epochs): epoch_start_time = time.time() train_acc = 0.0 train_loss = 0.0 val_acc = 0.0 val_loss = 0.0 model.train() for i, data in enumerate(train_loader): optimizer.zero_grad() # batch_loss.backward()的gradient会累加，所以每个batch都需要置零 pred = model(data[0]) # pred = model(data[0].cuda()) batch_loss = criterion(pred, data[1]) # batch_loss = criterion(pred, data[1].cuda()) batch_loss.backward() optimizer.step() train_acc += np.sum(np.argmax(pred.detach().numpy(), axis=1) == data[1].numpy()) # train_acc += np.sum(np.argmax(pred.cpu().detach().numpy(), axis=1) == data[1].numpy()) train_loss += batch_loss.item() model.eval() with torch.no_grad(): for i, data in enumerate(val_loader): pred = model[data[0]] # pred = model(data[0].cuda()) batch_loss = criterion(pred, data[1]) # batch_loss = criterion(pred, data[1].cuda()) val_acc += np.sum(np.argmax(pred.detach().numpy(), axis=1) == data[1].numpy()) # val_acc += np.sum(np.argmax(pred.cpu().detach().numpy(), axis=1) == data[1].numpy()) val_loss += batch_loss.item() print('[%03d/%03d] %2.2f sec(s) Train Acc: %3.6f Loss: %3.6f | Val Acc: %3.6f loss: %3.6f' % \ (epoch+1, epochs, time.time()-epoch_start_time, \ train_acc/train_set.__len__(), train_loss/train_set.__len__(), val_acc/val_set.__len__(), val_loss/val_set.__len__())) Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>PyTorch</tag>
        <tag>图片分类</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch入门：基于LeNet5和CIFAR10的图片分类]]></title>
    <url>%2F2021%2F04%2F04%2FPyTorch%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8ELeNet5%E5%92%8CCIFAR10%E7%9A%84%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[在PyTorch入门：使用PyTorch搭建神经网络LeNet5一文中，我们已经使用PyTorch实现了一个简单的神经网络LeNet5，本文将基于PyTorch使用LeNet5和CIFAR10实现图片分类模型的定义、训练和测试的全过程，代码(有详细注释)如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import torchimport torch.nn as nnimport torch.optim as optimimport torch.nn.functional as Fimport torchvisionimport torchvision.transforms as transformsimport matplotlib.pyplot as pltimport numpy as np## 构建神经网络模型：将LeNet5模型的输入改为3个通道class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(in_channels=3, out_channels=6, kernel_size=5) self.pool = nn.MaxPool2d(kernel_size=2, stride=2) self.conv2 = nn.Conv2d(in_channels=6, out_channels=16, kernel_size=5) self.fc1 = nn.Linear(in_features=16*5*5, out_features=120) self.fc2 = nn.Linear(in_features=120, out_features=84) self.fc3 = nn.Linear(in_features=84, out_features=10) def forward(self, x): x = self.pool(F.relu(self.conv1(x))) x = self.pool(F.relu(self.conv2(x))) x = x.view(-1, 16*5*5) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x## normalize：torchvision中数据集是元素值在[0,1]范围的PIL图片(C,H,W)，需将其数值范围转换为[-1,1]normalization = transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])## 加载CIFAR10数据集train_set = torchvision.datasets.CIFAR10(root='./data', train=True, transform=normalization, download=True)train_set_loader = torch.utils.data.DataLoader(dataset=train_set, batch_size=4, shuffle=True, num_workers=0) # Windows系统中建议把num_workers设为0test_set = torchvision.datasets.CIFAR10(root='./data', train=False, transform=normalization, download=True)test_set_loader = torch.utils.data.DataLoader(dataset=test_set, batch_size=4, shuffle=False, num_workers=0) # Windows系统中建议把num_workers设为0# ## 显示CIFAR10数据集中的一些图片# def imshow(img):# # print(img.size())# img = img / 2 + 0.5 # unnormalize: [-1,1] =&gt; [0,1]# img = img.numpy()# plt.imshow(np.transpose(img, (1, 2, 0))) # PIL的(C,H,W) =&gt; matplotlib的(H,W,C)# plt.show()# classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')# data_iter = iter(train_set_loader)# images, labels = data_iter.next() # images, labels都是tensor# # print(images.size())# # print(labels.size())# imshow(torchvision.utils.make_grid(images))# print(' '.join('%s' % classes[labels[j]] for j in range(len(labels))))## 定义神经网络、损失函数和优化器net = Net()criterion = nn.CrossEntropyLoss()optimizer = optim.SGD(params=net.parameters(), lr=0.001, momentum=0.9) # SGD with momentum## 训练神经网络print('Training Started')for epoch in range(5): # 1个epoch会将所有数据训练一次 running_loss = 0.0 # 用来在控制台输出loss，以观察训练情况 for i, data in enumerate(iterable=train_set_loader, start=0): # 获取数据 inputs, labels = data # 清空梯度缓存 optimizer.zero_grad() # forward + backward + optimize outputs = net(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() # 输出每2000个mini-batch的平均loss running_loss += loss.item() if i % 2000 == 1999: # print every 2000 mini-batches print('[%3d, %5d] loss: %.3f' % (epoch + 1, i + 1, running_loss / 2000)) running_loss = 0.0print('Finished Training')## 保存模型参数torch.save(net.state_dict(), './data/LeNet5.pt')## 测试模型print('Testing Started')net_new = Net()net_new.load_state_dict(torch.load('./data/LeNet5.pt'))correct = 0total = 0with torch.no_grad(): for data in test_set_loader: images, labels = data _, predictions = torch.max(net_new(images), 1) total += labels.size(0) correct += (predictions==labels).sum().item()print('Accuracy: %d/%d = %.2f%%' % (correct, total, correct/total*100) )"""Explore:使用GPU后会发现速度并没有增加很多，原因是LeNet这个模型非常小。如果将模型宽度增大（增加2个卷积层的卷积核数量），GPU对模型的加速效果会是怎么样的呢？""" Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>PyTorch</tag>
        <tag>图片分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch入门：使用PyTorch搭建神经网络LeNet5]]></title>
    <url>%2F2021%2F04%2F03%2FPyTorch%E5%85%A5%E9%97%A8%EF%BC%9A%E4%BD%BF%E7%94%A8PyTorch%E6%90%AD%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CLeNet5%2F</url>
    <content type="text"><![CDATA[前言在本文中，我们基于PyTorch构建一个简单的神经网络LeNet5。 在阅读本文之前，建议您了解一些卷积神经网络的前置知识，比如卷积、Max Pooling和全连接层等等，可以看我写的相关文章：李宏毅机器学习课程笔记-7.1CNN入门详解。 通过阅读本文，您可以学习到如何使用PyTorch构建神经网络LeNet5。 模型说明在本例中，我们使用如下图所示的神经网络模型：LeNet5。 该模型有1个输入层、2个卷积层、2次Max Pooling、2个全连接层和1个输出层。 输入层INPUT 1个channel，图片size是32×32。 卷积层C1 6个channel，特征图的size是28×28，即每个卷积核的size为(5,5)，stride为1。 下采样操作S2 6个channel，特征图的size是14×14，即Max Pooling窗口size为(2,2)。 卷积层C3 16个channel，特征图的size是10×10，即每个卷积核的size为(5,5)，stride为1。 下采样操作S4 16个channel，特征图的size是5×5，即Max Pooling窗口size为(2,2)。 全连接层F5 120个神经元。 全连接层F6 84个神经元。 输出层OUTPUT 10个神经元。 另外，除了输入层和输出层，剩下的卷积层、最大池化操作和全连接层后面都要加上Relu激活函数，下采样操作S4之后需要进行Flatten以和全连接层F5衔接起来。 代码实现1234567891011121314151617181920212223242526272829import torchimport torch.nn as nnimport torch.nn.functional as Fclass LeNet5(nn.Module): def __init__(self): super(LeNet5, self).__init__() # 卷积层 self.conv1 = nn.Conv2d(in_channels=1, out_channels=6, kernel_size=5) self.conv3 = nn.Conv2d(6, 16, 5) # 全连接层 self.fc5 = nn.Linear(in_features=16*5*5, out_features=120) self.fc6 = nn.Linear(120, 84) self.OUTPUT = nn.Linear(84, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, (2, 2)) # Max pooling over a (2, 2) window x = F.relu(self.conv3(x)) x = F.max_pool2d(x, 2) # If the size is a square you can only specify a single number x = x.view(-1, 16*5*5) # Flatten x = F.relu(self.fc5(x)) x = F.relu(self.fc6(x)) x = self.OUTPUT(x) return xnet = LeNet5()output = net(torch.rand(1, 1, 32, 32))# print(output) 参考链接https://pytorch.org/tutorials/beginner/blitz/neural_networks_tutorial.html 其实本文内容主要是PyTorch的官方教程。 PyTorch官方教程中代码实现与图片所示的LeNet5不符（PyTorch官方教程代码中是3×3的卷积核，而图片中LeNet5是5×5的卷积核），本文中我是按照图片所示模型结构实现的。 其实PyTorch开发者和其他开发者也注意到了这一问题，详见： https://github.com/pytorch/tutorials/pull/515 https://github.com/pytorch/tutorials/commit/630802450c13c78f02f744af1c47d1033b6fe206 https://github.com/pytorch/tutorials/pull/1257 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-8.1图神经网络入门]]></title>
    <url>%2F2021%2F04%2F02%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-8-1%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[GNN的用处分类（Classification）比如，有很多不同的化学分子，将其表示成图作为输入，用GNN判断其是否会导致突变，这就是一个有监督分类问题。 生成（Generation）比如，我们需要开发针对新冠病毒的新药，我们可以训练出一个可以生成我们想要的分子（输出形式为图）的GNN，然后用这个GNN生成可以对抗病毒的某种化学分子。 GraphVAE 为什么要用GNN上面列举的分类、生成的例子中输入或输出都是图，所以要用GNN。图不仅包含了各个结点的信息，更重要的是它包含了各个结点之间的关系。 使用GNN时可能遇到的问题 如何通过结点间的信息帮助模型 图中可能包含大量结点，数据集非常大 大量结点都是没有label的 GNN的两种思路很直观地可以想到，一个结点和它的相邻结点肯定有某些特定的关系，比如说相似（近朱者赤近墨者黑）、相反、合作等等。在多数情况下，数据集unlabeled node都是远多于labeled node的，我们想要得到一个较好的模型，那我们要如何利用仅有的少量labeled node以及它和邻居间的关系呢？结合CNN，我们要如何将卷积这个操作推广到GNN模型中，用卷积将结点嵌入到某个特征空间中呢？有两种方法 Spatial-based Convolution Generalize the concept of convolution(corelation) to graph. Spectral-based Convolution Back to the definition of convolution in signal processing. GNN导图 任务和数据集常见任务 Classification Regression Graph Classification Graph Representation Learning Link Prediction 常用数据集 CORA: citation network, 2.7k nodes and 5.4k links TU-MUTAG: 188 molecules with 18 nodes on average 其它https://www.dgl.ai/ Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>图神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-7.3CNN应用案例]]></title>
    <url>%2F2021%2F04%2F01%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-7-3CNN%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Deep DreamDeep Dream是这样的：如果给机器一张图片$x$，Deep Dream会把机器看到的内容加到图片$x$中得到$x’$。那如何实现呢？ 如上图所示，将图片$x$输入到CNN中，然后取出CNN中某一层$L$（可以是卷积、池化阶段的隐藏层，也可以是FNN中的隐藏层）的输出$O$，然后将$L$中的正值调大、负值调小得到一个新的输出$O’$，然后通过梯度下降找到一张新的图片$x’$使层$L$的输出为$O’$，这个$x’$就是我们要的结果。直观理解的话，也就是让CNN夸大它所看到的内容。 然后就得到了如下结果……（看到的时候我惊了，真是十分哇塞） Deep StyleDeep Style是这样的：如果给机器一张图片$x$和$y$，Deep Style可以把图片$y$的风格加到图片$x$上，也就是风格迁移。 那如何实现呢？论文：A Neural Algorithm of Artistic Style。 把图片$x$传入CNN并得到输出，然后其输出作为图片$x$的内容$c_x$（content）； 把图片$y$传入CNN并得到输出，但不是考虑输出的值是什么，而是考虑输出层中各个filter输出之间的相关性（corelation）作为图片$y$的风格$s_y$（style）； 最后基于同一个CNN找到图片$z$，图片$z$传入CNN后得到的内容$c_z$像$c_x$、风格$s_z$像$s_y$。 如下图所示 围棋CNN不单单可以用在图像上，还可以用在其它方面，比如下围棋。 在下围棋这件事上，其实FNN就可以（输入和输出都是19×19=361的vector），但CNN的效果更好。当然还可以用强化学习。 为什么CNN可以用来下围棋呢？因为围棋具有图像的3个性质，不过AlphaGo并没有用Max Pooling因为它不需要。 语音如下图所示，用语谱图（Spectrogram）表示语音。 语谱图的x轴是时间，y轴是频率，z轴是幅度。幅度用颜色表示（比如亮色表示高、暗色表示低）。 在语谱图中，CNN的卷积核往往只在y轴方向上移动，这样可以消除男生女生声音频率的差异；卷积核往往不在x轴上移动，因为时间域一般是在后面用LSTM等等进行处理，如下图所示。 文本CNN也可以用在文字处理上，比如文本情感分析。具体不再讲，可以看李宏毅老师的视频。 图片生成Deep Dream的方法还是不能画出图片，不过也有其它较为成功的方法，如下图所示。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-7.2CNN学到了什么]]></title>
    <url>%2F2021%2F03%2F31%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-7-2CNN%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[卷积核学到了什么如果想知道下图中第1个卷积层中的每个卷积核的功能，因为它参数比较少而且其输入是原图片，所以我们直接结合原图片观察卷积核的参数就可以知道该卷积核的功能。 如上图所示，CNN中第2个卷积层的输入不是直观的图片而且其卷积核的感受野比第1个卷积层中卷积核的感受野更大，因此我们无法通过观察卷积核参数了解卷积核学习到了什么。 上图中CNN第2个卷积层中有50个卷积核，每个卷积核的输出都是一个大小为11×11的矩阵。 现在定义函数$a^k=\sum_{i=1}^{11}\sum_{j=1}^{11}a^k_{ij}$来衡量某卷积核被“激活”的程度，即将卷积核所输出矩阵的元素之和作为其被“激活”程度，被“激活”程度指CNN输入与该卷积核有多匹配。 接下来，通过梯度下降求得$x^=arg\ max_x\ a^k$，即找到最能“激活”卷积核的输入图片$x^$，然后将其可视化希求反映该卷积核学习到的内容。 上图左下角可视化了最能“激活”第2个卷积层中某12个卷积核的12张图片，可以看出各卷积核适用于检测小的纹理（这个案例是数字识别）。 全连接层学到了什么如下图所示，我们同样可以用梯度下降找到最能“激活”全连接层中某个神经元的输入，将该输入其可视化，以此观察全连接层学习到了什么。和卷积核不同，卷积核学习到的是较小的pattern，全连接层中的神经元学习到的是尺寸较大的pattern。 输出层学到了什么如下图所示，我们同样可以用梯度下降找到最能“激活”输出层中某个神经元的输入，将该输入其可视化，以此观察输出层学习到了什么。在想象中这些输入应该是对应的数字，然而并不是（有人说眯着眼马马虎虎可以从中看到数字）。 在其它的案例中也有这样的情况，即机器学习到的内容和人类所理解的内容是不同的。这个视频里讲了相关例子。 但这个方法(通过“激活”卷积核反映学习到的内容)确实是有效的，那如何改进呢？我们可以对输入做一些限制（constraint）。 在该例中数字图片中底色是黑色，前景色（数字）是白色。 如下图所示，简单考虑的话，我们可以添加图片中大部分像素是黑色的限制（值接近0，也就是L1正则化），然后将求得的输入可视化。 当然，我们可以用更好的方法（比如说更好的限制）找到人类更容易理解的输入……这也是Deep Dream的精神。 神经网络可视化 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-7.1CNN入门详解]]></title>
    <url>%2F2021%2F03%2F29%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-7-1CNN%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[卷积神经网络（CNN）常常被用来做图像处理，当然也可以用一般的神经网络，那它们各自有什么优缺点呢？ FNN用于图片处理的缺点使用一般的全连接前馈神经网络（FNN）处理图片时的缺点： 需要很多的参数 假设有一张尺寸100×100的图片（尺寸已经算很小了），那输入层就有100×100×3=30K个像素，假设第一个隐藏层有1K个神经元（一个神经元包含30K个参数），这就已经需要30M个参数了…… 该架构中每个神经元就是一个分类器，这是没必要的 第一个隐藏层作为最基础的pattern分类器（比如判断有无绿色、边缘等），第二个隐藏层基于第一个隐藏层继续做pattern分类（比如木头、肉类），以此类推…… 按照人类的直观理解，我们不是像全连接神经网络一样去处理图片的。具体来看，有哪些方面呢？ 图片的一些性质结合全连接前馈神经网络的缺点和人类对图片的直观理解，可以得到下述图片的3个性质。 性质1：Some patterns are much smaller than the whole image.在识别某个模式（pattern）时，一个神经元并不需要图片的所有像素点。对于一张人类全身照的图片，我们只需要看到头部而非整张图片就可以判断它是一个人脸。所以我们应该是可以用少量参数去识别这些pattern的。 性质2：The same patterns appear in different regions.比如说人脸可以在图片的中间区域，也可以在图片的某个角落区域。所以识别不同区域中的相同pattern的多个分类器（或detector）应该用同一组参数或者共享参数。 性质3：Subsampling the pixels will not change the object将图片缩小/下采样，并不会影响我们理解图片。所以我们可以通过将图片变小，进而用更少的参数处理图片。 CNN架构说明2014年在ECCV上提出，针对上述的图片的3个性质，确定了CNN的架构如下。 如上图所示，图片经过卷积层然后进行最大池化（max pooling），这个步骤可以进行多次；然后将数据展开（Flatten），然后将数据传进全连接前馈网络得到最后的图片分类结果。 CNN架构作用探析 如上图所示，卷积是针对了图片的性质1和性质2，最大池化是针对了图片的性质3。 卷积(Convolution) ★假设有一张6×6的二值图，即一个6×6的矩阵。 卷积核（Filter）神经元就是一个计算/函数，卷积核其实就是神经元。 如下图所示，1个卷积层可以有多个卷积核，矩阵里元素的值就是需要通过学习得到的参数。 因为这里的输入是一个矩阵，所以卷积核也是1个矩阵（卷积核的通道数等于输入的通道数）。 假设卷积核大小是3×3，这对应了图片的性质1，即用小的卷积核识别一个小的pattern。 怎么做卷积如下图所示 卷积区域 根据该卷积核的大小（以3×3为例），选择图片中相同大小的区域进行卷积。 卷积的计算方法 从图片中扫描得到的3×3矩阵和卷积核的3×3矩阵，这2个矩阵相同位置的元素相乘可以得到9个值并求和（也就是内积）得到1个值，这就是1次卷积操作。 卷积顺序和方向 卷积核按照从左到右、从上到下的顺序，从图片左上角开始移动，移动步长（stride）可以设置（以1为例）。在扫描到的每个区域中，都进行1次卷积。1个卷积核移动结束后，则得到1个新的矩阵（大小为4×4），即1个卷积核的输出是1个矩阵。 卷积层有多个卷积核，每个卷积核都按照该方式进行卷积得到多个矩阵，这些矩阵合起来就形成了1个卷积层的特征图（Feature Map），这个特征图也就是卷积层的输出。 卷积层特征图的通道数等于该卷积层中卷积核的数量，即某卷积层有多少个卷积核，那该卷积层的特征图就有多少个通道。 卷积的作用在上图中，卷积核1的“对角线”的值都是1，就可以识别出图片中哪个区域具有“对角线”。在上图得到的4×4矩阵中，我们可以看到左上角和左下角3个元素的值为3，即有“对角线”。这对应了图片的性质2，我们用1个filter/1组参数识别了不同位置的相同pattern。 卷积核是矩阵还是张量卷积核可以是矩阵，也可以是张量，要根据其输入决定。 卷积核的通道数等于其所在卷积层输入的通道数（即其所在卷积层前一层的特征图的通道数），即单个卷积核会考虑输入的所有通道。 假如输入是一张RGB图片（大小为3×N×N，即有3个通道、每个通道中矩阵大小为N×N），那卷积核就是1个张量（大小为3×M×M，即有3个通道、每个通道中矩阵大小为M×M），卷积计算方法和上面一样是求内积（两个3×M×M的张量求内积）。 卷积中如何做梯度下降因为一个卷积核要对图片的不同区域进行多次卷积，每次卷积都会有一个梯度，最终把这些梯度取平均值就好了。 大概这么个意思，实操中这种底层的东西不需要我们实现。 Convolution VS Fully Connected其实，卷积核就是一个神经元，它相当于全连接层中的神经元并没有全连接（没有使用图片的所有像素，当然这样的层也就不能称为全连接层了），这样有两个好处 模型的参数更少如下图所示，因为没有使用所有像素、不是全连接，因此需要的参数更少。 参数共享如下图所示，因为用同1个卷积核在图片的不同区域做卷积，即用1组参数对不同区域的像素进行计算，得到了多个值、达成了多个神经元的效果，实现了参数共享。比如下图中神经元“3”处理图片第1个像素和神经元“-1”处理图片第2个像素就使用了同一个参数“1”（卷积核的第1个参数）。 因为实现了参数共享，卷积就比全连接进一步减少了参数量。 最大池化（Max Pooling）最大池化是一种下采样（Subsample）,下采样不一定要取最大值，也可以取平均值。 怎么做最大池化 如上图所示，假如某Max Pooling层的上1层是1个有2个卷积核的卷积层，该卷积层的输出是一个张量（大小为2×4×4，即2个通道、每个通道中矩阵的大小为4×4）。 对于输入中的每个通道，Max Pooling将4×4的矩阵划分成4个2×2的子矩阵（子矩阵大小可以人为设定），只取出每个子矩阵中的最大值就得到一个2×2的矩阵。又因为该Max Pooling层的输入有2个通道，所以其输出就是一个大小为2×2×2的张量。 取最大值的话，该怎么微分？见笔记“Tips for Training DNN”Maxout部分，Max Pooling和Maxout其实是一样的。 Flatten &amp; FNN经过一系列的卷积和最大池化，将得到的特征图展开排列，作为FNN的输入，最后输出结果。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-4.5逻辑回归Python实战]]></title>
    <url>%2F2021%2F03%2F28%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-4-5%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92Python%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文为作者学习李宏毅机器学习课程时参照样例完成homework2的记录。 关注我的公众号：臭咸鱼，回复LHY可获取课程PPT、数据和代码下载链接。 代码仓库：https://github.com/chouxianyu/LHY_ML2020_Codes 任务描述（Task Description） 二分类（Binary Classification） 根据个人资料，判断每个人的年收入是否超过50000美元。 数据集描述（Dataset Description） train.csv test_no_label.csv x_train.csv Y_train.csv X_test.csv 参考链接 https://colab.research.google.com/drive/1JaMKJU7hvnDoUfZjvUKzm9u-JLeX6B2C 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205import numpy as npimport matplotlib.pyplot as pltnp.random.seed(0) # 使每次随机生成的数字相同## 函数定义# 归一化def _normalize(X, train=True, specified_column=None, X_mean=None, X_std=None): # This function normalizes specific columns of X. # The mean and standard variance of training data will be reused when processing testing data. # # Arguments: # X: data to be processed # train: 'True' when processing training data, 'False' for testing data # specific_column: indexes of the columns that will be normalized. If 'None', all columns # will be normalized. # X_mean: mean value of training data, used when train = 'False' # X_std: standard deviation of training data, used when train = 'False' # Outputs: # X: normalized data # X_mean: computed mean value of training data # X_std: computed standard deviation of training data if specified_column is None: specified_column = np.arange(X.shape[1]) if train: X_mean = np.mean(X[:, specified_column], axis=0).reshape(1, -1) X_std = np.std(X[:, specified_column], axis=0).reshape(1, -1) X[:, specified_column] = (X[:, specified_column] - X_mean) / (X_std + 1e-8) return X, X_mean, X_std# 训练集划分def _train_valid_split(X, Y, valid_ratio=0.25): # This function splits data into training set and validation set. train_size = int(len(X) * (1 - valid_ratio)) return X[:train_size], Y[:train_size], X[train_size:], Y[train_size:]# 数据打乱def _shuffle(X, Y): # This function shuffles two equal-length list/array, X and Y, together. randomize = np.arange(len(X)) np.random.shuffle(randomize) return (X[randomize], Y[randomize])# sigmoid函数def _sigmoid(z): # Sigmoid function can be used to calculate probability. # To avoid overflow, minimum/maximum output value is set. return np.clip(1.0 / (1.0 + np.exp(-z)), 1e-8, 1 - ( 1e-8))# forwarddef _f(X, w, b): # This is the logistic regression function, parameterized by w and b # # Arguements: # X: input data, shape = [batch_size, data_dimension] # w: weight vector, shape = [data_dimension, ] # b: bias, scalar # Output: # predicted probability of each row of X being positively labeled, shape = [batch_size, ] return _sigmoid(np.matmul(X, w) + b)# 预测def _predict(X, w, b): # This function returns a truth value prediction for each row of X # by rounding the result of logistic regression function. return np.round(_f(X, w, b)).astype(np.int)# 计算精度def _accuracy(Y_pred, Y_label): # This function calculates prediction accuracy return 1 - np.mean(np.abs(Y_pred - Y_label))# 交叉熵损失函数def _cross_entropy_loss(y_pred, Y_label): # This function computes the cross entropy. # # Arguements: # y_pred: probabilistic predictions, float vector # Y_label: ground truth labels, bool vector # Output: # cross entropy, scalar return -np.dot(Y_label, np.log(y_pred)) - np.dot((1 - Y_label), np.log(1 - y_pred))# 梯度计算def _gradient(X, Y_label, w, b): # This function computes the gradient of cross entropy loss with respect to weight w and bias b. Y_pred = _f(X, w, b) pred_error = Y_label - Y_pred w_grad = -np.sum(pred_error * X.T, axis=1) b_grad = -np.sum(pred_error) return w_grad, b_grad## 文件路径X_train_fpath = '../data/X_train.csv'Y_train_fpath = '../data/Y_train.csv'X_test_fpath = '../data/X_test.csv'output_fpath = 'output.csv'## 读取数据with open(X_train_fpath) as f: next(f) # 不需要第一行的表头 X_train = np.array([line.strip('\n').split(',')[1:] for line in f], dtype=float) # 不要第一列的ID # print(X_train)with open(Y_train_fpath) as f: next(f) # 不需要第一行的表头 Y_train = np.array([line.strip('\n').split(',')[1] for line in f], dtype=float)# 不要第一列的ID，只取第二列 # print(Y_train)with open(X_test_fpath) as f: next(f) # 不需要第一行的表头 X_test = np.array([line.strip('\n').split(',')[1:] for line in f], dtype=float) # print(X_test)## 数据集处理# 训练集和测试集normalizationX_train, X_mean, X_std = _normalize(X_train, train=True)X_test, _, _ = _normalize(X_test, train=False, specified_column=None, X_mean=X_mean, X_std=X_std)# 训练集验证集划分X_train, Y_train, X_valid, Y_valid = _train_valid_split(X_train,Y_train, valid_ratio=0.1)train_size = X_train.shape[0]valid_size = X_valid.shape[0]test_size = X_test.shape[0]data_dim = X_train.shape[1]print('Size of training set: &#123;&#125;'.format(train_size))print('Size of validation set: &#123;&#125;'.format(valid_size))print('Size of testing set: &#123;&#125;'.format(test_size))print('Dimension of data: &#123;&#125;'.format(data_dim))## 训练（使用小批次梯度下降法，Mini-batch training）# 参数初始化w = np.zeros((data_dim, ))b = np.zeros((1, ))# 训练参数max_iter = 10batch_size = 8learning_rate = 0.2# 保存每个epoch的loss以作图train_loss = []valid_loss = []train_acc = []valid_acc = []step = 1# 迭代for epoch in range(max_iter): # 打乱训练集 X_train, Y_train = _shuffle(X_train, Y_train) # Mini-batch training for idx in range(int(np.floor(X_train.shape[0] / batch_size))): # 取batch X = X_train[idx * batch_size : idx * batch_size + batch_size] Y = Y_train[idx * batch_size : idx * batch_size + batch_size] # 计算梯度 w_grad, b_grad = _gradient(X, Y, w, b) # 梯度下降（learning rate decay with time） w = w - learning_rate / np.sqrt(step) * w_grad b = b - learning_rate / np.sqrt(step) * b_grad step = step + 1 # 计算训练集和验证集的loss和精度 y_train_pred = _f(X_train, w, b) Y_train_pred = np.round(y_train_pred) train_acc.append(_accuracy(Y_train_pred, Y_train)) train_loss.append(_cross_entropy_loss(y_train_pred, Y_train) / train_size) y_valid_pred = _f(X_valid, w, b) Y_valid_pred = np.round(y_valid_pred) valid_acc.append(_accuracy(Y_valid_pred, Y_valid)) valid_loss.append(_cross_entropy_loss(y_valid_pred, Y_valid) / valid_size)print('Training loss: &#123;&#125;'.format(train_loss[-1]))print('Validation loss: &#123;&#125;'.format(valid_loss[-1]))print('Training accuracy: &#123;&#125;'.format(train_acc[-1]))print('Validation accuracy: &#123;&#125;'.format(valid_acc[-1]))## 训练过程可视化# loss可视化plt.plot(train_loss)plt.plot(valid_loss)plt.title('Loss')plt.legend(['train', 'valid'])plt.savefig('Loss.png')plt.show()# accuracy可视化plt.plot(train_acc)plt.plot(valid_acc)plt.title('Accuracy')plt.legend(['train', 'valid'])plt.savefig('Accuracy.png')plt.show()## 预测测试集predictions = _predict(X_test, w, b)with open(output_fpath, 'w') as f: f.write('id,label\n') for i, label in enumerate(predictions): f.write('&#123;&#125;,&#123;&#125;\n'.format(i, label))## 寻找最重要的10个维度的特征index = np.argsort(np.abs(w))[::-1] # 将w按绝对值从大到小排序with open(X_test_fpath) as f: features = np.array(f.readline().strip('\n').split(',')) for i in index[:10]: print(features[i], w[i]) Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
        <tag>逻辑回归</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-4.4概率生成模型Python实战]]></title>
    <url>%2F2021%2F03%2F28%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-4-4%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8BPython%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文为作者学习李宏毅机器学习课程时参照样例完成homework2的记录。 关注我的公众号：臭咸鱼，回复LHY可获取课程PPT、数据和代码下载链接。 代码仓库：https://github.com/chouxianyu/LHY_ML2020_Codes 任务描述（Task Description） 二分类（Binary Classification） 根据个人资料，判断每个人的年收入是否超过50000美元。 数据集描述（Dataset Description） train.csv test_no_label.csv x_train.csv Y_train.csv X_test.csv 参考链接 https://colab.research.google.com/drive/1JaMKJU7hvnDoUfZjvUKzm9u-JLeX6B2C 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import numpy as np## 文件路径X_train_fpath = '../data/X_train.csv'Y_train_fpath = '../data/Y_train.csv'X_test_fpath = '../data/X_test.csv'output_fpath = 'output.csv'## 函数定义# 归一化def _normalize(X, train=True, specified_column=None, X_mean=None, X_std=None): # This function normalizes specific columns of X. # The mean and standard variance of training data will be reused when processing testing data. # # Arguments: # X: data to be processed # train: 'True' when processing training data, 'False' for testing data # specific_column: indexes of the columns that will be normalized. If 'None', all columns # will be normalized. # X_mean: mean value of training data, used when train = 'False' # X_std: standard deviation of training data, used when train = 'False' # Outputs: # X: normalized data # X_mean: computed mean value of training data # X_std: computed standard deviation of training data if specified_column is None: specified_column = np.arange(X.shape[1]) if train: X_mean = np.mean(X[:, specified_column], axis=0).reshape(1, -1) X_std = np.std(X[:, specified_column], axis=0).reshape(1, -1) X[:, specified_column] = (X[:, specified_column] - X_mean) / (X_std + 1e-8) return X, X_mean, X_std# 训练集划分def _train_valid_split(X, Y, valid_ratio=0.25): # This function splits data into training set and validation set. train_size = int(len(X) * (1 - valid_ratio)) return X[:train_size], Y[:train_size], X[train_size:], Y[train_size:]# sigmoid函数def _sigmoid(z): # Sigmoid function can be used to calculate probability. # To avoid overflow, minimum/maximum output value is set. return np.clip(1.0 / (1.0 + np.exp(-z)), 1e-8, 1 - ( 1e-8))# forwarddef _f(X, w, b): # This is the logistic regression function, parameterized by w and b # # Arguements: # X: input data, shape = [batch_size, data_dimension] # w: weight vector, shape = [data_dimension, ] # b: bias, scalar # Output: # predicted probability of each row of X being positively labeled, shape = [batch_size, ] return _sigmoid(np.matmul(X, w) + b)# 预测def _predict(X, w, b): # This function returns a truth value prediction for each row of X # by rounding the result of logistic regression function. return np.round(_f(X, w, b)).astype(np.int)# 计算精度def _accuracy(Y_pred, Y_label): # This function calculates prediction accuracy return 1 - np.mean(np.abs(Y_pred - Y_label))## 读取数据with open(X_train_fpath) as f: next(f) # 不需要第一行的表头 X_train = np.array([line.strip('\n').split(',')[1:] for line in f], dtype=float) # 不要第一列的ID # print(X_train)with open(Y_train_fpath) as f: next(f) # 不需要第一行的表头 Y_train = np.array([line.strip('\n').split(',')[1] for line in f], dtype=float)# 不要第一列的ID，只取第二列 # print(Y_train)with open(X_test_fpath) as f: next(f) # 不需要第一行的表头 X_test = np.array([line.strip('\n').split(',')[1:] for line in f], dtype=float) # print(X_test)## 数据集处理# 训练集和测试集normalizationX_train, X_mean, X_std = _normalize(X_train, train=True)X_test, _, _ = _normalize(X_test, train=False, specified_column=None, X_mean=X_mean, X_std=X_std)data_dim = X_train.shape[1]## 计算每个类别的样本的平均值和协方差# 区分类别X_train_0 = np.array([x for x, y in zip(X_train, Y_train) if y==0])X_train_1 = np.array([x for x, y in zip(X_train, Y_train) if y==1])# 计算每个类别的样本的平均值mean_0 = np.mean(X_train_0, axis=0) # 计算每个维度特征的平均值mean_1 = np.mean(X_train_1, axis=0)# 计算每个类别的样本的协方差矩阵（可以研究下协方差矩阵是如何计算的以及为什么）cov_0 = np.zeros((data_dim, data_dim))cov_1 = np.zeros((data_dim, data_dim))for x in X_train_0: cov_0 += np.dot(np.transpose([x - mean_0]), [x - mean_0]) / X_train_0.shape[0] # transpose没有参数的话，就是转置，计算协方差矩阵时需要转置for x in X_train_1: cov_1 += np.dot(np.transpose([x - mean_1]), [x - mean_1]) / X_train_1.shape[0]# 计算共享协方差矩阵（Shared covariance is taken as a weighted average of individual in-class covariance）cov = (cov_0 * X_train_0.shape[0] + cov_1 * X_train_1.shape[0]) / (X_train_0.shape[0] + X_train_1.shape[0])## 计算权重和偏置# 计算协方差矩阵的逆矩阵# Since covariance matrix may be nearly singular, np.linalg.inv() may give a large numerical error.# Via SVD decomposition, one can get matrix inverse efficiently and accurately.u, s, v = np.linalg.svd(cov, full_matrices=False)inv = np.matmul(v.T * 1 / s, u.T)# 计算weight和biasw = np.dot(inv, mean_0 - mean_1)b = (-0.5) * np.dot(mean_0, np.dot(inv, mean_0)) + 0.5 * np.dot(mean_1, np.dot(inv, mean_1)) + np.log(float(X_train_0.shape[0])) / X_train_1.shape[0]## 计算在训练集上的准确率Y_train_pred = 1 - _predict(X_train, w, b)print('Training accuracy: &#123;&#125;'.format(_accuracy(Y_train_pred, Y_train)))## 预测测试集结果predictions = 1 - _predict(X_test, w, b)with open(output_fpath, 'w') as f: f.write('id,label\n') for i, label in enumerate(predictions): f.write('&#123;&#125;,&#123;&#125;\n'.format(i, label))## 寻找最重要的10个维度的特征index = np.argsort(np.abs(w))[::-1] # 将w按绝对值从大到小排序with open(X_test_fpath) as f: features = np.array(f.readline().strip('\n').split(',')) for i in index[:10]: print(features[i], w[i]) Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>概率生成模型</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《基于深度学习的显著性目标检测综述》阅读笔记]]></title>
    <url>%2F2021%2F03%2F20%2F%E3%80%8A%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%98%BE%E8%91%97%E6%80%A7%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BB%BC%E8%BF%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本信息 论文名称 基于深度学习的显著性目标检测综述 作者 史彩娟等 发表时间 2020年 来源 知网 说明本文基本研究对象为：基于深度学习的SOD算法。 下文中将显著性目标检测简写为SOD（Salient Object Detection），将基于深度学习的显著性目标检测算法简写为DSOD（Deep Learning Based SOD）。 主要收获 知识 低层特征中包含更多的边界信息 通过编码低层特征距离来检测边界信息可能导致部分边界细节丢失。 通过引入相关操作来增强低层特征具有的边界信息，可以获得更清晰的边界，但容易造成显著性目标检测主体不准确的问题。 高层特征中包含更多的语义信息。 只对高层特征所包含的语义进行增强，有时会造成显著性目标边界模糊或者多个显著性目标重合。 只进行边界增强容易造成显著性目标不准确，而只进行语义增强则会引起显著性目标的边界不准确，所以可以同时增强两者。 因为通过语义增强可以减小无效目标的干扰，更好地定位显著性目标的位置；通过边界增强可以获得清晰的显著性目标边界。 金字塔结构可以处理高低层的特征 全局信息（颜色，纹理，背景/前景等）包含显著性目标的位置信息，而局部信息可以增强显著性目标边界。 一些未知的东西 BASNet是怎么实现的？其中的混合Loss是什么 Boundary-Enhanced Loss是什么？ 注意力机制（Attention）是什么？ 金字塔结构是什么？ 层次递归卷积神经网络(Hierarchical Recurrent Convolutional Neural Network，HRCNN)是什么？ 字幕网络(Image Captioning Network，ICN)是什么？ SqueezeNet是什么？3种设计原则？ MobileNet是什么？深度可分离卷积？ 可变形卷积是什么？ 评估指标 F-度量($F-measure,F_\beta$) 加权F-度量($Weighted\ F-measure,F_\beta^\omega$) P-R曲线 平均绝对误差(Mean Absolute Error, MAE) 思考 研究至少有2个思路：横向（分类）和纵向（深入）。 摘要 根据原理不同，分3类介绍并定性分析比较DSOD。 3个类别为：边界/语义增强、全局/局部结合、辅助网络 简单介绍DSOD的常用数据集和评估准则 现有DSOD方法在多个数据集上进行多方面的性能比较 包括定量比较、P-R曲线和视觉比较 现有DSOD算法在复杂背景、小目标、实时性检测等方面的不足 DSOD的未来发展方向，如复杂背景、实时、小目标、弱监督 1 引言 传统SOD方法主要利用人类直观感觉或启发式先验，如利用色度比较，背景比较和边界点先验等，通过人工提取特征来检测目标，但人工提取特征非常耗时。 DSOD可自动学习到多尺度特征，精度速度大幅提升，但也存在不足：复杂背景下的性能有待提升、实时性需提高、模型复杂度需降低。 2 基于深度学习的显著性目标检测方法 传统方法中人工提取特征耗时或者迁移性较差 DSOD可分为3个类别：边界/语义增强、全局/局部结合、辅助网络 ==图1==给出了今年DSOD的发展历程和主要算法 2.1 基于边界/语义增强的SOD2.1.1 基于边界增强的SOD方法 边界增强是指通过增强深度特征中的低层特征来获得更多的边界信息，从而更好的定位显著目标边界。 ELD算法和KSR算法通过编码低层特征距离来检测边界信息，定位显著性目标轮廓，但是轮廓边界有时会模糊，导致部分边界细节丢失。 DCL算法和DSS算法通过引入相关操作来增强低层特征具有的边界信息。 相较于直接编码低层特征距离的算法，这类方法获得的显著性目标边界更加清晰。但是，这些操作的引入容易引起显著性目标检测主体不准确，比如只有1个目标却检测出了2个。 原文中==图2==展示并对比了上述4个算法的检测效果。 还可以直接对显著性目标的边界进行检测，比如GearNet、AFNet（采用BEL，Boundary-Enhanced Loss）、BASNet。 这类方法能够提取清晰的显著性目标边界，边界细节相对较好，显著性目标的检测准确度较高(无关的显著性目标较少)，效果见原文==图3==。 2.1.2 基于语义增强的SOD方法 语义增强是指从高层特征中获得丰富的语义信息，从而更好的定位显著性目标，使显著性目标更加突出。 比如R_FCN算法、CPD算法和PoolNet算法等，算法效果见原文==图4==。 这类方法可以准确定位显著性目标，但是由于仅针对高层特征所包含的语义进行增强，有时会造成显著性目标边界模糊或者多个显著性目标重合。 还可以通过引入注意力机制进一步增强语义信息，如PiCANet和RAS算法。主体准确性和边界准确性都不错，算法效果见原文==图5==。 2.1.3 基于边界/语义增强的SOD方法 只进行边界增强容易造成显著性目标模糊，而只进行语义增强则会引起显著性目标的边界模糊，所以可以同时对两者进行增强。 因为通过语义增强可以减小无效目标的干扰，更好地定位显著性目标的位置；通过边界增强可以获得清晰的显著性目标边界 这类算法有Amulet、BDMPM等，算法效果见原文==图6==。 还可以采用金字塔结构同时对高低层特征进行处理，以同时增强显著性目标边界和语义。 这类算法有SRM算法、PAGE算法、FPA算法，算法效果见原文==图7==。 2.2 基于全局/局部结合的SOD 全局信息（颜色，纹理，背景/前景等）包含显著性目标的位置信息，而局部信息可以增强显著性目标边界。 一些检测方法采用递归操作、多分辨率操作和注意力机制等将全局/局部相结合以 获得更好的显著性目标检测性能 这类算法有DHSNet、GRL、NLDF、PAGR算法等，算法效果见原文==图8==。 2.3 基于辅助网络的SOD 基于辅助网络的显著性目标检测是指采用其它领域已有模型作为辅助网络来提升显著性目标检测性能 这类算法有MDF、C2S-Net、CapSal、MLMSNet算法等，算法效果见原文==图9==。 2.4 不同类型SOD方法分析比较 现有DSOD方法边界模糊的原因和解决办法 深度模型包含许多下采样操作，上采样后的特征难以恢复原有的空间信息，融合后引起边界模糊。因此，为了减小下采样操作引起的多尺度融合损失，引入一些特定操作，如 PoolNet 算法中采用功能聚合模块等。 针对不同因素对边界检测的影响，通过编码低层特征距离来检测边界信息，定位显著性目标轮廓，如ELD算法和KSR算法；或者是设计新的损失函数， 通过反向传播调整模型参数，如AFNet算法和BASNet算法。 基础模型简易导致检测的边界模糊，可以通过多尺度操作增强原有的特征效果，如DSS算法、SRM算法和PAGE算法等，或添加注意力机制来提取更有效的低层特征，如PFA算法等。 基于深度学习的显著性目标检测方法中常常引入注意力机制，大致可分为3类 时空域注意力，比较适合同时具有时序及空域特征的场景，通过递归神经网络 （Recurrent Neural Network，RNN）设计注意力机制，如PAGR算法。 软注意力，是一种确定性的注意力，可以直接通过网络生成，它也是可微的， 可以通过神经网络算出梯度并且前向传播和后向 反馈来学习得到注意力的权重，如PFA算法和RAS算法； 硬注意力，从输入信息中选择重要的特征，如PiCANet算法每个像素生成注意力图，这种方式更高效和直接。 3 常用数据集及评估标准3.1 常用数据集 SOD数据集 MSRA、SOD、MSRA10K、HKU-IS、DUTS、SED、ECSSD、DUTO-OMRON、PASCAL-S 常用DSOD数据集 MSRA10K：边界框级别的显著性真值标定 HKU-IS：4447个图像，多个断开连接的显著性目标，多目标的边界重合和色彩对比度较低 DUTS：10553个训练图像和5019个测试图像，训练和测试集都包含非常重要的场景 SOD：300张图像，像素级注释，大部分图像包含多个显著性目标，并且目标与背景的颜色对比度较低。 ECSSD：1000张图像，图像具有复杂的结构和背景 DUTO-OMRON：5168个高质量图像，图像具有多个显著性目标，背景相对复杂 PASCAL-S：8 个类别，850张图像，用于评估具有复杂背景、多个目标场景的模型性能 3.2 常用评估准则DSOD常用评估准则 F-度量($F-measure,F_\beta$) 对精度和召回率进行总体评估，最终值越大表明性能越好，其中$\beta$是一个参数，一般取$\beta^2=0.3$。公式暂略。 加权F-度量($Weighted\ F-measure,F_\beta^\omega$) 加权F-度量是F-度量的推广，通过交替计算精度和召回率得到。 加权F-度量为了解决邻域信息的不同， 为不同位置的不同误差分配了不同的权重。公式暂略。 P-R曲线 以Precision和Recall作为纵-横轴坐标的二维曲线，即查准率-查全率曲线，选取不同阈值时对应的精度和召回率绘制。P-R曲线围起来 的面积是AP(Average Precision)值，AP值越高，模型性能越好。公式暂略。 平均绝对误差(Mean Absolute Error, MAE) MAE值越小表示模型越好。公式暂略。 4 基于深度学习的显著性目标检测方法性能比较 在数据集ECSSD、DUT-OMRON、HKU-IS和DUTS-TE上进行实验，采用F-度量和平均绝对误差MAE作为评估准则 5 基于深度学习的显著性目标检测算法的不足与未来展望 不足与未来展望 复杂背景 设计适应复杂背景（对背景敏感或者前景背景对比度低等）的显著性目标检测模型 建立包含复杂背景的图像数据集 实时性 设计轻量化网络，比如遵守SqueezeNet特有的三种设计原则 采用深度可分离卷积，比如MobileNet 对网络直接进行压缩与编码 小目标 使用分辨率更高的卷积特征图以及残差模块来增强对小目标的检测能力 矩形框定位 可变形卷积 完全监督学习 无监督或弱监督 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>显著性目标检测</tag>
        <tag>论文笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PoolNet论文详解]]></title>
    <url>%2F2021%2F03%2F19%2FPoolNet%E8%AE%BA%E6%96%87%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[基本信息 论文名称 A Simple Pooling-Based Design for Real-Time Salient Object Detection 作者 Jiang-Jiang Liu, Qibin Hou, Ming-Ming Cheng等 发表时间 2020年 来源 CVPR2019 主要收获 知识 low-level和high-level可以指人类意识中的低级和高级，也可以指CNN物理结构中的浅层（低层）和深层（高层）。 因为CNN类似于金字塔的结构特点；其浅层阶段具有较大尺寸并保留丰富的低级信息；其深层阶段包含更多高级语义信息也更容易从中得到显著目标的位置，但很coarse（粗糙）。 一些未知的东西 FPN 上采样 ResNet PPM Richer convolutional features for edge detection SRM（A stagewise refinement model for detecting salient objects in images） weight decay balanced binary cross entropy loss standard binary cross entropy loss，BCE？ Abstract 思路 通过扩展池化在CNN中的作用，实现SOD。 实现 基于U-shape architecture，构造2个模块 GGM（global guidance module） 自底向上，用来为不同层的特征图提供潜在显著目标的位置信息。 FAM（feature aggregation module） 从顶向下，使coarse-level的语义信息和fine-level的特征较好地融合。 在自顶向下的融合操作之后添加FAM，可以将GGM中coarse-level的特征与不同尺度的特征无缝融合。 这2个模块使高级语义信息逐渐完善，生成信息丰富的显著性图。 通过锐化细节，和SOTA相比可以更精确地定位目标。 300×400的图片，FPS超过30，代码http://mmcheng.net/poolnet/。 1. Introduction U-shape结构 多数传统方法通过手工设计的特征，单独或同时捕捉局部细节和全局上下文信息，但其性能因缺乏高层语义信息而受到限制，而CNN可以在不同尺度空间中提取高级语义信息和低级细节特征。 因为CNN类似于金字塔的结构特点，其浅层阶段具有较大尺寸并保留丰富的低级信息，其深层阶段包含更多高级语义信息也更容易从中得到显著目标的位置。 基于上述知识，学者设计了许多结构，其中U-shape的结构最受关注，其通过在分类网络上构建自上而下的路径来构建丰富的特征图。 U-shape结构还存在提升空间 存在问题 因为U-shape结构中高级语义信息（位于深层网络）是逐步传到浅层的，与此同时深层捕捉到的位置信息可能会被稀释。 一个CNN的感受野大小和其深度是不成比例的。 解决方法 现有方法 现有方法（见原文参考文献）通过引入注意力机制、以循环方式细化特征图、结合多尺度特征信息、向显著图添加额外约束（例如边界loss）等方法解决上述U-shape结构的问题。 本文方法 本文提出的方法是基于U-shape并扩展池化技术，其中GGM和FAM都是基于FPN（feature pyramid networks）的。 PoolNet 因为GGM和FAM都基于池化，所以将本文方法取名为PoolNet。 GGM GGM包括一个修改过的PPM（pyramid pooling module）和一系列GGF（global guiding flows）。 PPM 和SRM（A stagewise refinement model for detecting salient objects in images）直接将PPM插入U-shape结构不同，本文提出的GGM是一个独立的模块。具体来讲，即把PPM放在backbone顶部用来捕捉全局指导信息（显著目标的位置） GGF 通过GGF，PPM收集到的高级语义信息可以传送到所有金字塔层，弥补了U-shape网络自上而下信号逐渐被稀释的问题。 FAM 考虑到来自GGF的coarse-level特征图与金字塔不同尺度特征图的融合问题，本文提出了一种FAM，其输入为融合后的特征图。 该模块首先将融合（==应该是FPN操作？==）得到的特征图转换到多个特征空间，以捕获不同尺度的局部上下文信息，然后将这些信息进行组合以更好地权衡融合的输入特征图的组成。（==最后半句没懂，“权衡”一词具体指什么？==） edge detection branch 还使用了边缘检测分支（edge detection branch），通过和边缘检测协同训练以锐化显著物体的细节。 性能 精度 Without bells and whistles，大幅超过之前的SOTA。 速度 一个NVIDIA Titan Xp GPU，图片尺寸300 × 400，速度超过30FPS。 不使用边缘检测分支时，5000张图片，训练时长不超过6小时，比多数方法快很多，因为池化操作比较快速。 2. Related Work暂略 3. PoolNet high-level semantic features are helpful for discovering the specific locations of salient objects. low- and midlevel features are also essential for improving the features extracted from deep layers from coarse level to fine level. 3.1. Overall Pipeline 基于FPN（一种U型结构，从底向上和自顶向下，优点是可以组合多层特征） 在从底向上之后引入GGM，提取高级语义信息后将其与各个金字塔层融合。 GGM之后，引入FAM保证不同尺度的特征图可以无缝融合。 3.2. Global Guidance Module 现有不足 FPN的问题 问题之一：自顶向下是在自底向上之后的，就是高级特征被传给低层时会逐渐稀释。 CNN的问题 根据实验，CNN的感受野比理论上要小得多，特别是对于较深的层，所以整个网络的感受野并不足够大以捕捉输入的全局信息。 直接影响 可以看原文图2，只能检测到显著目标的局部。 解决方法：GGM 使得每个尺度的特征图都可以感知显著目标的位置。 PPM 包括4个子分支，作用是捕获输入图像的上下文信息。 第一和最后一个子分支分别是一个identity mapping layer和一个global average pooling layer。 中间的两个分支，我们采用adaptive average pooling layer，以确保它们输出的特征图分别具有3×3和5×5的空间大小。 GGF 作用是将PPM捕捉到的信息与接下来自顶向下中不同金字塔层的特征图合理地融合在一起。 与SRM（A stagewise refinement model for detecting salient objects in images）不同，它是将PPM视为U形结构的一部分，而本文中的GGM独立于U形结构。 如原文图1中的绿色箭头，通过引入一系列GGF（identity mappings），可以将高级语义信息传递到各个级别的特征。 这样，我们在自上而下路径的每个部分中显式增加了全局导航信息的权重，以确保在构建FPN时不会稀释位置信息。 可以看原文图2，观察GGF的具体作用。 3.3. Feature Aggregation Module 解决的问题 使GGM的粗略特征图与金字塔不同尺度的特征地图无缝融合。 具体来讲，在原始的FPN（VGGNet版本）中，高层特征图上采样比率为2，所以在上采样后边加一个3×3的卷积可以减少其带来的aliasing effect。 但是，GGF还需要更大的上采样比率，比如8。所以使用FAM充分、高效地处理GGF和不同金字塔层特征图之间巨大的尺寸差异。 FAM 结构 每个FAM包含4个子分支，如原文图3所示。在forward过程中，输入的特征图先以不同比率进行下采样（平均池化），然后再以不同比率进行上采样，然后将4个分支融合（sum），然后送入一个3×3的卷积层。 优点 减少上采样带来的aliasing effect，特别是当上采样比率较大（比如8）的时候。 使每个spatial location（空间位置）可以看到不同尺度空间的局部上下文信息，而且增大了整个网络的感受野。 实验 原文图4 将FAM替换成2个卷积层进行对比，把FAM模块附近的特征图可视化，证明FAM可以更好地捕捉显著目标的位置和细节信息。 原文图2 f列和g列（尤其是第2行）进行对比，证明引入FAM可以sharpen显著目标的细节信息。 在下文的实验部分，会给出更多的数值结果。 4. Joint Training with Edge Detection 问题 第3节描述的网络结构已经在多个常用评估准则上超过了之前所有SOTA的单个模型的结果。 但是原文作者发现许多不准确（incomplete or over-predicted）的预测是由于不清晰的目标边界造成的。 Edge Detection Branch 在第3节描述的结构中添加1个预测分支，用来estimate显著目标的边界，具体结构见原文图1。 在3个不同尺度的FAM之后添加3个residual block，用来information transformation，这3个residual block和ResNet的设计相似并且具有{128,256,512}个通道（从fine level到coarse level）；和Richer convolutional features for edge detection一文相同，每个residual block后面都有1个16通道的3×3卷积层（用来feature compression），还有1个单通道的1×1卷积层（用来边缘检测）。 将上述3个16通道的3×3特征图进行拼接（concatenate）然后将其送入3个连续的48通道3×3卷积层，以将捕捉到的边缘信息传递给显著性目标检测分支，用来增强细节。 Train Edge Detection Branch taking the boundaries of salient objects as GT 和Instancelevel salient object segmentation一文相似，本文在训练阶段将显著目标的边界作为GT用来联合训练，然而这并没有带来任何性能提升并且仍然缺少目标边界的细节信息。如图5的c列，当场景的前后景对比度较低时，得到的显著性图和边界图仍然很模糊。导致这个问题的原因可能是来自显著目标的GT边界图仍然缺少显著目标的大部分细节信息。GT边界只告诉我们显著目标的外边界的位置，特别是当显著目标之间有重叠的时候。 Train Edge Detection Branch taking the boundaries of salient objects as GT 根据上述内容，本文尝试了和边缘检测任务实现协同训练，使用和和Richer convolutional features for edge detection一文中相同的数据集。在训练时，来自显著目标检测数据集和边缘检测数据集的图像被交替输入。如图5所示，和边缘检测任务实现协同训练大幅提升了检测到的显著目标的细节。在下文实验部分，会给出更多的定量分析。 5. Experimental Results5.1. Experiment Steup 实现细节 使用PyTorch框架，所有实验中的学习率优化器为Adam（5e-4的weight decay，初始学习率为5e-5然后15个epoch之后除以10）。 本文的网络共训练24个epoch。 网络backbone（如VGG-16、ResNet-50）的参数通过在ImageNet数据集上预训练的对应模型进行初始化，剩余参数随机初始化。 如果没有特别声明，本文中消融实验（ablation experiments）默认使用VGG-16作为backbone，并使用和Instancelevel salient object segmentation一文相同的联合数据集（MSRA-B和HKU-IS）。 本文在数据增强方面只使用了水平翻转。 在训练和测试中，和Deeply supervised salient object detection with short connections一文中一样，输入图片的尺寸保持不变。 数据集和损失函数 在6个常用数据集（ECSSD、PASCALS、DUT-OMRON、HKU-IS、SOD和DUTS）上开展实验以评估性能。 显著性目标检测中使用使用standard binary cross entropy loss，边缘检测使用balanced binary cross entropy loss。 评估标准 使用3个广泛应用的指标（PR曲线、F-measure score和MAE）评估本文提出的方法。 5.2. Ablation Studiesablation的译文是消融。 该section首先研究GGM和FAM的有效性，然后开展实验研究如何配置GGM，最后研究协同训练对性能的影响。 Effectiveness of GGM and FAMs 基于FPN的baseline，以VGG-16为backbone，研究GGM和FAMs的有效性。除了GGM和FAMs的不同组合，其它所有配置都相同。原文表1展示了其在数据集DUT-O和SOD上的性能，对应的视觉比较可以在原文图2中看到。 GGM Only 原文表1第4行数据说明GGM提升了F-measure和MAE。GGM生成的全局指导信息使网络更多地关注显著目标的完整性，大幅提升了所得显著性图的质量。因此，显著目标的细节（这些细节容易被感受野有限的模型错误预测为背景，比如原文图2的最后1行）可以被增强。 FAMs Only 原文表1第5行的数据说明简单地将FAMs嵌入到原文图1所示的FPN baseline中提升了F-measure和MAE。这可能是因为FAM中的池化操作扩大了整个网络的感受野，并且FPN baseline仍然需要融合不同尺度的特征图，这说明FAM了缓解上采样aliasing effect的有效性。 GGM &amp; FAMs 原文表1最后1行的数据说明同时引入GGM和FAMs可以得到更优的F-measure和MAE，这说明GGM和FAM是互补的。通过它们可以精确地定位显著目标并改善其细节（如图2所示）。原文图6中包含更多的定性结果。 Configuration of GGM 为更好地了解GGM，独立使用PPM和GGF开展实验，数据分别在原文表1的第2行和第3行。这2个实验的结果都比使用GGM时的结果（原文表1第4行的数据）。这说明PPM和GGF在GGM中都起着重要作用。 The Impact of Joint Training 如原文表2所示，在3个数据集上，将显著目标边界（SalEdge）作为GT进行训练并没有提升baseline的性能，而使用标准的边缘（StdEdge）作为GT可以大幅提升baseline的性能，特别是MAE。这说明引入详细的边缘信息有助于显著性目标检测。 5.3. Comparisons to the State-of-the-Arts该section比较了本文方法和13个SOTA方法（具体是哪13个方法见原文，此处省略）。为公平比较，这13个方法的结果是原结果或者使用初始公开代码得到的结果。所有结果都不经过任何后处理，所有预测得到的显著性图都使用同一份代码进行评估。 Quantitative Comparisons 如原文表3所示，分别使用VGG-16和ResNet-50作为backbone，并在多份训练集上开展实验以排除潜在的性能波动。可以看到，在相同的训练集上，使用相同的backbone，PoolNet超过了之前所有的SOTA方法。平均速度（FPS）对比如原文表4所示。 PR Curves 原文图7为在3个数据集上的PR曲线，可以看到PoolNet的PR曲线优于其它算法。随着Recall值趋于1，PoolNet的Precision比其它算法高很多。这说明PooNet得到的显著性图的错误正样本（false positives）较少。 Visual Comparisons 原文图6给出了PoolNet和其它算法的定性对比。从上到下，分别是透明目标、小目标、大目标、复杂形状和前背景低对比度。可以看出，在几乎所有环境下，PoolNet不仅可以正确找出显著目标，还可以增强它们的边缘。 6. Conclusion 本文设计GGM和FAM两个模块，提出PoolNet，并和边缘检测任务实现协同训练，在6个常用数据集上的效果优于之前所有SOTA方法。 GGM和FAM是独立于网络结构的，可以灵活地迁移到任何基于金字塔的模型。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>显著性目标检测</tag>
        <tag>论文笔记</tag>
        <tag>PoolNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BASNet论文详解]]></title>
    <url>%2F2021%2F03%2F08%2FBASNet%E8%AE%BA%E6%96%87%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[toc] 基本信息 论文名称 BASNet: Boundary-Aware Salient Object Detection 作者 Xuebin Qin等 发表时间 2019年 来源 CVPR2019 主要收获 知识 本文混合损失函数中的3种loss 本文核心是混合损失函数以及refine module，其中refine module借用了ResNet中的思路：$S_{refined}=S_{coarse}+S_{residual}$。 如图3所示，coarse saliency map存在2方面的问题：①the blurry and noisy boundaries(边界不准确、不清晰), ②the unevenly predicted regional probabilities(同类区域中像素概率不均匀) RRM_LC和RRM_MS等模块比较shallow，所以很难捕捉到可用于refinement的high level information。 评估指标 PR Curve PR Curve是1种评估预测所得显著性图的标准方式。1张显著性图的precision和recall通过比较二值化的显著性图及其ground truth计算。1个二值化threshold对应的1对precision和recall是数据集中所有显著性图的平均precision和recall。threshold从0到1变化，可以得到1个precision-recall pair序列，画出来就是PR Curve。 F-measure F-measure可以全面地衡量precision和recall，其基于1对precision和recall进行计算。在进行算法比较时，一般采用最大的F-measure进行比较。 MAE MAE指显著性图与其ground truth的average absolute per-pixel difference。模型对于1个数据集的MAE为所有显著性图的MAE的平均值。 一些未知的东西 U-Net SegNet dilation convolution 感受野的计算方法 Abstract 背景：多数前人工作只关注region accuracy而非boundary quality。 本文提出：a predict-refine architecture: BASNet and a new hybrid loss for Boundary-Aware Salient object detection BASNet a densely supervised Encoder-Decoder network, in charge of saliency prediction a residual refinement module(RRM), in charge of saliency map refinement The hybrid loss 3级层次结构：pixel-level, patch-level, map-level 方式：混合3种loss，Binary Cross Entropy (BCE), Structural SIMilarity (SSIM) and Intersection-over-Union (IoU) losses 效果：effectively segment the salient object regions and accurately predict the fine structures with clear boundaries 精度：在6个数据集上，ofregional and boundary evaluation measures超过SOTA。 速度：over 25 fps on a single GPU Code：https://github.com/NathanUA/BASNet 1. Inroducion 背景 近期FCN被用于显著性目标检测，性能优于传统算法，但their predicted saliency maps are still defective in fine structures and/or boundaries，如图1(c)和(d)所示。 two main challenges in accurate salient object detection network：networks that aggregate multi-level deep features are needed loss：models trained with CE loss usually have low confidence in differentiating boundary pixels, leading to blurry boundaries. Other losses such as Intersection over Union (IoU) loss, F-measure loss and Dice-score loss are not specifically designed for capturing fine structures。 BASNet: the prediction module and RRM To capture both global (coarse) and local (fine) contexts，a new predict-refine network is proposed。 the prediction module a U-Net-like densely supervised Encoder-Decoder network，transfers the input image to a probability map RRM a novel residual refinement module，refines the predicted map by learning the residuals between the coarse saliency map and ground truth the hybrid loss To obtain high confidence saliency map and clear boundary, we propose a hybrid loss that combines Binary Cross Entropy (BCE), Structural SIMilarity (SSIM) and IoU losses, which are expected to learn from ground truth information in pixel-, patch- and map- level, respectively. Rather than using explicit boundary losses (NLDF+ , C2S ), we implicitly inject the goal of accurate boundary prediction in the hybrid loss, contemplating that it may help reduce spurious error from cross propagating the information learned on the boundary and the other regions on the image。 毕竟任务不是边缘检测，所以不能只检测边缘。 2. Related Works Traditional Methods 早期方法根据1个预定义的基于手工特征计算的saliency measure搜索像素以检测显著目标。Borji等人提供了1个全面的综述。 Patch-wise Deep Methods 受深度卷积神经网络推动图片分类发展的启发，早期的deep方法基于从单/多尺度提取的local image patches将image pixels和super pixels分类为显著/非显著。这些方法通常生成coarse outputs因为在全连接层中spatial information会丢失。 FCN-based Methods 相比于Traditional Methods和Patch-wise Deep Methods，基于FCN的方法取得了重要进展，因为FCN is able to capture richer spatial and multiscale information。 UCF、Amulet、NLDF+、DSS+、HED、RAS、LFR、BMPM。 Deep Recurrent and attention Methods PAGRN、RADF+、RFCNPiCANetR Coarse to Fine Deep Methods 为捕捉finer structures和more accurate boundaries，学者提出了大量refinement策略。 SRM、R3Net+、DGRL 3. BASNet3.1. Overview of Network ArchitectureBASNet包括2个Module：Predict Module和Refine Module，如图2所示。 Predict Module a U-Net-like densely supervised Encoder-Decoder network，作用是predict saliency map from input images Refine Module Residual Refinement Module，refines the resulting saliency map of the prediction module by learning the residuals between the saliency map and the ground truth。 3.2. Predict Module 整体 受U-Net和SegNet启发，predict module是1个Encoder-Decoder网络，这种结构可以同时捕捉high level global contexts and low level details。 受HED启发，为减少过拟合，通过ground truth对decoder每个stage的最后1层进行监督，如图2所示。 encoder encoder部分包含1个输入卷积层和6个由basic res-blocks组成的stage，其中输入卷积层和前4个stage是修改过的ResNet34。 改动为本文中的输入卷积层有64个步长为1的3×3卷积核而非步长为2的7×7卷积核，并且在输入卷积层之后没有pooling，这使得在前几层获得更大尺寸的特征图但也减小了整体的感受野。 为获得和ResNet34相同的感受野，本文在ResNet34又加了2个stage，每个stage均由size为2的不重叠maxpooling层及3个512filter的basic res-block组成。 bridge 为进一步捕捉global infomation，本文在encoder和decoder之间添加了1个bridge。 该bridge包括3个512核的dilation为2的3×3卷积层，其中每个卷积层后都有1个BN层和ReLU。 decoder decoder几乎和encoder完全对称。decoder的每个stage包含3个卷积层，每个卷积层后有1个BN层和ReLU。 每个stage的输入是其前1个stage的输出和其对应的encoder中的stage的输出的concatenate结果。 为得到side-output saliency maps，bridge和decoder中每个stage的输出被进行处理，处理过程为：1个3×3卷积、上采样、sigmoid。因此输入1张图片，本文的predict module在训练过程中输出7个saliency maps，其中最后1个saliency map的accuracy最高，所以其作为predict module的最终输出传入refine module。 3.3. Refine Module Refinement Module通常被定义为1个residual block，其通过学习saliency map和ground truth之间的residual$S_{residual}$来refine预测得到的coarse saliency map$S_{coarse}$，公式为$S_{refined}=S_{coarse}+S_{residual}$。 如图3所示，coarse包含2方面的含义：①the blurry and noisy boundaries, ②the unevenly predicted regional probabilities，模型预测所得的coarse saliency map中这2方面的问题都会有。 RRM_LC(residual refinement module based on local context)起初被提出是用于boundary refinement，因为其感受野较小，Islam和Deng等人iteratively或recurrently在不同尺度上使用它refine saliency maps。Wang等人使用了PPM(pyramid pooling module)，其中3个尺度的pyramid pooling features被concatenate。为避免池化操作导致细节损失，RRM_MS使用kernel size和dilation不同的卷积层捕捉multi-scale contexts。然而这些模块是shallow的，所以很难捕捉到可用于refinement的high level information。 本文的RRM和predict module结构相似但简单很多，其包含1个输入层、1个encoder、1个bridge、1个decoder和1个输出层。encoder和decoder都包含4个stage，每个stage只包含1个64核的3×3卷积层，每个卷积层后面都有1个BN层和1个ReLU。bridge和1个stage结构相同，也包含1个64核的3×3卷积层(后面跟着1个BN层和1个ReLU)。encoder中下采样时使用maxpooling，decoder中上采样时使用bilinear interpolation。RRM的输出即本文整个模型最终的输出。 3.4. Hybrid Loss 训练中的Loss是各个side output的loss的加权和，每个side output的loss公式都是1个hybrid loss(3种loss之和)。本文模型对8个side output进行深度监督，其中7个side output来自Predict Module、1个side output来自Refine Module。 BCE Loss：在二分类和分割任务中，二值交叉熵损失函数（Binary Cross Entropy Loss，BCE Loss）是最常用的损失函数。公式略 SSIM Loss：结构相似损失（Structural Similarity Loss，SSIM Loss）在提出时被用于图像质量评价。它可以捕捉一张图片中的结构信息，因此本文将其集成于混合损失函数中，以获取显著目标标注中的结构信息。公式略 IoU Loss：交并比损失（Intersection over Union Loss，IoU Loss）在提出时被用来衡量2个集合的相似性，后来被作为目标检测和分割的标准评估指标。最近，它也被用在了显著性目标检测的训练中。公式略 本文阐述了3种loss的作用，图5中的热力图展示了每个像素的loss随训练过程的变化，3列分别代表训练过程中的不同阶段，3行分别是不同的loss。 BCE Loss是pixel-level的measure，它并不考虑周围像素的label并且foreground像素和background像素的权重相同，有助于所有像素的收敛。 SSIM Loss是patch-level的measure，它考虑每个像素的local neighborhood，对边界具有更高的权重(即使预测前景的概率相同，但边界附近的loss比前景中心的loss更高)。 在训练过程的初始阶段，边界周围像素的loss是最大的(见图5第2行)，这帮助集中于边界附近像素的收敛。随着训练过程，foreground的SSIM Loss减小而background的loss成为主导项。但只有当background的预测非常接近ground truth(0)时 background的loss才会起作用，这时loss会从1急速下降到0，因为通常只有在训练晚期BCE loss平滑(flat)时background的预测才会到0。SSIM Loss保证有足够的梯度使得网络继续学习。因为预测被push到0，background的预测看起来会更clean。 IoU Loss是map-level的measure，但是本文为了阐述所以根据式6画出了每个像素的IoU Loss。 随着foreground的预测越来越接近1，foreground的loss最终变成0。 把3个loss混合起来，利用BCE使每个像素都有smooth gradient，利用IoU给予foreground更多注意力，通过SSIM基于图像结构使得边界的loss更大。 4. Experimental Results4.1. Datasets在6个常用数据集上对模型进行了评估。具体是哪些数据集、这些数据集有哪些特点请见原文。 4.2. Implementation and Experimental Setup 训练 使用DUTS-TR训练模型，训练前进行离线数据增强(将图片水平翻转)。 将图片resize到256×256并随机裁剪成224×224。 encoder的部分参数使用ResNet34的预训练模型进行初始化，其它卷积层通过Xavier初始化。 使用Adam进行训练，超参数为默认值（初始学习率1e-3，betas=(0.9, 0.999)，eps=1e-8，weight decay=0） 一直训练到loss收敛，不使用validation set。最终经历了400k iterations，batch size为8，耗时125小时c 测试/推理 将原图resize到256×256，再将最终得到的显著图resize back到原图大小 软/硬件环境 训练和测试的软硬件环境一致。 PyTorch0.4.0，An eight-core PC with an AMD Ryzen 1800x 3.5 GHz CPU (with 32GB RAM) and a GTX 1080ti GPU (with 11GB memory) 256×256图片的推理耗时为0.04秒。 4.3. Evaluation MetricsPR Curve、F-measure、MAE、relaxed F-measure of boundary ($relaxF^b_{\beta}$)。对这几个评估指标的具体介绍请见原文。 PR Curve PR Curve是1种评估预测所得显著性图的标准方式。1张显著性图的precision和recall通过比较二值化的显著性图及其ground truth计算。1个二值化threshold对应的1对precision和recall是数据集中所有显著性图的平均precision和recall。threshold从0到1变化，可以得到1个precision-recall pair序列，画出来就是PR Curve。 F-measure F-measure可以全面地衡量precision和recall，其基于1对precision和recall进行计算。在进行算法比较时，一般采用最大的F-measure进行比较。 MAE MAE指显著性图与其ground truth的average absolute per-pixel difference。模型对于1个数据集的MAE为所有显著性图的MAE的平均值。 relaxed F-measure of boundary 此处省略，请见原文。 4.4. Ablation Study这个section验证了本文模型中的每个关键component。消融实验包括architecture ablation和loss ablation2个部分。消融实验是在ECSSD数据集上进行的。 architecture ablation 为证明BASNet的有效性，本文提供了BASNet与其它相关结构的量化对比结果。 Loss都使用BCE，首先以U-Net作为baseline，然后是Encoder-Decoder Network、Deep Supervision、RRM_LC、RRM_MS、RRM_Ours，结果如表1所示，可见本文提出的BASNet在这5个实验中性能最优。 loss ablation 为阐述本文提出的fusion loss的有效性，本文基于BASNet使用不同loss进行了1系列实验。表1中的结果证明本文提出的hybrid loss极大地提升了性能，特别是边界的质量。 为进一步阐述损失函数对于BASNet预测质量的影响，使用不同Loss对BASNet进行训练的结果如图7所示，很明显可以看出本文提出的混合损失函数达到了最优的质量。 4.5. Comparison with State-of-the-arts和15个SOTA算法进行比较。公平起见，使用原文作者提供的显著性图或者使用原文作者公开的模型。 Quantitative evaluation 图6展示了在5个数据集上的PR曲线和F-measure曲线，表2展示了在6个数据集上的maximum region-based F-measure、MAE、the relaxed boundary Fmeasure。数据提了很多个percent（略） Qualitative evaluation 图8展示对比了8种算法对不同类型图片的识别效果图，图片类型有images with low contrast、fine structures、large object touching image boundaries、complex object boundaries。 5. Conclusion略 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>显著性目标检测</tag>
        <tag>论文笔记</tag>
        <tag>BASNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSPNet论文阅读笔记]]></title>
    <url>%2F2021%2F03%2F05%2FPSPNet%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本信息 论文名称 Pyramid Scene Parsing Network 作者 Hengshuang Zhao等 发表时间 2016年 来源 CVPR2017 主要收获知识 scene parsing的目标是给图片中每个像素赋予1个类别标签，其可以提供对场景的完整理解，预测每个element的标签、位置和形状。 本文主要贡献 提出PSPNet，将difficult scenery context features嵌入1个FCN based pixel prediction framework。 基于deeply supervised loss，为ResNet提供1个高效的优化策略。 为SOTA的scene parsing and semantic segmentation构建了1个practical system，并公开了所有关键细节。 本文方法原理 为获得合适的global features，本文提出PSPNet。除了使用传统的dilated FCN实现pixel prediction，我们将pixel-level feature扩展到了专门设计的global pyramid pooling的特征中，局部和全局的clues共同使得最终的预测更可靠。我们还提出了1种使用deeply supervised loss的优化策略。我们给出了所有实验细节（对本文模型的性能很重要），并公开了代码和训练好的模型。 本文核心思路 scene parsing还面临着diverse scenes和unrestricted vocabulary的困难，其导致一些外表相似的物体被错误预测，但当有了context prior之后，理应可以得到正确的预测。目前基于FCN算法的主要问题也是缺乏利用global scene category clue的合适策略。所以PSPNet基于FCN将PPM（pyramid pooling module）作为高效的global context prior。 PPM核心思路 感受野的大小可以大概表示我们能用多少context information。而CNN的实验感受野比其理论感受野小得多，特别是网络深层。这使得许多网络没有充分融合重要的global scenery prior。 Global average pooling直接将所有像素混合得到1个vector可能会失去spatial relation并导致ambiguity。考虑到这一点，Global context information和sub-region context有助于区分各种category，1个更有力的representation可以是来自不同sub-regions的具有这些感受野的信息的融合。 其它 FCN用卷积层代替全连接层进行分类 dilated convolution可以增大神经网络的感受野。 本文baseline network是FCN和dilated network(《Semantic image segmentation with deep convolutional nets and fully connected crfs》)。 一些工作主要探索了2个方向：multi-scale feature ensembling和structure prediction，这2个方向都都改善了scene parsing的localization ability。 开创性的《Semantic image segmentation with deep convolutional nets and fully connected crfs》使用条件随机场(CRF)作为post processing以精化分割结果。 《Parsenet: Looking wider to see better》证明了global average pooling with FCN可以提升语义分割结果。 一些未知的东西 scene和vocabulary具体指什么？ context prior具体指什么？ knowledge graph（知识图谱）是什么？ dilated convolution是什么？ Abstract 背景 对于unrestricted open vocabulary和diverse scenes，scene parsing(场景解析)具有挑战性。 方法 本文使用PPM(pyramid pooling module)和提出的PSPNet(pyramid scene parsing network)，实现了通过融合different-region-based context获取全局context信息的能力。本文中的global prior presentation(全局先验表征)可在scene pareing任务中有效产生高质量结果，而PSPNet提供了1个出色的pixel-level prediction framework。 结果 本文提出的方法在多个数据集上实现了SOTA，取得ImageNet scene parsing challenge 2016、PASCAL VOC 2012 benchmark和Cityscapes benchmark的第1名。单独1个PSPNet在PASCAL VOC 2012取得mIoU accuracy 85.4%的新纪录，在Cityscapes取得mIoU accuracy 80.2%的新纪录。 1. Introduction 背景和意义 基于semantic segmentation的scene parsing是计算机视觉中的基本主题，其目标是给图片中每个像素赋予1个类别标签。scene parsing可提供对场景的完整理解，它可以预测每个element的标签、位置和形状。对于自动驾驶、机器人感应等潜在应用，该主题引起了广泛兴趣。 困难 scene parsing的困难与scene和label的多样性紧密相关。首创的scene parsing任务是对LMO数据集中2688张图片的33个场景进行分类。更多最近的PASCAL VOC语义分割数据集和PASCAL context数据集中包括更多context相似的标签，比如chair和sofa、horse和cow等等。新的ADE20K是最具挑战性的1个数据集数据集，其具有大量无限制开放的vocabulary和更多的scene类别，图1展示了其中一些具有代表性的图片。为这些数据集找到1个有效的算法需要克服许多困难。 目前进展 scene parsing的SOTA算法多数是基于全卷积神经网络（FCN）。基于CNN的算法推动了dynamic object understanding，但考虑到diverse scenes和unrestricted vocabulary则还面临着挑战。图2第1行中1个boat被错误识别为car，出现这些错误是由于similar appearance of objects。但当图片的context prior为1条河附近的boathouse时，理应得到正确的预测。 为了精准的场景感知，知识图谱依赖于scene context的先验信息(prior information)。我们发现目前基于FCN算法的主要问题是缺乏利用global scene category clue的合适策略。对于complex scene understanding，为了获取1个global image-level feature，spatial pyramid pooling被广泛应用，因为spatial statistics为overall scene interpretation提供了较好的descriptor。Spatial pyramid pooling network进一步增强了这个能力。 本文方法原理 与上述方法不同，为获得合适的global features，本文提出PSPNet。除了使用传统的dilated FCN实现pixel prediction，我们将pixel-level feature扩展到了专门设计的global pyramid pooling的特征中，局部和全局的clues共同使得最终的预测更可靠。我们还提出了1种使用deeply supervised loss的优化策略。我们给出了所有实验细节（对本文模型的性能很重要），并公开了代码和训练好的模型。 本文方法性能 在所有公开数据集上达到SOTA，是ImageNet scene parsing challenge 2016的冠军、PASCALVOC 2012 semantic segmentation benchmark的第1名、urban scene Cityscapes data的第1名。这证明PSPNet为pixellevel prediction tasks指明了1个方向，它甚至可以帮助基于CNN的stereo matching、optical flow、depth estimation等。 本文主要贡献 提出PSPNet，将difficult scenery context features嵌入1个FCN based pixel prediction framework。 基于deeply supervised loss，为ResNet提供1个高效的优化策略。 为SOTA的scene parsing and semantic segmentation构建了1个practical system，并公开了所有关键细节。 2. Related Work 受FCN用卷积层代替全连接层进行分类的启发，scene parsing和semantic segmentation等pixel-level prediction任务取得了巨大进步。为增大神经网络的感受野，《Semantic image segmentation with deep convolutional nets and fully connected crfs》和《Multi-scale context aggregation by dilated convolutions》使用了dilated convolution。Noh等人提出了1个coarse-to-fine structure with deconvolution network以学习segmentation mask。本文baseline network是FCN和dilated network(《Semantic image segmentation with deep convolutional nets and fully connected crfs》)。 其它工作主要探索了2个方向。 第1个方向是multi-scale feature ensembling。因为在深度网络中，higher-layer feature包含更多semantic meaning，很少location information。融合多尺度的特征可以提高性能。 第2个方向是基于structure prediction。开创性的《Semantic image segmentation with deep convolutional nets and fully connected crfs》使用条件随机场(CRF)作为post processing以精化分割结果。还有一些方法通过end-to-end modeling精化了网络。 这2个方向都都改善了scene parsing的localization ability（predicted semantic boundary fits objects），然而在复杂场景中还有很大空间可以更加有效地利用必要信息。 为充分利用global image-level priors(for diverse scene understanding)，一些方法使用传统方法而非神经网络提取了global context information。在object detection frameworks下也有了相似的提升。Liu等人证明了global average pooling with FCN可以提升语义分割结果。然而本文实验证明，对于ADE20K数据集，这些global descriptors还不足够representative。因此本文使用PSPNet实现了通过融合different-region-based context获取全局context信息的能力。 3. Pyramid Scene Parsing Network在把应用FCN到scene parsing时，我们观察到一些具有代表性的失败案例并对其进行了分析。这激发了我们将pyramid pooling module 作为高效global context prior的思路。图3展示了PSPNet的结构。 3.1. Important ObservationsADE20K数据集包含150个stuff/object category labels（比如wall、sky、tree）和1038张imagelevel scene descriptors（比如airport terminal、bedroom、street），所以形成了大量的label和分布广阔的scene。检查了《Semantic understanding of scenes through the ADE20K dataset》提供的FCN baseline的预测结果，我们总结出了complex-scene parsing的几个普遍问题：Mismatched Relationship、Confusion Categories和Inconspicuous Classes（具体内容见原文）。总结这些问题，很多错误与不同感受野的contextual relationship和global information部分或完全相关。因此1个具有合适global-scene-level prior的神经网络可以大量提高scene parsing的性能。 3.2. Pyramid Pooling Module实验证明，pyramid pooling module是高效的global contextual prior。 在1个神经网络中，感受野的大小可以大概表示我们能用多少context information。虽然理论上ResNet的感受野已经超过输入图片的大小了，但Zhou等人发现CNN的实验感受野比其理论感受野小得多，特别是网络深层。这使得许多网络没有充分融合重要的global scenery prior。本文提出1个高效的global prior representation来解决这个问题。 Global average pooling可以很好地作为global contextual prior的baseline model，常常被用在图片分类任务中，也被用于semantic segmentation。考虑到ADE20K数据集中图片scene的复杂性，该策略并不足以涵盖必要信息：图片的每个像素被标注为许多stuff/objects，直接将它们混合得到1个vector可能会失去spatial relation并导致ambiguity。考虑到这一点，Global context information和sub-region context有助于区分各种category，1个更有力的representation可以是来自不同sub-regions的具有这些感受野的信息的融合。一些场景/图片分类方面的工作[引]也得到了相似结论。 在《Hypercolumns for object segmentation and fine-grained localization》中，pyramid pooling生成的不同层次的feature maps最终被flatten和concatenate，然后送入1个全连接层进行分类。该global prior的目标是移除CNN用于图片分类时fixed-size的constraint。为进一步减少不同sub-region之间的context information loss，本文提出1个hierarchical global prior，包含不同尺度和不同sub-region的信息，称其为pyramid pooling module，用来在神经网络最后1个特征图上构建global scene prior，如图3(c)所示。 PPM的具体结构： PPM融合4个不同金字塔尺度的特征。最coarse的level是global pooling，生成1个single bin output。接下来的pyramid level将特征图划分成不同的sub-region并为不同location形成pooled representation。PPM中不同level的输出包含不同尺寸的特征图。为了保持global feature的占比，我们在每1个pyramid level后使用1×1卷积以将context representation的dimension减少到1。然后将这些1维特征图上采样以使其与初始特征图大小相同。最终将不同level的特征concatenate后作为最终的pyramid pooling global feature。 注意pyramid level的数量和每个level的size是可以修改的，它们与输入至pyramid pooling layer的特征图的size相关。该结构采用size不同、stride不同的pooling kernel以提取不同sub-region的特征。因此这些kernel在representation上应该保持合理的gap。本文中的PPM包含4个level，bin的size分别是1×1、2×2、3×3和6×6。关于选择最大池化还是平均池化，本文5.2节中做了大量实验。 3.3. Network Architecture如图3所示，输入1张图片，使用预训练的ResNet模型并使用dilated network的策略提取得到feature map。最后feature map的size是输入图片size的1/8。然后使用PPM获取context information。通过本文4个level的PPM，可以涵盖图片的whole、half和small portions。然后将PPM4个分支的输出和PPM的输入concatenate。最后再用1个卷积层获得最后的prediction。 PSPNet为pixel-level scene parsing提供了高效的global contextual prior。PPM提取到的特征比global pooling更具代表性。考虑到计算成本，PSPNet相比于其 baseline(the original dilated FCN network)并没有增加多少计算成本。通过end-to-end learning，全局的PPM特征和局部的FCN特征可以最优化。 4. Deep Supervision for ResNet-Based FCN深度网络可以得到好的性能，但增加网络深度可能导致optimization difficulty，ResNet通过在每个block中使用skip connection解决了这个问题。ResNet的Latter layers主要基于previous ones学习residues。 相反地，本文通过1个additional loss生成initial results，然后通过the final loss学习residue。因此，深度网络的优化被分解成易解的2个。 略…… Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>论文笔记</tag>
        <tag>scene parsing</tag>
        <tag>PSPNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FPN网络图解及论文笔记]]></title>
    <url>%2F2021%2F03%2F02%2FFPN%E7%BD%91%E7%BB%9C%E5%9B%BE%E8%A7%A3%E5%8F%8A%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[FPN网络图解 原图片以及PPT源文件下载链接（欢迎关注我的知乎！）： 链接：https://pan.baidu.com/s/10y78HagInyCuCA-aMeNJpg 提取码：iccm 复制这段内容后打开百度网盘手机App，操作更方便哦 基本信息 论文名称 Feature Pyramid Networks for Object Detection 作者 Tsung-Yi Lin等 Facebook AI Research 发表时间 2017年 来源 CVPR2017 主要收获 知识 高级语义信息是有助于识别目标但有害于定位目标，低级空间信息有害于识别目标但有助于定位目标（由于其下采样次数较少，所以其可以更准确地定位）。 SSD没有利用higher-resolution maps，而本文证明了higher-resolution maps对于检测小物体很重要。 Introduction整体思路 Feature Pyramids可以用于检测不同尺度的目标。 Featurized Image Pyramids将图片缩放到不同大小并分别提取其特征并进行检测，其结构如图1(a)所示，其被大量应用于手工特征，其优点是每个层次都具有很强的语义信息（即使是high-resolution levels），其缺点是分别提取每个层次的特征并进行检测导致推理时间相应加倍。 在recognition任务中，卷积网络逐渐取代了手工特征。卷积网络（Single feature map）逐渐不仅可以表示高级语义，在尺度变化方面也更具稳健性，因此可以只在一个尺度的特征图上进行检测，其结构如图1(b)所示，但其缺点是未利用到卷积网络固有的Pyramidal feature hierarchy。 卷积网络（Pyramidal feature hierarchy）天然具有多尺度的、金字塔型的特征层次，其结构如图1(c)所示，其缺点是造成不同层次特征图之间的语义差异，high-resolution maps中包含的低级特征降低了该特征图在目标检测任务中的表征能力。SSD并没有利用higher-resolution maps，但本文证明了higher-resolution maps对于检测小物体很重要。 如图2(top)所示，一些采用自上到下路径和skip connections的方法仅在自上到下路径顶部的单个特征图上进行预测，实际上这些方法还需要image pyramids以识别多尺度的目标。 如图2(bottom)和图1(d)所示，FPN自然地利用卷积网络固有的金字塔层次同时创建每层都有较强语义信息的特征金字塔，通过1个从上到下的路径和侧边连接将low-resolution、semantically strong的特征和high-resolution、semantically weak的特征结合起来，在自上到下路径所有特征图上都进行预测，最终仅从单尺度的输入图片得到各层都有较强语义信息的特征金字塔，且不需额外计算成本。 FPN以任意大小的单张图片为输入。 对于ResNet，FPN并不将其第1个stage的输出包含到FPN中因为其内存占用量比较大。 FPN中bottom-up路径中相邻层间下采样比例为2 FPN的building block 图3展示了创建top-down路径中特征图的building block。将top-down路径中coarser-resolution的特征图上采样（比例为2），将bottom-up路径中的特征图通过1×1卷积减少通道数，然后将两者相加（element-wise）。这个过程一直迭代到生成最大的特征图。在开始top-down路径之前会在bottom-up路径顶层使用1×1卷积生成尺度最小的特征图。在每个相加操作之后使用3×3卷积减少上采样带来的混淆效应（aliasing effect）。 FPN和传统的featurized image pyramid一样，各个金字塔层都使用共享的classifier/regressor。 一些未知的东西 特征金字塔 原文：E. H. Adelson, C. H. Anderson, J. R. Bergen, P. J. Burt, and J. M. Ogden. Pyramid methods in image processing. RCA engineer, 1984. 尺度不变性（scale-invariant） Abstract Feature Pyramids（特征金字塔）是识别系统中用来检测不同尺度的目标的一个基本组件 近期深度学习目标检测方法却避免了pyramid representations，如原文图1(b)，部分原因是它们是计算和内存密集型的 FPN(Feature Pyramid Network) 使用少量成本，利用卷积网络固有的多尺度金字塔层次结构来构建特征金字塔 是一种带有侧向连接的自顶向下的结构，可以在所有尺度上构建高级语义特征 性能 将FPN应用于基本的Faster-RCNN，在COCO detection benchmark上超过SOTA的single model 在GPU上达6FPS 1. Introduction 识别不同尺寸的目标是计算机视觉领域的一个基础挑战 Featurized Image Pyramids（特征化的图像金字塔） 定义 Featurized Image Pyramids即Feature pyramids built upon image pyramids（建立在图像金字塔上的特征金字塔），见原文图1(a)。也就是将图片缩放到不同大小并分别提取其特征并进行检测。 其构成了标准解决方案的基础，其具有尺度不变性（scale-invariant），因为可以通过金字塔中的不同层来处理不同尺寸的目标，可以基于层维度和位置维度对目标进行扫描检测。 应用 Featurized Image Pyramids在手工设计的特征中被大量使用，如DPM算法。 优点 所有最近的ImageNet和COCO比赛的前几名都在Featurized Image Pyramids上进行多尺度测试。 Featurized Image Pyramids的主要优点是每个层次都具有很强的语义信息，即使是high-resolution levels。 缺点 分别提取每个层次的特征并进行检测，推理时间相应地加倍。 考虑到内存等因素，不可能端到端地在图像金字塔上训练卷积网络，最多只能在测试的时候使用图像金字塔（同时这也造成训练和测试的不一致性） 因为这些原因，Fast和Faster R-CNN默认也就没有使用FIP。 卷积网络（Single feature map） 在Recognition任务中，手工特征逐渐被卷积网络取代。 卷积网络不仅可以表示高级语义，在尺度变化方面也更具稳健性，因此可以只在一个尺度的特征图上进行检测，如原文图1(b)。 但即使具备这样的稳健性，卷积网络中仍然需要金字塔（可以通过Pyramidal feature hierarchy改进）。 卷积网络（Pyramidal feature hierarchy） 固有金字塔特征层次 然而image pyramids并不是实现多尺度特征表示的唯一方法，卷积神经网络天然具有多尺度的、金字塔型的特征层次（feature hierarchy），如原文图1(c)。 缺点 卷积网络的特征层次产生了不同尺寸的特征图，但是造成不同层次特征图之间的语义差异，尺寸大的特征图（high-resolution maps）包含着低级特征，这些低级特征降低了该特征图在目标检测任务中的表征能力。 SSD是第一批尝试利用卷积网络中Pyramidal feature hierarchy的方法之一，但其也存在不足。理想情况中，SSD系列会利用forward pass中生成的多尺度特征，因此没有额外计算成本。但是为了避免使用低级特征，SSD没有使用已有的层，而是从网络高层开始构建金字塔并添加几个新层。因此SSD没有利用higher-resolution maps，而本文证明了higher-resolution maps对于检测小物体很重要。 Feature Pyramid Network 定义 自然地利用卷积网络固有的金字塔层次同时创建每层都有较强语义信息的特征金字塔。如图1(d)和图2(bottom)所示，通过1个从上到下的路径和侧边连接将low-resolution、semantically strong的特征和high-resolution、semantically weak的特征结合起来，仅从单尺度的输入图片得到各层都有较强语义信息的特征金字塔，且不需额外计算成本。 相关工作 如图2(top)所示，其它采用自上到下路径和skip connections的方法仅在自上到下路径顶部的单个特征图上进行预测，实际上这些方法还需要image pyramids以识别多尺度的目标，而FPN是在自上到下路径所有特征图上都进行预测。 效果 在detection和segmentation系统上进行评估，仅将FPN应用于基础的Faster R-CNN在COCO detection benchmark上实现SOTA。 在ablation experiments中，对于bounding box proposals，FPN将AR(Average Recall)提升了8 points；对于目标检测，将COCO-style Average Precision (AP)提升了2.3 points，将PASCAL-style AP，提高了3.8 points。 FPN易于应用于到mask proposals并能提升实例分割的AR和速度。 FPN可以进行端到端的多尺度训练，并且在训练和测试时都可以用，还不增加计算成本。 2. Related Work Hand-engineered features and early neural networks SIFT特征用于特征点匹配，HOG和后来的SIFT在整个图像金字塔上进行密集计算，它们在图像分类、目标检测、人体姿态估计等任务中被大量使用。 很快地也有了许多关于featurized image pyramids的研究。Dollar等人首先按尺度稀疏采样得到1个金字塔，然后对缺失的level进行插值，实现了快速的金字塔计算。在HOG和SIFT之前，使用卷积网络进行人脸检测的早期工作计算图像金字塔上的浅层网络以检测跨多尺度的人脸。 Deep ConvNet object detectors OverFeat采用1种与早期神经网络人脸检测器相似的策略，其将1个卷积网络作为1个sliding window detector应用于图像金字塔。 R-CNN采用1种基于region proposal的策略，其中在使用卷积网络分类之前each proposal was scale-normalized。 SPPNet表明这些基于region的detector可以更有效地应用于从单尺度图片提取出的特征图上。 最近更加准确的Fast R-CNN和Faster R-CNN等算法提倡使用从单尺度图片计算得到的特征，因为这可以实现accuracy和speed的trade-off。 Multi-scale detection仍然表现更佳，特别是对于小目标。 Methods using multiple layers 最近大量方法利用卷积网络中的不同层提高了检测和分割的性能。FCN在多个尺度上计算每个category的的partial score以得到语义分割，Hypercolumns将类似方法应用于object instance segmentation。HyperNet、ParseNet和ION等方法在计算结果前将多层特征拼接，这等价于对转换后的特征求和。SSD和MS-CNN在多个特征层分别预测结果，并没有将多层特征结合。 最近有很多方法在探索可以将低级特征和高级特征融合的lateral/skip connections，包括用于segmentation的U-Net和SharpMask、用于人脸检测的Recombinator networks、用于关键点预测的Stacked Hourglass networks。Ghiasi等人实现了在FCN上实现了1个Laplacian pyramid presentation，可以逐渐优化分割结果。即使这些方法采用了金字塔形状的结构，它们并不像featurized image pyramids一样在所有层独立预测结果，如图2所示，实际上这些方法还需要image pyramids以识别多尺度的目标。 3. Feature Pyramid NetworksFPN的目标是构造1个各层都具有较强高级语义信息的特征金字塔。FPN is general-purpose（多用途的），本文将其应用于RPN和Fast R-CNN，在Sec. 6中将其generalize到instance segmentation proposals。 FPN通过全卷积的方式，以任意大小的单张图片为输入，在多个尺度输出对应比例大小的特征图。该过程独立于骨干网络的具体架构，本文展示了基于ResNet的结果。FPN的构建包括1个bottom-up路径、1个top-down路径和lateral connections。 Bottom-up pathway Bottom-up pathway就是骨干网络的feedforward，每层间下采样比例为2。网络中经常有连续几个层输出的特征图尺寸相同，我们称这些层位于同1个stage。在FPN中，为每个stage定义1个金字塔层。取每个stage中最后1层的输出代表该stage，因为每个stage中最深的层应该具有最强的特征。 对于ResNet，使用后4个stage（相对于输入的步长分别为4、8、16、32）的输出，并不将第1个stage的输出包含到FPN中因为其内存占用量比较大。 Top-down pathway and lateral connections top-down pathway将金字塔中空间信息粗糙、语义信息更强的高层特征图上采样生成尺寸较大的特征图，然后通过lateral connections用bottom-up路径中的特征对这些特征进行增强。每个lateral connection将bottom-up路径和top-down路径中相同尺寸的特征图融合。bottom-up路径中的特征图具有较低级别的语义信息，但是由于其下采样次数较少所以其可以更准确地定位。 图3展示了创建top-down路径中特征图的building block。将top-down路径中coarser-resolution的特征图上采样（比例为2），将bottom-up路径中的特征图通过1×1卷积减少通道数，然后将两者相加（element-wise）。这个过程一直迭代到生成最大的特征图。在开始top-down路径之前会在bottom-up路径顶层使用1×1卷积生成尺度最小的特征图。在每个相加操作之后使用3×3卷积减少上采样带来的混淆效应（aliasing effect）。 因为各个金字塔层都和传统的featurized image pyramid一样使用共享的classifier/regressor，所以将所有额外卷积层的输出通道数设置为256。在这些额外的层中，并不存在non-linearities，但我们凭经验发现其影响很小。 simplicity对FPN非常重要，我们发现FPN对很多设计选择具有鲁棒性。我们使用更sophisticated的block（比如使用multilayer residual blocks作为连接）进行实验并观察到了略胜一筹的结果。设计更优的connection并非本文的重点，所以我们采用了上述的简单设计。 4. Applications略…… Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>论文笔记</tag>
        <tag>FPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ResNet50网络结构图及结构详解]]></title>
    <url>%2F2021%2F02%2F26%2FResNet50%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE%E5%8F%8A%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[toc] 引言之前我读了ResNet的论文Deep Residual Learning for Image Recognition，也做了论文笔记，笔记里记录了ResNet的理论基础（核心思想、基本Block结构、Bottleneck结构、ResNet多个版本的大致结构等等），看本文之间可以先看看打打理论基础。 一个下午的时间，我用PPT纯手工做了一张图片详细说明ResNet50的具体结构，本文将结合该图片详细介绍ResNet50。 这张图和这篇文章估计全网最详细了（狗头）。 废话不多说，先放图片（文末有图片和PPT源文件的下载链接）。 上图（称为本图）可划分为左、中、右3个部分，三者内容分别如下 ResNet50整体结构 ResNet50各个Stage具体结构 Bottleneck具体结构 接下来为正文内容，本文先后介绍了本图从左到右的3个部分，并对Bottleneck进行了简要分析。 ResNet50整体结构首先需要声明，这张图的内容是ResNet的Backbone部分（即图中没有ResNet中的全局平均池化层和全连接层）。 如本图所示，输入INPUT经过ResNet50的5个阶段（Stage 0、Stage 1、……）得到输出OUTPUT。 下面附上ResNet原文展示的ResNet结构，大家可以结合着看，看不懂也没关系，只看本文也可以无痛理解的。 上图描述了ResNet多个版本的具体结构，本文描述的“ResNet50”中的50指有50个层。和上图一样，本图描述的ResNet也分为5个阶段。 ResNet各个Stage具体结构如本图所示，ResNet分为5个stage（阶段），其中Stage 0的结构比较简单，可以视其为对INPUT的预处理，后4个Stage都由Bottleneck组成，结构较为相似。Stage 1包含3个Bottleneck，剩下的3个stage分别包括4、6、3个Bottleneck。 现在对Stage 0和Stage 1进行详细描述，同理就可以理解后3个Stage。 Stage 0 (3,224,224)指输入INPUT的通道数(channel)、高(height)和宽(width)，即(C,H,W)。现假设输入的高度和宽度相等，所以用(C,W,W)表示。 该stage中第1层包括3个先后操作 CONV CONV是卷积（Convolution）的缩写，7×7指卷积核大小，64指卷积核的数量（即该卷积层输出的通道数），/2指卷积核的步长为2。 BN BN是Batch Normalization的缩写，即常说的BN层。 RELU RELU指ReLU激活函数。 该stage中第2层为MAXPOOL，即最大池化层，其kernel大小为3×3、步长为2。 (64,56,56)是该stage输出的通道数(channel)、高(height)和宽(width)，其中64等于该stage第1层卷积层中卷积核的数量，56等于224/2/2（步长为2会使输入尺寸减半）。 总体来讲，在Stage 0中，形状为(3,224,224)的输入先后经过卷积层、BN层、ReLU激活函数、MaxPooling层得到了形状为(64,56,56)的输出。 Stage 1在理解了Stage 0以及熟悉图中各种符号的含义之后，可以很容易地理解Stage 1。理解了Stage 1之后，剩下的3个stage就不用我讲啦，你自己就能看懂。 Stage 1的输入的形状为(64,56,56)，输出的形状为(64,56,56)。 下面介绍Bottleneck的具体结构（难点），把Bottleneck搞懂后，你就懂Stage 1了。 Bottleneck具体结构现在让我们把目光放在本图最右侧，最右侧介绍了2种Bottleneck的结构。 “BTNK”是BottleNeck的缩写（本文自创，请谨慎使用）。 2种Bottleneck分别对应了2种情况：输入与输出通道数相同（BTNK2）、输入与输出通道数不同（BTNK1），这一点可以结合ResNet原文去看喔。 BTNK2我们首先来讲BTNK2。 BTNK2有2个可变的参数C和W，即输入的形状(C,W,W)中的c和W。 令形状为(C,W,W)的输入为$x$，令BTNK2左侧的3个卷积块（以及相关BN和RELU）为函数$F(x)$，两者相加（$F(x)+x$）后再经过1个ReLU激活函数，就得到了BTNK2的输出，该输出的形状仍为(C,W,W)，即上文所说的BTNK2对应输入$x$与输出$F(x)$通道数相同的情况。 BTNK1BTNK1有4个可变的参数C、W、C1和S。 与BTNK2相比，BTNK2多了1个右侧的卷积层，令其为函数$G(x)$。BTNK1对应了输入$x$与输出$F(x)$通道数不同的情况，也正是这个添加的卷积层将$x$变为$G(x)$，起到匹配输入与输出维度差异的作用（$G(x)$和$F(x)$通道数相同），进而可以进行求和$F(x)+G(x)$。 简要分析可知，ResNet后4个stage中都有BTNK1和BTNK2。 4个stage中BTNK2参数规律相同 4个stage中BTNK2的参数全都是1个模式和规律，只是输入的形状(C,W,W)不同。 Stage 1中BTNK1参数的规律与后3个stage不同 然而，4个stage中BTNK1的参数的模式并非全都一样。具体来讲，后3个stage中BTNK1的参数模式一致，Stage 1中BTNK1的模式与后3个stage的不一样，这表现在以下2个方面： 参数S：BTNK1左右两个1×1卷积层是否下采样 Stage 1中的BTNK1：步长S为1，没有进行下采样，输入尺寸和输出尺寸相等。 后3个stage的BTNK1：步长S为2，进行了下采样，输入尺寸是输出尺寸的2倍。 参数C和C1：BTNK1左侧第一个1×1卷积层是否减少通道数 Stage 1中的BTNK1：输入通道数C和左侧1×1卷积层通道数C1相等（C=C1=64），即左侧1×1卷积层没有减少通道数。 后3个stage的BTNK1：输入通道数C和左侧1×1卷积层通道数C1不相等（C=2*C1），左侧1×1卷积层有减少通道数。 为什么Stage 1中BTNK1参数的规律与后3个stage不同？（个人观点） 关于BTNK1左右两个1×1卷积层是否下采样 因为Stage 0中刚刚对网络输入进行了卷积和最大池化，还没有进行残差学习，此时直接下采样会损失大量信息；而后3个stage直接进行下采样时，前面的网络已经进行过残差学习了，所以可以直接进行下采样。 关于BTNK1左侧第一个1×1卷积层是否减少通道数 根据ResNet原文可知，Bottleneck左侧两个1×1卷积层的主要作用分别是减少通道数和恢复通道数，这样就可以使它们中间的3×3卷积层的输入和输出的通道数都较小，因此效率更高。 Stage 1中BTNK1的输入通道数C为64，它本来就比较小，因此没有必要通过左侧第一个1×1卷积层减少通道数。 福利 扫码关注微信公众号后回复resnet即可直接获取图片和PPT源文件的下载链接。 参考链接https://www.bilibili.com/read/cv2051292 https://arxiv.org/abs/1512.03385 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>论文笔记</tag>
        <tag>ResNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ResNet论文阅读笔记]]></title>
    <url>%2F2021%2F02%2F26%2FResNet%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[toc] 基本信息 论文名称 Deep Residual Learning for Image Recognition 作者 Kaiming He Microsoft Research 发表时间 2015年 来源 CVPR2016 主要收获 知识 较深的神经网络难以训练 网络的深度对于许多视觉识别任务至关重要 152层的ResNet，8× deeper than VGG，但却有更低的计算复杂度，在ImageNet测试集上错误率为3.57%，获ILSVRC 2015中图像分类任务的第1名。 ResNet在COCO目标检测数据集上获得了28％的相对改进，在其它几个数据集和任务上也取得第1名。 假设多个非线性层可以渐近地逼近复杂函数（该假设还有待讨论，详见引文），则等效于假设它们可以渐近地近似残差函数。 理论基础：假设目标函数为H(x)，可将其表示为H(x)=F(x)+x。若最优解是identity mapping，则此时F(x)为0，使参数为0比学习H(x)更加容易。 F(x)+x可以通过shortcut connections实现，不需额外参数，仅需微小计算量（element-wise addition）。 基础网络（Plain Network）采用VGGNet的设计思路，主要使用3×3卷积并遵守2个设计原则：①若输出特征图的尺寸不变，则通道数也应不变；②若输出特征的尺寸减半，则通道数应增1倍以保留时间复杂度。 ResNet50网络结构图解以及Bottleneck结构图解 未知点 residual：并不只是ResNet中的residual，在其它领域和算法中也有residual的概念，有待了解。 inception：《Going deeper with convolutions》 highway networks：《Highway networks》、《Training very deep networks》 VGGNet的设计思想 bacth normalization mini-batch Abstract 较深的神经网络难以训练，本文提出一个residual learning framework训练较深的神经网络。 We explicitly reformulate the layers as learning residual functions with reference to the layer inputs, instead of learning unreferenced functions. 通过大量empirical实验证明，本文中提出的残差网络更易优化，并可以从大量增加的网络深度中获取准确性。用152层（8× deeper than VGG），但却有更低的计算复杂度，在ImageNet测试集上错误率为3.57%(top5)，获ILSVRC 2015中图像分类任务的第1名。 网络的深度对于许多视觉识别任务至关重要。ResNet在COCO目标检测数据集上获得了28％的相对改进，在其它几个数据集和任务上也取得第1名。 1. Introduction 背景/问题 深度网络以1种end-to-end的多层的方式，自然地集成了low/mid/high-level features和classifiers[引]，并且features的“levels”可以通过堆叠层数（深度）来enrich。 最近有研究[引]证明网络的深度十分重要，ImageNet上的领先结果[引]都使用了”very deep” model[引]（16到30层），较深的网络在其它视觉识别任务中也有好的效果。 既然深度如此重要，那有个问题是：Is learning better networks as easy as stacking more layers。要回答这个问题，1个障碍是梯度消失/爆炸（会影响模型收敛），该问题已通过normalized initialization[引]和intermediate normalization layers[引]得到很大的解决，可以使数十层的网络通过SGD收敛。 深度模型收敛之后，又遇到了the degradation problem：随着网络深度增加，准确率变得饱和然后迅速下降，并且实验结果说明这种下降并不是过拟合导致的。相关研究[引]指出给1个层数合适的网络添加更多的层会导致训练误差增高，本文图1和图4也彻底证明了这一点。 考虑1个shallower architecture并基于此添加一些层形成1个deeper counterpart，如果添加的这些层是identity mapping，那这个deeper counterpart则等同于这个shallower architecture。这说明1个deeper model的训练误差应不高于其shallower counterpart。但实验证明，目前的模型并没有达到这个效果。 本文所提方法的原理及优点 本文提出1个deep residual learning framework来解决degradation问题。each few stacked layers并不直接拟合1个desired underlying mapping：$H(x)$，而是拟合1个residual mapping：$F(x)=H(x)-x$，即原先想要的underlying mapping为$H(x)=F(x)+x$。 我们假定该residual mapping比原先的mapping更易优化。在极端情况下如果identity mapping是最优的，使residual为0比拟合1个identity mapping更加容易。 $F(x)+x$可以通过shortcut connections实现，在本方法中其仅需进行identity mapping和相加，如原文图2所示。这种identity shortcut connections不需要额外参数和计算量。整个网络仍可以通过SGD进行end-to-end训练，并易于通过Caffe等开源库实现。 实验与结果 本文在ImageNet上进行了全面实验以说明degradation问题和评估本文的方法。 Our extremely deep residual nets are easy to optimize, but the counterpart “plain” nets (that simply stack layers) exhibit higher training error when the depth increases. Our deep residual nets can easily enjoy accuracy gains from greatly increased depth, producing results substantially better than previous networks. 在CIFAR-10上进行实验也出现了类似现象，说明degradation问题和本文方法并不只适用于特定数据集。我们训练了超过100层的网络，还尝试了超过1000层的网络。 在ImageNet上，我们的152层网络是最深的，但其比VGG计算复杂度更低，在ImageNet测试集上错误率为3.57%(top5)，获ILSVRC 2015中图像分类任务的第1名。在其它识别任务中也有出色表现，有多项第1名（略）。这说明the residual learning principle is generic，我们猜想本方法也适用于其它视觉和非视觉问题。 2. Related Work Residual Representations image recognition VLAD[引]、Fisher Vector[引]、encoding residual vectors[引] low-level vision and computer graphics Multigrid method[引]、hierarchical basis preconditioning[引]、 Shortcut Connections some practices and theories of shortcut connections 具体看引文 comparison with the shortcut connections with gating functions（shortcut connections with gating functions） 3. Deep Residual Learning3.1. Residual Learning假设某几个连续的层（并非必须是整个网络）要拟合的目标是函数H(x)，x是其中第1层的输入。假设多个非线性层可以渐近地逼近复杂函数（该假设还有待讨论，详见引文），则等效于假设它们可以渐近地近似残差函数，即F(x)=H(x)-x（假设输入和输出的维数相同）。虽然H(x)和F(x)+x形式相同， 但学习成本是不同的。这种重构的思路来源于原文图1所示的the degradation problem，其指出深度模型在通过多个层拟合identity mappings时遇到了问题。通过重构，训练师使参数趋于0会更容易。 在真实情况中，虽然identity mappings并不一定是最优解，但该思路还是可能对the degradation problem进行了precondition。相对于1个zero mapping，如果最优解更接近于identity mappings，那么参考identity mappings做扰动应该比从头学习1个新的函数要更容易。本文通过实验（图7）表明，学习到的残差函数通常具有较小的响应（small responses），这表明identity mappings提供了合理的precondition。 3.2. Identity Mapping by Shortcuts每几个层都进行residual learning，形成1个具有多层的block（见原文图2）。图2所示的block有2层，其公式（式1）为$y=F(x,\{W_i\})+x=\sigma(W_2\sigma(W_1x+b_1)+b)$，其中$\sigma$是ReLU。 F(x)+x通过shortcut connection实现，即保存输入x然后和输出F(x)相加得到F(x)+x，并且使用的这种shortcut connection并不增加参数和计算量（仅增加了微不足道的element-wise addition）。 在式1中，F(x)和x的通道数必须是一样的，否则就需要在shortcut connections中对x进行1个线性投影（linear projection）以匹配维度，即式2：$y=F(x,\{W_i\})+W_sx$，其中$W_s$仅被用来匹配F(x)的维度。 每个block中可以有更多层，比如3（如图5所示的BottleNeck），但如果每个block中只有1层的话，公式就变成了1个线性层$y = W_1x+x$。 这种block也适用于卷积层，其中F(x)+x是每个维度对应位置元素相加。 3.3. Network Architectures Plain Network 根据VGG网络的理论，主要使用3×3卷积并遵守2个设计原则：①若输出特征图的尺寸不变，则通道数也应不变；②若输出特征的尺寸减半，则通道数应增1倍以保留时间复杂度。 本文直接通过步长为2的卷积层进行下采样，网络尾部是1个global average pooling layer和1个1000-way fully-connected layer with softmax，共有34层权重（图3中间的网络）。 该模型中的通道比VGG网络更少，有更低的复杂度，FLOPS是VGG19的18%。 Residual Network 基于上述Plain Network，添加shortcut connections（图3右边的网络），形成ResNet34。 对于identity shortcut，当输出和输入的通道数相同时（实线），就直接每个通道对应位置元素相加； 当输出的通道数大于输入时（虚线），有2个方法：①The shortcut still performs identity mapping, with extra zero entries padded for increasing dimensions. ②通过式2表示的projection shortcut匹配通道（以1×1卷积实现）。对于这2个方法，当输出和输入的尺寸不同时，这是通过步长为2实现（尺寸减半，通道数对应增加1倍）的。 3.4. Implementation在ImageNet上 按照引文41，将图片根据短边随机缩放到[256,480]。随机224×224 crop，随机水平翻转，减去像素均值。 按照引文21，每个卷积后和每个激活函数前使用bacth normalization。 按照引文13，初始化模型参数。 从头训练，SGD，mini-batch大小为256，学习率从0.1开始当loss稳定时除以10，训练了60W个iteration。 weight decay 0.0001，momentum 0.9。 不使用dropout。 4. Experiments4.1. ImageNet Classification Plain Networks 略 Residual Networks 略 Deeper Bottleneck Architectures 考虑到可接受的训练时长，使用Bottleneck（图5所示），每个block中包含3个层：1×1卷积、3×3卷积、1×1卷积，其中2个1×1卷积分别用来减少和恢复维度，使得3×3卷积接收和输出更少的通道数。 不需额外参数的identity shortcuts对于Bottleneck非常重要，如果把Bottleneck中的identity shortcut换成projection，模型的时间复杂度和参数量就会增加1倍，因为shortcut连接到了2个高维特征上。所以identity shortcuts使得基于Bottleneck的模型更加有效。 50-layer ResNet ResNet50，将ResNet34中包含2层的block换成Bottleneck，就得到了ResNet50。当输出的通道数大于输入时，使用第2种方法（式2）。 略…… Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>论文笔记</tag>
        <tag>ResNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-6.4学习率调整方法]]></title>
    <url>%2F2021%2F02%2F15%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-6-4%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%B0%83%E6%95%B4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[RMSProp2013年Hinton在Coursera提出。 背景 RMSProp是Adagrad的升级版。 在训练神经网络时，损失函数不一定是凸函数（局部最小值即为全局最小值），可能是各种各样的函数，有时需要较大的学习率，有时需要较小的学习率，而Adagrad并不能实现这种效果，因此产生了RMSProp。 定义 w^{t+1}=w^t-\frac{\eta}{\sigma^t}g^t\\ \sigma^0=g^0,\sigma^t=\sqrt{\alpha(\sigma^{t-1})^2+(1-\alpha)(g^t)^2} 其中$w$是某个参数；$\eta$是学习率；$g$是梯度；$\alpha$代表旧的梯度的重要性，值越小则旧的梯度越不重要。 神经网络中很难找到最优的参数吗？ 面临的问题有plateau、saddle point和local minima。 | 英文 | 中文 | 梯度 | | :—————: | :————: | :——————————————————-: | | plateau | 停滞期 | $\frac{\partial L}{\partial w}\approx0$ | | saddle point | 鞍点 | $\frac{\partial L}{\partial w}=0$ | | local minima | 局部最小值 | $\frac{\partial L}{\partial w}=0$ | 2007年有人（名字读音好像是young la ken）指出神经网络的error surface是很平滑的，没有很多局部最优。 假设有1000个参数，一个参数处于局部最优的概率是$p$，则整个神经网络处于局部最优的概率是$p^{1000}$，这个值是很小的。 Momentum1986年提出 如何处理停滞期、鞍点、局部最小值等问题？ 考虑现实世界中物体具有惯性、动量（Momentum）的特点，尽可能避免“小球”陷入error surface上的这几种位置。 定义 如下图所示，不仅考虑当前的梯度，还考虑上一次的移动方向：$v^t=\lambda v^{t-1}-\eta g^t,v^0=0$， 其中上标$t$是迭代次数；$v$指移动方向（movement），类似于物理中的速度；$g$是梯度（gradient）；$\lambda$用来控制惯性的重要性，值越大代表惯性越重要；$\eta$是学习率。 AdamRMSProp+Momentum+Bias Correction，2015年提出 Adam VS SGDM目前常用的就是Adam和SGDM。 Adam训练速度快，large generalization gap（在训练集和验证集上的性能差异大），但不稳定；SGDM更稳定，little generalization gap，更加converge（收敛）。 领域 技术/模型 优化器 Q&amp;A、文意理解、文章生成 BERT Adam BERT的Backbone、翻译 Transformer Adam 语音生成 Tacotron Adam 目标检测 YOLO SGDM 目标检测 Mask R-CNN SGDM 图片分类 ResNet SGDM 图片生成 Big-GAN Adam 元学习 MAML Adam SGDM适用于计算机视觉，Adam适用于NLP、Speech Synthesis、GAN、Reinforcement Learning。 SWATS2017年提出，尝试把Adam和SGDM结合，其实就是前一段时间用Adam，后一段时间用SGDM，但在切换时需要解决一些问题。 尝试改进Adam AMSGrad Adam的问题 Non-informative gradients contribute more than informative gradients. 在Adam中，之前所有的梯度都会对第$t$步的movement产生影响。然而较早阶段(比如第1、2步)的梯度信息是相对无效的，较晚阶段（比如$t-1$、$t-2$步）的梯度信息是相对有效的。在Adam中，可能发生较早阶段梯度相对于较晚阶段梯度比重更大的问题。 提出AMSGrad 2018年提出 AdaBound 2019年提出，目的也是改进Adam。 Adam需要warm up吗？需要 warm up：开始时学习率小，后面学习率大。 因为实验结果说明在刚开始的几次（大概是10次）迭代中，参数值的分布比较散乱（distort），因此梯度值就比较散乱，导致梯度下降不稳定。 RAdam 2020年提出 Lookahead 2019年提出，像一个wrapper一样套在优化器外面，适用于Adam、SGDM等任何优化器。 迭代几次后会回头检查一下。 Nadam 2016年提出，把NAG的概念应用到Adam上。 AdamW 2017年提出，这个优化器还是有重要应用的（训练出了某个BERT模型）。 尝试改进SGDM LR range test 2017年提出 Cyclical LR 2017年提出 SGDR 2017年提出，模拟Cosine但并不是Cosine One-cycle LR 2017年提出，warm-up+annealing+fine-tuning SGDW 2017年提出， 改进Momentum 背景 如果梯度指出要停下来，但动量说要继续走，这样可能导致坏的结果。 NAG（Nesterov accelerated gradient） 1983年提出，会预测下一步。 Early Stopping如果学习率调整得较好，随着迭代次数增加，神经网络在训练集上的loss会越来越小，但因为验证集（Validation set）和训练集不完全一样，所以神经网络在验证集上的loss可能不降反升，所以我们应该在神经网络在验证集上loss最小时停止训练。 Keras文档中就有关于Early stopping的说明。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>学习率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-6.3常用激活函数]]></title>
    <url>%2F2021%2F02%2F15%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-6-3%E5%B8%B8%E7%94%A8%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[toc] 梯度消失（Vanishing Gradient Problem） 定义 1980年代常用的激活函数是sigmoid函数。以MNIST手写数字识别为例，在使用sigmoid函数时会发现随着神经网络层数增加，识别准确率逐渐下降，这个现象的原因并不是过拟合（原因见上文），而是梯度消失。 如上图所示，当神经网络层数很多时，靠近输入层的参数的梯度会很小，靠近输出层的参数的梯度会很大。当每个参数的学习率相同时，靠近输入层的参数会更新得很慢，靠近输出层的几层参数会更新得很快。所以，当靠近输入层的参数几乎还是随机数时，靠近输出层的参数已经收敛了。 原因 按照反向传播的式子，这确实是会发生的。 直观感觉上，sigmoid函数输入的范围是无穷大，但输出的范围是[0,1]，也就是说sigmoid函数减弱了输入变化导致输出变化的幅度。那为什么靠近输出层的参数的梯度更大呢？sigmoid函数是一层层叠起来的，不断地减弱靠近输入层的参数的变化导致输出变化的幅度，所以更靠后的参数的梯度越大。 解决方法 Hinton提出无监督逐层训练方法以解决这个问题，其基本思想是每次训练一层隐节点。 后来Hinton等人提出修改激活函数，比如换成ReLU。 ReLU(Rectified Linear Unit) 定义 当输入小于等于0时，输出为0；当输入大于0时，输出等于输入。 优点 相比于sigmoid函数，它有以下优点 运算更快 更符合生物学 等同于无穷多个bias不同的sigmoid函数叠加起来 可以解决梯度消失问题 如何解决梯度消失问题 当ReLU输出为0时该激活函数对神经网络不起作用，所以在神经网络中生效的激活函数都是输出等于输入，所以就不会出现sigmoid函数导致的减弱输入变化导致输出变化的幅度的情况。 ReLU会使整个神经网络变成线性的吗？ 可知有效的激活函数都是线性的，但整个神经网络还是非线性的。当输入改变很小、不改变每个激活函数的Operation Region（操作区域，大概意思就是输入范围）时，整个神经网络是线性的；当输入改变很大、改变了Operation Region时，整个神经网络就是非线性的。==目前我是凭直觉理解这一点，还未细究== ReLU可以做微分吗？ 不用处理输入为0的情况，当输入小于0时，微分就是0，当输入大于0时微分就是1。 Leaky ReLU当输入小于等于0时，输出为输入的0.01倍；当输入大于0时，输出等于输入。 Parametric ReLU当输入小于等于0时，输出为输入的$\alpha$倍；当输入大于0时，输出等于输入。 其中$\alpha$是通过梯度下降学习到的参数 Maxout 定义 通过学习得到一个激活函数，人为将每层输出的多个值分组，然后输出每组值中的最大值。（跟maxpooling一模一样） ReLU是Maxout的一个特例 Maxout比ReLU包含了更多的函数 Maxout可以得到任意的分段线性凸函数（piecewise linear convex），有几个分段取决于每组里有几个值 如何训练Maxout Maxout只是选择输出哪一个线性函数的值而已，因此Maxout激活函数还是线性的。 因为在多个值中只选择最大值进行输出，所以会形成一个比较瘦长/窄深的神经网络。 在多个值中只选择最大值进行输出，这并不会导致一些参数无法被训练：因为输入不同导致一组值中的最大值不同，所以各个参数都可能被训练到。 当输入不同时，形成的也是不同结构的神经网络。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>梯度消失</tag>
        <tag>激活函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-6.2神经网络精度低不一定是因为过拟合]]></title>
    <url>%2F2021%2F02%2F10%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-6-2%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%B2%BE%E5%BA%A6%E4%BD%8E%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E5%9B%A0%E4%B8%BA%E8%BF%87%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[相比于决策树等方法，神经网络更不容易过拟合。 K近邻、决策树等方法在训练集上更容易得到100%等很高的正确率，神经网络一般不能，训练神经网络首先遇到的问题一般是在训练集上的精度不高。 不要总是把精度低归咎于过拟合 如果模型在训练集上精度高，对于K近邻、决策树等方法我们可以直接判断为过拟合，但对于神经网络来说我们还需要检查神经网络在测试集上的精度。如果神经网络在训练集上精度高但在测试集上精度低，这才说明神经网络过拟合了。 如果56层的神经网络和20层的神经网络相比，56层网络在测试集上的精度低于20层网络，这还不能判断为56层网络包含了过多参数导致过拟合。一般来讲，56层网络优于20层网络，但如果我们发现56层网络在训练集上的精度本来就低于20层网络，那原因可能有很多而非过拟合，比如56层网络没训练好导致一个不好的局部最优、虽然56层网络的参数多但结构有问题等等。 感兴趣可以看看ResNet论文Deep Residual Learning for Image Recognition，这篇论文可能与该问题有关。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>过拟合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-6.1神经网络训练问题与解决方案]]></title>
    <url>%2F2021%2F02%2F09%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-6-1%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AE%AD%E7%BB%83%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[明确问题类型及其对应方法在深度学习中，一般有两种问题： 在训练集上性能不好 在测试集上性能不好。 当一个方法被提出时，它往往是针对这两个问题其中之一的，比如dropout方法是用来处理在测试集上性能不好的情况。 处理神经网络在训练集上性能不好的情况的方法 修改神经网络架构，比如换成更好的激活函数 sigmoid函数会导致梯度消失，可以换成ReLU、Leaky ReLU、Parametric ReLU、Maxout 调整学习率 比如RMSProp、Momentum、Adam 处理神经网络在测试集上性能不好的情况的方法 Early Stopping、Regularization，这两个是比较传统的方法，不只适用于深度学习 Dropout，比较有深度学习的特色 一些性能优化方法的简介下面3点都是在增加模型的随机性，鼓励模型做更多的exploration。 Shuffling 输入数据的顺序不要固定，mini-batch每次要重新生成 Dropout 鼓励每个神经元都学到东西，也可以广义地理解为增加随机性 Gradient noise 2015年提出，计算完梯度后，加上Gaussian noise。 随着迭代次数增加，noise应该逐渐变小。 下面3点是关于学习率调整的技巧 warm up 开始时学习率较小，等稳定之后学习率变大 Curriculum learning 2009年提出，先使用简单的数据训练模型（一方面此时模型比较弱，另一方面在clean data中更容易提取到核心特征），然后再用难的数据训练模型。 这样可以提高模型的鲁棒性。 Fine-tuning 下面3点是关于数据预处理的技巧，避免模型学习到太极端的参数 Normalization 有Batch Normalization、Instance Normalization、Group Normalization、Layer Normalization、Positional Normalization Regularization Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>学习率</tag>
        <tag>正则化</tag>
        <tag>激活函数</tag>
        <tag>Dropout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1055The World's Richest]]></title>
    <url>%2F2021%2F02%2F05%2FPAT%E7%94%B2%E7%BA%A71055The-World-s-Richest%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://pintia.cn/problem-sets/994805342720868352/problems/994805421066272768 题目考点 排序，重点在时间复杂度优化上 题目难度 PAT甲级25分 题目大意 给出N个人，请找出指定年龄范围内最有钱的M个人、 输入 N：正整数，不超过100000，人的数量 K：正整数，不超过1000，查询的数量 N个人：每行包括名字（不包含空格、最多8个字符的字符串）、年龄（范围(0,200]）、净值（范围为±1e6） K次查询：M（筛选最有钱的几个人，不超过100）、年龄范围[Amin,Amax] 输出 对于每1个查询，输出是第几个查询（从1到K），然后按净值非增序输出指定年龄范围内最有钱的M个人的信息，如果有重复则按年龄非降序输出，如果还有重复则按名字非降序输出。如果指定年龄范围内没人，就输出None。 题解一解题思路 关于指定年龄范围，只要在输出时进行年龄判断即可。 也可以考虑在结构体比较函数中进行年龄判断，当有不符合年龄限制的人时，将其往后放。 关于最有钱的人的数量，排序后只输出前M个符合年龄范围的人即可。 用这个思路，测试点1和2会超时，因为这个算法的时间复杂度为$O(k\cdot n)$，最大为1e8（耗时约1秒）。 M最大值为100，N最大值为100000，N和M差距很大，在N个人中寻找符合条件的M个人非常耗时。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Problem: PAT Advanced 1055// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805421066272768// Tags: 排序#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int ageMin, ageMax;struct Person&#123; string name; int age, wealth;&#125;;bool personCmp(Person&amp; p1, Person&amp; p2)&#123; if (p1.age&lt;ageMin || p1.age&gt;ageMax) return false; if (p2.age&lt;ageMin || p2.age&gt;ageMax) return true; if (p1.wealth == p2.wealth)&#123; if (p1.age == p2.age) return p1.name &lt; p2.name; else return p1.age &lt; p2.age; &#125; else return p1.wealth &gt; p2.wealth;&#125;int main()&#123; int n,k; scanf("%d %d", &amp;n, &amp;k); vector&lt;Person&gt; people(n); for(int i=0; i&lt;n; i++) cin &gt;&gt; people[i].name &gt;&gt; people[i].age &gt;&gt; people[i].wealth; for (int x=1, m; x&lt;=k; x++)&#123; scanf("%d%d%d", &amp;m, &amp;ageMin, &amp;ageMax); sort(people.begin(), people.end(), personCmp); printf("Case #%d:\n", x); int count=0; for(int i=0; i&lt;n &amp;&amp; count&lt;m; i++) if (people[i].age&gt;=ageMin &amp;&amp; people[i].age&lt;=ageMax)&#123; printf("%s %d %d\n", people[i].name.c_str(), people[i].age, people[i].wealth); count++; &#125; if (count==0) printf("None\n"); &#125; return 0;&#125; 题解二解题思路 年龄范围是(0,200]，每次最多找100个人（M不超过100），那我们取出每个年龄的前100名，这样最多有20000个人。在这20000个人中查找M个人，还是快的（时间复杂度从题解一的1e8到现在的2e7），就不会超时了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Problem: PAT Advanced 1055// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805421066272768// Tags: 排序#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int ageMin, ageMax;struct Person&#123; string name; int age, wealth;&#125;;bool personCmp(Person&amp; p1, Person&amp; p2)&#123; if (p1.wealth == p2.wealth)&#123; if (p1.age == p2.age) return p1.name &lt; p2.name; else return p1.age &lt; p2.age; &#125; else return p1.wealth &gt; p2.wealth;&#125;int main()&#123; int n,k, selectedNum[201]=&#123;0&#125;; scanf("%d %d", &amp;n, &amp;k); vector&lt;Person&gt; people(n), selectedPeople; for(int i=0; i&lt;n; i++) cin &gt;&gt; people[i].name &gt;&gt; people[i].age &gt;&gt; people[i].wealth; sort(people.begin(), people.end(), personCmp); for(int i=0; i&lt;n; i++) if (selectedNum[people[i].age] &lt; 100)&#123; selectedPeople.push_back(people[i]); selectedNum[people[i].age]++; &#125; for (int x=1, m; x&lt;=k; x++)&#123; scanf("%d%d%d", &amp;m, &amp;ageMin, &amp;ageMax); printf("Case #%d:\n", x); int count=0; for(int i=0; i&lt;selectedPeople.size() &amp;&amp; count&lt;m; i++) if (selectedPeople[i].age&gt;=ageMin &amp;&amp; selectedPeople[i].age&lt;=ageMax)&#123; printf("%s %d %d\n", selectedPeople[i].name.c_str(), selectedPeople[i].age, selectedPeople[i].wealth); count++; &#125; if (count==0) printf("None\n"); &#125; return 0;&#125; 参考链接 https://blog.csdn.net/liuchuo/article/details/52225204 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1028List Sorting]]></title>
    <url>%2F2021%2F02%2F05%2FPAT%E7%94%B2%E7%BA%A71028List-Sorting%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://pintia.cn/problem-sets/994805342720868352/problems/994805468327690240 题目考点 结构体排序，就超简单…… 题目难度 PAT甲级25分 题目大意 Excel可以按照某一列进行排序，要求实现这个函数。 输入 N：整数，不超过100000，记录的数量 C：整数，按照C这1列进行排序 N个学生：每行包括学生ID（6位数字），名字（不包含空格、不超过8个字符的字符串），分数（范围[0,100]） 输出 输出N个学生。如果C=1则按照ID升序排列；如果C=2则按照名字非降序排列；如果C=3则按照分数非降序。如果名字或分数重复就按ID增序排列。 题解解题思路 啊这（问号脸，这么简单？），学生放在vector里，写个结构体排序函数（把C定义成全局变量，在排序函数里根据C选取排序规则），调用STL里的sort就好了。 代码12345678910111213141516171819202122232425262728293031323334353637383940// Problem: PAT Advanced 1028// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805468327690240// Tags: #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int c;struct Student&#123; string id, name; int grade;&#125;;bool studentCmp(Student&amp; s1, Student&amp; s2)&#123; if (c==1)&#123; return s1.id &lt; s2.id; &#125; else if(c==2)&#123; return s1.name==s2.name? s1.id &lt; s2.id : s1.name &lt; s2.name; &#125; return s1.grade==s2.grade? s1.id &lt; s2.id : s1.grade &lt; s2.grade;&#125;int main()&#123; int n; scanf("%d%d", &amp;n, &amp;c); vector&lt;Student&gt; students(n); for(int i=0; i&lt;n; i++) cin &gt;&gt; students[i].id &gt;&gt; students[i].name &gt;&gt; students[i].grade; sort(students.begin(), students.end(), studentCmp); for (auto it=students.begin(); it!=students.end(); it++)&#123; printf("%s %s %d\n", it-&gt;id.c_str(), it-&gt;name.c_str(), it-&gt;grade); &#125; return 0;&#125; Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1025PAT Ranking]]></title>
    <url>%2F2021%2F02%2F02%2FPAT%E7%94%B2%E7%BA%A71025PAT-Ranking%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872 题目考点 排序、模拟。排序是简单的结构体排序，模拟也不难。这题比较简单（我竟然没看题解做出来了，捂脸） 题目难度 PAT甲级25分 题目大意 汇总PAT各个考场的ranklist，生成最后的rank 输入 N：正数，不超过100，考场的数量 N个ranklist： 1个ranklist包括：第1个数字是K（正整数，不超过300，考生数量），然后K行，每行包括注册号（13位数字）和考生总分 输出 考生总数 最终的ranklist：包括注册号、final rank、考场号（索引为[1,N]）、考场中排名 先按final rank非降序输出，再按注册号非降序输出。 题解解题思路 每读取1个考场的考生数据，就将其存入该考场的vector，然后排序计算local rank，再存入保存所有考生的vector，最后把所有考生排序，计算final rank，输出。 要根据分数排序，输出时还要根据排名和注册号排序 后者已经包括了前者，因为rank升序就是分数降序，所以写一个排序函数就行了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Problem: PAT Advanced 1025// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872// Tags: 排序 模拟#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct Testee&#123; string id; int location, score, rank[2]; Testee()&#123;&#125; Testee(string id_, int location_, int score_)&#123; id = id_; location = location_; score = score_; &#125; void display()&#123; cout &lt;&lt; id; printf(" %d %d %d\n", rank[1], location, rank[0]); &#125;&#125;;bool testeeCmp(Testee&amp; a, Testee&amp; b)&#123; return a.score==b.score ? a.id&lt;b.id : a.score&gt;b.score ;&#125;void calcRank(vector&lt;Testee&gt;&amp; testees,int j)&#123; testees[0].rank[j] = 1; for (int i=1; i &lt; testees.size(); i++)&#123; if (testees[i].score == testees[i-1].score) testees[i].rank[j] = testees[i-1].rank[j]; else testees[i].rank[j] = i+1; &#125;&#125;int main()&#123; // 定义变量 int n, k, score; string id; scanf("%d", &amp;n); vector&lt;Testee&gt; allTestees; // 读取输入，并计算local rank，将不同考场的考生保存到同1个vector里 for (int i=1; i&lt;=n; i++)&#123; // 遍历考场 scanf("%d", &amp;k); vector&lt;Testee&gt; localTestees(k); for (int j=0; j&lt;k; j++)&#123; // 读取考生信息 cin &gt;&gt; localTestees[j].id &gt;&gt; localTestees[j].score; localTestees[j].location = i; &#125; sort(localTestees.begin(), localTestees.end(), testeeCmp); calcRank(localTestees, 0); // 计算该考场考生的local rank for (int j=0; j&lt;k; j++) // 将不同考场的考生保存到一个vector里 allTestees.push_back(localTestees[j]); &#125; // 计算final rank sort(allTestees.begin(), allTestees.end(), testeeCmp); calcRank(allTestees, 1); // 输出结果 printf("%d\n", allTestees.size()); for (int i=0; i &lt; allTestees.size(); i++)&#123; allTestees[i].display(); &#125; return 0;&#125; Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1016Phone Bills]]></title>
    <url>%2F2021%2F02%2F02%2FPAT%E7%94%B2%E7%BA%A71016Phone-Bills%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://pintia.cn/problem-sets/994805342720868352/problems/994805493648703488 题目考点 map、排序、模拟。map是简单地用了一下，排序也不难，重在模拟。 题目难度 PAT甲级25分 题目大意 长途电话每分钟收取一定费用，收费金额取决于拨打电话的时间。每次电话的开始时间和结束时间都会被记录，给出一系列通话记录，请生成每个月的账单。 输入 1行24个非负整数：00:00 - 01:00、01:00 - 02:00，以此类推一天中每个小时的收费金额（单位是cents/minute） N：正整数，不超过1000，通话记录的数量 N行通话记录：1行的内容包括客户名称（最多20个字符的字符串，不包含空格）、日期和时间（MM:dd:HH:mm）、1个词（on-line或off-line），这些通话记录都是同一个月的。1个on-line记录与同1客户的时间顺序上的1个off-line记录配对，没有形成pair的通话记录会被忽略。输入中至少会有1个pair。假设同1客户不会有2条时间相同的记录。输入中时间的格式为24小时制。 输出 按客户名称的字母表顺序为每1个客户输出账单。对于每1个客户来说，要输出其名字、账单的月份、每条通话记录（包括开始时间、结束时间、通话分钟数、收费金额，要按时间顺序输出多条通话记录）、账单总金额 题解解题思路 找到pair，生成通话记录 先根据时间排序，然后判断是否形成pair（时间顺序、同用户、onLine和offLine） 计算1次通话的费用，还有总费用 可以从0开始计算（需要先对收费金额进行处理），这样计算更容易。on-line和off-line2个时间点，计算0点到这2个时间点一直通话的收费，取差额即为应该支付的费用。 确定月份 输出时取第1个记录的月份 客户名字字典序 map实现（也可以通过结构体排序实现） Record时间序输出 通过结构体排序实现 读取输入时不一定要保存原信息 比如时间本身是string，我们可以直接记录month、day等，把:等分隔符去除。on-line和off-line是字符串，我们可以用bool表示。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Problem: PAT Advanced 1016// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805493648703488// Tags: map 排序#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int charge[25];struct Record&#123; string name; bool status; int month, day, hour, minute, time; void setStatus(string&amp; status)&#123; if (status == "on-line") this-&gt;status = true; else this-&gt;status = false; &#125; void calcTime()&#123; // 以月初为零点的时间 time = day * 24 * 60 + hour * 60 + minute; &#125; bool pairWith(Record&amp; r)&#123; return name == r.name &amp;&amp; status==true &amp;&amp; r.status==false; &#125; double calcCostFromZero()&#123; double cost = day * 60 * charge[24] + minute * charge[hour]; // 天、分钟 for (int i=0; i&lt;hour; i++)&#123; // 小时 cost += 60 * charge[i]; &#125; return cost / 100.0; // cent换算成美元 &#125; void print()&#123; printf("%02d:%02d:%02d ", day, hour, minute); &#125;&#125;;bool recordCmp(Record&amp; a, Record&amp; b)&#123; return a.name == b.name ? a.time &lt; b.time : a.name &lt; b.name;&#125;int main()&#123; // 读取输入并处理数据 int n; for (int i=0; i&lt;24; i++)&#123; scanf("%d", charge + i); charge[24] += charge[i]; // charge[24]是1整天都在通话时1天的收费 &#125; scanf("%d", &amp;n); vector&lt;Record&gt; records(n); string status; for (int i=0; i&lt;n; i++)&#123; cin &gt;&gt; records[i].name; scanf("%d:%d:%d:%d", &amp;records[i].month, &amp;records[i].day, &amp;records[i].hour, &amp;records[i].minute); cin &gt;&gt; status; records[i].setStatus(status); records[i].calcTime(); // 以月初为0点 &#125; sort(records.begin(), records.end(), recordCmp); // 为每个客户记录订单 map&lt;string, vector&lt;Record&gt;&gt; customers; for (int i=1; i&lt;n; i++)&#123; if (records[i-1].pairWith(records[i]))&#123; customers[records[i].name].push_back(records[i-1]); customers[records[i].name].push_back(records[i]); &#125; &#125; // 输出结果 for(auto customer=customers.begin(); customer!=customers.end(); customer++)&#123; cout &lt;&lt; customer-&gt;first; records = customer-&gt;second; printf(" %02d\n", records[0].month); double totalCost = 0, cost; for (int i=1; i&lt;records.size(); i+=2)&#123; cost = records[i].calcCostFromZero() - records[i-1].calcCostFromZero(); totalCost += cost; records[i-1].print(); records[i].print(); printf("%d ", records[i].time - records[i-1].time); printf("$%.02f\n", cost); &#125; printf("Total amount: $%.02f\n", totalCost); &#125; return 0;&#125; 参考链接 https://blog.csdn.net/liuchuo/article/details/52294397 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>排序</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1012The Best Rank]]></title>
    <url>%2F2021%2F01%2F31%2FPAT%E7%94%B2%E7%BA%A71012The-Best-Rank%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480 题目考点 排序、模拟，重点在模拟而非排序 题目难度 PAT甲级25分 题目大意 给出多个学生的C语言（C）、数学（M）、英语成绩（E），要求四舍五入计算3门课的均分（A），请在这4个成绩中输出指定同学的best rank。 输入 N：学生的数量，不超过2000 M：查询的数量，不超过2000 N个学生的成绩：每行包括学生ID（6个数字组成的string）、C语言成绩、数学成绩、英语成绩 M个要查询的学生ID 输出 对于要查询的每一个学生，在一行中输出其best rank以及此rank对应的科目 rank方法为A&gt;C&gt;M&gt;E，如果有1个学生有多个best rank相同，则输出优先级高的那个 如果查询的学生不存在，输出N/A。 题解解题思路 需要解决的问题 如何求出best rank？ 要求best rank，就需要先求出每个学生每个科目的rank，然后取最优。 ID是6位数字，严格来讲需要用string保存，那如何定义索引进而通过索引获取学生信息？ 如何实现rank方法的优先级？ 如何判断学生是否存在？ 注意点 淦，自己的思路卡在怎么处理ID了。大神的思路真的妙，我咋这么笨…… 思路：如果ID作为索引并不方便，用map或者数组将ID映射到索引是更好的方法。 关于best rank，我开始想的是进行多次排序，每次排序后更新best rank。 如果这么做，因为rank有优先级就需要按照A、C、M、E的顺序排序，这样也是可行的。 但我没想到用数组保存多个分数，这样可以通过index来循环，就不用重复写几次排序和rank更新，同时可以在存储/遍历的时候就按照ACME的顺序存储/遍历以简化程序逻辑。这里的关键点是用数组和循环的方式实现一个操作的多次重复。 排名不能是1,1,2,3,4，应该是1,1,3,4,5。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// Problem: PAT Advanced 1012// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805502658068480// Tags: 排序#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;int s; // 课程（Subject）的索引，[0,3]，studentCmp需要使用struct Student&#123; string id; int score[4]; // A C M E int rank[4]; int bestSubject;&#125; students[2000];bool studentCmp(Student&amp; a, Student &amp; b)&#123; return a.score[s] &gt; b.score[s]; // 从大到小排序&#125;int main()&#123; // 读取数据 int n, m; scanf("%d %d", &amp;n, &amp;m); for(int i=0; i&lt;n; i++)&#123; cin &gt;&gt; students[i].id; scanf("%d %d %d", &amp;students[i].score[1], &amp;students[i].score[2], &amp;students[i].score[3]); students[i].score[0] = (students[i].score[1] + students[i].score[2] + students[i].score[3])/3.0 + 0.5; &#125; // 计算每个学生4个成绩的rank for (s=0; s &lt; 4; s++)&#123; // 按不同科目的成绩排序，s用以选择科目 sort(students, students+n, studentCmp); students[0].rank[s] = 1; for (int i=1; i&lt;n;i++)&#123; if (students[i].score[s] == students[i-1].score[s]) // 同分则rank相同 students[i].rank[s] = students[i-1].rank[s]; else students[i].rank[s] = i+1; &#125; &#125; // 计算每个学生的best rank map&lt;string, int&gt; mm; // 至此，学生数组students中学生的索引不再变化，将学生ID映射到索引 for (int i=0; i&lt;n; i++)&#123; // 遍历学生 mm[students[i].id] = i + 1; // map中索引是int，默认值为0，所以索引需要+1避免和0混淆 students[i].bestSubject = 0; // 计算该学生的best rank（记录best rank对应科目的索引） for (int j=1; j&lt;4; j++)&#123; if (students[i].rank[j] &lt; students[i].rank[students[i].bestSubject]) students[i].bestSubject = j; &#125; &#125; // 输出查询结果 char symbol[] = &#123;'A', 'C', 'M', 'E'&#125;; string studentID; for(int i=0, index, bestSubject; i&lt;m; i++)&#123; cin &gt;&gt; studentID; if (mm[studentID] != 0)&#123; index = mm[studentID] - 1; bestSubject = students[index].bestSubject; printf("%d %c\n", students[index].rank[bestSubject], symbol[bestSubject]); &#125; else printf("N/A\n"); &#125; return 0;&#125; 参考链接 https://blog.csdn.net/liuchuo/article/details/52202171 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1056Mice and Rice]]></title>
    <url>%2F2021%2F01%2F30%2FPAT%E7%94%B2%E7%BA%A71056Mice-and-Rice%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://pintia.cn/problem-sets/994805342720868352/problems/994805419468242944 题目考点 队列、模拟。重点在模拟，队列只用到了建立、入队、出队、清空（需要自己实现，创建新的队列然后赋值或者swap）。 题目难度 PAT甲级25分 题目大意 给定1个图，每个玩家控制1只老鼠移动，每个老鼠的目标是尽可能多地吃大米变成Fat Mouse。 $N_P$个玩家的顺序是随机的，每$N_G$个玩家分成1组进行比赛。每轮的获胜者继续每$N_G$个玩家分成一组进行比赛，直到最后1只老鼠。 每组中最快的老鼠获胜并进入下一轮，一轮中失败的老鼠的rank（排名）相同。 假设每只老鼠的重量是固定的，给出所有大米的重量和玩家初始顺序，请输出每个玩家的rank。 输入 $N_P$：玩家的数量，正整数，不超过1000 $N_G$：每组中最多有几个玩家（如果剩下的老鼠不够$N_G$只，这几只就形成最后一组），正整数，不超过1000 $W_i$：$N_P$个老鼠的重量，互异的非负数 $N_P$个玩家的顺序，玩家索引为$[0,N_P-1]$ 输出 按玩家索引顺序最终所有玩家的rank 题解解题思路 两个队列：一个保存本轮玩家，一个保存下轮玩家，一直循环到结束（队列里只有1个人）。 关于rank，起初我的想法是通过比赛轮数得到rank，然而发现不行，因为rank要看人数，而不是由在几轮失败决定。 怎么算rank我也想了挺久，后来看了题解才知道：5个人比赛，2个人晋级，那这失败的3个人的rank就是3（即2+1）妙啊。 除了rank，其它部分就比较简单了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Problem: PAT Advanced 1056// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805419468242944// Tags: #include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int playerNum, playerMaxNumInAGroup; // 玩家数量，1组最多多少玩家queue&lt;int&gt; nowPlayers, nextPlayers; // 本轮玩家的索引和下轮玩家的索引int weight[1002]; // 老鼠的重量int rrank[1002]; // 玩家的排名int groupNum; // 本轮比赛有多少组/*一组玩家进行比赛*/int findFatMouse()&#123; int maxWeight = weight[nowPlayers.front()], fatMouse = nowPlayers.front(); rrank[nowPlayers.front()] = groupNum + 1; nowPlayers.pop(); for (int i=1; i &lt; playerMaxNumInAGroup &amp;&amp; !nowPlayers.empty(); i++)&#123; if (weight[nowPlayers.front()] &gt; maxWeight)&#123; maxWeight = weight[nowPlayers.front()]; fatMouse = nowPlayers.front(); &#125; rrank[nowPlayers.front()] = groupNum + 1; nowPlayers.pop(); &#125; nextPlayers.push(fatMouse);&#125;/*计算本轮比赛有几组*/int calcGroupNum()&#123; int nowPlayerNum = nowPlayers.size(); if (nowPlayerNum % playerMaxNumInAGroup == 0) return nowPlayerNum / playerMaxNumInAGroup; else return nowPlayerNum / playerMaxNumInAGroup + 1;&#125;int main()&#123; // 读取变量 scanf("%d%d", &amp;playerNum, &amp;playerMaxNumInAGroup); for(int i=0; i &lt; playerNum; i++) scanf("%d", weight+i); for(int i=0, player; i &lt; playerNum; i++)&#123; scanf("%d", &amp;player); nowPlayers.push(player); &#125; // 进行比赛 while(nowPlayers.size() &gt; 1)&#123; nextPlayers = queue&lt;int&gt;(); // 清空下一轮比赛的玩家队列 groupNum = calcGroupNum(); // 计算本轮比赛有几组，本轮失败的玩家的rank即为groupNum + 1 for (int i = 0; i &lt; groupNum; i++) // 进行本轮的groupNum组比赛 findFatMouse(); // 一组玩家进行比赛 nowPlayers = nextPlayers; // 进行下一轮比赛，更新玩家队列 &#125; rrank[nowPlayers.front()] = 1; // 剩下的1个人就是最终的第1名 // 输出排名 printf("%d", rrank[0]); for (int i = 1; i &lt; playerNum; i++) printf(" %d", rrank[i]); return 0;&#125; 参考链接 https://blog.csdn.net/liuchuo/article/details/54427590 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>队列</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1014Waiting in Line]]></title>
    <url>%2F2021%2F01%2F28%2FPAT%E7%94%B2%E7%BA%A71014Waiting-in-Line%2F</url>
    <content type="text"><![CDATA[题目介绍 题目链接 https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936 题目考点 队列和模拟，重难点在于模拟而非队列 题目难度 PAT甲级30分 题目大意 有N个窗口，每个窗口最多允许M个人站在黄线前排队，剩下的客户在黄线外等候。 客户进入黄线时会选择人数最少的窗口排队，如果有重复，就选择索引最小的窗口 客户$C_i$办理业务需要$T_i$分钟。 前N个客户在8:00开始服务。 请计算某个客户结束服务的时间。 输入 N：正整数，不超过20，服务窗口的数量 M：正整数，不超过10，每个服务窗口前最多有几个人等待 K：正整数，不超过1000，顾客的数量，顾客索引为[1,K] Q：要查询的顾客服务完成时间的数量 K个正整数：每个顾客完成服务需要几分钟 Q个正整数：需要查询的Q个顾客 输出 按HH:MM的格式输出Q个顾客完成服务的时间，如果在17:00之前还没有开始服务，则输出Sorry。 题解解题思路 题目中有一个信息并没有十分明确地表达出来：黄线外的客户进入黄线以内时，索引小的人优先。根据这一点，所以从1到K遍历客户就可以。 整体思路：计算出所有客户完成服务的时间，最后进行Q个查询并根据分钟数输出完成服务的时间（或sorry） 如何计算出所有客户完成服务的时间？其实是个模拟题，核心在于入队，入队分2个阶段。 为什么核心是入队？某客户完成服务的时间取决于它前面1个客户完成服务的时间。而在某客户入队时，该客户前面就是队尾客户，所以该客户完成服务的时间=队尾客户完成服务的时间+该客户的服务时长。如果入队时队伍是空的，那该客户完成服务的时间就等于其服务所需时长。 入队第1阶段是前N×M个客户入队 无需等待黄线，只需按照客户索引顺序依次入队，其中前N个客户是在8:00开始服务。 如何让这些客户正确地排队呢？用2层循环。内循环：在n个窗口中选择窗口（从1到N）入队。外循环：使内循环重复m次达到n×m的效果。这样就实现了“选择人数最少、索引最小的窗口”的要求。 在客户入队时，我们需要不断更新客户索引，所以当已经没有客户时（即客户索引超过K时）要停止入队；另外所有窗口排满时也要停止入队，这通过双循环的判断条件实现。 入队第2阶段是剩下的客户入队 假如还有剩下的客户（即客户索引还未超过K时），那就要找出队伍最短的窗口，让下一个客户入队。 如何找到队伍最短的窗口呢？在该方法中，并不是通过比较n个窗口的排队长度。因为如果还剩有客户就说明每个窗口都是满的，那队伍最短就没有意义了。而最快有客户结束服务的窗口（如果有重复，就选索引最小的窗口）就是队伍最短的窗口，也就是找到哪个窗口队首客户完成服务的时间最早。 其它 关于题目 好久没做题目了，脑子和手都很生疏。看到这道题，我就想起来数学建模里做过的题、排队论什么的。思路很乱，我很自闭，这份题解的核心在于抓住了入队的规律。如果是更复杂的排队论问题，也许就需要模拟，模拟出一个时钟，然后某一分钟遍历所有窗口？这种思路确实可以，但效率不高。 关于算法题 脱离这道题来讲，模拟题（可能大多数算法题也是）都是找规律，然后用规律去求结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Problem: PAT Advanced 1014// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805498207911936// Tags: 队列#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;queue&lt;int&gt; window[20]; // n个窗口，每个窗口是一个排队队列int processingTime[1001]; // k个客户需要的分钟数，index为[1,k]int finishTime[1001]; // k个客户结束服务的时间，index为[1,k]int main()&#123; // 变量定义并初始化 int customerIndex = 1; // 客户索引，后面用来遍历客户 int n, m, k, q; // 窗口个数、单个窗口队伍最大长度、客户数量、查询数量 scanf("%d %d %d %d", &amp;n, &amp;m, &amp;k, &amp;q); for (int i=1; i &lt;= k; i++) scanf("%d", processingTime+i); // 处理前n×m个客户（内循环：在n个窗口中选择1个窗口入队。外循环：使内循环重复m次达到n×m的效果） while(m--)&#123; for (int j=0; j &lt; n &amp;&amp; customerIndex &lt;= k; j++)&#123; // 客户优先选择队伍最短、索引最小的窗口 if (window[j].empty())&#123; // 如果队伍是空的，那该客户在8:00开始服务，其完成服务的时间就等于其服务时长 finishTime[customerIndex] = processingTime[customerIndex]; &#125; else&#123; finishTime[customerIndex] = finishTime[window[j].back()] + processingTime[customerIndex]; // 该客户完成服务的时间=队尾客户完成服务的时间+该客户的服务时长 &#125; window[j].push(customerIndex); // 当前客户入队 customerIndex++; // 更新客户索引（考虑下一位客户） &#125; &#125; // 如果还剩有客户的话，处理剩下的客户 while(customerIndex &lt;= k)&#123; int quickestFinishTime = finishTime[window[0].front()], quickestWindow = 0; // 找出队伍最短的窗口 for (int i=1; i &lt; n; i++)&#123; if (finishTime[window[i].front()] &lt; quickestFinishTime)&#123; quickestFinishTime = finishTime[window[i].front()]; quickestWindow = i; &#125; &#125; finishTime[customerIndex] = finishTime[window[quickestWindow].back()] + processingTime[customerIndex]; // 记录当前客户结束服务的时间 window[quickestWindow].pop(); window[quickestWindow].push(customerIndex); customerIndex++; &#125; int query_customer; while(q--)&#123; scanf("%d", &amp;query_customer); if (finishTime[query_customer] - processingTime[query_customer] &lt; 540)&#123; printf("%02d:%02d\n", finishTime[query_customer]/60+8, finishTime[query_customer]%60); &#125;else&#123; printf("Sorry\n"); &#125; &#125; return 0;&#125; 参考链接 https://blog.csdn.net/liuchuo/article/details/54561626 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>队列</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python批量处理邮件：poplib和email快速上手教程]]></title>
    <url>%2F2021%2F01%2F27%2Fpython%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E9%82%AE%E4%BB%B6%EF%BC%9Apoplib%E5%92%8Cemail%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[toc] 引言 poplib是一个python第三方库，基于它我们可以连接POP3服务器。 email是一个python内置的模块，基于它我们可以管理邮箱中的邮件。 Some Story 我现在需要下载很多邮件的附件。我之前有一份相同功能的代码（点击这里），发布出来之后博客访问量也挺高。然而，当时由于时间原因我对那份代码只是一知半解，运行起来后就没具体研究。所以趁这个机会我又写了一份代码，原因有很多：一是于己我要把代码细节给搞懂，二是针对这次的需求进行修改，三是水一篇博客（bushi，这份代码十分简要并且注释十分详细）。 快速上手代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import poplibimport email""" 需求：消息标题、附件名称（存在header中）都是以字节为单位进行传输的，中文内容需要解码 功能：对header进行解码"""def decode(header: str): value, charset = email.header.decode_header(header)[0] if charset: return str(value, encoding=charset) else: return value""" 功能：下载某一个消息的所有附件"""def download_attachment(msg): subject = decode(msg.get('Subject')) # 获取消息标题 for part in msg.walk(): # 遍历整个msg的内容 if part.get_content_disposition() == 'attachment': attachment_name = decode(part.get_filename()) # 获取附件名称 attachment_content = part.get_payload(decode=True) # 下载附件 attachment_file = open('./' + attachment_name, 'wb') # 在指定目录下创建文件，注意二进制文件需要用wb模式打开 attachment_file.write(attachment_content) # 将附件保存到本地 attachment_file.close() print('Done………………', subject)def main(): """连接到POP3服务器""" server = poplib.POP3(host='pop.163.com') # 创建一个POP3对象，参数host是指定服务器 """身份验证""" server.user('xxxx@163.com') # 参数是你的邮箱地址 server.pass_('xxxxx') # 参数是你的邮箱密码，如果出现poplib.error_proto: b'-ERR login fail'，就用开启POP3服务时拿到的授权码 """获取邮箱中消息（邮件）数量""" msg_count, _ = server.stat() """遍历消息并保存附件""" for i in range(msg_count): """获取消息内容：POP3.retr(which)检索index为which的整个消息，并将其设为已读""" _, lines, _ = server.retr( i+1) # 3个结果分别是响应结果（1个包含是否请求成功和该消息大小的字符串），消息内容（一个字符串列表，每个元素是消息内容的一行），消息大小（即有多少个octets，octet特指8bit的字节） """将bytes格式的消息内容拼接""" msg_bytes_content = b'\r\n'.join(lines) """将字符串格式的消息内容转换为email模块支持的格式（&lt;class 'email.message.Message'&gt;）""" msg = email.message_from_bytes(msg_bytes_content) """下载消息中的附件""" download_attachment(msg)if __name__ == "__main__": main() 参考链接 https://docs.python.org/zh-cn/3/library/poplib.html https://docs.python.org/zh-cn/3/library/email.html 自定义修改：如果需要对上面的代码进行修改，比如需要获取邮件正文而非邮件附件，则可以进一步去看文档（特别是email.message）。 我注释的一些代码也很重要，建议读者自己写几封测试邮件，把代码看懂，然后再去看文档，就可以啦！ Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>python</tag>
        <tag>下载邮件附件</tag>
        <tag>poplib</tag>
        <tag>email</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-5.3神经网络中的反向传播算法]]></title>
    <url>%2F2021%2F01%2F27%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-5-3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[TOC] 链式法则（Chain Rule） $z=h(y),y=g(x)\to\frac{dz}{dx}=\frac{dz}{dy}\frac{dy}{dx}$ $z=k(x,y),x=g(s),y=h(s)\to\frac{dz}{ds}=\frac{dz}{dx}\frac{dx}{ds}+\frac{dz}{dy}\frac{dy}{ds}$ 反向传播算法（Backpropagation）变量定义如下图所示，设神经网络的输入为$x^n$，该输入对应的label是$\hat y^n$，神经网络的参数是$\theta$，神经网络的输出是$y^n$。 整个神经网络的Loss为$L(\theta)=\sum_{n=1}^{N}C^n(\theta)$。假设$\theta$中有一个参数$w$，那$\frac{\partial L(\theta)}{\partial w}=\sum^N_{n=1}\frac{\partial C^n(\theta)}{\partial w}$。 一个神经元的情况如下图所示，$z=x_1w_1+x_2w_x+b$，根据链式法则可知$\frac{\partial C}{\partial w}=\frac{\partial z}{\partial w}\frac{\partial C}{\partial z}$，其中为所有参数$w$计算$\frac{\partial z}{\partial w}$是Forward Pass、为所有激活函数的输入$z$计算$\frac{\partial C}{\partial z}$是Backward Pass。 Forward PassForward Pass是为所有参数$w$计算$\frac{\partial z}{\partial w}$，它的方向是从前往后算的，所以叫Forward Pass。 以一个神经元为例，因为$z=x_1w_1+x_2w_x+b$，所以$\frac{\partial z}{\partial w_1}=x_1,\frac{\partial z}{\partial w_2}=x_2$，如下图所示。 规律是：该权重乘以的那个输入的值。所以当有多个神经元时，如下图所示。 Backward PassBackward Pass是为所有激活函数的输入$z$计算$\frac{\partial C}{\partial z}$，它的方向是从后往前算的，要先算出输出层的$\frac{\partial C}{\partial z}$，再往前计算其它神经元的$\frac{\partial C}{\partial z}$，所以叫Backward Pass。 如上图所示，令$a=\sigma(z)$，根据链式法则，可知$\frac{\partial C}{\partial z}=\frac{\partial a}{\partial z}\frac{\partial C}{\partial a}$，其中$\frac{\partial a}{\partial z}=\sigma’(z)$是一个常数，因为在Forward Pass时$z$的值就已经确定了，而$\frac{\partial C}{\partial a}=\frac{\partial z’}{\partial a}\frac{\partial C}{\partial z’}+\frac{\partial z’’}{\partial a}\frac{\partial C}{\partial z’’}=w_3\frac{\partial C}{\partial z’}+w_4\frac{\partial C}{\partial z’’}$，所以$\frac{\partial C}{\partial z}=\sigma’(z)[w_3\frac{\partial C}{\partial z’}+w_4\frac{\partial C}{\partial z’’}]$。 对于式子$\frac{\partial C}{\partial z}=\sigma’(z)[w_3\frac{\partial C}{\partial z’}+w_4\frac{\partial C}{\partial z’’}]$，我们可以发现两点： $\frac{\partial C}{\partial z}$的计算式是递归的，因为在计算$\frac{\partial C}{\partial z}$的时候需要计算$\frac{\partial C}{\partial z’}$和$\frac{\partial C}{\partial z’’}$。 如下图所示，输出层的$\frac{\partial C}{\partial z’}$和$\frac{\partial C}{\partial z’’}$是容易计算的。 $\frac{\partial C}{\partial z}$的计算式$\frac{\partial C}{\partial z}=\sigma’(z)[w_3\frac{\partial C}{\partial z’}+w_4\frac{\partial C}{\partial z’’}]$是一个神经元的形式 如下图所示，只不过没有嵌套sigmoid函数而是乘以一个常数$\sigma’(z)$，每个$\frac{\partial C}{\partial z}$都是一个神经元的形式，所以可以通过神经网络计算$\frac{\partial C}{\partial z}$。 总结 通过Forward Pass，为所有参数$w$计算$\frac{\partial z}{\partial w}$； 通过Backward Pass，为所有激活函数的输入$z$计算$\frac{\partial C}{\partial z}$； 最后$\frac{\partial C}{\partial w}=\frac{\partial C}{\partial z}\frac{\partial z}{\partial w}$，也就求出了梯度。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>反向传播算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-5.2神经网络为什么要是深度的]]></title>
    <url>%2F2021%2F01%2F27%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-5-2%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%98%AF%E6%B7%B1%E5%BA%A6%E7%9A%84%2F</url>
    <content type="text"><![CDATA[[TOC] 为什么是“深度”神经网络？问题与答案 矮胖的神经网络和高瘦的神经网络，假设它们参数量相同，哪一个更好呢？ 2011年有一个实验，证明在参数量相当的情况下，高瘦的神经网络（即深度神经网络）的准确度更高，因为深度可以实现模块化。 只用一个神经元足够多的隐藏层，这个模型就包括了任意函数，那为什么不这么做呢？ 这样确实可以包括任意函数，但实现的效率不高。 相关网址http://neuralnetworksanddeeplearning.com/chap4.html，也可以通过谷歌等找找其它答案。 “深度”的好处 模块化（Modularization） 就像写程序一样，我们不能把所有代码写在main函数里，而需要通过定义函数等方式将程序模块化。 如下图所示，假如要做一个图片的四分类，两个维度分别是头发长短和性别，如果使用矮胖的神经网络会遇到一个问题，就是短头发的女生样本和长头发的男生样本会比较少，那这两个类别的分类器就会比较差。 如下图所示，我们可以先定义各属性的分类器（Classifiers for the attributes），即先定义性别和头发长短的分类器，然后再做四分类。这样第一层分类器就不会遇到样本少的问题，第二层的分类器也容易训练，整体上也需要更少的训练集。 在深度神经网络中，每层网络都可以作为下一层网络使用的一个模块，并且这个模块化是通过机器学习自动得到的。 常有“人工智能=机器学习+大数据”的说法，但实际上“深度”使得需要的数据更少，如果数据集无限大，根本就不需要机器学习，只要去数据库里拿就好了。深度学习也并不是通过大量参数暴力拟合出一个模型，反而是在通过模块化有效利用数据。 这里只是一个图像分类的例子，“深度”产生的模块化在语音识别任务中也有体现，与逻辑电路也有相似的问题和结论，具体可以看李宏毅视频。 端到端学习（End-to-end Learning） 深度神经网络模型就像是把一个个函数串接在一起，每个函数负责某个功能，每个函数负责什么功能是通过机器学习根据数据自动确定的。李宏毅视频中有讲这一点在语音识别、CV任务中的体现。 处理复杂任务 有时类似的输入要输出差别很大的结果，比如白色的狗和北极熊看起来差不多，但分类结果非常不同；有时差别很大的输入要输出相同的结果，比如火车正面和侧面的图片都应该被分类成火车。 只有一个隐藏层的网络是无法处理这种任务的。李宏毅视频中有讲这一点在语音识别、CV任务中的体现。 其它 Do deep nets really need to be deep? 李宏毅视频里也还有很多关于“深度”的探讨。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-5.1深度学习之引言]]></title>
    <url>%2F2021%2F01%2F27%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-5-1%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%95%E8%A8%80%2F</url>
    <content type="text"><![CDATA[[TOC] 深度学习的历史 1958年：心理学家Rosenblatt提出感知机（Perceptron） 它是一个线性模型。 1969年：有人说感知机是线性模型，具有局限性。 1980年代：多层感知机（Multi-layer Perceptron） 和当今的神经网络是没有本质差别的。 1986年：Hinton提出反向传播算法（Backpropagation） 但是超过3个隐藏层的神经网络，还是训练不出好的结果。 1989年：有人提出一个隐藏层就可以得到任何函数，为什么要多层？ 多层感知机慢慢淡出大家的视野。 2006年：受限玻尔兹曼机初始化（RBM Initialization） Hinton提出用受限玻尔兹曼机做初始化，很多人觉得这是个大突破，但实际上用处并不大。 至少让多层感知机回到大家的视野。 2009年：GPU 2011年：神经网络用于语音识别 2012年：神经网络技术赢得ILSVRC（ImageNet Large Scale Visual Recognition Challenge） 深度学习的三个步骤和机器学习一样： 确定模型（Model）/函数集（Function Set），在深度学习中就是定义一个神经网络。 不同的连接会构成多样的网络结构。 确定如何评价函数的好坏 如果是多分类，那和Classification一章中一样，计算每个样本预测结果与Ground Truth的交叉熵，然后求和，即为Loss。 确定如何找到最好的函数 还是Gradient Descent。 神经网络模型对应的函数比较复杂，而反向传播算法（Backpropagation）是一个很有效的计算神经网络梯度的方法。 神经网络的结构 输入层（Input Layer） 实际上就是输入，并不是真正的“层”。 隐藏层（Hidden Layers） 输入层和输出层之间的层。Deep指有很多隐藏层，多少层才算Deep并没有统一标准。 可以看成特征提取器（Feature Extractor），作用是代替特征工程（Feature Engineering）。 输出层（Output Layer） 最后一层。 可以看成分类器 全连接前馈神经网络即Fully Connected Feedforward Neural Network，FFN。 全连接是指每个神经元与上一层的所有神经元相连。 前馈神经网络（FNN，Feedforward Neural Network）是指各神经元分层排列，每个神经元只与前一层的神经元相连，接收前一层的输出，并输出给下一层，各层间没有反馈。 一些网络其中Residual Net并不是一般的全连接前馈神经网络 网络结构 提出年份 层数 ImageNet错误率 AlexNet 2012 8 16.4% VGGNet 2014 19 7.3% GoogleNet 2014 22 6.7% Residual Net 2015 152 3.57% 机器学习和深度学习面对的不同问题 在机器学习中，人类需要手工做特征工程（Feature Engineering），人类需要思考如何提取特征。 有了深度学习以后，人类可以不做特征工程，但也遇到了新的问题：人类需要设计合适的网络结构。 这两个问题哪个更容易呢？可能后者更容易些，比如在图像识别、语音识别任务中，人类可能并不知道自己是如何识别图像和语音的，就无法通过符号主义进行特征工程。 关于深度学习的一些疑问 虽然深度学习的的准确度很高，但是它使用的参数更多，参数多、准确度高也是很正常的事，所以有什么特别之处呢？ 只用一个神经元足够多的隐藏层，这个模型就包括了任意函数，那为什么不这么做而非要深度呢？为什么要是Deep而不是Fat呢？ 如何设计神经网络的结构？ 多少层？每一层有多少个神经元？ 只能凭经验（实验结果）和直觉，当然可以让机器自己去找网络结构，即网络架构搜索（NAS，Network Architecture Search）。 必须用全连接前馈神经网络吗？ 不是。比如卷积神经网络（Convolutional Neural Networks, CNN）。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-4.3分类模型之逻辑回归]]></title>
    <url>%2F2021%2F01%2F17%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-4-3%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[逻辑回归假设训练集如下，有2个类别$C_1$和$C_2$，表格中的每列为一个样本。 例如，第一列表示样本$x^1$的类别为$C_1$，所以它的标签$\hat y^1$是1。 $x^1$ $x^2$ $x^2$ $\dots$ $x^N$ $C_1$ $C_1$ $C_2$ $\dots$ $C_1$ $\hat y^1=1$ $\hat y^2=1$ $\hat y^3=0$ $\dots$ $\hat y^N=1$ 模型定义在分类（Classification）一节中，我们要找到一个模型$P_{w,b}(C_1|x)$，如果$P_{w,b}(C_1|x)\geq0.5$，则$x$属于类别$C_1$，否则属于类别$C_2$。 可知$P_{w,b}(C_1|x)=\sigma(z)$，其中$\sigma(z)=\frac{1}{1+e^{-z}}$（Sigmoid Function），$z=w\cdot x+b=\sum_{i=1}^Nw_ix_i+b$。 最终我们找到了模型$f_{w,b}(x)=\sigma(\sum_{i=1}^Nw_ix_i+b)$，这其实就是逻辑回归（Logistic Regression）。 损失函数从模型$f_{w,b}(x)=P_{w,b}(C_1|x)$中取样得到训练集的概率为：$L(w,b)=f_{w,b}(x^1)f_{w,b}(x^2)(1-f_{w,b}(x^3))\dots f_{w,b}(x^N)$（似然函数）。 我们要求$w^,b^=arg\ max_{w,b}L(w,b)$，等同于$w^,b^=arg\ min_{w,b}-lnL(w,b)$（对数似然方程，Log-likelihood Equation）。 而$-lnL(w,b)=-lnf_{w,b}(x^1)-lnf_{w,b}(x^2)-ln(1-f_{w,b}(x^3))\dots$，其中$lnf_{w,b}(x^n)=\hat y^nlnf_{w,b}(x^n)+(1-\hat y^n)ln(1-f(x^n))$，所以$-lnL(w,b)=\sum_{n=1}^N-[\hat y^nlnf_{w,b}(x^n)+(1-\hat y^n)ln(1-f_{w,b}(x^n))]$，式中$n$用来选择某个样本。 假设有两个伯努利分布$p$和$q$，在$p$中有$p(x=1)=\hat y^n,p(x=0)=1-\hat y^n$，在$q$中有$q(x=1)=f(x^n),q(x=0)=1-f(x^n)$，则$p$和$q$的交叉熵（Cross Entropy，代表两个分布有多接近，两个分布一模一样时交叉熵为0）为$H(p,q)=-\sum_xp(x)ln(q(x))$。 所以损失函数$L(f)=\sum_{n=1}^NC(f(x^n),\hat y^n)$，其中$C(f(x^n),\hat y^n)=-[\hat y^nlnf_{w,b}(x^n)+(1-\hat y^n)ln(1-f_{w,b}(x^n))]$，即损失函数为所有样本的$f(x^n)$与$\hat y^n$的交叉熵之和，式中$n$用来选择某个样本。 梯度$\frac{-lnL(w,b)}{\partial w_i}=\sum_{n=1}^{N}-(\hat y^n-f_{w,b}(x^n))x_i^n$（推导过程省略，具体见李宏毅机器学习视频14分56秒），其中$i$用来选择数据的某个维度，$n$用来选择某个样本，$N$为数据集中样本个数。 该式表明，预测值与label相差越大时，参数更新的步幅越大，这符合常理。 逻辑回归VS线性回归 模型逻辑回归模型比线性回归模型多了一个sigmoid函数； 逻辑回归输出是[0,1]，而线性回归的输出是任意值。 损失函数逻辑回归模型使用的训练集中label的值必须是0或1，而线性回归模型训练集中label的值是真实值。 图中线性回归损失函数中的$\frac{1}{2}$是为了方便求导 这里有一个问题，为什么逻辑回归模型中不使用Square Error呢？这个问题的答案见下文 梯度逻辑回归模型和线性回归模型的梯度公式一样 为什么逻辑回归模型中不使用Square Error 由上图可知，当label的值为1时，不管预测值是0还是1，梯度都为0，当label值为0时也是这样。 如下图所示，如果在逻辑回归中使用Square Error，当梯度接近0时，我们无法判断目前与最优解的距离，也就无法调节学习率；并且在大多数时候梯度都是接近0的，收敛速度会很慢。 判别模型VS生成模型形式对比逻辑回归是一个判别模型（Discriminative Model），用正态分布描述后验概率（Posterior Probability）则是生成模型（Generative Model）。 如果生成模型中共用协方差矩阵，那两个模型/函数集其实是一样的，都是$P(C_1|x)=\sigma(w\cdot x+b)$。 因为做了不同的假设，即使是使用同一个数据集、同一个模型，找到的函数是不一样的。 优劣对比 如果现在数据很少，当假设了概率分布之后，就可以需要更少的数据用于训练，受数据影响较小；而判别模型就只根据数据来学习，易受数据影响，需要更多数据。 当假设了概率分布之后，生成模型受数据影响较小，对噪声的鲁棒性更强。 对于生成模型来讲，先验的和基于类别的概率（Priors and class-dependent probabilities），即$P(C_1)$和$P(C_2)$，可以从不同的来源估计得到。以语音识别为例，如果使用生成模型，可能并不需要声音的数据，网上的文本也可以用来估计某段文本出现的概率。 多分类（Multi-class Classification）以3个类别$C_1$、$C_2$和$C_3$为例，分别对应参数$w^1,b_1$、$w^2,b_2$和$w^3,b_3$，即$z_1=w^1\cdot x+b_1$、$z_2=w^2\cdot x+b_2$和$z_3=w^3\cdot x+b_3$。 Softmax使用Softmax（$y_i=\frac{e^{z_i}}{\sum_{j=1}^3e^{z_j}}$），使得$0&lt;y_i&lt;1$以及$\sum_{i=1}^3y_i=1$，其中$y_i=P(C_i|x)$，即一个样本$x$属于类别$C_i$的概率不超过1，属于所有类别的概率之和为1。==Softmax公式中的z是一个参数吗？怎么确定或求得？== Softmax公式中为什么要用$e$？这是有原因/可解释的，可以看下PRML，也可以搜下最大熵。 最大熵（Maximum Entropy）其实也是一种分类器，和逻辑回归一样，只是从信息论的角度来看待。 损失函数计算预测值$y$和$\hat y$的交叉熵，$y$和$\hat y$都是一个向量，即$-\sum_{i=1}^3\hat y^ilny^i$。 这时需要使用one-hot编码：如果$x\in C_1$，则$y=\begin{bmatrix}1\\0\\0\end{bmatrix}$；如果$x\in C_2$，则$y=\begin{bmatrix}0\\1\\0\end{bmatrix}$；如果$x\in C_3$，则$y=\begin{bmatrix}0\\0\\1\end{bmatrix}$。 梯度和逻辑回归的思路一样。 逻辑回归的局限如下图所示，假如有2个类别，数据集中有4个样本，每个样本有2维特征，将这4个样本画在图上。 如下图所示，假如用逻辑回归做分类，即$y=\sigma(z)=\sigma(w_1x_1+w_2x_2+b)$，我们找不到一个可以把“蓝色”样本和“红色”样本间隔开的函数。 假如一定要用逻辑回归，那我们可以怎么办呢？我们可以尝试特征变换（Feature Transformation）。 特征变换（Feature Transformation）在上面的例子中，我们并不能找到一个能将蓝色样本和红色样本间隔开的函数。 如下图所示，我们可以把原始的数据/特征转换到另外一个空间，在这个新的特征空间中，找到一个函数将“蓝色”样本和“红色”样本间隔开。 比如把原始的两维特征变换为与$\begin{bmatrix}0\\0\end{bmatrix}$和$\begin{bmatrix}1\\1\end{bmatrix}$的距离，在这个新的特征空间中，“蓝色”样本和“红色”样本是可分的。 但有一个问题是，我们并不一定知道怎么进行特征变换。或者说我们想让机器自己学会特征变换，这可以通过级联逻辑回归模型实现，即把多个逻辑回归模型连接起来，如下图所示。 下图中有3个逻辑回归模型，根据颜色称它们为小蓝、小绿和小红。小蓝和小绿的作用是分别将原始的2维特征变换为新的特征$x_1’$和$x_2’$，小红的作用是在新的特征空间$\begin{bmatrix}x_1’\\x_2’\end{bmatrix}$上将样本分类。 如下图所示，举一个例子。小蓝的功能是（下图左上角），离$(1,0)$越远、离$(0,1)$越近，则$x_1’$越大；小蓝的功能是（下图左下角），离$(1,0)$越远、离$(0,1)$越近，则$x_2’$越小。小蓝和小绿将特征映射到新的特征空间$\begin{bmatrix}x_1’\\x_2’\end{bmatrix}$中，结果见下图右下角，然后小红就能找到一个函数将“蓝色”样本和“红色”样本间隔开。 神经网络（Neural Network）假如把上例中的一个逻辑回归叫做神经元（Neuron），那我们就形成了一个神经网络。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>线性回归</tag>
        <tag>逻辑回归</tag>
        <tag>分类</tag>
        <tag>Softmax</tag>
        <tag>特征变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-4.2分类模型之概率生成模型]]></title>
    <url>%2F2021%2F01%2F17%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-4-2%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[贝叶斯公式$P(A\cap B)=P(A)P(B|A)=P(B)P(A|B)$ $P(A|B)=\frac{P(B|A)P(A)}{P(B)}$ 全概率公式$P(B)=\sum_{i=1}^nP(A_i)P(B|A_i)$ 概率生成模型（Probalitity Generative Model）理论与定义假设有两个类别$C_1$和$C_2$，要判断对象$x$属于哪个类别，即计算$x$属于类别$C_1$的概率，这样把分类问题变成了概率计算问题。 根据贝叶斯公式（Bayes’ theorem）和全概率公式（Total Probability Theorem）可以知道，$x$属于类别$C_1$的概率为$P(C_1|x)=\frac{P(x|C_1)P(C_1)}{P(x)}=\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)}$，如果$P(C_1|x)&gt;0.5$则类别为$C_1$，否则类别为$C_2$。 概率生成模型的意思就是可以通过这个模型生成一个$x$。 具体来讲就是，根据$P(x)=P(x|C_1)P(C_1)+P(x|C_2)P(C_2)$计算出$P(x)$，就可以知道$x$的分布进而生成$x$。如果想要计算出$P(x)$，就要根据训练集估计出$P(C_1)$、$P(x|C_1)$、$P(C_2)$、$P(x|C_2)$这四个值。 更直观一点地讲，每个类别就是一个多元正态分布，其中多元是因为每个样本有多个维度的特征。 可以根据数据集中属于两个类别的对象的数量计算$P(C_1)$和$P(C_2)$这两个先验概率（Prior Probability）。 如果有2个样本属于类别$C_1$，4个样本属于类别$C_2$，那$P(C_1)=\frac{1}{3}$、$P(C_2)=\frac{2}{3}$。 要计算后验概率（Posterior Probability）$P(x|C_1)$和$P(x|C_2)$，可以假设训练集中的各类别样本的特征分别是从某个多元正态分布（多元对应特征的多维）中取样得到的，或者说是假设训练集中各类别样本的特征分别符合某多元正态分布。 该正态分布的输入是一个样本的特征$x$，输出为样本$x$是从这个正态分布取样得到（或者说该样本属于某类别）的概率密度，然后通过积分就可以求得$P(x|C_1)$和$P(x|C_2)$。 正态分布公式为$f_{\mu,\Sigma}(x)=\frac{1}{(2\pi)^{\frac{D}{2}}}\frac{1}{|\Sigma|^{\frac{1}{2}}}e^{-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)}$。 正态分布有2个参数，即均值$\mu$（代表正态分布的中心位置）和协方差矩阵（Covariance Matrix）$\Sigma$（代表正态分布的离散程度），计算出均值$\mu$和协方差$\Sigma$即可得到该正态分布。 公式中的$D$为多维特征的维度。 实际上从任何一个正态分布中取样都有可能得到训练集中的特征，只是概率不同而已。通过极大似然估计（Maximum Likelihood Estimate，MLE），我们可以找到取样得到训练集特征的概率最大的那个正态分布，假设其均值和协方差矩阵为$\mu^$和$\Sigma^$。 根据某正态分布的均值$\mu$和协方差$\Sigma$，可以计算出从该正态分布取样得到训练集的概率。$L(\mu,\Sigma)=f_{\mu,\Sigma}(x^1)f_{\mu,\Sigma}(x^2)\dots f_{\mu,\Sigma}(x^N)$，这就是似然函数（Likelihood Function），其中$N$是训练集中某个类别样本的数量。 $\mu^,\Sigma^=arg\ max_{\mu,\Sigma}L(\mu,\Sigma)$。 当然可以求导。 直觉：$\mu^=\frac{1}{N}\sum_{i=1}^Nx^i$，$\Sigma^=\frac{1}{N}\sum_{i=1}^N(x^i-\mu^)(x^i-\mu^)T$。 协方差矩阵共享每个类别的特征符合一个多元正态分布，每个多元正态分布也有不同的均值和协方差矩阵。让每个类别对应的多元正态分布共享一个协方差矩阵（各个协方差矩阵的加权平均和），公式为$\Sigma=\frac{N_1}{N_1+N_2}\Sigma^1+\frac{N_2}{N_1+N_2}\Sigma^2$，可以减少模型参数，缓解过拟合。 极大似然估计 定义 极大似然估计指已知某个随机样本满足某种概率分布，但是其中具体的参数不清楚，然后通过若干次试验，观察其结果，利用结果推出参数的大概值。一般说来，在一次试验中如果事件A发生了，则认为此时的参数值会使得$P(A|\theta)$最大，极大似然估计法就是要这样估计出的参数值，使所选取的样本在被选的总体中出现的可能性为最大。 求极大似然函数估计值的一般步骤： 写出似然函数 对似然函数取对数，并整理 求导数 解似然方程 当共享协方差矩阵时 此时似然函数是$L(\mu^1,\mu^2,\Sigma)=f_{\mu^1,\Sigma}(x^1)f_{\mu^2,\Sigma}(x^2)\dots f_{\mu^1,\Sigma}(x^{N_1})\times f_{\mu^2,\Sigma}(x^{N_1+1})f_{\mu^2,\Sigma}(x^{N_1+2})\dots f_{\mu^2,\Sigma}(x^{N_1+N_2})$，其中$N_1$为训练集中类别$C_1$的样本数、$N_2$为训练集中类别$C_2$的样本数。 当只有两个类别、两个特征时，如果共享协方差矩阵，那最终得到的两个类别的分界线是直线（横纵轴是两个特征），这一点可以在下文解释。 除了正态分布，还可以用其它的概率模型。 比如对于二值特征，可以使用伯努利分布（Bernouli Distribution）。 朴素贝叶斯分类 如果假设样本各个维度的数据是互相独立的，那这就是朴素贝叶斯分类器（Naive Bayes Classfier）。 Sigmoid函数由上面我们知道$P(C_1|x)=\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)}=\frac{1}{1+\frac{P(x|C_2)P(C_2)}{P(x|C_1)P(C_1)}}$， 令$z=ln\frac{P(x|C_1P(C_1)}{P(x|C_2P(C_2))}$，则$P(C_1|x)=\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)}=\frac{1}{1+\frac{P(x|C_2)P(C_2)}{P(x|C_1)P(C_1)}}=\frac{1}{1+e^{-z}}=\sigma(z)$，这就是Sigmoid函数。 如果共享协方差矩阵，经过运算可以得到$z=w^T\cdot x+b$的形式，其中常量$w^T=(\mu^1-\mu^2)^T\Sigma^{-1}$，常量$b=-\frac{1}{2}(\mu^1)^T(\Sigma^1)^{-1}\mu^1+\frac{1}{2}(\mu^2)^T(\Sigma^2)^{-1}\mu^2+ln\frac{N_1}{N_2}$，即形如$P(C_1|x)=\sigma(w\cdot x+b)$。 我们最终得到了一个这么简单的一个式子，有一个问题是，我们假设了分布、用了一堆概率，为什么不能直接定义线性模型呢？该问题的答案在下一篇文章李宏毅机器学习课程笔记-4.3分类模型之逻辑回归中的判别模型VS生成模型部分。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>概率生成模型</tag>
        <tag>分类</tag>
        <tag>贝叶斯</tag>
        <tag>Sigmoid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-4.1分类简介及其与回归的区别]]></title>
    <url>%2F2021%2F01%2F17%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-4-1%E5%88%86%E7%B1%BB%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E4%B8%8E%E5%9B%9E%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[分类模型应用案例（Classification Cases） 信用评分（Credit Scoring） 输入：收入、储蓄、职业、年龄、信用历史等等 输出：是否贷款 医疗诊断（Medical Diagnosis） 输入：现在症状、年龄、性别、病史 输出：哪种疾病 手写文字识别（Handwritten Character Recognition） 输入：文字图片 输出：是哪一个汉字 人脸识别（Face Recognition） 输入：面部图片 输出：是哪个人 把分类当成回归去做？不行。 假设有两个类别，其中类别1的标签为1，类别2的标签为-1，那0就是分界线，大于0就是类别1，小于0就是类别2。 回归模型会惩罚那些太正确的样本。如果结果远远大于1，它的分类应该是类别1还是类别2？这时为了降低整体误差，需要调整已经找到的回归函数，就会导致结果的不准确。 假设有多个类别，类别1的标签是1，类别2的标签是2，类别3的标签是3。 这样的话，标签间具有2和3相近、3大于2这种本来不存在的数字关系。 理想替代方案（Ideal Alternatives） 模型 模型可以根据特征判断类型，输入是特征，输出是类别 损失函数 预测错误的次数，即$L(f)=\sum_n\delta(f(x^n)\neq\hat y^n)$。 这个函数不可微 如何找到最好的函数 比如感知机（Perceptron）、支持向量机（SVM） Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>分类</tag>
        <tag>回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-3.梯度下降精讲]]></title>
    <url>%2F2020%2F12%2F27%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-3-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%B2%BE%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[梯度下降伪代码梯度下降可以优化损失函数的值，使其尽量小，即可找到最好（在数据集上拟合效果最好）的模型参数。 现在假设模型$f$中只有一个参数$w$，则损失函数为$L(f)=L(w)$，梯度下降算法如下（若模型有多个参数，按相同方法更新各参数） 初始化参数 随机选取一个$w^0$（$w^0$并不一定是随机选取），令$w=w^0$。 计算梯度 $\frac{dL(f)}{dw}|_{w=w^0}$ 如果小于0，此时$w$增大则$L(f)$会减小；如果大于0，此时$w$减小则$L(w)$会减小。 如果模型有多个参数，则计算损失函数在各个参数方向上的偏导数。 更新模型参数 $w^1=w^0-lr\frac{dL(f)}{dw}|_{w=w^0}$ $w$的变化量取决于梯度和学习率（Learning Rate）的大小：梯度绝对值或学习率越大，则$w$变化量越大。 如果模型有多个参数，则用上一步计算出的偏导数对应更新各参数。 重复第2步和第3步 经过多次参数更新/迭代（iteration），可以使损失函数的值达到局部最小（即局部最优，Local Optimal），但不一定是全局最优。 自适应学习率（Adaptive Learning Rate）梯度下降过程中，固定学习率并不合理。学习率太大，可能导致loss不减小反而增大；学习率太小，loss会减小得很慢。 基本原则是随着参数迭代更新，学习率应该越来越小，比如$\eta^{t}=\frac{\eta}{\sqrt{t+1}}$。 更好的方法：每个参数有各自的学习率，比如Adagrad。 AdagradAdaptive Gradient Descent，自适应梯度下降。2011年提出，核心是每个参数（parameter）有不同的学习率 定义每次迭代中，学习率要除以它对应参数的之前梯度的均方根（RMS） 。 即$w^{t+1}=w^t-\frac{\eta}{\sqrt{\sum_{i=0}^t(g^i)^2}}g^t$，其中$t$是迭代次数，$w$是参数，$g$是梯度，$\eta$是初始学习率。 随着参数迭代，$t$越来越大，$\sqrt{\sum_{i=0}^t(g^i)^2}$也越来越大，因此学习率的变化趋势是越来越小。 Adagrad的矛盾（Contradiction）一般的梯度下降方法$w^{t+1}=w^t-\eta^tg^t$中，$\eta^t$是常量，梯度越大时，则参数更新的步幅越大，这是由$g^t$项决定的。 在Adagrad中，$\eta$是常量，梯度$g^t$越大时会使得参数更新的步幅越大，但$\sqrt{\sum_{i=0}^t(g^i)^2}$越大会使得参数更新的步幅越小，这是一个矛盾吗？ 为什么要除以之前梯度的均方根？ 一种直观的解释：增强参数更新步幅变化的惯性 与之前梯度相比如果现在的梯度更大，则现在梯度除以之前梯度会使参数更新的步幅更大；如果现在的梯度更小，则会使步幅更新的步幅更小。 这样就相当于增强了参数更新步幅变化的惯性，即如果参数更新的步幅突然变大或变小，就扩大这个趋势。 同时考虑一次梯度和二次梯度 在Adagrad中，之前梯度的均方根是用来通过一次梯度估计二次梯度（虽然可以直接使用二次梯度，但其很难计算）。 只考虑一个参数 当参数只有一个或只考虑一个参数时，梯度越大，离最优点就越远，参数更新的步幅应该越大。 考虑多个参数 当参数有多个或者考虑多个参数时，上述内容不一定成立。如果参数1的梯度比参数2的梯度大，但如果损失函数关于参数1的曲线比关于参数2的曲线更陡峭（即二次梯度更大），那参数1离最优点的距离可能比参数2更近。 所以当参数有多个或者考虑多个参数时，我们既要考虑一次梯度又要考虑二次梯度。 结论是一次梯度越大、二次梯度越小，离最优点就越远，参数更新的步幅应该越大。 SGDStochastic Gradient Descent，随机梯度下降，1847年提出，可以让训练过程更快。 普通梯度下降中需要计算所有样本的Loss，而SGD只计算一个样本的Loss，然后进行梯度下降。 梯度下降的数学理论建议直接看李宏毅老师的本节视频，从42分27秒开始看，老师讲得很好。 初始化一组参数后，我们找到邻域中另一个使损失函数值最小的一组参数并更新参数（然后不断重复这一步骤）。 在极小的邻域中，可以利用泰勒级数将损失函数简化，然后求其最小值，损失函数简化后，要使其最小即是让其中两个向量的內积最小，由此可以得出新的一组参数的值（具体过程略），这就是梯度下降。 学习率的作用是限制邻域大小，学习率太大可能使邻域太大，导致损失函数展开成泰勒级数时的误差较大。 当然也可以将损失函数展开成2次（比如牛顿迭代法），但这并不实用，因为要计算二次微分，甚至可能要求出海森矩阵（Hessian Matrix）逆矩阵等等，这些在做深度学习时是不实用的。 梯度下降的局限性梯度下降过程中，每次参数更新不一定都会使损失函数的值更小。 求出的只是局部最小值（Local Minima）甚至是鞍点（Saddle Point），不一定是全局最优解。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>梯度下降</tag>
        <tag>学习率</tag>
        <tag>Adagrad</tag>
        <tag>SGD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-2.5线性回归Python实战]]></title>
    <url>%2F2020%2F12%2F25%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-5%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92Python%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文为作者学习李宏毅机器学习课程时参照样例完成homework1的记录。 关注我的公众号：臭咸鱼，回复LHY可获取课程PPT、数据和代码下载链接。 代码仓库：https://github.com/chouxianyu/LHY_ML2020_Codes 任务描述（Task Description） 现在有某地空气质量的观测数据，请使用线性回归拟合数据，预测PM2.5。 数据集描述（Dataset Description） train.csv 该文件中是2014年每月前20天每小时的观察数据，每小时的数据是18个维度的（其中之一是PM2.5）。 test.csv 该文件中包含240组数据，每组数据是连续9个小时的所有观测数据（同样是18个维度）。 请预测每组数据对应的第10个小时的PM2.5数值。 结果格式 要求上交结果的格式为CSV文件。 第一行必须是id,value。 从第二行开始每行分别为id值及预测的PM2.5数值，两者用逗号间隔 总结 数据处理 将数据处理、转换成什么形式，要根据数据集格式、任务来确定。 要熟练掌握pandas、numpy等数据处理工具，特别是要知道它们能实现什么功能。 参考链接 https://colab.research.google.com/drive/131sSqmrmWXfjFZ3jWSELl8cm0Ox5ah3C Python代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import pandas as pdimport numpy as npimport csv## 读取数据data = pd.read_csv('./train.csv', encoding = 'big5') # 读取训练集# print(data.describe())## 数据预处理data = data.iloc[:, 3:] # 不需要使用前三列的表头，所以删除data[data == 'NR'] = 0 # 将非数值NR改为0raw_data = data.to_numpy() # pandas转numpy数组，形状是4320(=18*20*12)*24# print(raw_data.shape)## 修改数据格式# 数据格式为12(month)*18(features)*480(=24*20hours)，即12个月、每个月有480小时的数据（18维）month_data = &#123;&#125; # 字典for month in range(12): sample = np.empty([18, 480]) for day in range(20): sample[ : , 24 * day : 24 * (day + 1)] = raw_data[(month * 20 + day) * 18 : (month * 20 + day + 1) * 18, : ] month_data[month] = sample## 修改数据格式# 数据格式为每个月有连续的480个小时，每10个小时形成1个object，每个月就有471个object，12个月就有471*12个oeject，每个object包括x(18*9的featrues)和y(1个PM2.5数值)。x = np.empty([471*12, 18*9], dtype=float) # 471*12行，一行是一个object的xy = np.empty([471*12, 1], dtype=float) # 471*12行，一行是一个object的yfor month in range(12): for day in range(20): for hour in range(24): if day == 19 and hour &gt; 14: # 最后一个10小时从第20天14小时开始，防止越界 continue x[month * 471 + day * 24 + hour, :] = month_data[month][:,day * 24 + hour : day * 24 + hour + 9].reshape(1, -1) # reshape时的(1, -1)指：1行、列数自动计算 y[month * 471 + day * 24 + hour, 0] = month_data[month][9, day * 24 + hour + 9] # 取对应的第10个小时的PM2.5的值# print(x, y)## 标准化#关于标准化，可以看这篇文章https://www.cnblogs.com/chouxianyu/p/13872444.htmlmean_x = np.mean(x, axis=0) # 平均值，axis=0指沿着列计算平均值，即计算每列的平均值std_x = np.std(x, axis=0) # 标准差，axis=0指沿着列计算平均值，即计算每列的标准差# print(mean_x.shape, std_x.shape)for i in range(len(x)): for j in range(len(x[0])): if std_x[j] != 0: x[i][j] = (x[i][j] - mean_x[j]) / std_x[j]## 训练dim = 18 * 9 + 1 # 这个+1是为了保存偏置w = np.zeros([dim, 1])x = np.concatenate((np.ones([471 * 12, 1]), x), axis=1).astype(float) # axis=1表示将两个数组按行拼接，向x中添加1是为了让其与weight中的偏置相乘learning_rate = 100 # 学习率iter_time = 1000 # 迭代次数adagrad = np.zeros([dim, 1])eps = 1e-10 # eps是避免Adagrad分母为0而加的for t in range(iter_time): loss = np.sqrt(np.sum(np.power(np.dot(x, w) - y, 2)) / 471 / 12) # RMSE if (t % 100 == 0): print(t, loss) gradient = 2 * np.dot(x.transpose(), np.dot(x, w) - y) # dim*1 adagrad += gradient ** 2 w -= learning_rate * gradient / np.sqrt(adagrad + eps)np.save('weight.npy', w)print('Training Done')## 测试# 读取数据test_data = pd.read_csv('./test.csv',header=None, encoding='big5')test_data = test_data.iloc[ : , 2:] # 去除表头（前两列）test_data[test_data == 'NR'] = 0test_data = test_data.to_numpy()test_x = np.empty([240, 18 * 9]) # 240个object，一行是一个object的x# 修改数据格式for i in range(240): test_x[i, :] = test_data[i * 18 : (i + 1) * 18, : ].reshape(1, -1) # 格式和训练集一样# 标准化for i in range(len(test_x)): for j in range(len(test_x[0])): if std_x[j] != 0: test_x[i, j] = (test_x[i, j] - mean_x[j]) / std_x[j]test_x = np.concatenate((np.ones([240, 1]), test_x), axis=1).astype(float) # axis=1表示将两个数组按行拼接，向x中添加1是为了让其与weight中的偏置相乘## 预测w = np.load('weight.npy')ans_y = np.dot(test_x, w)# print('ans_y.shape', ans_y.shape)with open('answer.csv', mode='w', newline='') as answer_file: csv_writer = csv.writer(answer_file) csv_writer.writerow(['id', 'value']) for i in range(240): row = ['id_' + str(i), ans_y[i][0]] csv_writer.writerow(row) # print(row) Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>线性回归</tag>
        <tag>adgrad</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-2.4交叉验证]]></title>
    <url>%2F2020%2F12%2F24%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-4%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[交叉验证（Cross Validation）在机器学习中，通常不能将全部数据用于模型训练，否则将没有数据集可以用来评估模型。 The Validation Set Approach 定义 将数据集划分成训练集（Training Set）和测试集（Test Set）两部分。 缺点 这种方法的缺点是依赖于训练集和测试集的划分方法，并且只用了部分数据进行模型的训练。 LOOCV（Leave One Out Cross Validation） 定义 假设数据集中有N个数据，取其中1个数据作为测试集，将剩下的N-1个数据作为训练集，这样重复N次就得到N个模型以及N个误差值，最终使用这N个误差值的平均值评估该模型。 优点 该方法不受训练集和测试集划分方法的影响，因为每个数据都单独做过测试集；同时该方法用了N-1个数据训练模型，也几乎用到了所有的数据，保证了模型的Bias更小。 缺点 该方法的缺点是计算量过大，是The Validation Set Approach耗时的N-1倍。 K折交叉验证（K-fold Cross Validation） 定义 该方法是LOOCV的折中，即将数据集分成K份。 如何选取K的值 K的选取是一个Bias和Variance的trade-off。一般选择K=5或10。 K越大，每次训练时训练集的数据量就越大，则Bias越小；但每次训练时的训练集之间的相关性越大（考虑最极端的情况K=N，也就是LOOCV，每次训练使用的数据几乎是一样的），这种大相关性会导致最终的误差具有更大的Variance。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>交叉验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-2.3欠拟合与过拟合]]></title>
    <url>%2F2020%2F12%2F24%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-3%E6%AC%A0%E6%8B%9F%E5%90%88%E4%B8%8E%E8%BF%87%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[欠拟合（Underfitting）定义Bias较大、Variance较小。 如果模型在训练集上的误差很大，则此时Bias是大的，情况为欠拟合。 Bias大时如何处理使用更复杂的模型，比如添加考虑更多维度的输入、把线性模型换成非线性模型。 过拟合（Overfitting）定义Bias较小、Variance较大。 如果模型在训练集上的误差很小，但是在测试集上的误差很大，则此时Variance是大的，情况为过拟合。 Variance大时如何处理 使用更复杂的数据集 比如添加数据（很有效，但不一定做得到）、数据增强等方法。 使用更简单的模型（不是根本方法） 可能是模型过于复杂导致了过拟合，因此可以简化模型缓解过拟合。 正则化（Regularization） 正则化可能会使Bias增大，所以需要调整正则化的参数。 如$L_{new}=L_{old}+\lambda \sum(w_i)^2$，其中$\lambda$是一个常数。 加上正则项$\lambda \sum(w_i)^2$的目的是让函数参数的值尽可能地接近0，使函数变得更平滑。 平滑（Smooth）定义平滑是指输入变化影响输出变化的程度（输出对输入的敏感程度）。 假设输入变化，如果函数越不平滑，则输出变化程度越大。 函数参数越接近0，这个函数就越平滑（smooth）。 我们为什么喜欢一个平滑的函数？适度平滑的函数可以缓解函数输入中包含的噪声对函数输出的影响。 如果输入中包含一些噪声/干扰（noise），那平滑函数的输出受输入中包含的噪声干扰的程度更小。 我们为什么不喜欢过于平滑的函数？函数过于平滑，就无法有效地提取数据的特征，这不是我们想要的函数。 假设有一个极限平滑的函数，即该函数的输出不受输入的影响，那当然不是个好的函数。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>Bias</tag>
        <tag>Variance</tag>
        <tag>过拟合</tag>
        <tag>欠拟合</tag>
        <tag>正则化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-2.2如何选择模型、减小误差]]></title>
    <url>%2F2020%2F12%2F24%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-2%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B%E3%80%81%E5%87%8F%E5%B0%8F%E8%AF%AF%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[模型选择（How to select model） 模型越复杂，一般其在训练集上的误差（Error）越小。 因为更复杂的模型（函数集）包含了更多的函数。比如二次模型包含了线性（一次）模型。 模型越复杂，其在测试集上的误差（Error）不一定越小。 因为模型过于复杂时，越容易被数据影响，可能导致过拟合。 误差（Error）误差的来源暂时称通过机器学习得到的函数为人工函数，它其实是对“上帝函数”的估计（Estimator），和“上帝函数”之间是有误差的。 误差来源于两方面：一是Bias，二是Variance，需要权衡（trade-off）两者以使总误差最小。 如上图所示，Bias是指人工函数（的期望）和上帝函数之间的距离，Variance是指人工函数的离散程度（或者说是不稳定程度）。 如上图所示，横轴是模型的复杂程度（1次幂、2次幂、……），纵轴是误差大小。模型越复杂，Bias越小，Variance越大。 Variance定义使用相同模型在不同数据上拟合得到的函数是不同的，这些函数之间的离散程度就是Variance。 以射箭为例，Variance衡量的就是射得稳不稳。 模型越复杂，Variance越大。因为模型越简单，越不容易被数据影响（对数据不敏感，感知数据变化的能力较差），那Variance就越小。 Bias定义使用相同模型在不同数据上拟合得到的函数是不同的，取这些函数的“期望”，该期望与“真理”的差距就是Bias。 以射箭为例，Bias衡量的就是射得准不准（这里的“准”的含义有待商榷）。 模型越简单，Bias越大。因为模型就是个函数集（Function Set）。模型越简单，则其包含的函数就越少、包含“上帝函数”的几率就越小，甚至可能不包括上帝函数。 在函数集很小的情况下，即使是其中最好的函数，它与“上帝函数”的差距也还是很大的。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>Bias</tag>
        <tag>Variance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-2.1线性回归模型]]></title>
    <url>%2F2020%2F12%2F24%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-1%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[回归模型应用案例（Regression Cases） 股票市场预测（Stock Market Forecast） 预测某个公司明天的股票情况 自动驾驶车（Self-Driving Car） 预测方向盘转动角度 推荐系统（Recommendation） 预测某用户购买某商品的可能性 线性回归模型（Linear Regression Model）如$y=f(x)=w\cdot x+b$ $y$是输出； $\hat y$是真实值/标签（label） $w$是权重（weight）； $b$是偏置（bias）； $x$是输入（input），也可叫做特征（feature） 数据集中一般包含多个object，每个object一般包含多个component。此时，上标是object的索引，下标是component的索引。 损失函数（Loss Function） 如果不考虑模型的好坏，衡量一个函数的好坏，其实是衡量模型参数的好坏。 以线性模型为例，就是衡量参数$w$和$b$的好坏。如$L(f)=L(w,b)=\sum_{n=1}^{10}(\hat y-(b+w\cdot x^n))^2$，把所有样本误差的平方和作为损失函数 输入 一个函数 输出 多么地不好（how bad it is）。损失函数值越大，则这个函数越差、与数据集中内容越不相符。 梯度下降（Gradient Descent）梯度下降可以优化损失函数的值，使其尽量小，即可找到最好（在数据集上拟合效果最好）的模型参数。 现在假设模型$f$中只有一个参数$w$，则损失函数为$L(f)=L(w)$，梯度下降算法如下（若模型有多个参数，按相同方法更新各参数） 初始化参数 随机选取一个$w^0$（$w^0$并不一定是随机选取），令$w=w^0$。 计算梯度 $\frac{dL(f)}{dw}|_{w=w^0}$ 如果小于0，此时$w$增大则$L(f)$会减小；如果大于0，此时$w$减小则$L(w)$会减小。 如果模型有多个参数，则计算损失函数在各个参数方向上的偏导数。 更新模型参数 $w^1=w^0-lr\frac{dL(f)}{dw}|_{w=w^0}$ $w$的变化量取决于梯度和学习率（Learning Rate）的大小：梯度绝对值或学习率越大，则$w$变化量越大。 如果模型有多个参数，则用上一步计算出的偏导数对应更新各参数。 重复第2步和第3步 经过多次参数更新/迭代（iteration），可以使损失函数的值达到局部最小（即局部最优，Local Optimal），但不一定是全局最优。 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>线性回归，梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李宏毅机器学习课程笔记-1.机器学习概论]]></title>
    <url>%2F2020%2F12%2F22%2F%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[机器学习是什么机器学习就是让机器能自动找到一个函数（function） 语音识别（Speech Recognition） 输入是音频，输出是音频对应的文字。 图像分类 输入是图片，输出是类别（比如猫、狗）。 AlphaGo下围棋 输入是当前棋盘的状态，输出是下一步落棋的位置。 对话/问答系统 机器能够找到哪些函数？为解决不同的问题、完成不同的任务，需要找到不同的函数，那机器学习能找到哪些函数呢？ 回归（Regression） 输出是一个连续的数值、标量，比如PM2.5预测。 分类（Classification） 输出是一个离散的值。 二分类（Binary Classification）的输出就是0或1、Yes或No、…，比如文本情感分析的输出可以是正面和负面。 多分类（Multi-Category Classification）的输出就是[1,2,3,…,N]，比如图像分类里判断一张图片是猫还是狗还是杯子。 生成（Generation） 很多教科书把机器学习划分为回归问题和分类问题，但其实不止这两种问题，还有其它问题，比如生成（Generation）。 生成（Generation）指让机器学习如何创造/生成，比如生成文本、图片等。 如何告诉机器我们希望找到什么函数我们该如何为机器提供学习资料？ 有监督学习（Supervised Learning） 可以把有监督学习中的“监督”理解为“标签（Label）”，即数据集中不仅包括特征还包括标签。 有了标签，我们就可以评价一个函数的好坏，进而优化这个函数。 使用Loss判断函数的好坏，Loss越小，函数越好。个人想法：值得一提的是，Loss/评价指标是多样的、优化方法也是多样的。 强化学习（Reinforcement Learning） 原始的AlpahGo是先通过有监督学习优化到一定程度，然后用强化学习继续优化。 新版本的AlphaGo是完全通过强化学习实现的，优于原始的AlphaGo。 无监督学习（Unsupervised Learning） 只给机器提供数据特征，但不提供数据标签。==那机器能学到什么呢？== 下面以让机器学习下围棋为例：有监督学习VS强化学习。 有监督学习 函数的输入（数据特征）就是棋盘状态，函数的输出（数据标签）就是下一步落棋的位置。 此时，我们需要为机器提供的数据就类似棋谱（如果现在棋局是这样，那下一步怎么落棋最好），但其实人类不一定知道怎么落棋最好。 个人想法：理论上，通过这样的有监督学习，机器是无法超越人类的。因为这样的有监督学习的本质是人类把自己的下棋策略教给机器，机器学习的内容仅仅是人类的下棋策略而无法“自主进行思考”，所以理论上机器是无法超越人类的。同时要注意，这里的人类指全人类。 强化学习 让机器跟自己、别人下棋，把结果（赢或输）作为Reward，引导机器学习如何下棋。 如果它赢了，那它就知道这一盘里有几步棋下得好，但不知道是哪几步；如果它输了，它就知道这一盘里有几步棋下得不好，但不知道是哪几步。 个人想法：理论上，通过这样的强化学习，机器是可以超过人类的。因为两者的学习材料没有本质区别，但机器的机能却优于人类，这里讲的机能包括信息共享能力、记忆能力、执行能力等方面 机器如何找出我们想找到的函数 我们要给定函数形式/范围（模型） 比如假定函数是线性模型、神经网络等等。模型就是一个函数集，模型的参数确定以后，才得到一个函数。 找到更好的函数： 使用梯度下降（Gradient Descent），找到更好的函数。 前沿研究 AI的可解释性（Explainable AI） 比如，机器为什么认为这张图片里有一只猫？ 对抗攻击（Adversarial Attack） 对输入故意添加一些人无法察觉的细微的干扰，导致模型以高置信度给出一个错误的输出。 模型压缩（Network Compression） 把模型压缩以减少模型对计算资源消耗。 异常检测（Anomaly Detection） 使机器知道它遇到了自己不知道的东西。 迁移学习（Transfer Learning/Domain Adversarial Learning） 一个模型已经学到了一些知识，将这些知识应用到另一个任务中。 元学习（Meta Learning） 让机器学习如何学习。 机器学习是我们教机器学习某种知识，元学习是我们教机器如何学习。 终身学习（Life-Long Learning） 让机器终身学习，学习完任务1、再继续学任务2、…… 机器学习的三个步骤 确定模型（Model）/函数集（Function Set） 确定如何评价函数的好坏 确定如何找到最好的函数 Github（github.com）：@chouxianyu Github Pages（github.io）：@臭咸鱼 知乎（zhihu.com）：@臭咸鱼 博客园（cnblogs.com）：@臭咸鱼 B站（bilibili.com）：@绝版臭咸鱼 微信公众号：@臭咸鱼 转载请注明出处，欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙江理工大学计算机科学与技术专业课程笔记、试题、课件等复习资料大礼包]]></title>
    <url>%2F2020%2F11%2F26%2F%E6%B5%99%E6%B1%9F%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E3%80%81%E8%AF%95%E9%A2%98%E3%80%81%E8%AF%BE%E4%BB%B6%E7%AD%89%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99%E5%A4%A7%E7%A4%BC%E5%8C%85%2F</url>
    <content type="text"><![CDATA[模拟电路与数字电路 链接：https://pan.baidu.com/s/1KTUmyqRAG0ilQrBEB72eFQ提取码：5n4y复制这段内容后打开百度网盘手机App，操作更方便哦 百度网盘不让分享，请尽快保存 C++试题 链接：https://pan.baidu.com/s/1QtMMzJxFOl6fsDHVzKIeyw 提取码：os8k 复制这段内容后打开百度网盘手机App，操作更方便哦 C语言试题 链接：https://pan.baidu.com/s/1OsE0BsLJ-kXGibNTg1GfgQ 提取码：kaso 复制这段内容后打开百度网盘手机App，操作更方便哦 JAVA试题 链接：https://pan.baidu.com/s/11EpvCdIeQokMbMDR2MdZCQ 提取码：knly 复制这段内容后打开百度网盘手机App，操作更方便哦 汇编语言（试题、笔记、实验、参考书） 链接：https://pan.baidu.com/s/1OxCLyAbOB2Egp6jJLdN2kg 提取码：44eg 复制这段内容后打开百度网盘手机App，操作更方便哦 概率论与数理统计 链接：https://pan.baidu.com/s/1qgyFsn-2JHO0hwxK08uUQw 提取码：e0is 复制这段内容后打开百度网盘手机App，操作更方便哦 高等数学 链接：https://pan.baidu.com/s/1n7sTD9tutaQTuca-eI1jKg 提取码：95xp 复制这段内容后打开百度网盘手机App，操作更方便哦 离散数学 链接：https://pan.baidu.com/s/1ltfwSqB5or90wRFQVOYncQ 提取码：yagu 复制这段内容后打开百度网盘手机App，操作更方便哦 线性代数 链接：https://pan.baidu.com/s/19DgVokKrFj9aA2KMC7HVtw 提取码：mac6 复制这段内容后打开百度网盘手机App，操作更方便哦 普通物理 链接：https://pan.baidu.com/s/13OtioAw5SX1sA_fmO-n4Zw 提取码：gkwr 复制这段内容后打开百度网盘手机App，操作更方便哦 电子服务信任与信誉 链接：https://pan.baidu.com/s/1xqeruRJ_d2ZQ2edNR_wxGw 提取码：1eqp 复制这段内容后打开百度网盘手机App，操作更方便哦 编译原理 链接：https://pan.baidu.com/s/1QNAigX7gtjNxVE5hdgysWg 提取码：5n5g 复制这段内容后打开百度网盘手机App，操作更方便哦 操作系统 链接：https://pan.baidu.com/s/1cHQ7yfFFmKLWSmhTp-FdrQ 提取码：qcjn 复制这段内容后打开百度网盘手机App，操作更方便哦 服务外包概论 链接：https://pan.baidu.com/s/1ICG6Z6tiIa7ViL2JMdFYPQ 提取码：jaa2 复制这段内容后打开百度网盘手机App，操作更方便哦 软件工程 链接：https://pan.baidu.com/s/1YoT2-vTHM_tX_UysTpwlHw 提取码：8csu 复制这段内容后打开百度网盘手机App，操作更方便哦 数据库系统与应用设计 链接：https://pan.baidu.com/s/1s1Y92c00PPjtAl5pEjjlSQ 提取码：ql1g 复制这段内容后打开百度网盘手机App，操作更方便哦 计算机网络 链接：https://pan.baidu.com/s/1YJ8vW7aHVjFYhkWRL0kCbQ 提取码：jh0j 复制这段内容后打开百度网盘手机App，操作更方便哦 计算机系统结构 链接：https://pan.baidu.com/s/1-LZ4RFh5tOOxukwXIyO7OQ 提取码：kxkq 复制这段内容后打开百度网盘手机App，操作更方便哦 计算机组成原理 链接：https://pan.baidu.com/s/1Uk08FMucWBFotmjD0cIKgA 提取码：ea1t 复制这段内容后打开百度网盘手机App，操作更方便哦 数据结构与算法 链接：https://pan.baidu.com/s/1rxLY0hKenxFBd2692LG1vQ 提取码：xyfz 复制这段内容后打开百度网盘手机App，操作更方便哦 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>期末大礼包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一文详解特征缩放、标准化、归一化的定义、区别、特点和作用]]></title>
    <url>%2F2020%2F10%2F25%2F%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE%E3%80%81%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E7%89%B9%E7%82%B9%E5%92%8C%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言我在学李宏毅的机器学习课程，助教给的回归作业代码中有数据标准化的操作。 我听过数据标准化，还有归一化、批量归一化等等，但不是很懂，不知道他们具体是什么、有什么区别。 百度上找了挺多文章，讲得都不是很系统，比如大多文章都没讲懂标准化和归一化的区别或者是不同文章讲的内容矛盾了。 用谷歌一搜，就找到了很多很有价值的相关文章，然后我也写了这篇文章做个记录。 相对来讲，中文社区要比英文社区差些，部分原因是名词滥用或中英翻译问题，比如标准化和归一化、常量指针和指针常量。emmm 概要本文主要讲解了以下内容 特征缩放是什么/特征缩放的定义 归一化是什么/归一化的定义 标准化是什么/标准化的定义 归一化和标准化的区别 为什么要进行特征缩放/特征缩放有什么作用 有哪些常见的特征缩放方法 什么时候适合进行特征缩放/特征缩放方法的应用 名词定义这几个词是有区别的，特别是标准化和归一化，不要滥用（在本文中也请区分这几个词）。 中文 英文 特征缩放 Feature Scaling 标准化 Standardization(Z-Score Normalization) 归一化 Normalization 可以认为Feature Scaling包括Standardization和Normalization，其中Standardization可以叫做Z-Score Normalization。 为什么需要进行特征缩放背景：多指标量纲和数量级不同使用单一指标对某事物进行评价并不合理，因此需要多指标综合评价方法。多指标综合评价方法，就是把描述某事物不同方面的多个指标综合起来得到一个综合指标，并通过它评价、比较该事物。 由于性质不同，不同评价指标通常具有不同的量纲和数量级。当各指标相差很大时，如果直接使用原始指标值计算综合指标，就会突出数值较大的指标在分析中的作用、削弱数值较小的指标在分析中的作用。 为消除各评价指标间量纲和数量级的差异、保证结果的可靠性，就需要对各指标的原始数据进行特征缩放（也有数据标准化、数据归一化的说法，但这些叫法不准确，所以不推荐）。 由于量纲和数量级不同，所以需要特征缩放。特征缩放可以显著提升部分机器学习算法的性能，但它对部分算法没有帮助。 不进行特征缩放会有什么后果假如特征$x_1$的数值是100左右，特征$x_2$的数值是1左右，方程为$y=b+w_1x_1+w_2x_2$，那$w_1$对$y$的影响就更大，对Loss的影响也更大，损失函数关于$w_1$的梯度也更大，而损失函数关于$w_2$的梯度却很小，因此两个特征就不能使用相同的学习率。 不进行特征缩放的话，Error Surface就是一个椭圆，梯度下降时不一定是朝着最优点（圆心），速度就慢。 如果进行了特征缩放，Error Surface会尽可能趋近于圆，因此梯度下降时会一直朝着最优点（圆心），所以速度快。 各类算法是否需要进行特征缩放基于梯度下降的算法（Gradient Descent Based Algorithms）在基于梯度下降进行优化的算法中，需要进行特征缩放，比如线性回归、逻辑回归、神经网络等。 因为计算梯度时会使用特征的值，如果各特征的的取值范围差异很大，不同特征对应梯度的值就会差异很大。 为保证平滑走到最优点、按相同速率更新各特征的权重，需要进行特征放缩。 通过特征放缩，可以使数值范围变小，进而加速梯度下降。 基于距离的算法（Distance-Based Algorithms）在基于距离进行优化的算法中，需要进行特征缩放，比如K近邻、K-Means、SVM、PCA等。 因为这些算法是基于数据点的特征值计算它们的距离，距离越小则两者越相似。 基于树的算法（Tree-Based Algorithms）基于树的算法（比如决策树）对特征（features）的数值范围并不敏感，不需要进行特征缩放。 决策树仅基于单个feature拆分节点，并不受其它feature的影响。 线性判别分析、朴素贝叶斯等算法这两个算法处理了特征数量级差异大的问题，因此不需要进行特征缩放。 四种特征缩放的方法标准化和归一化都可以实现特征缩放，但两者是有区别的。 假设我们有一份数据$x$，它有$N$行$M$列，即有$N$个对象，每个对象有$M$个特征，$x^i_j$表示对象$i$的特征$j$。 Standardization（Z-Score Normalization） Mean Normalization Min-Max Normalization Unit Vector Normalization/Scaling to unit length 标准化（Standardization/Z-Score Normalization） 定义 公式为$\hat x[:,j]=\frac{x[:,j]-mean(x[:,j])}{std(x[:,j])}$，其中$mean$代表平均值，$std$代表标准差， $mean(x[:,j])=\frac{1}{N}\cdot\sum_{i=1}^Nx[i,j]$， $std(x[:,j])=\sqrt{\frac{1}{N-1}\cdot\sum^N_{i=1}(x[i,j]-\mu_j)^2}$。 特点 使数据的平均值变为0、标准差变为1，不改变数据的分布类型，数值范围不一定，消除了数据的量纲差异。 假设 标准化假设数据是正态分布，但这个要求并不十分严格，如果数据是正态分布则该技术会更有效。 何时使用 当我们使用的算法假设数据是正态分布时，可以使用Standardization，比如线性回归、逻辑回归、线性判别分析。 因为Standardization使数据平均值为0，也可以在一些假设数据中心为0（zero centric data）的算法中使用，比如主成分分析（PCA）。 归一化（Normalization） 特点 把数据调整到[0,1]，并且消除了数据的量纲差异。 也可以把数据调到[-1,1]，在使用SVM和Adaboost时就需要这样。 何时使用 当我们不知道数据分布时或者我们知道数据不是正态分布时，这是一个很好的方法。 换种说法就是，当我们使用的算法没有假设数据的分布类型时，就可以使用Normalization，比如K近邻算法和人工神经网络。 Mean Normalization 定义 $\hat x[:,j]=\frac{x[:,j]-mean(x[:,j])}{max(x[:,j])-min(x[:,j])}$ 其中$mean$代表平均值，$max$代表最大值，$min$代表最小值。 特点 把数据调到[-1,1]，平均值为0 何时使用 一些假设数据中心为0（zero centric data）的算法，比如主成分分析（PCA）。 Min-Max Normalization 定义 $\hat x[:,j]=\frac{x[:,j]-min(x[:,j])}{max(x[:,j])-min(x[:,j])}$ 其中$max$代表最大值，$min$代表最小值。 特点 把数据调到[0,1] 何时使用 当处理具有严格数值范围要求的数据（比如图片）时，这非常有用。 Unit Vector Normalization/Scaling to unit length 定义 $\hat x[i,:]=\frac{x[i,:]}{||x[i,:]||}$ 把每个对象的特征向量变成单位长度。 特点 把数据调到[0,1] 何时使用 当处理具有严格数值范围要求的数据（比如图片）时，这非常有用。 参考链接下面几篇文章确实讲得很清晰、精准，作为机器学习新手的我都能看懂。 这篇文章的内容也都是从下面这些文章里提取总结出来的，所以如果我上面哪里讲得不清楚、不好的话，建议直接查看下面几篇文章或者直接谷歌搜索相关名词。 https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96 https://www.analyticsvidhya.com/blog/2020/04/feature-scaling-machine-learning-normalization-standardization/ 这篇文章讲得很不错，建议参考。 https://medium.com/greyatom/why-how-and-when-to-scale-your-features-4b30ab09db5e 这篇文章讲得很不错，建议参考。 https://machinelearningmastery.com/normalize-standardize-machine-learning-data-weka/ 这篇文章讲了Weka的使用，但我们并不需要看Weka怎么用，看文章里其它理论部分即可。 https://towardsdatascience.com/understand-data-normalization-in-machine-learning-8ff3062101f0 这篇文章更偏向于实践一些，也很不错。 https://en.wikipedia.org/wiki/Feature_scaling 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>特征缩放</tag>
        <tag>标准化</tag>
        <tag>归一化</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ModuleNotFoundError-No module named jupyter_nbextensions_configurator]]></title>
    <url>%2F2020%2F10%2F24%2FModuleNotFoundError-No-module-named-jupyter-nbextensions-configurator%2F</url>
    <content type="text"><![CDATA[启动Anaconda中的Jupyter Notebook的时候，出现如下错误 12345678910[W 08:37:25.964 NotebookApp] Error loading server extension jupyter_nbextensions_configurator Traceback (most recent call last): File &quot;D:\WorkingSoftware\Anaconda3\lib\site-packages\notebook\notebookapp.py&quot;, line 1615, in init_server_extensions mod = importlib.import_module(modulename) File &quot;D:\WorkingSoftware\Anaconda3\lib\importlib\__init__.py&quot;, line 127, in import_module return _bootstrap._gcd_import(name[level:], package, level) File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1006, in _gcd_import File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 983, in _find_and_load File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 965, in _find_and_load_unlocked ModuleNotFoundError: No module named &apos;jupyter_nbextensions_configurator&apos; 经查询，在Anaconda Prompt某Python环境（我使用的是Anaconda默认的base环境）中运行如下命令 1python -m pip install jupyter_nbextensions_configurator 再次打开Jupyter Notebook时就可以发现问题已经解决。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>python</tag>
        <tag>Jupyter</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode运行Python代码:文件存在但出现FileNotFoundError]]></title>
    <url>%2F2020%2F10%2F23%2FVSCode%E8%BF%90%E8%A1%8CPython%E4%BB%A3%E7%A0%81-%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E4%BD%86%E5%87%BA%E7%8E%B0FileNotFoundError%2F</url>
    <content type="text"><![CDATA[今天使用VSCode运行Python代码，读取当前目录下的CSV文件，代码如下 12import pandas as pddata = pd.read_csv('./train.csv') 我已确认过我的Python代码文件和train.csv在同一个目录，正常情况下这份代码不应该报错的。 但我运行这份代码时，终端内容如下 1234E:\Study\LHYMachineLearning&gt;python -u "e:\Study\LHYMachineLearning\LHYMLCode\hw1_regression\hw1_regression.py"Traceback (most recent call last):………………&lt;此处内容省略&gt;FileNotFoundError: [Errno 2] File b'./train.csv' does not exist: b'./train.csv' 但是如果我修改VSCode终端的所在路径，这样运行就不会报错。 1E:\Study\LHYMachineLearning\LHYMLCode\hw1_regression&gt;python -u hw1_regression.py 所以问题就在于运行命令时VSCode终端的所在路径，这里不再过多解释，上面两条命令的对比十分明显了。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>python</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(hexo)YAMLException can not read a block mapping entry; a multiline key may not be an implicit key]]></title>
    <url>%2F2020%2F10%2F19%2Fhexo-YAMLException-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key%2F</url>
    <content type="text"><![CDATA[运行hexo g后，报错如下： 1YAMLException can not read a block mapping entry; a multiline key may not be an implicit key 根据报错定位（一般会定位到文件的某行某列），检查一下是不是哪里少了空格，我的情况是文章开头的tags后边少了个空格。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1118Birds in Forest]]></title>
    <url>%2F2020%2F10%2F19%2FPAT%E7%94%B2%E7%BA%A71118Birds-in-Forest%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712 题解题目要求 输入 N：正整数，不超过1000，照片的数量 N张照片：每张照片中有K只鸟，鸟的索引从1开始，不超过10000。假设一张图片中出现的所有鸟属于同一棵树 Q：正整数，不超过10000，查询的数量 Q个查询 输出 有多少颗树、多少只鸟 判断Q对鸟是否属于同一颗树 解题思路 用并查集做就行，这道题和PAT甲级1114Family Property很相似，但简单很多。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Problem: PAT Advanced 1118// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712// Tags: 并查集 路径压缩#include &lt;iostream&gt;using namespace std;const int MAXN = 10001;int tree[MAXN];int birdNum[MAXN];int findTree(int x)&#123; return (x == -1 || x == tree[x]) ? x : tree[x] = findTree(tree[x]);&#125;void UNION(int a, int b)&#123; int ta = findTree(a), tb = findTree(b); if (ta != tb) tree[tb] = ta;&#125;int main()&#123; fill(tree, tree + MAXN, -1); int n, q, k, bird1, bird2; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;k); scanf("%d", &amp;bird1); if (tree[bird1] == -1) tree[bird1] = bird1; // 记录该鸟 for (int j = 1; j &lt; k; j++)&#123; scanf("%d", &amp;bird2); if (tree[bird2] == -1) tree[bird2] = bird2; // 记录该鸟 UNION(bird1, bird2); &#125; &#125; int tempTree; for (int i = 0; i &lt; MAXN; i++)&#123; tempTree = findTree(i); if (tempTree != -1)&#123; birdNum[tempTree] += 1; &#125; &#125; int treeCount = 0, birdCount = 0; for (int i = 0; i &lt; MAXN; i++)&#123; if (birdNum[i] &gt; 0)&#123; treeCount += 1; birdCount += birdNum[i]; &#125; &#125; printf("%d %d\n", treeCount, birdCount); scanf("%d", &amp;q); int tree1, tree2; while (q--)&#123; scanf("%d%d", &amp;bird1, &amp;bird2); tree1 = findTree(bird1); tree2 = findTree(bird2); if (tree1 != -1 &amp;&amp; tree2 != -1 &amp;&amp; tree1 == tree2) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>并查集</tag>
        <tag>路径压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1114Family Property]]></title>
    <url>%2F2020%2F10%2F19%2FPAT%E7%94%B2%E7%BA%A71114Family-Property%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288 题解题目要求 给出每个人的家庭成员和属于他的房产信息，请计算每个家庭的成员数、房产平均面积、房产数 输入 N：不超过1000，人的数量 N个有房产的人的信息：id、父亲、母亲、孩子、房产数、房产面积 输出 输出家庭数量 输出每个家庭的最小id、人数、平均房产数、平均房产面积（按平均房产面积降序，然后按最小id升序） 解题思路 题目只给了N个有房产的人的信息，但人并不一定是N个，也不一定是10000个，因此需要标记一个id是否有效（即这个人是否存在） 如果一个人的代表人是-1，则这个人不存在 题目要求输出每个家庭的最小id，这个最小id可以在建立家族关系时保存，即合并两个家族时取较小的id 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// Problem: PAT Advanced 1114// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288// Tags: 并查集 路径压缩#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;struct Family&#123; int id, memberNum = 0; double estateNum = 0, estateArea = 0;&#125;;const int MAXN = 10000;int representative[MAXN];int estateArea[MAXN];int estateNum[MAXN];Family families[MAXN];int findRepresentative(int x)&#123; return (x == -1 || x == representative[x]) ? x : representative[x] = findRepresentative(representative[x]);&#125;void UNION(int a, int b)&#123; int ra = findRepresentative(a), rb = findRepresentative(b); // 取家族中的最小id作为representative if (rb &lt; ra) representative[ra] = rb; else if (ra &lt; rb) representative[rb] = ra;&#125;bool familyCmp(Family&amp; f1, Family&amp; f2)&#123; return f1.estateArea == f2.estateArea ? f1.id &lt; f2.id : f1.estateArea &gt; f2.estateArea;&#125;int main()&#123; // 初始化家族关系 for (int i = 0; i &lt; MAXN; i++)&#123; representative[i] = -1; // representative为-1代表该人不存在 families[i].id = i; // 该人作为代表者时，对应一个家族。该id是为了排序用 &#125; // 建立家族关系 int n, id, fatherID, motherID, k, childID, num, area; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++)&#123; scanf("%d%d%d%d", &amp;id, &amp;fatherID, &amp;motherID, &amp;k); if (representative[id] == -1) representative[id] = id; // 记录：该人存在 if (fatherID != -1)&#123; if (representative[fatherID] == -1) representative[fatherID] = fatherID; // 记录：该人存在 UNION(id, fatherID); &#125; if (motherID != -1)&#123; if (representative[motherID] == -1) representative[motherID] = motherID; // 记录：该人存在 UNION(id, motherID); &#125; for (int j = 0; j &lt; k; j++)&#123; scanf("%d", &amp;childID); if (representative[childID] == -1) representative[childID] = childID; // 记录：该人存在 UNION(id, childID); &#125; scanf("%d%d", &amp;estateNum[id], &amp;estateArea[id]); &#125; // 统计家族数据 int tmp; for (int i = 0; i &lt; MAXN; i++)&#123; tmp = findRepresentative(i); if (tmp != -1)&#123; // 如果这个人存在 families[tmp].memberNum += 1; families[tmp].estateNum += estateNum[i]; families[tmp].estateArea += estateArea[i]; &#125; &#125; vector&lt;Family&gt; v; for(int i = 0; i &lt; MAXN; i++)&#123; if (families[i].memberNum &gt; 0)&#123; families[i].estateArea = families[i].estateArea / families[i].memberNum; families[i].estateNum = families[i].estateNum / families[i].memberNum; v.push_back(families[i]); &#125; &#125; printf("%d\n", v.size()); sort(v.begin(), v.end(), familyCmp); for (int i = 0; i &lt; v.size(); i++)&#123; printf("%04d %d %.3f %.3f\n", v[i].id, v[i].memberNum, v[i].estateNum, v[i].estateArea); &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>并查集</tag>
        <tag>路径压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1107Social Clusters]]></title>
    <url>%2F2020%2F10%2F18%2FPAT%E7%94%B2%E7%BA%A71107Social-Clusters%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744 题解题目要求 输入 N：正整数，不超过1000，人的数量，索引为[1,N] N个人的爱好：爱好的索引为[1,1000] 输出 有几个类（如果两人有共同爱好，则他们属于同一类） 每类的人数 解题思路代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Problem: PAT Advanced 1107// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744// Tags: 并查集 路径压缩#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; father, clusterSize;int likeHobby[1001]; // 保存这一爱好的代表人（任意）int findFather(int x)&#123; return father[x] == x ? x : father[x] = findFather(father[x]); // 路径压缩 // return father[x] == x ? x : findFather(father[x]);&#125;void UNION(int a, int b)&#123; int fa = findFather(a), fb = findFather(b); if (fa != fb) father[fa] = fb;&#125;bool cmp(int&amp; a, int&amp; b)&#123; return a &gt; b;&#125;int main()&#123; int n, k, hobby; scanf("%d", &amp;n); father.resize(n+1); clusterSize.resize(n+1); for (int i = 0; i &lt; father.size(); i++) // 初始化，每人都是一个cluster father[i] = i; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d:", &amp;k); for (int j = 0; j &lt; k; j++)&#123; scanf("%d", &amp;hobby); if (likeHobby[hobby] == 0) likeHobby[hobby] = i; UNION(i, likeHobby[hobby]); // 将i和他的爱好的代表人合并 &#125; &#125; // 统计每个cluster的人数 for (int i = 1; i &lt;= n; i++)&#123; clusterSize[findFather(i)]++; &#125; sort(clusterSize.begin(), clusterSize.end(), cmp); int cnt = 0; while (clusterSize[cnt] &gt; 0)&#123; cnt++; &#125; printf("%d\n", cnt); if (cnt &gt; 0)&#123; printf("%d", clusterSize[0]); for (int i = 1; i &lt; cnt; i++) printf(" %d", clusterSize[i]); &#125; return 0;&#125; 参考链接https://zhuanlan.zhihu.com/p/93647900 https://blog.csdn.net/liuchuo/article/details/52191082 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>并查集</tag>
        <tag>路径压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1098Insertion or Heap Sort]]></title>
    <url>%2F2020%2F10%2F18%2FPAT%E7%94%B2%E7%BA%A71098Insertion-or-Heap-Sort%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805368847187968 题解题目要求 给定一个序列，及用某种排序方法经过几次迭代后的结果，请指出用了什么排序方法。（升序） 输入 N：正整数，不超过100，给定序列中元素的个数 给定序列：N个整数 未完全排序的序列 输出 输出是堆排序还是插入排序 输出该排序算法下一步迭代的结果 解题思路 插入排序特征：序列分成左右两部分，左半部分是从小到大，右半部分是原序列。据此可以检测是否是插入排序，否则是堆排序。 堆排序特征：序列分成左右两部分，左半部分是大顶堆，右半部分是从小到大。 步骤如下： 将序列[1,N]构建成大顶堆（最终得到升序序列） 将堆顶元素(值最大)与末尾元素交换 将序列[1,N-1]构建/调整为大顶堆（重复步骤1、2） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Problem: PAT Advanced 1098// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805368847187968// Tags: 堆 排序 堆排序 插入排序 完全二叉树#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void max_heapify(vector&lt;int&gt;&amp; b, int start, int end)&#123; int father = start, child = father * 2; // 结点从1开始编号 while (child &lt;= end)&#123; if (child + 1 &lt;= end &amp;&amp; b[child] &lt; b[child + 1]) // 取值较大的子结点 child++; if (b[father] &gt;= b[child]) //如果父结点大于子结点，则不需调整，函数结束 break; swap(b[father], b[child]); father = child; child = father * 2; &#125;&#125;int main()&#123; int n; vector&lt;int&gt; a(n+1), b(n+1); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;a[i]); &#125; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;b[i]); &#125; int p = 2; while (p &lt;= n &amp;&amp; b[p] &gt;= b[p - 1]) p++; int index = p; while (p &lt;= n &amp;&amp; a[p] == b[p]) p++; if (p == n+1)&#123; printf("Insertion Sort\n"); int key = b[index]; p = index - 1; while (p &gt; 0 &amp;&amp; b[p] &gt;= b[index]) p--; for (int i = index; i &gt; p + 1; i--) b[i] = b[i-1]; b[p+1] = key; &#125; else&#123; printf("Heap Sort\n"); p = n; while (p &gt; 2 &amp;&amp; b[p] &gt;= b[1]) p--; swap(b[1], b[p]); max_heapify(b, 1, p - 1); &#125; printf("%d", b[1]); for (int i = 2; i &lt;= n; i++) printf(" %d", b[i]); return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/52252172 https://www.cnblogs.com/chengxiao/p/6129630.html https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>排序</tag>
        <tag>堆</tag>
        <tag>堆排序</tag>
        <tag>插入排序</tag>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1051Pop Sequence]]></title>
    <url>%2F2020%2F10%2F17%2FPAT%E7%94%B2%E7%BA%A71051Pop-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944 题解题目要求 背景 给定一个最大容量为M的栈，随机压入和弹出N个数(从1到N)。请判断一个序列是否有可能是该栈弹出的序列 输入 M：不超过1000，栈的最大容量 N：不超过1000，输入序列的长度 K：不超过1000，待检查的序列的数量 K个序列 解题思路模拟入栈和出栈的过程，参考了柳婼的题解。 从1到N入栈：每入栈一个数字，便判断是否出栈，如果可以出栈则出栈（重复此步骤）。如果入栈后，栈大小超过M，则跳出循环停止入栈，结果为NO；如果正确模拟了入栈和出栈，则结果为YES。 代码1234567891011121314151617181920212223242526272829303132333435363738// Problem: PAT Advanced 1051// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944// Tags: 栈#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;int main()&#123; int m, n, k; scanf("%d%d%d", &amp;m, &amp;n, &amp;k); vector&lt;int&gt; v(n + 1); while (k--)&#123; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;v[i]); stack&lt;int&gt; s; int current = 1; for (int i = 1; i &lt;= n; i++)&#123; s.push(i); if (s.size() &gt; m) break; while (!s.empty() &amp;&amp; s.top() == v[current])&#123; s.pop(); current++; &#125; &#125; if (current == n + 1) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/52215337 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1091Acute Stroke]]></title>
    <url>%2F2020%2F10%2F16%2FPAT%E7%94%B2%E7%BA%A71091Acute-Stroke%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072 题目要求 输入 M：正整数 N：正整数 L：正整数，不超过60，一个大脑中slice的数量 T：正整数，阈值，如果一个connected core的体积小于T，则这个core不能被计数 L个slice：每个slice是一个M×N的二值矩阵（1代表stroke，0代表正常）， 输出 输出所有core的体积之和 题解一解题思路三维的图，一个结点和周围六个结点是相邻的，本质上还是求连通分量。 DFS，会段错误（Segmentation Fault），因为递归层数太多，堆栈溢出了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Problem: PAT Advanced 1091// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072// Tags: BFS 图 连通分量 DFS#include &lt;iostream&gt;using namespace std;int m, n, l, t, volume;int brain[65][1300][130];bool visit[65][1300][130];int bias[6][3] = &#123; &#123;-1, 0, 0&#125;, &#123;1, 0, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, 0, -1&#125;, &#123;0, 0, 1&#125;,&#125;;void dfs(int i, int j, int k)&#123; visit[i][j][k] = true; volume++; for (int biasIndex = 0, ii, jj, kk; biasIndex &lt; 6; biasIndex++)&#123; ii = i + bias[biasIndex][0]; jj = j + bias[biasIndex][1]; kk = k + bias[biasIndex][2]; if (!visit[ii][jj][kk] &amp;&amp; brain[ii][jj][kk] == 1)&#123; dfs(ii, jj, kk); &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d", &amp;m, &amp;n, &amp;l, &amp;t); for (int i = 1; i &lt;= l; i++)&#123; for (int j = 1; j &lt;= m; j++)&#123; for (int k = 1; k &lt;= n; k++)&#123; scanf("%d", &amp;brain[i][j][k]); &#125; &#125; &#125; int volumeSum = 0; for (int i = 1; i &lt;= l; i++)&#123; for (int j = 1; j &lt;= m; j++)&#123; for (int k = 1; k &lt;= n; k++)&#123; if (!visit[i][j][k] &amp;&amp; brain[i][j][k] == 1)&#123; volume = 0; dfs(i, j, k); if (volume &gt;= t)&#123; volumeSum += volume; &#125; &#125; &#125; &#125; &#125; printf("%d", volumeSum); return 0;&#125; 题解二解题思路用BFS方法遍历求连通分量 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Problem: PAT Advanced 1091// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072// Tags: BFS 图 连通分量 DFS#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct Node&#123; int i, j, k;&#125;;int m, n, l, t, volume;int brain[65][1300][130];bool visit[65][1300][130];Node bias[6] = &#123; &#123;-1, 0, 0&#125;, &#123;1, 0, 0&#125;, &#123;0, -1, 0&#125;, &#123;0, 1, 0&#125;, &#123;0, 0, -1&#125;, &#123;0, 0, 1&#125;,&#125;;void bfs(Node node)&#123; queue&lt;Node&gt; nodes; nodes.push(node); visit[node.i][node.j][node.k] = true; while (!nodes.empty())&#123; node = nodes.front(); nodes.pop(); volume++; for (int biasIndex = 0, ii, jj, kk; biasIndex &lt; 6; biasIndex++)&#123; ii = node.i + bias[biasIndex].i; jj = node.j + bias[biasIndex].j; kk = node.k + bias[biasIndex].k; if (!visit[ii][jj][kk] &amp;&amp; brain[ii][jj][kk])&#123; nodes.push(&#123;ii, jj, kk&#125;); visit[ii][jj][kk] = true; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d%d%d", &amp;m, &amp;n, &amp;l, &amp;t); for (int i = 1; i &lt;= l; i++)&#123; for (int j = 1; j &lt;= m; j++)&#123; for (int k = 1; k &lt;= n; k++)&#123; scanf("%d", &amp;brain[i][j][k]); &#125; &#125; &#125; int result = 0; for (int i = 1; i &lt;= l; i++)&#123; for (int j = 1; j &lt;= m; j++)&#123; for (int k = 1; k &lt;= n; k++)&#123; if (!visit[i][j][k] &amp;&amp; brain[i][j][k])&#123; volume = 0; bfs(&#123;i, j, k&#125;); if (volume &gt;= t)&#123; result += volume; &#125; &#125; &#125; &#125; &#125; printf("%d", result); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1076Forwards on Weibo]]></title>
    <url>%2F2020%2F10%2F10%2FPAT%E7%94%B2%E7%BA%A71076Forwards-on-Weibo%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736 题解题目要求 给定一个社交网络，请计算某用户的最大转发量（只计算L层间接关注者，假设一条微博，每个人只能转发一次）。 输入 N：正整数，不超过1000，用户的数量，索引为[1,N] L：正整数，不超过6，需要计算的间接关注者的层数 N个用户分别关注了哪些用户：每个用户关注的用户列表 K：正整数，要查询的用户的数量 K个要查询的用户： 输出 解题思路 需要判断层次的BFS：通过类来保存每个结点的层次即可 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Problem: PAT Advanced 1076// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736// Tags: 图 BFS#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int MAXN = 1001;int n, l;bool visit[MAXN];vector&lt;int&gt; followers[MAXN];struct User&#123; int id,layer;&#125;;int bfs(int tempID)&#123; queue&lt;User&gt; users; users.push(&#123;tempID, 0&#125;); visit[tempID] = true; int ret = 0; while (!users.empty())&#123; User u = users.front(); users.pop(); for (auto it = followers[u.id].begin(); it != followers[u.id].end(); it++)&#123; if (!visit[*it] &amp;&amp; u.layer &lt; l)&#123; visit[*it] = true; users.push(&#123;*it, u.layer + 1&#125;); ret++; &#125; &#125; &#125; return ret;&#125;int main()&#123; scanf("%d %d", &amp;n, &amp;l); int tempUser, m; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;m); for(int j = 0; j &lt; m; j++)&#123; scanf("%d", &amp;tempUser); followers[tempUser].push_back(i); &#125; &#125; int k; scanf("%d", &amp;k); while(k--)&#123; scanf("%d", &amp;tempUser); fill(visit, visit + MAXN, false); printf("%d\n", bfs(tempUser)); &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1131Subway Map]]></title>
    <url>%2F2020%2F10%2F05%2FPAT%E7%94%B2%E7%BA%A71131Subway-Map%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432 题解题目要求 给定起点和目标地，找到最快的路 输入 N：正整数，不超过100，地铁线路的数量，索引为[1,n] N条地铁线路：M个站点，站点索引为[0000,9999] 两条地铁线路不会经过同一条边（站到站） 可能存在环，但没有自环 每个站点最多有5条线路经过 K：正整数，不超过10，查询的数量 K对起点和终点 输出 对于每个查询，输出最少经过的站数。如果有多个解，输出换线最少的解。 解题思路 因为存在环，所以在DFS时需要用visit数组表示某个车站是否已经DFS过。其实只要存在可以从多个结点到达某个结点V的情况，就应该设置visit数组标记是否已访问过结点V，如果访问过则不用再访问。 注意输出要按四位输出 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Problem: PAT Advanced 1131// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432// Tags: 图 DFS#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 10000;int line[MAXN][MAXN];bool visited[MAXN];vector&lt;int&gt; nextStop[MAXN];vector&lt;int&gt; tempPath, ansPath;int tempTransfer, ansTransfer;int n, m, k, start, destination;void dfs(int stop,int preLine)&#123; if (visited[stop]) return ; tempPath.push_back(stop); visited[stop] = true; if (stop == destination)&#123; if (tempPath.size() &lt; ansPath.size())&#123; ansPath = tempPath; ansTransfer = tempTransfer; &#125;else if(tempPath.size() == ansPath.size() &amp;&amp; tempTransfer &lt; ansTransfer)&#123; ansPath = tempPath; ansTransfer = tempTransfer; &#125; &#125; else&#123; for (auto it = nextStop[stop].begin(); it != nextStop[stop].end(); it++)&#123; bool transferFlag = (line[stop][*it] != preLine); if (transferFlag) tempTransfer++; dfs(*it, line[stop][*it]); if (transferFlag) tempTransfer--; &#125; &#125; tempPath.pop_back(); visited[stop] = false;&#125;int main()&#123; scanf("%d", &amp;n); int u, v; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d%d", &amp;m, &amp;u); for (int j = 0; j &lt; m - 1; j++)&#123; scanf("%d", &amp;v); line[u][v] = i; line[v][u] = i; nextStop[u].push_back(v); nextStop[v].push_back(u); u = v; &#125; &#125; scanf("%d", &amp;k); while (k--)&#123; scanf("%d%d", &amp;start, &amp;destination); tempTransfer = -1; ansTransfer = MAXN; tempPath.clear(); ansPath.resize(MAXN); dfs(start, 0); printf("%d\n", ansPath.size() - 1); int tempStart = start, preLine = line[ansPath[0]][ansPath[1]]; for(int i = 0; i &lt; ansPath.size() - 1; i++)&#123; if (preLine != line[ansPath[i]][ansPath[i + 1]])&#123; // 要换线 printf("Take Line#%d from %04d to %04d.\n", preLine, tempStart, ansPath[i]); tempStart = ansPath[i]; preLine = line[ansPath[i]][ansPath[i + 1]]; &#125; &#125; printf("Take Line#%d from %04d to %04d.\n", preLine, tempStart, ansPath.back()); &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1130Infix Expression]]></title>
    <url>%2F2020%2F09%2F29%2FPAT%E7%94%B2%E7%BA%A71130Infix-Expression%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312 题解题目要求 给定语法树，请输出其中缀表达式，用圆括号表示优先级，最后一层不要圆括号。 输入 N：正整数，不超过20，语法树中结点的个数 N个结点：结点索引为[1,N]，-1代表空 解题思路就是二叉树的中序遍历而已，DFS就行。 最外层不需要括号，这时手动遍历根结点即可。 妙的是：所有结点中没有作为子结点的结点就是根结点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Problem: PAT Advanced 1130// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312// Tags: 二叉树 DFS#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Node&#123; string data; int left = -1; int right = -1;&#125;;int n;vector&lt;Node&gt; nodes;void dfs(int root)&#123; if (root &lt; 1 || root &gt; n) return; if (nodes[root].left != -1 || nodes[root].right != -1) printf("("); dfs(nodes[root].left); cout &lt;&lt; nodes[root].data; dfs(nodes[root].right); if (nodes[root].left != -1 || nodes[root].right != -1) printf(")");&#125;int main()&#123; scanf("%d", &amp;n); nodes.resize(n+1); vector&lt;bool&gt; visited(n + 1, false); for (int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; nodes[i].data; scanf("%d%d", &amp;nodes[i].left, &amp;nodes[i].right); if (nodes[i].left != -1) visited[nodes[i].left] = true; if (nodes[i].right != -1) visited[nodes[i].right] = true; &#125; int root = 1; while(visited[root]) root++; dfs(nodes[root].left); cout &lt;&lt; nodes[root].data; dfs(nodes[root].right); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>DFS</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1103Integer Factorization]]></title>
    <url>%2F2020%2F09%2F29%2FPAT%E7%94%B2%E7%BA%A71103Integer-Factorization%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224 题解题目要求 正整数N的K-P因数分解就是把N写成K个整数的P次幂之和。 输入 N：不超过400， K：不超过N P：大于1，不超过7 输出 按格式输出K个整数 解题思路DFS+剪枝 思路是按照柳神题解来的，我可真是个菜鸡┭┮﹏┭┮。 题目样例一的输出似乎是错的诶。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Problem: PAT Advanced 1103// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224// Tags: DFS 剪枝#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int n, k, p, maxFacSum = -1;vector&lt;int&gt; v, ans, tempAns;void init() &#123; int temp = 0, index = 1; while (temp &lt;= n) &#123; v.push_back(temp); temp = pow(index, p); index++; &#125;&#125;void dfs(int index, int tempSum,int tempK, int facSum)&#123; if (tempK == k)&#123; if (tempSum == n &amp;&amp; facSum &gt; maxFacSum)&#123; ans = tempAns; maxFacSum = facSum; &#125; return; &#125; while (index &gt;= 1)&#123; if (tempSum + v[index] &lt;= n)&#123; tempAns[tempK] = index; dfs(index, tempSum + v[index], tempK + 1, facSum + index); &#125; if (index == 1) return; index--; &#125;&#125;int main()&#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;p); init(); tempAns.resize(k); dfs(v.size() - 1, 0, 0, 0); if (maxFacSum == -1)&#123; printf("Impossible"); return 0; &#125; printf("%d = %d^%d", n, ans[0], p); for(int i = 1; i &lt; ans.size(); i++) printf(" + %d^%d", ans[i], p); return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/52493390 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>PAT</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1034Head of a Gang]]></title>
    <url>%2F2020%2F09%2F26%2FPAT%E7%94%B2%E7%BA%A71034Head-of-a-Gang%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805456881434624 题解题目要求 背景 A和B打电话，则A和B有关系，A和B关系的权重为他们间通话的总时长。 一个帮派由2个人以上组成，他们关系的总权重超过K。 帮派中和别人关系的总权重最大的人就是头目。现给出多个通话，请找出头目。 输入 N：正整数，不超过1000，通话的数量 K：正整数，不超过1000，权重阈值 N个通话 输出 帮派的数量 每个帮派的头目和成员数量（按头目名称的字典序输出） 解题思路 通过map保存名字和索引的关系。 一个帮派就是一个连通分量 通过DFS求有多少个连通分量，通过成员数量和总权重进行筛选，最终输出其结点数和头目 题目有个地方很奇怪？要把题目理解对了 In each gang, the one with maximum total weight is the head.这句话指出在每个帮派中，总权重最大的人就是头目。 我起初理解为应在这个帮派之内求每个人的权重（如果A属于某帮派而B不属于这个帮派，那计算A的总权重时，则不应该将A和B的权重包含在内）。但题目的意思是在所有人范围内计算总权重，即使帮派里不包含B，计算A的总权重时也要将A和B的权重计入。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Problem: PAT Advanced 1034// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805456881434624// Tags: 图 连通分量 map DFS#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; sti;map&lt;int, string&gt; its;map&lt;string, int&gt; ans;const int MAXN = 2001; // 最多1000个通话，最多就有2000个人int id = 1;int e[MAXN][MAXN];int weight[MAXN];bool visited[MAXN];void dfs(int u, int&amp; head, int&amp; totalWeight, int&amp; memberCount)&#123; visited[u] = true; memberCount += 1; if (weight[u] &gt; weight[head])&#123; head = u; &#125; for (int v = 1; v &lt; id; v++)&#123; if (e[u][v] &gt; 0)&#123; totalWeight += e[u][v]; // 在所有人范围内计算总权重 e[u][v] = e[v][u] = 0; if (!visited[v]) dfs(v, head, totalWeight, memberCount); &#125; &#125;&#125;int main()&#123; int n, k; scanf("%d %d", &amp;n, &amp;k); string s1, s2; int t; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; s1 &gt;&gt; s2; scanf("%d", &amp;t); if (sti[s1] == 0)&#123; sti[s1] = id; its[id] = s1; id++; &#125; if (sti[s2] == 0)&#123; sti[s2] = id; its[id] = s2; id++; &#125; e[sti[s1]][sti[s2]] += t; e[sti[s2]][sti[s1]] += t; weight[sti[s1]] += t; weight[sti[s2]] += t; &#125; for (int i = 1; i &lt; id; i++)&#123; if (!visited[i])&#123; int head = i, totalWeight = 0, memberCount = 0; dfs(i, head, totalWeight, memberCount); if (memberCount &gt; 2 &amp;&amp; totalWeight &gt; k) ans[its[head]] = memberCount; &#125; &#125; printf("%d\n", ans.size()); for (auto it = ans.begin(); it != ans.end(); it++) printf("%s %d\n", it-&gt;first.c_str(), it-&gt;second); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1021Deepest Root]]></title>
    <url>%2F2020%2F09%2F25%2FPAT%E7%94%B2%E7%BA%A71021Deepest-Root%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856 题解题目要求 输入 N：正整数，不超过10000，结点的数量，索引为[1,N] N-1条边 输出 输出深度最大的根结点，如果不唯一，则按升序输出。如果这个图不是树，则输出图中连通分量的数量 方法一解题思路 没有回路的无向图是连通的当且仅当它是树 求该图的连通分量数，如果连通分量数大于1，则输出连通分量数，程序终止； 对于每一个结点，将其作为根结点，通过dfs求其高度depth，将depth与全局最大高度maxDepth比较，并更新全局最大高度及其对应根结点； 输出根结点 代码如果用邻接矩阵，则第3个点会超时，用邻接表则不超时。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Problem: PAT Advanced 1021// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856// Tags: 树 图 连通分量 连通图 DFS#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 10001;int n, tempDepth = 0, depth = 0, maxDepth = 0;vector&lt;int&gt; deepestRoot;vector&lt;vector&lt;int&gt;&gt; v;bool visited[MAXN];void dfs(int u)&#123; visited[u] = true; tempDepth += 1; if (depth &lt; tempDepth)&#123; depth = tempDepth; &#125; for(int i = 0; i &lt; v[u].size(); i++)&#123; if (!visited[v[u][i]])&#123; dfs(v[u][i]); &#125; &#125; tempDepth -= 1;&#125;int main()&#123; scanf("%d", &amp;n); v.resize(n+1); int v1, v2; for (int i = 0; i &lt; n - 1; i++)&#123; scanf("%d %d", &amp;v1, &amp;v2); v[v1].push_back(v2); v[v2].push_back(v1); &#125; int num = 0; for (int i = 1; i &lt;= n; i++)&#123; if (!visited[i])&#123; dfs(i); num++; &#125; &#125; if (num &gt; 1)&#123; printf("Error: %d components", num); return 0; &#125; else if (num == 1)&#123; for (int root = 1; root &lt;= n; root++)&#123; fill(visited + 1, visited + 1 + n, false); depth = 0; dfs(root); if (maxDepth &lt; depth)&#123; maxDepth = depth; deepestRoot.clear(); deepestRoot.push_back(root); &#125; else if (maxDepth == depth)&#123; deepestRoot.push_back(root); &#125; &#125; for (int i = 0; i &lt; deepestRoot.size(); i++)&#123; printf("%d\n", deepestRoot[i]); &#125; &#125; return 0;&#125; 方法二思路 第一次DFS：判断连通分量数量，如果超过1，则直接输出，程序结束 同时保存深度最大的那些结点到数组s中 第二次DFS：从s中的任一个结点出发进行DFS，此时深度最大的结点与s的并集就是结果 这个思路很妙，并且速度很快：这是无向图，是双向的，所以正序倒序各求一遍合起来就是结果。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Problem: PAT Advanced 1021// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856// Tags: 树 图 连通分量 连通图 DFS set#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int MAXN = 10001;int n, depth = 0, maxDepth = 0;vector&lt;int&gt; temp;set&lt;int&gt; result;vector&lt;vector&lt;int&gt;&gt; v;bool visited[MAXN];void dfs(int u)&#123; visited[u] = true; depth += 1; if (maxDepth &lt; depth)&#123; maxDepth = depth; temp.clear(); temp.push_back(u); &#125; else if (maxDepth == depth)&#123; temp.push_back(u); &#125; for(int i = 0; i &lt; v[u].size(); i++)&#123; if (!visited[v[u][i]])&#123; dfs(v[u][i]); &#125; &#125; depth -= 1;&#125;int main()&#123; scanf("%d", &amp;n); v.resize(n+1); int v1, v2; for (int i = 0; i &lt; n - 1; i++)&#123; scanf("%d %d", &amp;v1, &amp;v2); v[v1].push_back(v2); v[v2].push_back(v1); &#125; int num = 0; for (int i = 1; i &lt;= n; i++)&#123; if (!visited[i])&#123; dfs(i); num++; &#125; &#125; if (num &gt; 1)&#123; printf("Error: %d components", num); return 0; &#125; else if (num == 1)&#123; for (int i = 0; i &lt; temp.size(); i++) result.insert(temp[i]); fill(visited + 1, visited + 1 + n, false); int u = temp[0]; temp.clear(); dfs(u); for (int i = 0; i &lt; temp.size(); i++) result.insert(temp[i]); for (auto it = result.begin(); it != result.end(); it++) printf("%d\n", *it); &#125; return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/52294178 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>连通图</tag>
        <tag>连通分量</tag>
        <tag>树</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1013Battle Over Cities]]></title>
    <url>%2F2020%2F09%2F25%2FPAT%E7%94%B2%E7%BA%A71013Battle-Over-Cities%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840 题解题目要求 在战争中，如果一个城市被敌方占领，那通向该城市或者从该城市出发的高速公路都会被关闭，需要修复其它公路保证所有的城市互相连通。（一个图去掉一个顶点，请补充边使该图变为连通图，即所有顶点都被经过） 输入 N：小于1000，城市总数，索引为[1,N] M：剩余高速公路的数量 K：需要被检查的城市的数量 M条高速公路 K个需要被检查的城市 输出 对于每个需要检查的城市，如果它被敌方占领，请输出需要修复几条高速公路。 解题思路知识概念 连通/通路 如果从顶点x出发，可以到达y，那x和y连通，这条路径就是一个通路。 连通图 如果图G中每两点间皆连通，则G是连通图。 最大连通子图 如果在这个子图中在添加一个顶点则该子图不再是连通图，则该子图就是最大连通子图。 连通分量 无向图G的一个最大连通子图称为G的一个连通分量或连通分支。 思路 这道题就是求去除某个结点后图中的连通分量数 添加路线的最小数量，就是去除该顶点后图中的连通分量数-1。 因为当a个互相分立的连通分量需要变为连通图的时候，只需要添加a-1个路线，就能让他们相连。 一个城市被占领，不用删除和其关联的所有边，只要将该顶点设置为已标记即可，这样DFS时就会忽略该顶点。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445// Problem: PAT Advanced 1013// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840// Tags: DFS 图 连通图 连通分量#include &lt;iostream&gt;using namespace std;const int MAXN = 1001;int n, m, k;bool e[MAXN][MAXN];bool visited[MAXN];void dfs(int u)&#123; visited[u] = true; for (int v = 1; v &lt;= n; v++)&#123; if (!visited[v] &amp;&amp; e[u][v])&#123; dfs(v); &#125; &#125;&#125;int main()&#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); int v1, v2; for (int i = 0; i &lt; m; i++)&#123; scanf("%d %d", &amp;v1, &amp;v2); e[v1][v2] = e[v2][v1] = true; &#125; int occupied; while (k--)&#123; fill(visited + 1, visited + 1 + n, false); scanf("%d", &amp;occupied); visited[occupied] = true; int num = 0; for (int i = 1; i &lt;= n; i++)&#123; if (!visited[i])&#123; dfs(i); num += 1; &#125; &#125; printf("%d\n", num - 1); &#125; return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/52293756 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>连通图</tag>
        <tag>连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1111Online Map]]></title>
    <url>%2F2020%2F09%2F24%2FPAT%E7%94%B2%E7%BA%A71111Online-Map%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856 题解题目要求 输入 N：取值范围是[2,500]，结点数量，索引为[0,N-1] M：正整数，边的数量 M条边 起点和终点 输出 最短路径 如果最短路径不唯一，输出其中最快的那条路径 最快路径 如果最快路径不唯一，输出其中经过结点最少的那条路径 解题思路这道题是先后做两次dijkstra+DFS，即可求解。 解法是dijkstra+DFS的题目还有： PAT甲级1087All Roads Lead to Rome PAT甲级1030Travel Plan PAT甲级1018Public Bike Management 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// Problem: PAT Advanced 1111// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856// Tags: 图 最短路 单源最短路 dijkstra BFS DFS#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m, start, destination;const int INF = 99999999;const int MAXN = 500;bool visited[MAXN];int dis[MAXN][MAXN];int timee[MAXN][MAXN];int minDis[MAXN];int minTime[MAXN];vector&lt;int&gt; disPath, timePath, tempPath, disPre[MAXN], timePre[MAXN];int disPathMinTime = INF, timePathMinNodeCount = INF;int calcPathTime(vector&lt;int&gt;&amp; vec)&#123; int sum = 0; for (int i = vec.size() - 1; i &gt;= 1; i--)&#123; sum += timee[vec[i]][vec[i - 1]]; &#125; return sum;&#125;void disDFS(int v)&#123; tempPath.push_back(v); if (v == start)&#123; int pathTime = calcPathTime(tempPath); if (disPathMinTime &gt; pathTime)&#123; disPath = tempPath; disPathMinTime = pathTime; &#125; tempPath.pop_back(); return; &#125; for (int i = 0; i &lt; disPre[v].size(); i++) disDFS(disPre[v][i]); tempPath.pop_back();&#125;void timeDFS(int v)&#123; tempPath.push_back(v); if (v == start)&#123; if (timePathMinNodeCount &gt; tempPath.size())&#123; timePath = tempPath; timePathMinNodeCount = tempPath.size(); &#125; tempPath.pop_back(); return; &#125; for (int i = 0; i &lt; timePre[v].size(); i++) timeDFS(timePre[v][i]); tempPath.pop_back();&#125;int main()&#123; fill(dis[0], dis[0] + MAXN * MAXN, INF); fill(timee[0], timee[0] + MAXN * MAXN, INF); fill(minDis, minDis + MAXN, INF); fill(minTime, minTime + MAXN, INF); scanf("%d %d", &amp;n, &amp;m); int v1, v2, oneWay, l, t; for (int i = 0; i &lt; m; i++)&#123; scanf("%d %d %d %d %d", &amp;v1, &amp;v2, &amp;oneWay, &amp;l, &amp;t); if (oneWay == 1)&#123; dis[v1][v2] = l; timee[v1][v2] = t; &#125; else if (oneWay == 0)&#123; dis[v1][v2] = dis[v2][v1] = l; timee[v1][v2] = timee[v2][v1] = t; &#125; &#125; scanf("%d %d", &amp;start, &amp;destination); minDis[start] = 0; for (int i = 0; i &lt; n; i++)&#123; int u = -1, tempMin = INF; for (int j = 0; j &lt; n; j++)&#123; if (!visited[j] &amp;&amp; tempMin &gt; minDis[j])&#123; tempMin = minDis[j]; u = j; &#125; &#125; if (u == -1) break; visited[u] = true; for (int v = 0; v &lt;n; v++)&#123; if (!visited[v] &amp;&amp; dis[u][v] != INF)&#123; if (minDis[v] &gt; minDis[u] + dis[u][v])&#123; minDis[v] = minDis[u] + dis[u][v]; disPre[v].clear(); disPre[v].push_back(u); &#125; else if (minDis[v] == minDis[u] + dis[u][v])&#123; disPre[v].push_back(u); &#125; &#125; &#125; &#125; disDFS(destination); fill(visited, visited + MAXN, false); minTime[start] = 0; for (int i = 0; i &lt; n; i++)&#123; int u = -1, tempMin = INF; for (int j = 0; j &lt; n; j++)&#123; if (!visited[j] &amp;&amp; tempMin &gt; minTime[j])&#123; u = j; tempMin = minTime[j]; &#125; &#125; if (u == -1) break; visited[u] = true; for (int v = 0; v &lt; n; v++)&#123; if (!visited[v] &amp;&amp; timee[u][v] != INF)&#123; if (minTime[v] &gt; minTime[u] + timee[u][v])&#123; minTime[v] = minTime[u] + timee[u][v]; timePre[v].clear(); timePre[v].push_back(u); &#125; else if (minTime[v] == minTime[u] + timee[u][v])&#123; timePre[v].push_back(u); &#125; &#125; &#125; &#125; tempPath.clear(); timeDFS(destination); bool isIdentical = true; if (disPath.size() == timePath.size())&#123; for (int i = 0; i &lt; disPath.size(); i++)&#123; if (disPath[i] != timePath[i])&#123; isIdentical = false; break; &#125; &#125; &#125; else&#123; isIdentical = false; &#125; if (isIdentical)&#123; printf("Distance = %d; Time = %d: %d", minDis[destination], minTime[destination], start); for (int i = disPath.size() - 2; i &gt;= 0; i--)&#123; printf(" -&gt; %d", disPath[i]); &#125; &#125; else&#123; printf("Distance = %d: %d", minDis[destination], start); for (int i = disPath.size() - 2; i &gt;= 0; i--)&#123; printf(" -&gt; %d", disPath[i]); &#125; printf("\nTime = %d: %d", minTime[destination], start); for (int i = timePath.size() - 2; i &gt;= 0; i--)&#123; printf(" -&gt; %d", timePath[i]); &#125; &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>最短路</tag>
        <tag>单源最短路</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1087All Roads Lead to Rome]]></title>
    <url>%2F2020%2F09%2F21%2FPAT%E7%94%B2%E7%BA%A71087All-Roads-Lead-to-Rome%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984 题解题目要求找到成本最低、快乐值总和最高的路径。优先找成本最低的，然后再找快乐值最高的，然后再找平均快乐值最高的。 输入 N：正整数，[2,200]，城市的数量 K：正整数，路径的数量 起始城市的名称 N-1个城市的名字及其快乐值 K条路径 输出 成本最低的路径的数量 成本 快乐值总和 平均快乐值（只输出整数部分） 路径 解题思路这是一道dijkstra+DFS的题，和PAT甲级1018Public Bike Management很类似，所以详细思路不再说明。 用两个map将城市的名字和索引相互对应 用dijkstra算法求出起始城市到所有城市的最短距离，并记录每个城市的前驱城市 使用DFS求出路径（并计算、比较快乐值总和与平均值） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// Problem: PAT Advanced 1087// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984// Tags: 图 最短路 单源最短路 dijkstra BFS DFS#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int n, k;string startCity;map&lt;string, int&gt; sti;map&lt;int, string&gt; its;const int INF = 9999999;const int MAXN = 201;int dis[MAXN][MAXN];int minDis[MAXN];bool visited[MAXN];int happiness[MAXN];vector&lt;int&gt; pre[MAXN];vector&lt;int&gt; path;vector&lt;int&gt; tempPath;int ansHappinessSum = -INF, ansPathNum = 0;double ansHappinessAve = -INF;void dfs(int v)&#123; tempPath.push_back(v); if (v == 1)&#123; // 到达起点 int happinessSum = 0; for (auto iter = tempPath.begin(); iter != tempPath.end(); iter++) happinessSum += happiness[*iter]; double happinessAve = happinessSum * 1.0 / (tempPath.size() - 1); if (ansHappinessSum &lt; happinessSum)&#123; path = tempPath; ansHappinessSum = happinessSum; ansHappinessAve = happinessAve; &#125; else if (ansHappinessSum == happinessSum &amp;&amp; ansHappinessAve &lt; happinessAve)&#123; path = tempPath; ansHappinessAve = happinessAve; &#125; ansPathNum++; tempPath.pop_back(); return ; &#125; for (int i = 0; i &lt; pre[v].size(); i++) dfs(pre[v][i]); tempPath.pop_back();&#125;int main()&#123; fill(dis[0], dis[0] + MAXN * MAXN, INF); fill(minDis, minDis + MAXN, INF); scanf("%d %d", &amp;n, &amp;k); cin &gt;&gt; startCity; sti[startCity] = 1; its[1] = startCity; string s; int h; for (int i = 2; i &lt;= n; i++)&#123; cin &gt;&gt; s; sti[s] = i; its[i] = s; scanf("%d", &amp;h); happiness[i] = h; &#125; string t; for (int i = 0; i &lt; k; i++)&#123; cin &gt;&gt; s &gt;&gt; t; scanf("%d", &amp;dis[sti[s]][sti[t]]); dis[sti[t]][sti[s]] = dis[sti[s]][sti[t]]; &#125; minDis[1] = 0; for (int i = 1; i &lt;= n; i++)&#123; int tempMin = INF, u = -1; for (int j = 1; j &lt;= n; j++)&#123; if (!visited[j] &amp;&amp; tempMin &gt; minDis[j])&#123; tempMin = minDis[j]; u = j; &#125; &#125; if (u == -1) break; visited[u] = true; for (int v = 1; v &lt;= n; v++)&#123; if (!visited[v] &amp;&amp; dis[u][v] != INF)&#123; if (minDis[v] &gt; minDis[u] + dis[u][v])&#123; minDis[v] = minDis[u] + dis[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if (minDis[v] == minDis[u] + dis[u][v])&#123; pre[v].push_back(u); &#125; &#125; &#125; &#125; dfs(sti["ROM"]); printf("%d %d %d %d\n%s", ansPathNum, minDis[sti["ROM"]], ansHappinessSum, int(ansHappinessAve), startCity.c_str()); for (int i = path.size() - 2; i &gt;= 0; i--) printf("-&gt;%s", its[path[i]].c_str()); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>最短路</tag>
        <tag>单源最短路</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1072Gas Station]]></title>
    <url>%2F2020%2F09%2F20%2FPAT%E7%94%B2%E7%BA%A71072Gas-Station%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072 题解题目要求加油站要离各个住宅的最小距离应该尽可能地大，但也要保证住宅在加油区的服务距离内。 现在给出几个加油站的候选位置，请你找出最好的一个（距离各住宅的最小距离最大）。如果有多个解，则选择离住宅平均距离最短的那个。如果还是有多个解，则选择索引较小的那个。 输入 N：正整数，不超过1000，住宅的数量，住宅索引为[1,N] M：正整数，不超过10，加油站候选位置的数量，索引为[G1,GM] K：正整数，不超过10000，边的数量 Ds：正整数，加油站的最大服务距离 K条边 输出 加油站候选位置的索引 加油站与住宅的最短距离和平均距离 数字必须精确到小数点后一位。 解不存在则输出No Solution 解题思路除了输入输出需要懂点心思，这道题就是一道简单的单源最短路题目了。 这里有两类结点：住宅和加油站，可以对输入进行处理，规定索引[1,n]是住宅，索引[n+1,n+m]是加油站 然后对每个加油站运行dijkstra算法，在不超过加油站服务距离的前提下求解 注意是优先求距离各住宅的最小距离最大的解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// Problem: PAT Advanced 1072// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072// Tags: 图 最短路 单源最短路 dijkstra BFS#include &lt;iostream&gt;#include &lt;climits&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;const int INF = INT_MAX;const int MAXN = 1011; // [1,n]是住宅，[n+1,n+m]是加油站int n, m, k, ds;bool visited[MAXN]; int dis[MAXN][MAXN];int minDis[MAXN];int main()&#123; fill(dis[0], dis[0] + MAXN * MAXN, INF); for (int i = 0; i &lt; MAXN; i++) dis[i][i] = 0; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;k, &amp;ds); string aStr, bStr; int a, b, c; for (int i = 0; i &lt; k; i++)&#123; cin &gt;&gt; aStr &gt;&gt; bStr; a = (aStr[0] == 'G') ? stoi(aStr.substr(1)) + n : stoi(aStr); b = (bStr[0] == 'G') ? stoi(bStr.substr(1)) + n : stoi(bStr); scanf("%d", &amp;c); if (c &lt; dis[a][b]) // 处理输入的特殊情况 dis[a][b] = dis[b][a] = c; &#125; // 对每个加油站运行dijkstra算法 int ansStation = -1; double ansDis = -INF, ansAverDis = INF; for (int station = n + 1; station &lt;= n + m; station++)&#123; double tempMin = INF, averDis = 0; fill(minDis, minDis + MAXN, INF); fill(visited, visited + MAXN, false); // 运行dijkstra算法，求该加油站到其它加油站和住宅的最短路径 minDis[station] = 0; for (int i = 1; i &lt;= n + m; i++)&#123; int tempMin = INF, u = -1; for (int j = 1; j &lt;= n + m; j++)&#123; if (!visited[j] &amp;&amp; minDis[j] &lt; tempMin)&#123; u = j; tempMin = minDis[j]; &#125; &#125; if (u == -1) break; visited[u] = true; for (int v = 1; v &lt;= n + m; v++)&#123; if (!visited[v] &amp;&amp; dis[u][v] != INF)&#123; if (minDis[v] &gt; minDis[u] + dis[u][v])&#123; minDis[v] = minDis[u] + dis[u][v]; &#125; &#125; &#125; &#125; // 更新最终结果 for (int i = 1; i &lt;= n; i++)&#123; if (minDis[i] &gt; ds)&#123; tempMin = -1; break; &#125; if (minDis[i] &lt; tempMin)&#123; tempMin = minDis[i]; &#125; averDis += minDis[i]; &#125; if (tempMin == -1) continue; averDis /= n; if (tempMin &gt; ansDis)&#123; ansDis = tempMin; ansStation = station; ansAverDis = averDis; &#125; else if (tempMin == ansDis &amp;&amp; averDis &lt; ansAverDis)&#123; ansStation = station; ansAverDis = averDis; &#125; &#125; if (ansStation == -1) printf("No Solution"); else printf("G%d\n%.1f %.1f", ansStation - n, ansDis, ansAverDis); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>最短路</tag>
        <tag>单源最短路</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1030Travel Plan]]></title>
    <url>%2F2020%2F09%2F18%2FPAT%E7%94%B2%E7%BA%A71030Travel-Plan%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392 题解题目要求 输入 N：正整数，不超过500，结点的数量，索引为[0,N-1] M：正整数，边的数量 S：起点索引 D：终点索引 M条边 输出 最短路径经过的结点 总距离 总成本 解题思路该题在普通最短路径题目基础上补充了2点 我是先做了PAT甲级1018Public Bike Management，这两题很相似，1018更难，这题更简单。 输出最短路径经过的结点 因为最终的最短路径只有一条，所以保存最短路径中每个结点的前一个结点，最终从D往回遍历即可 优先考虑距离，再考虑成本 通过if语句实现 代码最后生成path时我是递归存入vector，其实也可以直接迭代生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// Problem: PAT Advanced 1030// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392// Tags: 最短路 图 dijkstra 单源最短路 BFS#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 500;const int INF = 9999999;int n, m, s, d;bool visited[MAXN];int minDis[MAXN];int minCost[MAXN];int dis[MAXN][MAXN];int cost[MAXN][MAXN];int pre[MAXN];vector&lt;int&gt; path;void getPath(int v)&#123; path.push_back(v); if (v != s)&#123; getPath(pre[v]); &#125;&#125;int main()&#123; fill(minDis, minDis + MAXN, INF); fill(minCost, minCost + MAXN, INF); fill(dis[0], dis[0] + MAXN * MAXN, INF); fill(cost[0], cost[0] + MAXN * MAXN, INF); scanf("%d %d %d %d", &amp;n, &amp;m, &amp;s, &amp;d); int a, b; for (int i = 0; i &lt; m; i++)&#123; scanf("%d %d", &amp;a, &amp;b); scanf("%d %d", &amp;dis[a][b], &amp;cost[a][b]); dis[b][a] = dis[a][b]; cost[b][a] = cost[a][b]; &#125; minDis[s] = 0; minCost[s] = 0; for (int i = 0; i &lt; n; i++)&#123; int u = -1, minD = INF; for (int j = 0; j &lt; n; j++)&#123; if (!visited[j] &amp;&amp; minDis[j] &lt; minD)&#123; minD = minDis[j]; u = j; &#125; &#125; if (u == -1) break; visited[u] = true; for (int v = 0; v &lt; n; v++)&#123; if (!visited[v] &amp;&amp; dis[u][v] != INF)&#123; if (minDis[u] + dis[u][v] &lt; minDis[v])&#123; minDis[v] = minDis[u] + dis[u][v]; minCost[v] = minCost[u] + cost[u][v]; pre[v] = u; &#125; else if (minDis[u] + dis[u][v] == minDis[v] &amp;&amp; minCost[u] + cost[u][v] &lt; minCost[v])&#123; minCost[v] = minCost[u] + cost[u][v]; pre[v] = u; &#125; &#125; &#125; &#125; getPath(d); for (auto iter = path.rbegin(); iter != path.rend(); iter++) printf("%d ", *iter); printf("%d %d", minDis[d], minCost[d]); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>最短路</tag>
        <tag>单源最短路</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1018Public Bike Management]]></title>
    <url>%2F2020%2F09%2F18%2FPAT%E7%94%B2%E7%BA%A71018Public-Bike-Management%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024 题解题目要求 如果有多个最短路径，则选择PBMC送出自行车的数量最少的路径 如果还是有多条最短路径，那么就选择从车站带回的自行车数目最少的（带回的时候是不调整路过的车站的） PBMC携带或者从经过的车站收集一定数量的自行车前往某车站，并使路过的车站都达到半满。 输入 Cmax：不超过100，偶数，每个站点中最多有多少辆自行车 N：不超过500，站点的数量，站点索引为[1,N]，PBMC索引为0 Sp：有问题的站点 M：边的数量 N个站点中自行车的数量 M条边 输出 PBMC要送多少辆自行车 路径 要送多少辆自行车到PBMC 解题思路PAT甲级1030Travel Plan和这题很类似，但比这题简单，大概是比这题少了一个DFS。 dijkstra 除了要求出PBMC到所有结点的最短路径长度，还要在算法过程中记录所有最短路径上每个结点的前一个结点，进而进行下一步的DFS。 DFS 运行dijkstra算法后，已经记录了所有最短路径上每个结点的前一个结点（可以有多个），然后从结点sp开始DFS，相当于从sp走到PBMC。 DFS过程中要记录当前路径 求路径上多余或缺少的自行车的数量 DFS过程中，如果当前结点是PBMC，则从PBMC走到sp，求多余或缺少的自行车的数量，再和全局最小值比较、更新 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// Problem: PAT Advanced 1018// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024// Tags: 最短路 dijkstra BFS DFS 单源最短路 图#include &lt;iostream&gt;#include &lt;climits&gt;#include &lt;vector&gt;using namespace std;const int INF = INT_MAX;const int MAXN = 505;int cmax, n, sp, m;int minStationNeed = INF, minStationExtra = INF; // PBMC最少需要送出多少辆车，最少要送多少辆车到PBMCint e[MAXN][MAXN]; // 车站间的距离int dis[MAXN]; // PBMC到各车站的最短路径的长度int extraBikeNum[MAXN]; // 各车站中有多少辆自行车是多余的bool visited[MAXN]; // 是否已求出PBMC到各车站的最短路vector&lt;int&gt; pre[MAXN]; // 在保证路径最短的前提下，最短路径中每个车站的前一个车站vector&lt;int&gt; path;vector&lt;int&gt; tempPath;void dfs(int v)&#123; // 遍历当前结点 tempPath.push_back(v); if (v == 0)&#123; // 此时已形成一条最短路径的逆序，存储在tempPath中 int stationNeed = 0, stationExtra = 0; for (int i = tempPath.size() - 1; i &gt;= 0; i--)&#123; int u = tempPath[i]; if (extraBikeNum[u] &gt; 0)&#123; // 当前站点中自行车数量超过容量的一半，则可以送给后面的车站或者送回PBMC stationExtra += extraBikeNum[u]; &#125; else if (extraBikeNum[u] &lt; 0)&#123; // 当前站点中自行车数量少于容量的一半 if (stationExtra + extraBikeNum[u] &gt;= 0)&#123; // 前边车站多出来的自行车足够使当前车站半满 stationExtra += extraBikeNum[u]; &#125; else&#123; stationNeed -= (stationExtra + extraBikeNum[u]); stationExtra = 0; &#125; &#125; &#125; if (stationNeed &lt; minStationNeed)&#123; path = tempPath; minStationNeed = stationNeed; minStationExtra = stationExtra; &#125; else if (stationNeed == minStationNeed &amp;&amp; stationExtra &lt; minStationExtra)&#123; path = tempPath; minStationExtra = stationExtra; &#125; &#125; // DFS for (int i= 0; i &lt; pre[v].size(); i++) dfs(pre[v][i]); // 回溯 tempPath.pop_back();&#125;int main()&#123; // 初始化 fill(e[0], e[0] + MAXN * MAXN, INF); fill(dis, dis + MAXN, INF); // 获取输入 scanf("%d %d %d %d", &amp;cmax, &amp;n, &amp;sp, &amp;m); for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;extraBikeNum[i]); extraBikeNum[i] = extraBikeNum[i] - cmax / 2; &#125; int a, b, c; for (int i = 0; i &lt; m; i++)&#123; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); e[a][b] = e[b][a] = c; &#125; dis[0] = 0; // PBMC为起点 for (int i = 0; i &lt;= n; i++)&#123; int u = -1, minDis = INF; for (int j = 0; j &lt;= n; j++)&#123; if (!visited[j] &amp;&amp; dis[j] &lt; minDis)&#123; minDis = dis[j]; u = j; &#125; &#125; if (u == -1) break; visited[u] = true; for (int v = 0; v &lt;= n; v++)&#123; if (!visited[v] &amp;&amp; e[u][v] != INF)&#123; if (dis[u] + e[u][v] &lt; dis[v])&#123; dis[v] = dis[u] + e[u][v]; pre[v].clear(); // 新的最短路径，所以要clear pre[v].push_back(u); // u是v的最短路径中v的前一个车站 &#125; else if (dis[u] + e[u][v] == dis[v])&#123; pre[v].push_back(u); // u是v的最短路径中v的前一个车站 &#125; &#125; &#125; &#125; dfs(sp); printf("%d 0", minStationNeed); for (int i = path.size() - 2; i &gt;= 0; i--) printf("-&gt;%d", path[i]); printf(" %d", minStationExtra); return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/52316405 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>最短路</tag>
        <tag>单源最短路</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1003Emergency]]></title>
    <url>%2F2020%2F09%2F17%2FPAT%E7%94%B2%E7%BA%A71003Emergency%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376 题解题目要求 有几个城市，每个城市中有多个救援队，城市间由公路相连，公路的长度不一 输入 N：正整数，不超过500，城市的数量，城市索引为[0,N-1] M：公路的数量 c1：你现在所在的城市 c2：你需要去的城市 各城市中救援队数量：N个整数 各条公路连接的两个城市其该公路的长度：M行 保证c1到c2至少有一条路径 输出 c1到c2的最短路径的数量 在保证路径最短的前提下，最多可以聚集多少只救援队 解题思路 dijkstra算法 特点 适用于边权为正的情况 单源最短路（Single-Source Shortest Paths，SSSP），求单个源点到所有结点的最短路 同时适用于有向图和无向图 伪代码 n个结点 1234567891011bool visited[n]; // 标记：是否找到源点s到某点的最短路径int dis[n]; // 记录源点s到某点的最短路径的长度int w[n][n]; // 结点间的距离visited数组置false;dis数组置无穷大，dis[s]置0;循环n次&#123; 寻找未被标记的、距离结点s最近的结点u; 如果找到u则将其标记(visited[u] = true),否则结束循环; 如果存在边&lt;u,v&gt;,则更新dis[v] = min(dis[v], dis[u] + w[u][v]); // 贪心&#125; 其它 c1到c2的最短路径的数量pathNum 如果dis[v] &lt; dis[u] + w[u][v]，则pathNum[v] = path[u] u到v只有一条边，所以源点到u和v的路径的数量相等 如果dis[v] == dis[u] + w[u][v]，则pathNum[v] = path[u] + path[v] 在距离相等的情况下，除了经过u，还可以从其他结点到达v 在保证路径最短的前提下，最多可以聚集多少只救援队 如果dis[v] &lt; dis[u] + w[u][v]，则teamGatherNum[v] = teamGatherNum[u] + teamNum[v] 如果dis[v] == dis[u] + w[u][v]，则teamGatherNum[v] = min(teamGatherNum[v], teamGatherNum[u] + teamNum[v]) 此时最短路径不止一条，所以要判断哪条路径聚集的救援队更多 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Problem: PAT Advanced 1003// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376// Tags: 最短路 djikstra DFS 单源最短路 贪心#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;const int MAXN = 500; // 最多500个城市const int INF = INT_MAX; // 最大距离int cityDis[MAXN][MAXN]; // 城市间的距离int teamNum[MAXN]; // 每个城市中有多少个救援队int shortestPathDis[MAXN]; // 起点城市c1到各个城市最短路径的距离int shortestPathNum[MAXN]; // 起点城市c1到各个城市最短路径的数量int teamGatherNum[MAXN]; // 从起点城市c1到各个城市的最短路径上，最多能聚集到多少个救援队bool visited[MAXN]; // 标记：是否已求出起点城市c1到某城市的最短路径int main()&#123; // 初始化变量 fill(cityDis[0], cityDis[0] + MAXN * MAXN, INF); fill(shortestPathDis, shortestPathDis + MAXN, INF); // 读取输入 int n, m, c1, c2; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;c1, &amp;c2); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;teamNum[i]); int a, b, d; for (int i = 0; i &lt; m; i++)&#123; scanf("%d %d %d", &amp;a, &amp;b, &amp;d); cityDis[a][b] = cityDis[b][a] = d; &#125; // 初始化起点城市c1 shortestPathDis[c1] = 0; teamGatherNum[c1] = teamNum[c1]; shortestPathNum[c1] = 1; // 迭代直至求出起点城市c1到所有城市的最短距离 for (int i = 0; i &lt; n; i++)&#123; // 寻找未被标记的、距离起点城市c1最近的城市u（贪心） int u = -1, minDis = INF; for(int j = 0; j &lt; n; j++)&#123; if (!visited[j] &amp;&amp; shortestPathDis[j] &lt; minDis)&#123; u = j; minDis = shortestPathDis[j]; &#125; &#125; // 各城市都已被标记，则已求出结果，退出循环即可；否则根据贪心策略，现在已求出起点城市c1到城市u的最短距离 if (u == -1) break; visited[u] = true; // 如果有边&lt;u,v&gt;，则更新城市v的相关变量（最简洁的dijkstra算法只更新shortestPathDis[v]即可） for (int v = 0; v &lt; n; v++)&#123; if (!visited[v] &amp;&amp; cityDis[u][v] != INF)&#123; if (shortestPathDis[v] &gt; shortestPathDis[u] + cityDis[u][v])&#123; shortestPathDis[v] = shortestPathDis[u] + cityDis[u][v]; shortestPathNum[v] = shortestPathNum[u]; teamGatherNum[v] = teamGatherNum[u] + teamNum[v]; &#125; else if (shortestPathDis[v] == shortestPathDis[u] + cityDis[u][v])&#123; shortestPathNum[v] = shortestPathNum[u] + shortestPathNum[v]; if (teamGatherNum[v] &lt; teamGatherNum[u] + teamNum[v]) teamGatherNum[v] = teamGatherNum[u] + teamNum[v]; &#125; &#125; &#125; &#125; printf("%d %d", shortestPathNum[c2], teamGatherNum[c2]); return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/52300668 https://blog.csdn.net/qq_35644234/article/details/60870719 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>BFS</tag>
        <tag>PAT</tag>
        <tag>贪心</tag>
        <tag>图</tag>
        <tag>最短路</tag>
        <tag>单源最短路</tag>
        <tag>dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1146Topological Order]]></title>
    <url>%2F2020%2F09%2F15%2FPAT%E7%94%B2%E7%BA%A71146Topological-Order%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760 题解题目要求给定一个有向图，请判断一个序列是否是该有向图的拓扑序列。 输入 N：正整数，不超过1000，图中顶点的数量，顶点索引为[1,N] M：正整数，不超过10000，有向边的数量 M条有向边：开始顶点索引、结束顶点索引 K：不超过100，待检验的序列的个数 K个序列：索引为[0,K] 输出 对于每个排列，如果不是拓扑排序则输出其索引 解题思路 保存每个结点的前驱结点 使用一维数组保存每个结点是否已访问 遍历序列判断每个结点的前驱结点是否已访问，如果未访问，则该序列不是拓扑序列 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Problem: PAT Advanced 1146// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760// Tags: 拓扑序列 图#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; before;int main()&#123; int n, m, k; scanf("%d %d", &amp;n, &amp;m); before.resize(n+1); int v1, v2; for (int i = 0; i &lt; m; i++)&#123; scanf("%d %d", &amp;v1, &amp;v2); before[v2].push_back(v1); &#125; scanf("%d", &amp;k); vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++)&#123; // 判断k个序列 // 保存一个序列 vector&lt;int&gt; sequence(n); for (int j = 0; j &lt; n; j++)&#123; scanf("%d", &amp;sequence[j]); &#125; // 判断该序列是否是拓扑序列 vector&lt;bool&gt; visited(n + 1, false); bool isTopological = true; for (int j = 0; j &lt; n; j++)&#123; v2 = sequence[j]; for (auto iter = before[v2].begin(); iter != before[v2].end(); iter++)&#123; if (!visited[*iter])&#123; isTopological = false; result.push_back(i); break; &#125; &#125; if (isTopological) visited[v2] = true; else break; &#125; &#125; // 输出结果 auto iter = result.begin(); printf("%d", *iter); iter++; while (iter != result.end())&#123; printf(" %d", *iter); iter++; &#125; printf("\n"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>拓扑序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1135Is It A Red-Black Tree]]></title>
    <url>%2F2020%2F09%2F15%2FPAT%E7%94%B2%E7%BA%A71135Is-It-A-Red-Black-Tree%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640 题解题目要求 红黑树 在二叉搜索树的基础上，红黑树还具有以下特征 每个结点是红色或者黑色 根结点是黑色的 叶子结点（NULL）都是黑色 每个红色结点的两个子结点都是黑色 从每个叶子到根的所有路径上不能有两个连续的红色结点 每个结点到其每个叶子结点的所有路径都包含相同数目的黑色节点。 给定一颗二叉搜索树，请判断它是否是一个合法的红黑树。 输入 K：正整数，不超过30，测试用例的数量 N：正整数，不超过30，二叉树中结点的数量 二叉树的先序遍历结果：结点的值都是正整数，用负数代表红色结点 输出 判断每颗二叉搜索树是否是红黑树，是则输出Yes，否则输出No。 解题思路 根据先序遍历结果和二叉搜索树的性质（左子树小于根结点小于右子树），递归构建二叉树 判断性质3：根结点是否是黑色 判断性质4，见代码中的函数judge1 判断性质5，见代码中的函数judge2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Problem: PAT Advanced 1135// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640// Tags: Tree BST RBTree#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;struct Node&#123; int val; Node* left = nullptr; Node* right = nullptr;&#125;;Node* build(Node* root, int v)&#123; if (root == nullptr)&#123; root = new Node(); root-&gt;val = v; &#125; else if (abs(v) &lt;= abs(root-&gt;val)) root-&gt;left = build(root-&gt;left, v); else root-&gt;right = build(root-&gt;right, v); return root;&#125;bool judge1(Node* root)&#123; if (root == nullptr) return true; if (root-&gt;val &lt; 0)&#123; if (root-&gt;left != nullptr &amp;&amp; root-&gt;left-&gt;val &lt; 0) return false; if (root-&gt;right != nullptr &amp;&amp; root-&gt;right-&gt;val &lt; 0) return false; &#125; return judge1(root-&gt;left) &amp;&amp; judge1(root-&gt;right);&#125;int getDepth(Node* root)&#123; if (root == nullptr) return 0; int ret = max(getDepth(root-&gt;left), getDepth(root-&gt;right)); return root-&gt;val &gt; 0 ? ret + 1 : ret;&#125;bool judge2(Node *root)&#123; if (root == nullptr) return true; if (getDepth(root-&gt;left) != getDepth(root-&gt;right)) return false; return judge2(root-&gt;left) &amp;&amp; judge2(root-&gt;right);&#125;int main()&#123; int k, n, val; scanf("%d", &amp;k); while (k--)&#123; scanf("%d", &amp;n); Node* root = nullptr; for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;val); root = build(root, val); &#125; if (root-&gt;val &lt; 0 || !judge1(root) || !judge2(root)) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/78037334 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>BST</tag>
        <tag>PAT</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1138Postorder Traversal]]></title>
    <url>%2F2020%2F09%2F08%2FPAT%E7%94%B2%E7%BA%A71138Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200 题解题目要求假设二叉树中所有结点的值都是互异的正整数，给定二叉树的先序和后序遍历，请输出该树后序遍历的第一个数字。 输入 N：正整数，不超过50000，二叉树中结点的数量 先序遍历结果 中序遍历结果 解题思路 根据先序遍历和中序遍历结果可以确定一颗树，这道题的关键就是如何确定出这颗树并遍历它。 可以参考PAT甲级1151LCA in a Binary Tree，这道题里也是根据先序遍历和中序遍历结果确定出了一棵树。 设置全局flag判断是否是该树后序遍历的第一个数字，如果是则输出，不是则不输出 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Problem: PAT Advanced 1138// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200// Tags: Tree DFS#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;vector&lt;int&gt; preOrder; // 先序遍历结果vector&lt;int&gt; inOrder; // 中序遍历结果map&lt;int, int&gt; inPos; // 结点到中序遍历结果inOrder索引的映射bool firstIsPrinted = false; // 为true代表后序遍历时的第一个结点已经输出void postOrderTraverse(int inLeft, int inRight, int preRoot)&#123; if (firstIsPrinted) // 只输出后序遍历的第一个结点即可 return ; if (inRight &lt; inLeft) // 该树不存在 return ; int inRoot = inPos[preOrder[preRoot]]; // 当前树的根结点在中序遍历结果inOrder中的索引 // 后序遍历 postOrderTraverse(inLeft, inRoot - 1, preRoot + 1); // 遍历左子树并判断左子树是否存在 postOrderTraverse(inRoot + 1, inRight, preRoot + 1 + (inRoot - inLeft)); // 遍历右子树并判断右子树是否存在 if (!firstIsPrinted)&#123; // 只输出后序遍历的第一个结点即可 printf("%d", inOrder[inRoot]); firstIsPrinted = true; &#125;&#125;int main()&#123; int n; scanf("%d", &amp;n); preOrder.resize(n + 1); inOrder.resize(n + 1); for (int i = 1; i &lt;= n; i++) // 读取先序遍历结果 scanf("%d", &amp;preOrder[i]); for (int i = 1; i &lt;= n; i++)&#123; // 读取中序遍历结果 scanf("%d", &amp;inOrder[i]); inPos[inOrder[i]] = i; &#125; postOrderTraverse(1, n, 1); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>PAT</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1143Lowest Common Ancestor]]></title>
    <url>%2F2020%2F09%2F07%2FPAT%E7%94%B2%E7%BA%A71143Lowest-Common-Ancestor%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312 题解题目要求 最近公共祖先（LCA，The lowest common ancestor） 在一颗树中，结点U和V的LCA是U和V为其后代的深度最大的结点。 二叉搜索树（BST，binary search tree） 树中的每个结点的值都大于其左子树中结点的值 树中的每个结点的值都不超过其右子树中结点的值 每个结点的左子树和右子树都是二叉搜索树 给定一个二叉搜索树中的任意两个结点，请找到他们的LCA。 输入 M：正整数，不超过1000，需要测试的结点对的数量 N：正整数，不超过10000，二叉搜索树中结点的数量 N个结点（互异）：按照先序遍历的顺序给出，值都在int范围内 M个结点对 输出 对于每个结点对，判断结点对中每个结点是否存在，如果都存在则找到他们的LCA。 解题思路不需建树 判断结点是否在树中 读取树的先序遍历时使用map记录一个结点是否在树中 寻找LCA 根据BST的性质，如果一个结点的值处于u和v的值之间，那这个结点就是u和v的LCA。 这道题涉及LCA，也可以看看另外一道题：PAT甲级1151 LCA in a Binary Tree 代码123456789101112131415161718192021222324252627282930313233343536373839404142// Problem: PAT Advanced 1143// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312// Tags: Tree BST LCA map#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main()&#123; int m, n, u, v, a; scanf("%d %d", &amp;m, &amp;n); vector&lt;int&gt; preOrder(n); map&lt;int, bool&gt; exists; for (int i = 0; i &lt; n; i++)&#123; // 读取先序遍历结果并记录结点是否出现过 scanf("%d", &amp;preOrder[i]); exists[preOrder[i]] = true; &#125; while (m--) &#123; // m个结点对 scanf("%d %d", &amp;u, &amp;v); for (int i = 0; i &lt; n; i++)&#123; // 寻找LCA a = preOrder[i]; if (u &lt; a &amp;&amp; v &gt; a || v &lt; a &amp;&amp; u &gt; a || (a == u) || (a == v) ) break; &#125; if (exists[u] == false &amp;&amp; exists[v] == false) printf("ERROR: %d and %d are not found.\n", u, v); else if (exists[u] == false || exists[v] == false) printf("ERROR: %d is not found.\n", exists[u]==false ? u : v); else if (a == u || a == v) printf("%d is an ancestor of %d.\n", a, a == u ? v : u); else printf("LCA of %d and %d is %d.\n", u, v, a); &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>BST</tag>
        <tag>PAT</tag>
        <tag>map</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1151LCA in a Binary Tree]]></title>
    <url>%2F2020%2F09%2F07%2FPAT%E7%94%B2%E7%BA%A71151LCA-in-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/1038430130011897856 题解题目要求 最近公共祖先（LCA，The lowest common ancestor） 在一颗树中，结点U和V的LCA是U和V为其后代的深度最大的结点。 给定一颗二叉树中的任意两个结点，请找到它们的LCA。 输入 M：正整数，不超过1000，需要测试的结点对的数量 N：正整数，不超过10000，二叉树中结点的数量，结点值都在int范围内 二叉树中序遍历结果：N个数字 二叉树先序遍历结果：N个数字 M个结点对： 输出 对于每个结点对，判断结点对中每个结点是否存在，如果都存在则找到他们的LCA。 思路根据先序遍历结果和中序遍历结果可以确定一颗树中序遍历结果加先序遍历结果可以唯一确定一棵树，在不构建树的情况下，在每一层的递归中，可以得到树的根结点。 使用两个数组分别保存树的先序遍历结果和后序遍历结果 根据先序遍历结果可以确定根节点 比如刚开始的第一个结点就是整棵树的根结点 根据中序遍历结果和整棵树的根结点可以确定整棵树的左右子树 中序遍历结果中，根结点左侧就是整棵树的左子树的中序遍历结果，根结点右侧就是整棵树的右子树的中序遍历结果 递归确定左右子树的结构 某颗树的结构可根据2个变量确定：其根结点在整颗树先序遍历结果中的索引、其中序遍历结果序列（可通过起始索引和结束索引2个变量确定） 123456789101112131415void func(int leftPosBoundOfInOrder, int rightPosBoundOfInOrder, int rootPosOfPreOrder)&#123; /* 当前这颗树在整棵树中序遍历结果inOrder的范围索引为[leftPosBoundOfInOrder,rightPosBoundOfInOrder] rootPosOfPreOrder指当前这颗树根结点在整棵树先序遍历结果preOrder中的索引 */ // 越界判断 if (leftPosBoundOfInOrder &gt; rightPosBoundOfInOrder) return; // 左子树 lca(leftPosBoundOfInOrder, rootPosOfInOrder - 1, rootPosOfPreOrder + 1); // 右子树 lca(rootPosOfInOrder + 1, rightPosBoundOfInOrder, rootPosOfPreOrder + (rootPosOfInOrder - leftPosBoundOfInOrder) + 1);&#125;func(1, n, 1); // 调用（假设整颗树有n个结点，在数组中的索引为[1,n]） PAT甲级1138Postorder Traversal这道题也涉及如何根据先序遍历结果和中序遍历结果确定一棵树并遍历它，可以看一看。 最近公共祖先LCA已知某颗树的根结点， 若u和u在根结点的左边，则u和v的最近公共祖先在当前子树根结点的左子树寻找； 如果u和v在当前子树根结点的右边，则u和v的最近公共祖先就在当前子树的右子树寻找； 如果u和v在当前子树根结点的两边，在当前子树的根结点就是u和v的最近公共祖先； 如果u或v就是根结点，那其就是这两个结点的最近公共祖先。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Problem: PAT Advanced 1151// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038430130011897856// Tags: Tree LCA Map#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;int u, v;map&lt;int, int&gt; pos;vector&lt;int&gt; inOrder, preOrder;void lca(int leftPosBoundOfInOrder, int rightPosBoundOfInOrder, int rootPosOfPreOrder)&#123; /* 当前这颗树在整棵树中序遍历结果inOrder的范围索引为[leftPosBoundOfInOrder,rightPosBoundOfInOrder] rootPosOfPreOrder指当前这颗树根结点在整棵树先序遍历结果preOrder中的索引 */ if (leftPosBoundOfInOrder &gt; rightPosBoundOfInOrder) return; // 越界判断 int rootPosOfInOrder = pos[preOrder[rootPosOfPreOrder]]; // 根结点在中序遍历结果中的索引 int uPosOfInorder = pos[u]; // 结点u在中序遍历结果中的索引 int vPosOfInorder = pos[v]; // 结点v在中序遍历结果中的索引 // u和v都在左子树就去左子树找 if (uPosOfInorder &lt; rootPosOfInOrder &amp;&amp; vPosOfInorder &lt; rootPosOfInOrder) lca(leftPosBoundOfInOrder, rootPosOfInOrder - 1, rootPosOfPreOrder + 1); // u和v都在右子树就去右子树找 else if (uPosOfInorder &gt; rootPosOfInOrder &amp;&amp; vPosOfInorder &gt; rootPosOfInOrder) lca(rootPosOfInOrder + 1, rightPosBoundOfInOrder, rootPosOfPreOrder + (rootPosOfInOrder - leftPosBoundOfInOrder) + 1); // u和v在分别在左右子树，则当前树的根节点就是LCA else if ((uPosOfInorder &lt; rootPosOfInOrder &amp;&amp; vPosOfInorder &gt; rootPosOfInOrder) || (uPosOfInorder &gt; rootPosOfInOrder &amp;&amp; vPosOfInorder &lt; rootPosOfInOrder)) printf("LCA of %d and %d is %d.\n", u, v, preOrder[rootPosOfPreOrder]); // 结点u就是根结点 else if (uPosOfInorder == rootPosOfInOrder) printf("%d is an ancestor of %d.\n", u, v); // 结点v就是根结点 else if (vPosOfInorder == rootPosOfInOrder) printf("%d is an ancestor of %d.\n", v, u);&#125;int main()&#123; int m, n; // 结点对个数，结点个数 scanf("%d %d", &amp;m, &amp;n); inOrder.resize(n + 1), preOrder.resize(n + 1); for (int i = 1; i &lt;= n; i++)&#123; // 记录中序遍历结果，并记录各结点的索引 scanf("%d", &amp;inOrder[i]); pos[inOrder[i]] = i; &#125; for (int i = 1; i &lt;= n; i++)&#123; // 记录先序遍历结果 scanf("%d", &amp;preOrder[i]); &#125; while (m--)&#123; scanf("%d %d", &amp;u, &amp;v); if (pos[u] == 0 &amp;&amp; pos[v] == 0) // 判断元素是否存在 printf("ERROR: %d and %d are not found.\n", u, v); else if(pos[u] == 0 || pos[v] == 0) printf("ERROR: %d is not found.\n", pos[u] == 0 ? u : v); else lca(1, n, 1); &#125; return 0;&#125; 参考链接https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/80452127 https://blog.csdn.net/liuchuo/article/details/82560863 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>PAT</tag>
        <tag>map</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1142Maximal Clique]]></title>
    <url>%2F2020%2F09%2F06%2FPAT%E7%94%B2%E7%BA%A71142Maximal-Clique%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552 题解题目要求 团：某无向图的一个顶点子集，其中任意两个不同的顶点相邻，则这个顶点子集是这个图的一个团。 极大团：如果一个团在加入任何一个顶点后都不再是一个团，则这个团是一个极大团。 现在给你一个图，请你判断一些点集是否是团或极大团。 输入 Nv：正整数，不超过200，图中顶点的数量 Ne：正整数，图中边的数量 Ne条边：顶点索引为[1,Nv] M：正整数，不超过100，需要判断的顶点子集的个数 M个顶点子集：第一个数字k是顶点个数（不超过Nv），剩下的数字是顶点索引 输出 对于每个顶点子集，请判断它是最大团还是最大团以外的团或者不是团 思路 使用邻接矩阵保存边，用二维数组表示 使用vector保存顶点子集，并使用set保存顶点子集以外的顶点 根据定义判断顶点子集中的顶点是否两两相邻，如果是则为团，不是则不是团 如果是团，根据最大团的定义，遍历顶点子集以外的顶点，判断是否可以再添加一个顶点且该顶点与顶点子集中每个顶点都相邻 如果可以则说明不是极大团，不可以则不是极大团 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Problem: PAT Advanced 1142// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552// Tags: Graph Clique Maximal Clique#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;bool edge[201][201];int main()&#123; int ne, nv, m; scanf("%d %d", &amp;nv, &amp;ne); int v1, v2; for (int i = 0; i &lt; ne; i++)&#123; // 记录边 scanf("%d %d", &amp;v1, &amp;v2); edge[v1][v2] = edge[v2][v1] = true; &#125; scanf("%d", &amp;m); while (m--)&#123; // 判断m个顶点子集 set&lt;int&gt; leftV; // 该顶点子集以外的结点 for (int i = 1; i &lt;= nv; i++)&#123; leftV.insert(i); &#125; int k; scanf("%d", &amp;k); vector&lt;int&gt; v(k); for (int i = 0; i &lt; k; i++)&#123; // 记录顶点子集 scanf("%d", &amp;v[i]); leftV.erase(v[i]); &#125; bool isClique = true; // 先判断是否是团 for (int i = 0; i &lt; k - 1; i++)&#123; for (int j = i + 1; j &lt; k; j++)&#123; if (edge[v[i]][v[j]] == false)&#123; isClique = false; break; &#125; &#125; if (isClique == false) break; &#125; if (isClique == false)&#123; printf("Not a Clique\n"); continue; &#125; bool isMaximalClique = true; // 如果是团，再判断是不是极大团（按照定义判断） for (auto it = leftV.begin(); it != leftV.end(); it++)&#123; int cnt = 0; for (int i = 0; i &lt; k; i++)&#123; if (edge[*it][v[i]] == true) cnt++; &#125; if (cnt == k)&#123; isMaximalClique = false; break; &#125; &#125; if (isMaximalClique) printf("Yes\n"); else printf("Not Maximal\n"); &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>set</tag>
        <tag>团</tag>
        <tag>极大团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1155Heap Paths]]></title>
    <url>%2F2020%2F09%2F06%2FPAT%E7%94%B2%E7%BA%A71155Heap-Paths%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552 题解题目要求堆（大顶堆或小顶堆）中，任意一条从根结点到叶子结点的路径上的值一定是非递增序列或者非递减序列。 现在给定一个完全二叉树，请检查它的每一条路径，判断这棵树是不是堆。 输入 N：正整数，大于1，不超过1000，树中结点的数量 N个结点的值（互异）：都是int范围内，按照层次遍历的顺序给出 输出 对于每棵树 先输出所有从根结点到叶子结点的路径，每条路径占一行，数字间用一个空格间隔，首尾不能有多余空格 输出顺序：对于每个结点，其右子树的所有路径要先于其左子树的所有路径输出 输出这颗树是大顶堆还是小顶堆，或者它不是堆 思路 利用完全二叉树的性质，将结点记录到一维数组中 使用DFS，使用vecotr记录当前遍历到的所有结点（即路径），如果当前结点是叶子结点则输出这条路径，否则先遍历右子树再遍历左子树 在DFS过程中判断是否违背大小顶堆性质 最后输出该树是否是大小顶堆 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Problem: PAT Advanced 1155// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552// Tags: Tree DFS Heap#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n;bool isMaxHeap = true, isMinHeap = true;int nodes[2010]; // 索引为[1,n]的元素有效vector&lt;int&gt; path; // 目前遍历到的所有结点void dfs(int i)&#123; if (i &gt; n) return; // 越界则无操作 if (i &gt; 1)&#123; // 检查是否是大小顶堆 if (nodes[i] &gt; nodes[i / 2]) isMaxHeap = false; else if(nodes[i] &lt; nodes[i / 2]) isMinHeap = false; &#125; path.push_back(nodes[i]); // 遍历当前结点 if (2 * i &gt; n &amp;&amp; 2 * i + 1 &gt; n)&#123; // 是叶子结点则输出当前遍历到的所有结点 auto it = path.begin(); printf("%d", *it); it++; while (it != path.end())&#123; printf(" %d", *it); it++; &#125; printf("\n"); &#125; else&#123; // 不是叶子结点 dfs(2 * i + 1); // 遍历右子树 dfs(2 * i); // 遍历左子树 &#125; path.pop_back(); // 回溯&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++)&#123; // 记录结点 scanf("%d", nodes+i); &#125; dfs(1); // 深度优先遍历树并在过程中判断是否为大顶堆或小顶堆 if (isMaxHeap) printf("Max Heap"); else if (isMinHeap) printf("Min Heap"); else printf("Not Heap"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
        <tag>PAT</tag>
        <tag>堆</tag>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1147Heaps]]></title>
    <url>%2F2020%2F09%2F05%2FPAT%E7%94%B2%E7%BA%A71147Heaps%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648 题解题目要求给定一个完全二叉树，请判断它是不是堆（大顶堆指父结点的值大于等于子结点的值，小顶堆指父结点的值小于等于子结点的值） 输入 M：需要测试的树的数量，不超过100 N：每颗树中值的数量，大于1，不超过1000 M颗树：每颗树包含N个互异的值（int范围内），按照层次遍历的顺序给出 输出 对于每颗树，输出它是最大堆还是最小堆，或者它不是个堆，然后后序遍历输出这个树，值之间用空格间隔 思路 完全二叉树性质 如果某结点的序号为i，如果它的左右子结点存在，那左子结点序号为2i，右子结点序号为2i+1。 相应地，如果某子结点的序号为i，那其父结点的序号为i/2，其中i为int类型、只取i/2所得结果的整数部分。 因为是完全二叉树，所以不用建树，将所有结点按层次遍历的顺序存入数组即可 遍历除了根结点以外的结点，判断是否违反大顶堆或小顶堆的特点，然后输出是否是堆 递归实现后序遍历 代码1234567891011121314151617181920212223242526272829303132333435363738// Problem: PAT Advanced 1147// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648// Tags: Tree DFS Heap#include &lt;iostream&gt;using namespace std;int nodes[1005]; // 存储n个结点int m, n;void postOrderTrace(int i)&#123; if (i &gt; n) return ; // 避免越界 postOrderTrace(2 * i); postOrderTrace(2 * i + 1); if (i == 1) printf("%d\n", nodes[i]); else printf("%d ", nodes[i]);&#125;int main()&#123; scanf("%d %d", &amp;m, &amp;n); while (m--)&#123; for (int i = 1; i &lt;= n; i++) // 读取树 scanf("%d", nodes+i); bool isMaxHeap = true, isMinHeap = true; // 遍历判断是否是大小顶堆 for (int i = 2; i &lt;= n; i++) if (nodes[i] &gt; nodes[i/2]) isMaxHeap = false; else if(nodes[i] &lt; nodes[i/2]) isMinHeap = false; if (isMaxHeap) printf("Max Heap\n"); else if(isMinHeap) printf("Min Heap\n"); else printf("Not Heap\n"); postOrderTrace(1); // 后序遍历完全二叉树 &#125; return 0;&#125; 参考链接https://www.cnblogs.com/chouxianyu/p/13293152.html 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>DFS</tag>
        <tag>PAT</tag>
        <tag>堆</tag>
        <tag>完全二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1150Travelling Salesman Problem]]></title>
    <url>%2F2020%2F09%2F05%2FPAT%E7%94%B2%E7%BA%A71150Travelling-Salesman-Problem%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384 题解题目要求 现在给你一些环，请你找到其中与旅行商问题答案最接近的那个环（旅行商问题的定义在此不再说明） 输入 N：大于2，不超过200，城市的数量 M：无向图中边的数量， M条边：每条边表示为City1 City2 Dist，其中城市索引为[1,N]，城市间距离为不超过100的正数 K：正整数，path的数量 K条path：每条path的格式为：n c1 c2 c3 … cn，其中n是path中城市的数量，ci是城市索引 输出 对于每条path，输出Path X: TotalDist (Description)，其中X是[1,K]，TotalDist是总距离（不存在则输出NA），Description是 经过每个城市的简单环：TS simple cycle 经过每个城市的环，但不是简单环：TS cycle 不是经过每个城市的环：Not a TS cycle 最终输出Shortest Dist(X) = TotalDist，其中X是和旅行商问题解最接近的那个环的索引，TotalDist是其距离总和。（已确保只有一个解） 解题思路 距离用二维数组表示，默认值为0，为0则说明两个城市间不存在边 读取每条path时，用一维数组存储某个节点被访问的次数（注意城市索引是1到N） 在路径合法的前提下 TS cycle：即经过每个城市并且是一个环，即每个城市被访问的次数都大于0且首尾城市相同 TS simple cycle：在TS cycle的基础上，要求没有子环，只有起点城市被访问过2次，其它城市都只被访问过一次 将k个path的结果存放在一维数组中 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// Problem: PAT Advanced 1150// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384// Tags: Graph TSP#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int distances[205][205]; // 各个城市之间的距离。如果为0，则说明两个城市间无边、不可直达int main()&#123; int n, m, k; scanf("%d %d", &amp;n, &amp;m); int c1, c2, dist; for (int i = 0; i &lt; m; i++)&#123; // 存储各个城市之间的距离 scanf("%d %d %d", &amp;c1, &amp;c2, &amp;dist); distances[c1][c2] = distances[c2][c1] = dist; &#125; int bestX, bestDist = INT_MAX; scanf("%d", &amp;k); for(int x = 1; x &lt;= k; x++)&#123; vector&lt;int&gt; visited(n + 1, 0); int numOfCities, firstCity, pathTotalDist = 0; bool pathIslegal = true; scanf("%d %d", &amp;numOfCities, &amp;firstCity); visited[firstCity] += 1; // 访问第一个城市 c1 = firstCity; // 更新上一个城市 for(int i = 0 ; i &lt; numOfCities - 1; i++)&#123; scanf("%d", &amp;c2); // 读取当前城市 if (distances[c1][c2] != 0)&#123; visited[c2] += 1; pathTotalDist += distances[c1][c2]; // 计算该路径的总距离 &#125; else&#123; // path中两个城市不存在边 pathIslegal = false; &#125; c1 = c2; // 更新上一个城市 &#125; if (!pathIslegal)&#123; // 路径非法 printf("Path %d: NA (Not a TS cycle)\n", x); continue; &#125; if (firstCity != c2)&#123; // 在路径合法的前提下，第一个城市和最后一个城市不同，则该路径不是环 printf("Path %d: %d (Not a TS cycle)\n", x, pathTotalDist); continue; &#125; bool isTS = true; for (int i = 1; i &lt; n + 1; i++)&#123; if (visited[i] &lt; 1)&#123; isTS = false; break; &#125; &#125; if (!isTS)&#123; // 该路径没有经过所有城市 printf("Path %d: %d (Not a TS cycle)\n", x, pathTotalDist); continue; &#125; bool isSimple = true; for (int i = 1; i &lt; n + 1; i++)&#123; // 已确保是环且经过所有城市，判断是否是简单环，并更新最短TS环路 if (pathTotalDist &lt; bestDist)&#123; bestX = x; bestDist = pathTotalDist; &#125; if (i != firstCity &amp;&amp; visited[i] &gt; 1)&#123; isSimple = false; &#125; &#125; if (isSimple) printf("Path %d: %d (TS simple cycle)\n", x, pathTotalDist); else printf("Path %d: %d (TS cycle)\n", x, pathTotalDist); &#125; printf("Shortest Dist(%d) = %d\n", bestX, bestDist); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>TSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1149Dangerous Goods Packaging]]></title>
    <url>%2F2020%2F09%2F02%2FPAT%E7%94%B2%E7%BA%A71149Dangerous-Goods-Packaging%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176 题目要求当用容器运输货物时，一些货物是不能装在一起的。现在告诉你哪些货物能装在一起，给你一些货物，请判断这些货物是否可以被装在一起 输入 N：不能装在一起的货物对的数量，不超过10000 M：要运输的货物的组数，不超过100 N组不能装在一起的货物：每组包括两个货物索引 M组货物 第一个数字K（不超过1000）是货物的数量，然后剩下的是货物索引（5位数字） 输出 对于M组货物中的每组，如果其中没有不可以装在一起的货物则输出Yes，否则输出No 题解一思路这个思路会超时 通过map和hash记录两个货物是否可以被装在一起，相当于一个邻接矩阵 为什么不定义矩阵？如果要用矩阵，在这里就需要定义一个100000×100000的bool矩阵，大概会占用10GB，而内存限制是64MB。 对于每组货物，两两判断是否不相容，是一个两层循环，时间复杂度是$K^2$，再算上M组查询，时间复杂度就是$MK^2$，最大值为100×1000×1000=1e8，大概会耗时1秒，肯定会超过400ms的时间限制。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Problem: PAT Advanced 1149// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176// Tags: Graph Map Hash#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n, m, k; scanf("%d %d", &amp;n, &amp;m); int good1, good2; unordered_map&lt;int, bool&gt; incompatible; // 通过map和hash记录两个货物是否可以被装在一起 while (n--)&#123; // 通过map和hash记录两个货物是否可以被装在一起 scanf("%d %d", &amp;good1, &amp;good2); incompatible[good1 * 100000 + good2] = true; incompatible[good2 * 100000 + good1] = true; &#125; while (m--)&#123; //判断m组货物 scanf("%d", &amp;k); vector&lt;int&gt; goods(k); for (int i = 0; i &lt; k; i++) // 记录k个货物 scanf("%d", &amp;goods[i]); bool isYes = true; for(int i = 0; i &lt; k - 1; i++)&#123; //判断k个货物是否可以放在一起 good1 = goods[i]; for (int j = i + 1; j &lt; k; j++)&#123; good2 = goods[j]; if (incompatible[good1 * 100000 + good2] || incompatible[good2 * 100000 + good1])&#123; isYes = false; break; &#125; &#125; &#125; // 输出结果 if (isYes) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 题解二思路 使用邻接表保存每个货物的不能装在一起的货物 对于每组货物，使用一维数组保存每个货物是否在这组货物中 查询邻接表，并通过一维数组判断每个货物的不相容货物是否出现在这组货物中 这里也是用了两层循环，但这两层循环的时间复杂度是$N$，再算上M组查询，时间复杂度就是$MN$，最大值为100×10000=1e6。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Problem: PAT Advanced 1149// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176// Tags: Graph Map Hash#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; incompatible[100000]; // 邻接表，货物与哪些货物不能装在一起int main()&#123; int n, m, k, good1, good2; scanf("%d %d", &amp;n, &amp;m); while (n--)&#123; // 建立邻接表 scanf("%d %d", &amp;good1, &amp;good2); incompatible[good1].push_back(good2); incompatible[good2].push_back(good1); &#125; while (m--)&#123; // m组货物 scanf("%d", &amp;k); vector&lt;int&gt; goods(k); // 该组货物 bool contained[100000]=&#123;false&#125;; // 该组货物中有哪些货物 for (int i = 0; i &lt; k; i++)&#123; // 记录该组货物 scanf("%d", &amp;goods[i]); contained[goods[i]] = true; &#125; bool isYes = true; for (int i = 0; i &lt; k; i++)&#123; // 查询邻接表，并通过一维数组判断每个货物的不相容货物是否出现在这组货物中 for (int j = 0; j &lt; incompatible[goods[i]].size(); j++)&#123; if (contained[incompatible[goods[i]][j]])&#123; isYes = false; break; &#125; &#125; &#125; // 输出结果 if (isYes) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/82560836 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1134Vertex Cover]]></title>
    <url>%2F2020%2F09%2F01%2FPAT%E7%94%B2%E7%BA%A71134Vertex-Cover%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088 题目要求 vertex cover vertex cover指图中的每条边都和这组顶点中至少一个顶点相关，先给定一个图和几组顶点，请判断这几组顶点是否为vertex cover 输入 N：顶点数量，不超过10000 M：边的数量，不超过10000 M条边：顶点通过[0,N-1]表示/索引 K：有几组顶点，不超过100 K组顶点 一组顶点的第一个数字是顶点数量，剩下的是顶点索引 输出 是vertex则输出Yes，不是则输出No 题解一思路 定义Edge结构体，包括两个端点 把M条边存入vector 将顶点组存入set（vector也可以） 遍历每条边判断其两个端点是否在set中 只要有一条边的两个端点都不在set中，则不是vertex cover 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Problem: PAT Advanced 1134// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088// Tags: Graph Hash Set#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;struct Edge&#123; int v1, v2;&#125;;int main()&#123; int n, m, k; scanf("%d %d", &amp;n, &amp;m); vector&lt;Edge&gt; edges(m); // 存储边 for (int i = 0; i &lt; m; i++) scanf("%d %d", &amp;edges[i].v1, &amp;edges[i].v2); scanf("%d", &amp;k); while (k--)&#123; set&lt;int&gt; vertices; int vertexNum, vertex; scanf("%d", &amp;vertexNum); for (int i = 0; i &lt; vertexNum; i++)&#123; // 将一组顶点存入set scanf("%d", &amp;vertex); vertices.insert(vertex); &#125; bool isVertexCover = true; for (auto it = edges.begin(); it != edges.end(); it++)&#123; // 只要有一条边的两个端点都不在set中，则不是vertex cover if (vertices.find(it-&gt;v1) == vertices.end() &amp;&amp; vertices.find(it-&gt;v2) == vertices.end())&#123; isVertexCover = false; break; &#125; &#125; if (isVertexCover) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 题解二比上一个方法快 思路 给M条边编号为[0,M-1] 读取每条边时，保存每个顶点与哪条边相关，将这个信息存入vector 定义vector表示各条边是否被覆盖，遍历上一步得到的vector标记各条边是否被覆盖，最后遍历这一步定义的vector判断是否符合vertex cover的条件 注意点 一个顶点可以和多条边相关 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445// Problem: PAT Advanced 1134// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088// Tags: Graph Hash Set#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n, m, k; scanf("%d %d", &amp;n, &amp;m); vector&lt;int&gt; cover[n]; // cover[2].push_back(3) 代表顶点2覆盖了边3 int v1, v2; for (int i = 0; i &lt; m; i++)&#123; scanf("%d %d", &amp;v1, &amp;v2); cover[v1].push_back(i); cover[v2].push_back(i); &#125; scanf("%d", &amp;k); while (k--)&#123; vector&lt;bool&gt; isCovered(m, false); // m条边是否被覆盖 int vertexNum, vertex; scanf("%d", &amp;vertexNum); for (int i = 0; i &lt; vertexNum; i++)&#123; // 遍历顶点，将其覆盖的边标记 scanf("%d", &amp;vertex); for (int j = 0; j &lt; cover[vertex].size(); j++) isCovered[cover[vertex][j]] = true; &#125; bool isVertexCover = true; for (int i = 0; i &lt; m; i++)&#123; if (isCovered[i] == false)&#123; isVertexCover = false; break; &#125; &#125; if (isVertexCover) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/78037329 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>set</tag>
        <tag>点覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1139First Contact]]></title>
    <url>%2F2020%2F09%2F01%2FPAT%E7%94%B2%E7%BA%A71139First-Contact%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312 题解题目要求 背景 男生A喜欢女孩B，A找男生C让女孩D跟B说，其中C是A的朋友，D是B和C的朋友。女生也是这样联系男生 输入 N：人的数量，1到300 M：朋友关系的数量 M个朋友关系：用4位数字表示一个人，其中负数代表性别是女生 K：查询数量，不超过100 K次查询：每次查询是A和B的ID，假设A喜欢B 输出 输出有几对C和D可以帮助A联系B 输出这几对C和D 如果A和B是异性，则A和C应该是同性，B和D同性；如果A和B是同性，则这4人性别应该相同 即A和C同性，B和D同性 先按C的ID非降序输出，再按D的ID增序输出 思路 使用邻接矩阵表示两个人是否是朋友，用邻接表存储一个人的同性朋友 给定A和B以后，枚举A的朋友C，枚举B的朋友D，如果C和D是朋友则保存C和D 注意点 输出时要以4位数字输出，用printf(&quot;%04d&quot;)，第二和第三个测试点都测试了这个 如果用int接收一对朋友，-0000和0000对于int来说都是0，将无法得知这个人的性别 在这里我对他们的id进行了处理：把女生映射到[0,9999]，男生映射到[10000,19999] 也可以使用其他的哈希方法 正常回路为A-C-D-B，不可以形成A-B-D-B或A-C-A-B的回路，即AD不相等、BC不相等 写循环代码时注意一些变量是否会随着循环运行而改变，比如数组大小、外层循环变量是否被内层循环改变 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// Problem: PAT Advanced 1139// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312// Tags: Graph Hash#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool isFriend[20000][20000]; // 邻接矩阵vector&lt;int&gt; friends[20000]; // 邻接表，同性朋友struct Helper&#123; int c, d;&#125;;int transform(string s)&#123; // 将负数映射到[0,9999]，将正数映射到[10000,19999] if (s[0] == '-') return abs(stoi(s)); else return 10000 + stoi(s);&#125;int restore(int num)&#123; // 将transform得到的[0,19999]的数字映射到[0,9999]，即原来的[-9999,9999]取绝对值得到[0,9999]，以进行输出 if (num &gt; 9999) return num - 10000; else return num;&#125;bool helperCmp(Helper&amp; h1, Helper&amp; h2)&#123; return h1.c == h2.c ? h1.d &lt; h2.d : h1.c &lt; h2.c;&#125;int main()&#123; int n, m, k, a, b, c ,d; string s, t; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++)&#123; // 将图存入邻接矩阵和邻接表 cin &gt;&gt; s &gt;&gt; t; a = transform(s); b = transform(t); isFriend[a][b] = isFriend[b][a] = true; if ( (a&lt;10000 &amp;&amp; b&lt;10000) || (a&gt;9999 &amp;&amp; b&gt;9999) )&#123; // 同性则存储到邻接表 friends[a].push_back(b); friends[b].push_back(a); &#125; &#125; scanf("%d", &amp;k); while (k--)&#123; cin &gt;&gt; s &gt;&gt; t; a = transform(s); b = transform(t); vector&lt;Helper&gt; helpers; for (auto it1 = friends[a].begin(); it1 != friends[a].end(); it1++)&#123; c = *it1; if (c == b) // C和B不能是一个人 continue; for (auto it2 = friends[b].begin(); it2 != friends[b].end(); it2++)&#123; d = *it2; if (d == a) // D和A不能是一个人 continue; if (isFriend[c][d]) helpers.push_back(&#123;restore(c), restore(d)&#125;); &#125; &#125; sort(helpers.begin(), helpers.end(), helperCmp); printf("%d\n", helpers.size()); for (auto it = helpers.begin(); it != helpers.end(); it++) printf("%04d %04d\n", it-&gt;c, it-&gt;d); &#125; return 0;&#125; 一份超时的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Problem: PAT Advanced 1139// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312// Tags: Graph Hash Map#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;struct Helper&#123; string c, d;&#125;;bool helperCmp(Helper&amp; h1, Helper&amp; h2)&#123; return abs(stoi(h1.c)) == abs(stoi(h2.c)) ? abs(stoi(h1.d)) &lt; abs(stoi(h2.d)) : abs(stoi(h1.c)) &lt; abs(stoi(h2.c));&#125;int main()&#123; int n, m, k; string a, b, c, d; unordered_map&lt;string, vector&lt;string&gt;&gt; friends; // 会很耗时 scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++)&#123; // 存储朋友关系 cin &gt;&gt; a &gt;&gt; b; if (a[0] != '-') a = '+' + a; if (b[0] != '-') b = '+' + b; friends[a].push_back(b); friends[b].push_back(a); &#125; scanf("%d", &amp;k); while (k--)&#123; cin &gt;&gt; a &gt;&gt; b; // a喜欢b if (a[0] != '-') a = '+' + a; if (b[0] != '-') b = '+' + b; vector&lt;Helper&gt; helpers; // 下边这个大的for循环也很耗时间 for (auto it1 = friends[a].begin(); it1 != friends[a].end(); it1++)&#123; c = *it1; // a的朋友c if (b == c || a[0] != c[0]) // a和c不可以是同一个人，且应该是同性 continue; for (auto it2 = friends[c].begin(); it2 != friends[c].end(); it2++)&#123; d = *it2; // c的朋友d if (a == d || b[0] != d[0]) // a和d不可以是同一个人，且应该是同性 continue; if (find(friends[d].begin(), friends[d].end(), b) != friends[d].end())&#123; helpers.push_back(&#123;c, d&#125;); &#125; &#125; &#125; sort(helpers.begin(), helpers.end(), helperCmp); // 按id升序存储，达到题目输出要求 int num = helpers.size(); printf("%d\n", num); for (int i = 0; i &lt; num; i++) printf("%04d %04d\n", abs(stoi(helpers[i].c)), abs(stoi(helpers[i].d))); &#125; return 0;&#125; 参考链接https://blog.csdn.net/liuchuo/article/details/79065004 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>map</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1154Vertex Coloring]]></title>
    <url>%2F2020%2F08%2F30%2FPAT%E7%94%B2%E7%BA%A71154Vertex-Coloring%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552 题解题目 k着色：相邻（有共享边）点的颜色不同 输入 N：点的数量，点的编号为[0,N-1]，不超过10000 M：边的数量，不超过10000 M条边 K：着色方案的数量，不超过100 K个着色方案：每行有N个数字，第i个数字就是第i个点的颜色，相同数字代表同色 输出 对于每个着色方案，如果它是某个k着色，则输出k-coloring，否则输出No 思路 把所有边存起来 把所有点的颜色存起来，并把颜色放入set中统计颜色个数 检查每条边两个点的颜色是否相同 注意点 cin、cout是会比scanf、printf慢的，如果用cin、cout，第三个测试点可能会超时 代码12345678910111213141516171819202122232425262728293031323334353637383940// Problem: PAT Advanced 1154// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552// Tags: Graph Map Set#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;struct Node&#123;int v1, v2;&#125;;int main()&#123; int n, m, k; scanf("%d %d", &amp;n, &amp;m); vector&lt;Node&gt; edges(m); for (int i = 0; i &lt; m; i++) // 获取边 scanf("%d %d", &amp;edges[i].v1, &amp;edges[i].v2); scanf("%d", &amp;k); while (k--) &#123; // k个着色方案 unordered_map&lt;int, int&gt; vColors; set&lt;int&gt; colors; for (int i = 0; i &lt; n ; i++)&#123; // 获取着色方案 scanf("%d", &amp;vColors[i]); colors.insert(vColors[i]); // 存储颜色 &#125; bool isYes = true; // 判断着色方案是否符合k着色标准 for (int i = 0; i &lt; m; i++) if (vColors[edges[i].v1] == vColors[edges[i].v2])&#123; isYes = false; break; &#125; if (isYes) printf("%d-coloring\n", colors.size()); else printf("No\n"); &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>图</tag>
        <tag>map</tag>
        <tag>set</tag>
        <tag>点着色</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1137Final Grading]]></title>
    <url>%2F2020%2F08%2F28%2FPAT%E7%94%B2%E7%BA%A71137Final-Grading%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608 题解题目要求 要获得证书，一个学生的在线编程作业至少要拿到200分，最后评分G至少要拿到60分。 如果期中分数大于期末分数，则G等于期中成绩乘以40%+期末成绩乘以60%，否则G等于期末成绩 输入 第一行 三个数字，都不超过10000 P：完成网上在线作业的学生的数量 M：参加期中考试的学生的数量 N：参加期末考试的学生的数量 P个学生网上在线作业的成绩 M个学生期中考试的成绩 N个学生期末考试的成绩 输出 输出获得证书的学生的ID及其3个成绩，按G(四舍五入到整数)降序输出，如果G相等，则按ID升序输出。如果某学生某些成绩不存在，则输出-1 英语 assignment 工作、任务 分配、指派 certificate 证明 round 四舍五入 思路 先读取在线编程作业分数，如果小于200，就不记录该学生的信息 在第一步记录的学生范围内，记录其期中分数 在第一步记录的学生范围内，记录其期末分数，同时计算其最后分数G，如果G大于60，则存入vector 将vector排序 输出 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Problem: PAT Advanced 1137// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608// Tags: unordered_map vector sort#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;struct Student&#123; string id; int gp=-1; int gm=-1; int gf=-1; int g=-1;&#125;;bool studentCmp(Student&amp; s1, Student&amp; s2)&#123; return s1.g == s2.g ? s1.id &lt; s2.id : s1.g &gt; s2.g;&#125;int main()&#123; int p, m, n; unordered_map&lt;string, Student&gt; students_map; cin &gt;&gt; p &gt;&gt; m &gt;&gt; n; string str; int score; for (int i = 0; i &lt; p; i++)&#123; cin &gt;&gt; str &gt;&gt; score; if (score &gt;= 200)&#123; // 在线编程分数大于200才行（不允许该分数不存在） students_map[str].id = str; students_map[str].gp = score; &#125; &#125; for (int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; str &gt;&gt; score; if (students_map.find(str) != students_map.end()) // 避免创建新的学生 students_map[str].gm = score; &#125; vector&lt;Student&gt; students_vec; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; str &gt;&gt; score; if (students_map.find(str) != students_map.end())&#123; // 避免创建新的学生 students_map[str].gf = score; if (students_map[str].gm &gt; students_map[str].gf) students_map[str].g = round(students_map[str].gm * 0.4 + students_map[str].gf * 0.6); else students_map[str].g = students_map[str].gf; if (students_map[str].g &gt;= 60) students_vec.push_back(students_map[str]); &#125; &#125; sort(students_vec.begin(), students_vec.end(), studentCmp); for (auto it = students_vec.begin(); it != students_vec.end(); it++) printf("%s %d %d %d %d\n", it-&gt;id.c_str(), it-&gt;gp, it-&gt;gm, it-&gt;gf, it-&gt;g); return 0;&#125; 参考链接https://blog.csdn.net/weixin_44385565/article/details/88669948 https://blog.csdn.net/liuchuo/article/details/79064895 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOLO(SOLO: Segmenting Objects by Locations)论文阅读笔记]]></title>
    <url>%2F2020%2F08%2F16%2FSOLO-SOLO-Segmenting-Objects-by-Locations-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[以下为我总结出的论文各部分的主要内容，某些地方可能夹带着一些自己的理解和思考。 [TOC] 摘要 本文内容：SOLO 提出新的、非常简单的实例分割方法SOLO 与许多其他密集预测任务（比如语义分割）相比，实例分割的难点 实例数量的不确定性 实例分割的主流方法，把实例分割任务分解为2个分类任务 先检测后分割，比如Mask R-CNN 先预测embedding vector，然后通过聚类将像素分组成独立实例 本文提出的SOLO的方法 引入“instance categories”的概念：根据实例的位置和大小为实例中的每个像素分配类别，从而很好地将实例分割转换为分类问题 SOLO的性能 精度与Mask R-CNN持平，比最近的其它single-shot实例分割算法要高。 1. 引言 实例分割的难点 语义分割可以视为给每个像素分类的任务，但由于实例数量的不确定性，导致语义分割等任务的方法不能在实例分割中奏效。 实例分割算法分类及其优缺点 为克服上面提到的实例分割的难点，最近的实例风格算法（也就是摘要提到的主流方法）可分为两类，缺点是step-wise、indirect top-down 思路 ‘detect-then-segment’，先检测矩形边界框，然后在每个矩形框内做分割 缺点 严重依赖精准的矩形检测框 bottom-up 思路 通过push属于不同实例的像素并close同一实例中的像素来学习affinity relation（亲和关系），为每个像素分配embedding vector，然后通过分组后处理以分离实例。 缺点 依赖像素级的embedding learning和分组后处理 SOLO 基于实例分割标注（有监督训练），直接预测实例的掩码 rethinking 图片中的物体实例的根本区别是什么？ 以MSCOCO为例，绝大多数情况下，图片中的两个实例要么有不同的中心位置、要么有不同尺寸，数据分析如下： 98.3%的object pair（实例对）的中心的距离超过30个像素 剩下的1.7%，其中40.5%的实例对的大小比例大于1.5 所以可以直接通过中心位置和大小区分实例 模仿语义分析主流方法 语义分析主流方法是用FCN（全卷积神经网络）输出N个通道，每个通道负责一个语义类别 SOLO模仿语义分析使用FCN的方法，提出“instance categories”的概念，即量化的中心位置center locations和实例大小object sizes 个人思考：这不是和YOLO很像吗？？ Locations SOLO如何处理Locations，即实例的位置 SOLO把一张图片分成a grid of S×S cells（S×S个单元格）即得到S×S个center location classes。 SOLO根据实例的中心坐标为每个实例分配one of the grid cells，作为该实例的center location category DeepMask and TensorMask，pack the mask into the channel axis。SOLO将center location category编码为channel axis，类似于语义分割中的语义类别。输出的每个channel代表一个center location category，预测属于这个center location category的实例的掩码。 SOLO这样处理Location的作用 本质上，instance category近似于center location。因此，把每个像素分类到instance category其中，等效于使用回归从每个像素预测center location。 将location预测任务转换为分类而不是回归的重要性在于，通过分类，使用固定数量的通道对不同数量的实例进行建模更加简单明了，同时又不依赖于grouping或者learning embeddings等后处理 个人思考：前文强调了实例分割任务中实例的数量是不确定的，导致实例分割很难，可以猜测是之前的方法是回归，处理实例数量不确定这个情况的方法并不优雅 Sizes SOLO如何处理Sizes，即实例的大小 使用特征金字塔网络FPN，为大小不同的实例分配对应大小的特征图，作为其object size classes。 注意FPN旨在检测图像中不同大小的实例。在之后，我们根据经验证明FPN是SOLO的核心组成部分，对分割性能（尤其是大小不同的目标）产生深远影响。 总结 SOLO只需要分割标注，不需要框标注（目前多数方法是需要的），即可完成实例分割 在COCO上的性能，摘要里讲过 通用性：我们通过实例轮廓检测的任务展示了我们框架的通用性，将实例边缘轮廓视为one-hot的二进制掩码，几乎没有任何修改，SOLO可以生成合理的实例轮廓。 SOLO只需解决两个像素级分类任务 和语义分割一样，所以可以再参考语义分割领域的进步，提高SOLO 本质上，SOLO通过离散量化将坐标回归转换为分类 避免了通常在诸如YOLO之类的检测器中使用的坐标规范化和对数转换 2. 相关工作回顾了一些和SOLO最相近的实例分割工作 Top-down Instance SegmentationSOLO和下面的方法相比， 不受限于anchor和box 典型方法 在边界框里做分割 FCIS FCIS：由region proposal network（RPN）生成的ROI中assemble（计算?）position-sensitive score maps，以预测实例掩码。 Mask R-CNN 扩展Faster R-CNN，具体来讲是在其中添加一个branch（用于在检测到的边界框中分割实例） PANet 基于Mask R-CNN，进一步增强了特征表示以提高准确性 Mask Scoring R-CNN 基于Mask R-CNN，添加了mask-IoU分支（预测所预测的掩码的质量并对掩码进行评分）以提高性能。 TensorMask 采用dense sliding window方法，通过预定义的windows和scales在每个像素的本地窗口中分割实例 Bottom-up Instance Segmentation这类方法通过将像素分组为图像中的实例（任意数量）来进行实例分割，可通过损失函数实现，这类方法的精度一般比Top-down的要低，特别是有复杂场景和语义类别的图片。 SGN 把语义分割分解为一系列分组问题 SSAP 学习像素对相关性金字塔，即两个像素属于同一实例的概率，并通过级联图分区顺序生成实例掩码。 Direct Instance Segmentation目前没有这种方法，最近提出的一些方法被视为‘semi-direct’（半直接）。 这两个方法都是分步骤的，或者是折中的（比如粗略表示掩码） AdaptIS 先预测点，然后生成位于这些点中的实例的实例的掩码 PolarMask PolarMask提出使用极坐标表示来编码掩码，并将每个像素的掩码预测转换为距离回归。 本文SOLO 图片作为输入，直接输出掩码和概率；全卷积；不需要box不需要分组也不需要ROI等 3. 我们的方法SOLO3.1 问题表述 实例分割做什么 给定一张图片，如果其中存在实例，要求返回实例的掩码 SOLO 将实例分割任务分为两个同时的任务：category-aware prediction和instance-aware mask generation 把图片分成a uniform grids（S×S），如果物体中心在某个grid cell中，那这个grid cell负责预测语义类别和掩码 3.1.1 语义类别 对于每个grid，SOLO都会预测C维输出表示语义类别概率，其中C是类别数，这些概率取决于grid cell。 如果将输入图像划分为S×S grids，则输出空间将为S×S×C，如图2（顶部）所示。 该设计基于以下假设：each cell of S×S grids必须属于一个单独的实例，因此仅属于一个语义类别。 这个假设很重要 在推理期间，C维输出表示每个对象实例的各类概率。 3.1.2 实例掩码 与语义类别预测并行，每个正grid cell还将生成相应的实例掩码。 对于输入图像I，如果将其划分为S×S grids，则总共最多会有$S^2$个预测的掩码。我们在3D输出张量的第3维（通道）上显式编码这些掩码。具体而言，实例掩码输出的尺寸为$H_I×W_I×S^2$，第k个通道将负责在grid(i,j)处分割实例，其中k = i·S + j（i和j从零开始）。为此，在语义类别和与类无关的掩码之间建立了一对一的对应关系（图2）。 预测实例掩码的直接方法是采用完全卷积网络，例如语义分割中的FCN。 FCN的缺点，这一点不是很懂 常规的卷积运算在某种程度上在空间上是不变的，空间不变性对于某些任务（例如图像分类）是理想的，因为它会引入鲁棒性。 但是，这里我们需要一个空间变化（spatially variant）的模型，或者更精确地说，是位置敏感的模型，因为我们的分割掩码的条件是网格单元和必须由不同的功能通道分隔。 最后还要进行NMS 3.2. 网络结构 FPN会为每个级别生成具有不同大小的特征图金字塔，并具有固定数量的通道（通常为256-d）。网格数可能在不同的金字塔上有所不同。 这些特征图用作每个预测头的输入：语义类别和实例掩码。 头部的权重在不同级别上共享。 3.3 SOLO Learning3.3.1 标签分配 正负样本 如果网格（i，j）在任一个实例的中心区域，则视其为正样本；否则，它为负样本。 中心区域 center (cx, cy)，factor，中心区域为(cx, cy, w×factor, h×factor)，factor=0.2 3.3.2 损失函数 损失函数 L = Lcate + λLmask 3.4. 推理 给定输入图像，然后通过骨干网络和FPN推理，并获得网格（i，j）处的类别得分pi，j和相应的掩码mk，其中k = i·S + j，因为我们通常保持行优先（有效）。 使用置信度阈值0.1来过滤低置信度的预测，然后选择得分排名前500位的掩码，并将其输入到NMS操作中，使用阈值0.5将预测的软掩码二进制化，保留前100个实例蒙版进行评估。 4. 实验 测试集：COCO 训练细节 synchronized SGD 8 GPUs with a total of 16 images per mini-batch、 36 epochs initial learning rate of 0.01，which is then divided by 10 at 27th and again at 33th epoch All models are initialized from ImageNet pre-trained weights 比例抖动：较短的图像边从640到800像素中随机采样。 4.1. 主要结果引言和摘要里讲过 4.2. SOLO如何工作/起效？核心在图4，可以看到预测出的掩码。每个网格将仅对应一个实例，多个相邻的掩码通道可以预测同一个实例，最后使用NMS抑制这些冗余掩码。 4.3. Ablation Experiments Grid number 在MS COCO上，S = 12已经可以达到27.2 AP。 将网格数提高到24时，SOLO获得29.0 AP。此结果表明，我们的单比例SOLO可适用于对象比例变化不大的某些场景。 Multi-level Prediction 单尺度SOLO在分割多尺度实例方面遇到了困难，使用FPN的多级预测可以很大程度上解决此问题，获得了35.8 AP，分割效果的所有指标均得到了很大的改善。 CoordConv 标准卷积可以在某种程度上具有空间变异性，两个或多个CoordConv无法带来明显的改善。 这表明单个CoordConv已经使预测对空间变体/位置敏感。 Loss function Focal Loss比BCE要好，因为实例掩码的大多数像素都在背景中，而FL可通过减少分类良好的样本的损失来减轻样本不平衡问题。但DL最好，而无需手动调整损耗超参数。 通过仔细调整平衡超参数并引入其他训练技巧，可以大大改善BCE和FL的结果。 但是，这里的要点是，DL使训练通常变得更加稳定，并且在不使用大量启发式方法的情况下更有可能获得良好的效果。 BCE 正样本的掩码损失权重设置为10，将像素权重设置为2 FL 掩码损失权重设置为20 DL Dice Loss可将像素视为一个整体，并可以自动在前景像素和背景像素之间建立适当的平衡。 4.4. SOLO-512较小SOLO版本，输入分辨率较小，旨在加快推理速度。SOLO-512和SOLO之间的其他训练和测试参数相同。 34.2 mask AP，SOLO-512达到了22.5 FPS的模型推断速度 5. Decoupled SOLO output space is decreased from H×W×$S^2$ to H×W×2S 表7所示，Decoupled SOLO的性能与普通SOLO相同,由于输出空间大大减少，因此在训练和测试期间，Decoupled SOLO需要的GPU内存要少得多。 6. 错误分析表8，对于每个预测的二进制掩码，我们用标注计算IoU，然后用最重叠的标注替换。 SOLO AP：37.1 Ground Truth AP：68.1 7. SOLO for 实例轮廓检测 改变掩码预测分支的优化目标 使用OpenCV的findContours函数将COCO中的标注转换为实例轮廓，然后使用该轮廓优化掩码分支。 使用Focal Loss来优化轮廓检测，其他设置与实例分割基线相同。 8. 结论 与Mask R-CNN相比，具有竞争优势。 端到端可训练，以恒定推理时间将输入图像直接映射到所需的实例掩码。 首次引入“实例类别”这一新概念，将实例分割变为为简单的分类任务，从而比所有当前方法都更加简单。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>论文笔记</tag>
        <tag>SOLO</tag>
        <tag>实例分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COCO(Microsoft COCO: Common Objects in Context)论文阅读笔记]]></title>
    <url>%2F2020%2F08%2F16%2FCOCO-Microsoft-COCO-Common-Objects-in-Context-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[以下为我总结出的论文各部分的主要内容，某些地方可能夹带着一些自己的理解和思考。 [toc] 摘要 该论文/该数据集的目的 推动目标识别领域的技术突破 数据集概要 320k张图片，250万个实例，91种实例类型 标注类型：实例分割 该数据集的主要创新：实例是放在natural context中的，并且语境有很多种而非人为定义的背景中，看Fig1就懂这一点创新了 本文工作 制作该数据集 统计分析该数据集，并与其它3个数据集做比较 使用DPM，提供该数据集的目标检测和实例分割的baseline，并分析其performance 引言 场景理解包含的任务 图像分类：识别目标的种类 定位：定位2D或3D目标 确定目标和场景的属性 描述物体间的关系 提供场景的语义描述 该数据集解决场景理解中3个核心研究问题 检测非图标的目标。图标型目标，比如百度搜到的那种自行车，绝大多数都是背景很空，中间放了个自行车；自然型目标，比如人在骑自行车，停车场中的自行车，背景、语义的差异是极大的。可以看Fig.2 对象之间的上下文推理，即上面第4个任务 目标的精确2D定位，即上面第2个任务中的实例分割 假设存在的问题并在该数据集上证明 现在的视觉识别系统识别图标型目标的能力相当好，但识别自然场景中的目标的能力却不好 一个观点 理解目标的空间位置关系，将成为场景分析的核心部分 数据集里的图片怎么来的？ 搜索两个目标 搜索场景 在标注时，分步进行，由于标注工作的不确定性在每个阶段中做了很多权衡 和其它数据集的区别，详见Fig.5 和ImageNet对比，COCO有更少类别，但每个类别有更多实例，更有利于目标的定位 和ImageNet、VOC、SUN相比，该数据集每个类别都有更多实例，更关键的是每张图中实例更多，有利于学习目标间的关系 和ImageNet相比、VOC相比，该数据集每张图里的实例更多；SUN一张图里的实例则比该数据集高，但整体上数据集中的实例更少。 相关工作该数据集依次解决3个问题： 图像分类 目标检测 semantic scene labeling 图像分类 图像分类做什么 给出二进制标签，指出图片中是否包含某目标，见Fig1(a) 进展 MNIST、COIL等数量少，甚至只有一种类别 CIFAR-10 and CIFAR-100，类别多了些，但还很少且是入门级别entry-level，和人类认知相差很多 ImageNet突然实现数量和类别（both entry-level and fine-grained）的大增长 目标检测 目标检测做什么 识别并定位某物体，典型的定位方式是矩形框，见Fig.1(b) 发展 人脸识别，先是各种临时数据集，后来出现了更复杂的 行人识别，Caltech Pedestrian Dataset 基础目标识别，2005到2012年多年努力，VOC数据集 语义分割 语义分割做什么 确定图片里每个像素属于什么类别，即使是“背景”，见Fig.1(c) 发展 很难标注，比如草、街道；有室内和室外的数据集；有些数据集还有深度信息（什么意思？没懂） SUN数据集，长尾现象（类别数量不平衡，比如wall有20213个，但boat只有349个） 该数据集（COCO）保证每个类别有大量实例 其它视觉数据集 Middlebury datasets，立体视觉，多视图立体，光流 Berkeley Segmentation Data Set(BSDS500)，分割，边缘检测 图片收集如何选择目标的类别以及候选图片 常见目标类别 对类别的要求 所有类别中有代表性的那些类别 和现实应用相关 高频出现以保证数据集数据多 其它类别 是否要包括stuff、thing，是否要包括细粒度（Fine-grained）、对象部分（object-part） thing：很容易区分和标注，比如person、chair。该数据集中做了标注 stuff：没有明显边界，比如sky、street、grass。 该数据集中没有标注，stuff包含了重要的上下文信息，对其标注是有益的，这一点可以改进 类别细分度 例：牧羊犬是狗，狗也是哺乳动物 为使方案可行，并且保证每个类别有大量实例，该数据集的类别选择entry-level，入门级别，即人们普遍使用的类别，dog、chair、person 对象部分 预计将包含对象部分类别，比如face、hands、wheels，它们有益于现实应用 确定类别 PASCAL VOC+a subset of the 1200 most frequently used words that denote visually identifiable objects 让4到8岁的小孩说出他们在室内外看到的物体 合著者投票5级制投票，考虑是否常用、现实应用价值、与其它类别的差异程度 根据投票结果选择，同时保证每个类别实例数量均匀且充足。为保证向后兼容，VOC的所有类别都被包含了 最终得到91个类别 非图标图片收集 将图片分为3类 iconic object images，通过谷歌和必应图片搜索可以很方便地找到 iconic scene images non-iconic images，目标是主要收集这些图片 收集non-iconic images，两个策略 像VOC一样，从Flickr中收集，其中的图片有可以搜索的原数据和关键词 成对搜索类别，比如dog + car，搜索结果一般都是non-iconic images，甚至图片里不只这两个类别 还有scene/object category pairs 如果找不到足够的图片，就单独搜索类别然后筛选出non-iconic images 图片标注如何标注收集到的图片 标注pipeline，见Fig3 类别标注 实例定位 实例分割 对于众包任务，标注人员，来自Amazon’s Mechanical Turk (AMT)，用户接口见附录 提高标注质量 类别标注和实例定位这两个阶段的标注人员增加到8个 增加一个阶段验证实例分割的标注结果 类别标注 类别标注做什么 确定图片里有哪些类别，Fig3(a)，大致标出位置 类别标注怎么做 分级/分步：把91个类别分为11个父类 只需标出图片里有哪些类别，比如有多个dog，标出一个即可。 给定图像，向标注人员依次显示每组类别，并要求其指示是否存在该父类的实例。 如果某标注人员负责从父类（比如动物）中确定存在实例，则对于存在的每个下属类别（狗，猫等），工作人员必须将类别的图标拖到该类别的一个实例上的图像上。 共8个标注人员负责这项工作，如果有任何标注人员指出该类别，则认为该类别存在（提高recall）；误报将在后续阶段处理。 类别标注耗时多久 这个阶段耗时20000工时 实例定位 实例定位做什么 基于上一步类别标注的结果，标注图像中对象类别的所有实例，大致位置，如果有多个dog，都要标注出来。Fig3(b) 实例定位怎么做 标注人员在上一个阶段中找到的特定类别的每个实例的顶部放置一个叉号 标注人员可以用放大镜去找到小的实例 每个工作人员被要求为每个图像标记最多10个给定类别的实例。 实例定位耗时多久 每个图像由8名工人标记，总计约10,000个工时 实例分割 实例分割做什么 基于上一步实例定位的结果， 实例分割怎么做 修改了Bell等人开发的用户接口， 如果在图像中已经对其他实例进行了分割，则将这些分割显示给工作人员。 工作人员还可能指示图像中没有给定类别的对象实例（这意味着来自上一阶段的假肯定标签），或者所有对象实例都已被分割。 为最小化成本，每个实例仅有一名标注人员分割 初步标注出的质量不高，所以训练标注人员，标注人员和标注结果的质量提高了 要求多个工作人员（3至5名）判断每个标注，并表明其是否与实例完全匹配。质量不高的标注将被丢弃，并将相应的实例添加回未标注的对象池中。 一些批准的工人总是生成差劲的标注；从这些工人那里获得的所有工作都被丢弃 如果实例很密集，比如人群、一车香蕉，就会标注为一个“crowds”（出于评估目的，标记为crowds的区域将被忽略，并且不会影响探测器的得分） 实例分割耗时多久 22 worker hours per 1,000 segmentations. 标注性能分析 10个标注人员和7个专家标注对比（其实是合著者） Ground Truth根据专家的标注确定，10个标注人员的recall更高，见Fig4(a) 测评中recall更关键，因为错误标注可以在之后去掉 大多数标注人员具有很高的precision；这些标注人员通常会完成更多工作，见Fig4(b) Caption Annotation 为每张图片提供5个说明注释，这一版本的数据集不久后发布 数据统计和ImageNet, PASCAL VOC 2012, and SUN进行对比 各自特点 ImageNet：类别多且很多是细粒度的 SUN：关注场景类型及其中的常见目标 VOC：主要应用于自然图片的目标检测 COCO：自然图片中的目标检测和分割 其它内容就是Fig5，以及前面引言INtroduction里对数据集本身的描述 Fig5 每个类别的实例的数量，比较均匀 每张图片里的类别的数量，ImageNet和VOC多数只有1或2个类别，而COCO多数有1-6个类别 每张图片里的实例的数量，SUN最多，ImageNet和VOC多数是1-2个，COCO多数是1-5个 类别数量VS实例数量，越靠右上角越复杂 实例在图片中的占比（尺寸维度），几个数据集差不多，50%以上的目标都不超过图片尺寸的10% 数据集划分为更快发行数据集，COCO被分成大致等量的两部分 第一部分，2014公开，82783训练，40504验证，40775测试 第二部分，2015公开，165,482 train, 81,208 val, and 81,434 test images. 训练和验证的标注会公开，但测试集的标注不会公开 算法分析目标框检测 从COCO中选55k张图片，根据分割标注进行tight-fitting得到矩形框 在COCO和VOC上测试数据集 测试两个模型：DPMv5-P和DPMv5-C。P指在PascalVOC2012上训练的。C指在COCO（5000正样本，10000负样本）上训练的，使用默认设置训练COCO的模型。 两个模型在两个数据集上进行测试，在COCO上的性能都比在VOC上的性能低（见Table1），指出COCO包含更多难的图片。 关于训练集对性能的影响的结论：文中指出在训练过程中包含困难（非图标）图像可能并不总是有帮助，如果该模型不够丰富，无法捕获此类外观可变性，则此类示例可能会充当噪声并污染学习的模型。 我们的数据集允许探索此类问题。 一个结论：根据实验，模型在MS COCO的总体性能要低得多。这些观察结果支持两个假设：1）MS COCO比PASCAL VOC困难得多，并且2）在有更多训练数据的情况下，在MS COCO上训练的模型可以更好地推广到更容易的数据集，例如PASCAL VOC。 基于检测框生成分割 对每个类别，学习其像素级掩码，方式是将训练得到的实例（框）对齐，然后平均，见Fig7 通过分割评估检测 现在有分割标注，通过tight-fitting得到矩形框1，以预测（检测）的分割tight-fitting得到的矩形框2和矩形框1的交并比应大于等于0.5为标准，见Fig8 结论 即使预测和标签的真实边界框重叠得很好，预测的分割也可能无法恢复对象细节，见Fig9左 Fig9中的结论没怎么看懂，大概是说即使标注及其矩形框IOU很大，也还是难以预测 Fig9右，在COCO上测试，正确预测的平均交并比也都不高，基本不超0.5，这一点也不是很懂 讨论又强调了一些东西 over 70,000 worker hours non-iconic images of objects in natural environments and varied viewpoints. rich contextual information 未来展望/方向： 现在没有标注stuff，未来可以标注 附录 detailed descriptions of the AMT user interfaces the full list of OBJECT &amp; SCENE CATEGORIES 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>论文笔记</tag>
        <tag>COCO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1141PAT Ranking of Institutions]]></title>
    <url>%2F2020%2F08%2F11%2FPAT%E7%94%B2%E7%BA%A71141PAT-Ranking-of-Institutions%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184 题解题目要求n个考生，每个考生信息为： ID 6个字符的字符串，第一位是考试等级（B、A、T） score 分数，[0,100]的整数 school 不超6位的学校码，由英文字母组成，不区分大小写，但输入中有大小写 请输出： 第一行输出学校的数量 然后按rank的非降序输出Rank School TWS Ns rank是排名，从1开始，根据TWS非升序排序。 如果TWS相等，则两校的rank也相等，且应按NS增序输出；如果Ns也相等，则按学校码的字母表顺序输出 school是学校码，用小写输出 TWS是加权分，等于该校B级考生总分/1.5+该校A级考生总分+该校T级考生总分*1.5，只取计算结果的整数部分 Ns是该校的考生数 思路 注意将学校码转换为小写 输出顺序有两方面： 如果TWS相等，则两校的rank也相等，这一点要在最后控制 其它输出顺序通过sort函数使用的cmp函数控制 我这里是使用了一个map，最后存入vector排序；也可以使用两个map（键都为学校码），一个存每个TWS，一个存Ns，最后都存入vector 我计算TWS的方法比较麻烦，因为刚开始理解错了TWS的公式 用map而不是unorder_map的话，最后一个测试点会超时 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Problem: PAT Advanced 1141// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184// Tags: map unordered_map sort#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;struct School&#123; string code; // 小写的学校码 double testeeScoreSums[3] = &#123;0, 0, 0&#125;; int TWS; int Ns = 0; void calcTWS()&#123; this-&gt;TWS = testeeScoreSums[0] / 1.5 + testeeScoreSums[1] + testeeScoreSums[2] * 1.5; &#125;&#125;;// 按照要求比较两个学校// 根据TWS非升序排序。如果TWS相等，则按Ns增序输出；如果Ns也相等，则按学校码的字母表顺序输出bool schoolCmp(School &amp;s1, School &amp;s2)&#123; if (s1.TWS == s2.TWS) if (s1.Ns == s2.Ns) return s1.code &lt; s2.code; else return s1.Ns &lt; s2.Ns; else return s1.TWS &gt; s2.TWS;&#125;int main()&#123; int n, score; // the number of testees, the score of a testee string id, schoolCode, testLevels="BAT"; // the id of a testee, the school of a testee, three test levels unordered_map&lt;string, School&gt; schoolsMap; // 键为学校码，值为学校 // 获取输入 cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; id &gt;&gt; score &gt;&gt; schoolCode; transform(schoolCode.begin(), schoolCode.end(), schoolCode.begin(), ::tolower); // 将学校码转为小写 schoolsMap[schoolCode].code = schoolCode; for (int j = 0; j &lt; 3; j++) if(id[0] == testLevels[j])&#123; schoolsMap[schoolCode].testeeScoreSums[j] += score; // 分别统计该校三个等级考生的总分 schoolsMap[schoolCode].Ns += 1; // 统计该校考生数 break; &#125; &#125; // 将学校存入vector并排序 vector&lt;School&gt; schools; for (unordered_map&lt;string, School&gt;::iterator it = schoolsMap.begin(); it != schoolsMap.end(); it++)&#123; it-&gt;second.calcTWS(); schools.push_back(it-&gt;second); &#125; sort(schools.begin(), schools.end(), schoolCmp); // 输出结果，如果TWS相等，则两校的rank也相等，其它输出顺序要求已通过schoolCmp控制 int schoolNum = schools.size(), rank = 1; printf("%d\n%d %s %d %d\n", schoolNum, rank, schools[0].code.c_str(), schools[0].TWS, schools[0].Ns); for (int i = 1; i &lt; schoolNum; i++)&#123; if(schools[i].TWS &lt; schools[i-1].TWS) rank = i+1; printf("%d %s %d %d\n", rank, schools[i].code.c_str(), schools[i].TWS, schools[i].Ns); &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1153Decode Registration Card of PAT]]></title>
    <url>%2F2020%2F08%2F10%2FPAT%E7%94%B2%E7%BA%A71153Decode-Registration-Card-of-PAT%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/1071785190929788928 题解题目要求和思路PAT注册号分4个部分： 第1位字母代表考试等级 第2到4位数字是考试地点，大小从101到999 第5到10位数字为考试日期 第11到13位数字是考生号，大小从000到999 1：给定考试等级，要求输出该考试等级所有考生的注册号和分数（注册号升序，分数非升序） 遍历找出指定考试等级的考生，然后排序输出 2：给定考试地点，要求输出该考试地点中考生数和考生分数之和 遍历找出指定考试地点的考生，然后统计数据 3：给定考试时间，要求输出每个考试地点的考生数（考试地点升序，考生数非升序） 遍历考生， 统计每个考试地点的考生数到unordered_map里（统计到map里会超时），键是考试地点，值是考生数，然后输出（我这里是先存入vector再输出） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// Problem: PAT Advanced 1153// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785190929788928// Tags: map unordered_map sort#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;using namespace std;// 保存参试者的信息和最终要输出的结果struct Node&#123; string str; int val;&#125;;bool nodeCmp(Node&amp; t1, Node&amp; t2)&#123; return t1.val == t2.val ? t1.str &lt; t2.str : t1.val &gt; t2.val;&#125;int main()&#123; // 获取考生信息 int n, m; // 输入和查询的数量 cin &gt;&gt; n &gt;&gt; m; vector&lt;Node&gt; testees(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; testees[i].str &gt;&gt; testees[i].val; // 获取要求并求解 int type; string term; for (int caseIndex = 1; caseIndex &lt;= m; caseIndex++)&#123; // 获取要求 cin &gt;&gt; type &gt;&gt; term; printf("Case %d: %d %s\n", caseIndex, type, term.c_str()); // type为1和3时的结果 vector&lt;Node&gt; results; switch (type)&#123; case 1 : &#123; for ( int i = 0; i &lt; n; i++) if (testees[i].str[0] == term[0]) results.push_back(testees[i]); break; &#125; case 2 : &#123; int testeeNum = 0, testeeScoreSum = 0; for (int i = 0; i &lt; n; i++) if (testees[i].str.substr(1, 3) == term)&#123; testeeNum += 1; testeeScoreSum += testees[i].val; &#125; if (testeeNum == 0 &amp;&amp; testeeScoreSum == 0) printf("NA\n"); else printf("%d %d\n", testeeNum, testeeScoreSum); break; &#125; case 3 : &#123; unordered_map&lt;string, int&gt; statistics; for (int i = 0; i &lt; n; i++) if (testees[i].str.substr(4, 6) == term) statistics[testees[i].str.substr(1, 3)] += 1; for (auto it : statistics) results.push_back(&#123;it.first, it.second&#125;); &#125; &#125; if (type == 1 || type == 3)&#123; if (results.empty()) printf("NA\n"); else&#123; sort(results.begin(), results.end(), nodeCmp); for (int i = 0; i &lt; results.size(); i++) printf("%s %d\n", results[i].str.c_str(), results[i].val); &#125; &#125; &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python语言通过PyQt5和socket实现UDP服务器]]></title>
    <url>%2F2020%2F08%2F10%2F%E4%BD%BF%E7%94%A8Python%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87PyQt5%E5%92%8Csocket%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言最近做了一个小软件，记录一下相关内容。 已有条件现在已有一个硬件设备作为客户端（暂称其为“电路”）。 基于SIM卡，电路可以通过UDP协议传输数据（程序已经内置在电路中），只需要修改配置文件（位于SD卡中，主要修改服务器端的IP和端口）即可。 需求我面向的需求是这样的：我需要开发一个服务器端的程序，接收多个客户端发来的数据并开发可视化界面。 总结从开发角度和技术角度来看，软件的基础和核心技术是使用UDP协议进行数据传输，并使用PyQt5和pyqtgraph做可视化界面（还用到了QThread和自定义的下拉复选框），开发过程中还涉及到了内网穿透和NATAPP。 理论基础：运输层为使用UDP协议进行数据传输，我大致复习了一下计算机网络中的运输层。 功能运输层实现两台主机中进程之间的通信，一个主机中的多个进程可以和另一台主机中的多个进程通信。 运输层实现上述功能的方案是端口（port） 两个主要协议运输层有两个主要协议： 传输控制协议TCP（Transmission Control Protocol） 用户数据报协议UDP（User Datagram Protocol） TCP TCP是面向连接的 应用进程在传输数据前必须先建立连接，数据传送结束后要释放连接 TCP连接是点对点的 每一条TCP连接只能有两个端点 TCP不提供广播或多播服务 TCP提供可靠交付的服务 通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达 TCP面向字节流 虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成一连串的无结构的字节流。 TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小 TCP保证接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样，同时接收方应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据 UDP UDP是无连接的 在传输数据前不需要先建立连接，主机在收到UDP报文后不需要给出任何确认 UDP是面向报文的 发送方：UDP对应用层交下来的报文，不合并也不拆分，添加首部后就交付给IP层 接收方：UDP对IP层交上来的UDP用户数据包，在去除首部后就直接交付给应用层的进程 UDP尽最大努力交付 不保证可靠交付 UDP支持一对一、一对多、多对一和多对多的交互通信 Python中的UDP编程Python中的UDP编程可以通过socket来实现，下面是一个简单样例 服务器端1234567891011121314151617import socketserver_ip = '127.0.0.1'server_port = 9999# 建立套接字s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # socket.SOCK_DGRAM代表是UDP通信# 绑定IP和端口s.bind((server_ip, server_port))print('Bind UDP Server on %s:%s' % (server_ip, server_port))while True: # 接收数据 data, addr = s.recvfrom(1024) print(addr, "\t", data) # 发送数据 s.sendto(b'Received:%s'%data, addr) 客户端123456789101112import socketserver_ip = '127.0.0.1'server_port = 59955s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # socket.SOCK_DGRAM代表是UDP通信for data in [b'Michael', b'Tracy', b'Sarah']: # 发送数据 s.sendto(data, (server_ip, server_port)) # 接收数据 # print(s.recv(1024).decode('utf-8'))s.close() 值得注意的问题：缓冲区机制UDP通信时，两个主机都要建立一个socket。 我这里的情况是客户端会一直给服务器端发数据。 在服务器端我发现socket一旦建立（准确来讲是创建socket对象并绑定至本地端口），就会一直接收数据，而不是调用recvfrom等函数（这类函数用来接收数据）时才会接收。 估计这是缓冲区机制，UDP应该就是这么设计的。大概就是socket对象创建后，收到的内容就会放入缓冲区，如果调用了recvfrom等数据接收函数就从缓冲区中取出数据。 内网穿透为什么要用内网穿透先不讲内网穿透是什么，有兴趣的可以自己去查查，下面我大概讲讲我浅显的理解。 在开发服务器端程序的过程中，我用的是自己的电脑，连接的网络是手机热点（因为在宿舍），因此我的电脑是没有公网IP的。 客户端程序用的是SIM卡，用的是公网（外网）IP，我开发的服务器端程序用的是私网（内网）IP。 公网IP是无法访问私网IP的（因为NAT），所以我需要让我的服务器端程序能够被外网访问。 问了一下@roadwide，他说要用内网穿透，并推荐了NATAPP等软件。 NATAPP的使用怎么用呢？看看官方教程就知道了，链接放在文章末尾了。 讲一个比较关键的点，以理解下NATAPP是干嘛的 NATAPP运行起来后，就会将上图红框里的URL映射到本机（127.0.0.1）的80端口。 NATAPP会给我一个URL（作为我的外网IP），这样客户端程序通过访问NATAPP给我的URL就可以间接访问我在本机运行的服务器端程序。 PyQt5QThread服务器端程序的界面上有两个作用分别是开始接收数据和停止接收数据的按钮。 接收数据是通过一个while循环（循环体中接收一个数据）实现的，如果点击开始接收数据的按钮，那就运行while循环直到停止接收数据的按钮被点击。 刚开始实现数据接收功能时发现程序界面会崩溃、点击不动，因为直接把while循环写在软件主界面的代码中。 后来使用了PyQt5中的QThread（也有人说QThread并不是一个线程），在一个线程中实现while循环，然后就成功了。 在实现时我参考了其他网友的代码，参考链接放在文章末尾，注意一点是实现方式不止一种，比如说有些网友说用threading也可以，而且我也发现我的思路和参考的那份代码稍有不一样（我们实现的功能是相似的，但我只用了一个pyqtSignal，而那位网友用了两个）。 下拉复选框这个软件需要有一个下拉复选框，而PyQt5中并没有这个东西，因此需要手动实现，这里我参考了其他网友的实现方式，参考链接见文章末尾。 参考链接Python中的UDP编程https://blog.csdn.net/vict_wang/article/details/81587093 https://www.jb51.net/article/165933.htm 理解NAT和内网穿透https://baike.baidu.com/item/nat/320024 https://baike.baidu.com/item/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F NATAPPhttps://natapp.cn/# https://natapp.cn/article/natapp_newbie PyQt5 PyQt5下拉式复选框QComboCheckBox https://blog.csdn.net/LJX4ever/article/details/78039318 QThread实现循环 https://segmentfault.com/a/1190000020746912?utm_source=tag-newest AttributeError: ‘PyQt5.QtCore.pyqtSignal’ object has no attribute ‘connect’ pyqtgraph pyqtgraph中绘制多个线条（我实现这个功能时也看了pyqtgraph的example） https://zmister.com/archives/219.html#plot-2 pyqtgraph中添加图例（legend） https://zmister.com/archives/220.html?replytocom=558 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>python</tag>
        <tag>计算机网络</tag>
        <tag>UDP</tag>
        <tag>PyQt5</tag>
        <tag>socket</tag>
        <tag>pyqtgraph</tag>
        <tag>QThread</tag>
        <tag>内网穿透</tag>
        <tag>NATAPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1145Hashing - Average Search Time]]></title>
    <url>%2F2020%2F08%2F07%2FPAT%E7%94%B2%E7%BA%A71145Hashing-Average-Search-Time%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805343236767744 题解基础知识：哈希为做这道题，我简单复习了一下哈希（点击查看）。 题目要求往一个哈希表里插入n个正整数，然后从哈希表里查找m个正整数，请输出平均查找次数（即比较次数） 哈希函数定义为$H(key)= key \% TSize$，其中$TSize$是哈希表的最大容量，它最好是素数，如果输入的不是素数就必须找到大于输入的最小素数。 用二次探测（仅具有正增量）解决冲突。 英语 distinct 截然不同的, 完全分开的 sequence 有关联的一组事物, 一连串 quadratic 二次的，二次方程式 probe n. 探针；调查 vi. 调查；探测 vt. 探查；用探针探测 collision 碰撞, 冲突, 抵触 Quadratic probing (with positive increments only) is used to solve the collisions. 二次探测（仅具有正增量）用于解决冲突。 synonym 同义词 accurate up to 1 decimal place 精确到小数点后1位 注意点 待查找的元素可能不存在 题目说了输入的关键字都是正整数，所以可以把0作为表中某个位置没有元素的标志 注意这里的二次探测再散列只有正增量 查找时间指查找时进行比较的次数，如果没有再探测（即一次就找到了），那比较次数就是1 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Problem: PAT Advanced 1145// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343236767744// Tags: Hash#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool isPrime(int num)&#123; if (num &lt; 2) return false; for (int i = 2; i * i &lt;= num; i++) if (num % i == 0) return false; return true;&#125;int main()&#123; // 获取输入的第一行 int mSize, n, m; // 哈希表最大容量、输入的整数的数量、待查找的整数的数量，都不超过1e4 cin &gt;&gt; mSize &gt;&gt; n &gt;&gt; m; // 建立哈希表 while (!isPrime(mSize)) mSize++; // 使哈希表表长为大于等于输入的最小素数 vector&lt;int&gt; hashTable(mSize); // 哈希表 int key, pos; // 关键字、哈希地址 bool posFound; // 某个key的位置是否找到了 for (int i=0; i &lt; n; i++)&#123; cin &gt;&gt; key; // 获取关键字 posFound = false; for (int j = 0; j &lt; mSize; j++)&#123; // 二次探测再散列（只有正增量） pos = (key + j * j) % mSize; if (hashTable[pos] == 0)&#123; // 这要求key不为0 hashTable[pos] = key; posFound = true; break; &#125; &#125; if (!posFound) printf("%d cannot be inserted.\n", key); &#125; // 查找元素并统计平均查找次数 double count = 0; for (int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; key; for (int j = 0; j &lt;= mSize; j++)&#123; // 题目似乎有问题，应该是j&lt;mSize的，而不是&lt;= pos = (key + j * j) % mSize; count += 1; if (hashTable[pos] == key || hashTable[pos] == 0) // 注意待查找的元素可能不存在 break; &#125; &#125; printf("%.1f", count / m); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-哈希]]></title>
    <url>%2F2020%2F08%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[背景散列（hash）是常见的算法思想之一，在很多程序中都会有意无意地使用到。 若给出$N$个正整数，再给出$M$个正整数，问这M个数中的每个数分别是否在$N$个数出现过，其中$N,M\leq10^5$，且所有正整数均不超过$10^5$。 对这个问题，最直接的思路是：对每个欲查询的正整数$x$，遍历$N$个数，看是否有一个数与x相等。这种做法的时间复杂度是$O(NM)$，当$N$和$M$都很大（$10^5$级别）时，显然是无法承受的。 不妨用空间换时间，即设定一个bool型数组hashTable[100010]，其中hashTable[x]==true表示正整数$x$在$n$个正整数中出现过。这样就可以在一开始读入$N$个正整数时就对hashTable进行赋值，于是对于$M$个欲查询的数，就能直接通过hashTable判断出每个数是否出现过。显然这种做法的时间复杂度为$O(M+N)$。 同样的，如果题目要求统计次数而非是否出现，就把数组改成int型，这两个问题的解法都有一个特点，那就是直接把输入的数作为数组的下标来对这个数的性质进行统计（这种做法非常实用，请务必掌握）。这是一个很好的用空间换时间的策略，因为它将查询的复杂度降到了$O(1)$级别。 但这个策略暂时还有一个问题——上面的题目中出现的每个数都不会超过$10^5$，因此直接作为数组下标是可行的，但是如果输入可能是$10^9$大小的整数，或者甚至是一个字符串，就不能将它们直接作为数组下标了。这时可以使用散列。 散列/哈希简介一般来说，可以精简地将散列定义为“将元素通过一个函数转换为整数，使得该正数可以尽量唯一地代表这个元素”，其中把这个转换函数称为散列函数H，也就是说，如果元素在转换前为key，那么转换后就是一个整数H(key)。 对于key是整数的情况来说，常用的散列函数有直接定址法、平方取中法、除留余数法。 H(key1)==H(key2)，这种情况叫作冲突。常用的解决冲突的方法有线性探查法、平方探查法和链地址法，其中前两种都计算了新的hash值，又称为开放定址法。 在写代码时，这种散列的功能可以用STL中的map代替。 哈希函数、哈希表、哈希地址根据设定的哈希函数$H(key)$和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集上的“像”作为记录在表中的存储位置，这种表便称为哈希表，这一映像过程称为哈希造表或散列，所得存储位置成哈希地址或散列地址。 冲突、同义词不同的关键字经哈希函数映像后求得到的哈希地址可能相同，即$key1\neq key2\ and \ H(key1)=H(key2)$，这就是冲突（collision）；具有相同哈希地址的关键字对该哈希函数来说就是同义词（synonym）。 哈希函数选得合适可以减少冲突现象。 一般情况下，哈希函数是一个压缩映像（关键字集合到地址集合的映像，而关键字集合的大小远大于地址集合），因此冲突只能尽可能地少而不能完全避免。 哈希函数的构造方法常用的构造哈希函数的方法有： 直接定址法 数字分析法 平方取中法 折叠法 除留余数法 随机数法 处理冲突的方法处理冲突过程中会有一个地址序列$H_i,i=1,2,\dots,k$，即如果发生冲突，就去找下一个地址。 通常用的处理冲突的方法有下列几种： 开放定址法 再哈希法 链地址法 建立一个公共溢出区 开放定址法 H_i=(H(key)+d_i)\ MOD\ m \ ，\ i=1,2,\dots, k(k\leq m-1)其中$H(key)$为哈希函数；$m$是哈希表表长；$d_i$为增量序列，可以有下面3种取法： $d_i=1,2,3\dots,m-1$，称为线性探测再散列 $d_i=1^2,-1^2,2^2,-2^2,3^2,\dots,\pm k^2,(k\leq m/2)$，称为二次探测再散列 $d_i=伪随机数序列$，称为伪随机探测再散列 字符串hash一个点$P$的坐标$(x,y)$可以用下面的散列函数进行处理： $H(P)=x\times Range+y$，这样对数据范围内的任意两个整点$P_1$和$P_2$，$H(P_1)$都不会等于$H(P_2)$。 字符串hash是指将一个字符串$S$转换为一个整数,使得该整数可以尽可能地唯一地代表字符串$S$。本节只讨论将字符串转换为唯一的整数。 假设字符串$S$由大写字母$A \sim Z$构成。在这个假设下，可以把26个大写字母视为$0\sim25$，进而转换为二十六进制，再转换为十进制，可得一唯一整数。只是$S$的长度并不可太长。 在上面的假设下，假如还可以由$a\sim z$组成，可以再把$a\sim z$对应为$26\sim51$，进而转换为五十二进制，再转换为十进制。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1133Splitting A Linked List]]></title>
    <url>%2F2020%2F08%2F07%2FPAT%E7%94%B2%E7%BA%A71133Splitting-A-Linked-List%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320 题解题目要求给1个有n（不超过1e5）个结点的单向链表和数字k（不超过1e3），链表的值属于[-1e5,1e5]要求将链表改为（或输出）：负数结点出现在正数结点之前，值属于[0,k]的结点出现在值大于k的结点之前，其余不变## 注意点 PAT中的这种链表适合用数组形式的链表 PAT里的链表和LeetCode里的链表（LeetCode里的链表是基于指针的）不太一样，因此操作也要适当调整 不一定要修改链表结构，能按要求输出就可以 思路用数组表示链表，然后遍历将链表里的结点分成3类（小于0的、0到k的、大于k的）并存入3个数组，然后按顺序遍历3个数组并输出 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Problem: PAT Advanced 1133// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320// Tags: Linked List#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode&#123; int val; int next;&#125;;ListNode list[int(1e5) + 10];vector&lt;int&gt; parts[3];int main()&#123; // 获取输入 int head, n, k; // 头结点地址、结点数量、k cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; int address; for (int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; address; cin &gt;&gt; list[address].val &gt;&gt; list[address].next; &#125; // 遍历链表将其中的结点分为3个部分 int p = head; while(p != -1)&#123; int partIndex = 1; // 默认为第2部分，即结点的值属于[0,k] if (list[p].val &lt; 0) partIndex = 0; else if(list[p].val &gt; k) partIndex = 2; parts[partIndex].push_back(p); p = list[p].next; &#125; // 将划分好的3部分结点输出 bool isFirstLine = true; for (int i = 0; i &lt; 3; i++)&#123; for (int j = 0; j &lt; parts[i].size(); j++)&#123; if (isFirstLine)&#123; printf("%05d %d", parts[i][j], list[parts[i][j]].val); isFirstLine = false; &#125; else printf(" %05d\n%05d %d", parts[i][j], parts[i][j], list[parts[i][j]].val); &#125; &#125; cout &lt;&lt; " -1"; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>单向链表</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1144The Missing Number]]></title>
    <url>%2F2020%2F08%2F06%2FPAT%E7%94%B2%E7%BA%A71144The-Missing-Number%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805343463260160 题解题目要求给n（小于1e5）个int，找到最小的不在这些数字里的正整数 注意点 map未创建某元素时，如果直接访问，则其value是一个默认值 根据输入样例可知n个数字中可以有重复数字 map会按照key自动升序排列 这道题也可以暴力解，创建一个int数组，因为最后要求正整数，所以可以不统计负数 如果这么做，要注意一个边界情况：不缺数字，比如输入了5个数字，分别是1 2 3 4 5 代码12345678910111213141516171819202122232425// Problem: PAT Advanced 1144// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343463260160// Tags: map#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; map&lt;int, int&gt; numCount; int num; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num; numCount[num]++; // 计数，根据输入样例可知n个数字中可以有重复数字 &#125; num = 0; while (++num) // map未创建某元素时，如果直接访问，则其value是一个默认值 if (numCount[num] == 0) break; cout &lt;&lt; num; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1132Cut Integer]]></title>
    <url>%2F2020%2F08%2F06%2FPAT%E7%94%B2%E7%BA%A71132Cut-Integer%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805347145859072 题解给n个k位（k为偶数）的整数z，将其分成a和b，判断z/(a*b)是不是一个整数即可 这里要注意a和b是否为0，这是个边界情况，如果没有处理这个边界情况，有2个测试点不能过，只能得14分 1234567891011121314151617181920212223242526// Problem: PAT Advanced 1132// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347145859072// Tags: Math#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; while (n--)&#123; string z; cin &gt;&gt; z; string a = z.substr(0, z.length() / 2), b = z.substr(z.length() / 2, z.length() / 2); int mul = stoi(a) * stoi(b); if (mul != 0 &amp;&amp; stoi(z) % mul == 0)&#123; cout &lt;&lt; "Yes\n"; &#125; else&#123; cout &lt;&lt; "No\n"; &#125; &#125; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1148Werewolf - Simple Version]]></title>
    <url>%2F2020%2F08%2F05%2FPAT%E7%94%B2%E7%BA%A71148Werewolf-Simple-Version%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/1038429808099098624 题解题目要求N（5到100）个玩家，其中2个狼人，只有1个狼人在撒谎（题目里说至少有1个狼人在撒谎但不是所有狼人都在撒谎……直接讲只有1个狼人在撒谎不行吗……），共有2人撒谎，请找出两个狼人 描述中+则是人类，-则是狼人 如果有解，请按增序输出狼人 如果多个解，则输出最小的 没有讲解则输出”No Solution” 思路刚看完题时没啥思路……特别是有多个解的情况，让我以为要求出所有解，我似乎还想过枚举是谁在撒谎（得到谁在撒谎并不能很有效地得到答案……） 可以枚举狼人是谁的情况，如果与题目和输入相符（1个狼人和1个人在撒谎），则直接输出狼人（如果有多个解，从小到大枚举狼人求得的第一个解就是多个解中最小的解） 123456789101112131415161718192021222324252627282930313233343536373839// Problem: PAT Advanced 1148// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429808099098624// Tags: Math#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; // 获取输入 int n; cin &gt;&gt; n; vector&lt;int&gt; statements(n+1); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; statements[i]; for (int i = 1; i &lt; n; i++)&#123; for(int j = i+1; j &lt;= n; j++)&#123; // 枚举2个狼人是i和j vector&lt;int&gt; identities(n+1, 1); // 玩家身份：1代表人类，-1代表狼人 identities[i] = identities[j] = -1; // i和j是狼人 // 寻找撒谎的玩家 vector&lt;int&gt; liars; for (int k = 1; k &lt; statements.size(); k++)&#123; if (statements[k] * identities[abs(statements[k])] &lt; 0) liars.push_back(k); &#125; // 判断当前枚举的狼人i和j是否符合题目要求和输入 if (liars.size() == 2 &amp;&amp; identities[liars[0]] + identities[liars[1]] == 0)&#123; cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j; return 0; &#125; &#125; &#125; cout &lt;&lt; "No Solution"; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1136A Delayed Palindrome]]></title>
    <url>%2F2020%2F08%2F05%2FPAT%E7%94%B2%E7%BA%A71136A-Delayed-Palindrome%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624 题解一英语 notation 标记法 palindromic 回文的 palindrome 回文 be paired with 与……配对 思路、注意点和代码 要实现回文数判断 要实现字符串逆序 整体思路就是题目描述的那样：判断是不是回文数，不是的话就逆序后和原数相加，重复这一过程直至得到回文数或者超过10次迭代 下面是我刚开始时写的代码，结果是Partially Accepted，得了14分。 1234567891011121314151617181920212223242526272829303132333435// Problem: PAT Advanced 1136// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624// Tags: String#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPalindromic(string s)&#123; int len = s.length(); for (int i = 0; i &lt; len/2; i++) if(s[i] != s[len-1-i]) return false; return true;&#125;int main()&#123; string a_str, b_str, c_str; int a, b, c; cin &gt;&gt; a_str; int N = 10; while (N--)&#123; b_str = string(a_str.rbegin(), a_str.rend()); c_str = to_string(stoi(a_str) + stoi(b_str)); cout &lt;&lt; a_str &lt;&lt; " + " &lt;&lt; b_str &lt;&lt; " = " &lt;&lt; c_str &lt;&lt; endl; if (isPalindromic(c_str))&#123; cout &lt;&lt; c_str &lt;&lt; " is a palindromic number."; return 0; &#125; a_str = c_str; &#125; cout &lt;&lt; "Not found in 10 iterations."; return 0;&#125; 题解二看了下柳婼的代码，和我写的题解一相比，她的代码有以下不同： 她考虑了输入就是回文数的边界情况，我没有考虑，这个测试点占4分 回文数的判断方法不同，她是判断逆序后是否相等，我是遍历判断 她手动实现了字符串数字的加法，而我是将字符串转成数字进而相加，这里我忽略了数值范围，这个测试点占2分 题目说不超过1000位，就算使用longlong也不行，所以必须手动实现字符串相加 基于我刚开始写的题解一和上面分析的内容，正确代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Problem: PAT Advanced 1136// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624// Tags: String Palindrome#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPalindromic(string s)&#123; int len = s.length(); for (int i = 0; i &lt; len/2; i++) if(s[i] != s[len-1-i]) return false; return true;&#125;string addString(string a, string b)&#123; int carry = 0; int sum; for (int i = a.length() - 1; i &gt;= 0; i--) &#123; sum = a[i] - '0' + b[i] - '0' + carry; // 注意进位和'0' a[i] = sum % 10 + '0'; // 注意'0' carry = sum / 10; &#125; if (carry == 1) a = "1" + a; return a;&#125;int main()&#123; string a_str, b_str, c_str; cin &gt;&gt; a_str; if (isPalindromic(a_str))&#123; cout &lt;&lt; a_str &lt;&lt; " is a palindromic number."; return 0; &#125; int N = 10; while (N--)&#123; b_str = string(a_str.rbegin(), a_str.rend()); c_str = addString(a_str, b_str); cout &lt;&lt; a_str &lt;&lt; " + " &lt;&lt; b_str &lt;&lt; " = " &lt;&lt; c_str &lt;&lt; endl; if (isPalindromic(c_str))&#123; cout &lt;&lt; c_str &lt;&lt; " is a palindromic number."; return 0; &#125; a_str = c_str; &#125; cout &lt;&lt; "Not found in 10 iterations."; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>字符串</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1140Look-and-say Sequence]]></title>
    <url>%2F2020%2F08%2F04%2FPAT%E7%94%B2%E7%BA%A71140Look-and-say-Sequence%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/994805344490864640 题解一英语 corresponding to 与…相一致，我之前似乎记成了“根据……” 思路、注意点和代码 题目：第n+1个数字是第n个数字的一种描述 第n+1个串是第n个串中各个数字的统计 统计规则是不好描述，我就不描述了。看样例或者代码就能看出来了 注意点： 按照我的解法的话，要注意处理一种情况：第3个字符串D111的情况 首先D出现了1次，得到D1；然后从第一个1开始统计，直到下标大于字符串长度，这时已经不用再遍历字符串，应保证遍历结束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Problem: PAT Advanced 1140// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344490864640// Tags: String#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;string generateNext(string str)&#123; // 字符串长度 int len = str.length(); // 生成下一个字符串 stringstream next; for (int i = 0; i &lt; len; i++)&#123; // 获取key char key = str[i]; // 统计key出现的次数 int count = 1; // key出现的次数 int j = i + 1; // 作为下标用来循环 while (j &lt; len) &#123; if (key == str[j]) count += 1; else&#123; // 发现了和key不一样的字符str[j]，即该key的数量统计结束，且外层循环应接着从j开始 // i=j-1而非i=j，是因为外层循环结束后i还要++ i = j - 1; break; &#125; j++; &#125; // 将该key及其次数保存至新字符串 next &lt;&lt; key; next &lt;&lt; count; // 处理样例中第3个字符串D111的情况，即内层循环不是通过break结束而是一直循环至j==len的情况 // 这种情况则不用再进行外层循环了，因为最后一个key一直延续到了串的结尾 if (j == len) break; &#125; return next.str();&#125;int main()&#123; // D是0到9 // 第n+1个数字是第n个数字的一种描述 string s; int n; cin &gt;&gt; s &gt;&gt; n; n -= 1; // 用户输入的其实就是第1个串 while (n--)&#123; // cout &lt;&lt; s &lt;&lt; endl; s = generateNext(s); &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 题解二 参考了柳婼的代码，妙啊，她的代码和我上面写的题解一相比，有以下不同： 用j-i实现计数功能，而非像我一样定义变量count进行计数 把s[i]==s[j]放在内层循环的判断条件中，而非像我一样使用if+break语句 外层循环结束后不是i++，而是直接i=j（前提是j此时是下一个待统计字符的下标） 内存循环j从i开始，而非像我一样从i+1开始。这一点是我的想法比较好 参考她的思路后，代码如下： 12345678910111213141516171819202122232425262728// Problem: PAT Advanced 1140// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344490864640// Tags: String#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int main()&#123; string s; // 用户输入的数字，最终结果 int n, j; // 第n个字符串，循环遍历 cin &gt;&gt; s &gt;&gt; n; n -= 1; // 用户输入的其实就是第1个串 while (n--)&#123; string t = ""; for (int i = 0; i &lt; s.length(); i=j)&#123; for (j = i+1; j &lt; s.length() &amp;&amp; s[i] == s[j]; j++); t += s[i]; t += to_string(j - i); &#125; s = t; &#125; cout &lt;&lt; s &lt;&lt; endl; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级1152Google Recruitment]]></title>
    <url>%2F2020%2F08%2F04%2FPAT%E7%94%B2%E7%BA%A71152Google-Recruitment%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805342720868352/problems/1071785055080476672 题解涉及到的英语知识 recruitment 招聘 the first 10-digit prime found in consecutive digits of the natural constant e 由自然常数e的连续数字中的第一个10位素数 prime 素数 consecutive 连续的，连贯的 transcendental number 超越数：在数论中，超越数是指任何一个不是代数数的无理数。只要它不是任何一个有理系数代数方程的根，它即是超越数。最著名的超越数是e以及π。 思路、代码以及注意点 题目要求 题目给出L位的数字N，要求求出其中第一个K位的素数，如果不存在则输出404 提示：开头的0也算是素数的一部分，比如0002应和2等价 思路 遍历字符串并取子串，判断它是否为素数，找到第一个素数即可，找不到的话就输出404 注意点 如果找到了第一个素数，则输出结果时要输出字符串，方便处理0002这种情况 找不到第一个素数，以字符串或者数字形式输出404都可以 123456789101112131415161718192021222324252627282930313233343536// Problem: PAT Advanced 1152// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785055080476672// Tags: String Prime#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPrime(int num);int main()&#123; // 题目给出L位的数字N，要求求出其中第一个K位的素数，如果不存在则输出404 // 提示：开头的0也算是素数的一部分，比如0002应和2等价 int L, K; // 数字位数，所求素数位数 string N; // 数字 cin &gt;&gt; L &gt;&gt; K &gt;&gt; N; for (int i = 0; i &lt;= L - K; i++)&#123; string str = N.substr(i, K); if (isPrime(stoi(str)))&#123; cout &lt;&lt; str &lt;&lt; endl; return 0; &#125; &#125; cout &lt;&lt; 404 &lt;&lt; endl; return 0;&#125;bool isPrime(int num)&#123; if (num&lt;=1) return false; for (int i = 2; i * i &lt;= num; i++) if (num % i == 0) return false; return true;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>字符串</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode230二叉搜索树中第K小的元素]]></title>
    <url>%2F2020%2F08%2F01%2FLeetCode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/ 题解 递归解法 根据BST的性质，中序遍历BST得到的结点序列为结点的升序序列，序列中第k个元素就是第k小的元素。 所以可以中序遍历BST生成升序序列，找到第k个元素则停止遍历。 1234567891011121314151617181920212223242526272829303132333435363738394041// Problem: LeetCode 230// URL: https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/// Tags: Tree BST Recursion DFS// Difficulty: Medium#include &lt;vector&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;private: vector&lt;int&gt; vals; int k;public: // 中序遍历 void inorder(TreeNode* root)&#123; if (root==nullptr) return; // 遍历左子树 inorder(root-&gt;left); // 剪枝：如果已经遍历到第K个元素，则不用再遍历 if (this-&gt;vals.size() &gt;= this-&gt;k) return; // 遍历当前根结点 this-&gt;vals.push_back(root-&gt;val); // 遍历右子树 inorder(root-&gt;right); &#125; // 获取BST中第k小的元素 int kthSmallest(TreeNode* root, int k) &#123; this-&gt;k = k; // 中序遍历生成元素的升序序列 inorder(root); // 结果为升序序列中的第k个元素，下面的两行代码都可以 return this-&gt;vals[k - 1]; // return this-&gt;vals.back(); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode669修剪二叉搜索树]]></title>
    <url>%2F2020%2F08%2F01%2FLeetCode669%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/trim-a-binary-search-tree/ 题解 递归解法 我看了题解写出来的，我分析题目的时候以为还要交换左右子树什么的……，其实不用 思路见代码注释 123456789101112131415161718192021222324252627// Problem: LeetCode 669// URL: https://leetcode-cn.com/problems/trim-a-binary-search-tree/// Tags: Tree BST Recursion// Difficulty: Easystruct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;public: TreeNode* trimBST(TreeNode* root, int L, int R) &#123; // 处理空链表 if (root == nullptr) return nullptr; // 如果根结点小于L，则根结点以及左子树会被剪掉，整个树的修剪结果是修剪后的右子树 if (root-&gt;val &lt; L) return trimBST(root-&gt;right, L, R); // 如果根结点小于L，则根结点以及右子树会被剪掉，整个树的修剪结果是修剪后的左子树 if (root-&gt;val &gt; R) return trimBST(root-&gt;left, L, R); // 根结点不需要修剪，则修剪左右子树 root-&gt;left = trimBST(root-&gt;left, L, R); root-&gt;right = trimBST(root-&gt;right, L, R); // 修剪完成，返回根结点 return root; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode328奇偶链表]]></title>
    <url>%2F2020%2F07%2F31%2FLeetCode328%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/odd-even-linked-list/ 题解 我自己写的 思路是：首先建立两个链表（奇数号结点链表和偶数号结点链表），然后遍历整个链表并通过尾插法构造这两个链表，最后将偶数号结点链表连接到奇数号结点链表尾部即可。 时间复杂度是$O(n)$，空间复杂度是$O(1)$ 具体思路见代码注释 12345678910111213141516171819202122232425262728293031323334353637383940414243// Problem: LeetCode 328// URL: https://leetcode-cn.com/problems/odd-even-linked-list/// Tags: Linked List// Difficulty: Mediumstruct ListNode&#123; int val; ListNode* next;&#125;;class Solution&#123;public: ListNode* oddEvenList(ListNode* head) &#123; // 处理0个、1个或者2个结点的情况 if (head == nullptr || head-&gt;next == nullptr || head-&gt;next-&gt;next == nullptr) return head; // 奇数号结点链表首尾 ListNode *oddHead = head, *oddTail = oddHead; // 偶数号结点链表首尾 ListNode *evenHead = head-&gt;next, *evenTail = evenHead; // 当前结点是第奇数个还是偶数个，true则为第奇数个，false则为第偶数个 bool oddFlag = true; // 从第三个结点开始遍历 head = head-&gt;next-&gt;next; // 遍历链表，将链表分为奇数号结点链表和偶数号结点链表 while(head != nullptr)&#123; if(oddFlag==true)&#123; oddTail-&gt;next = head; oddTail = oddTail-&gt;next; &#125; else&#123; evenTail-&gt;next = head; evenTail = evenTail-&gt;next; &#125; oddFlag = !oddFlag; head = head-&gt;next; &#125; // 连接奇数号结点链表和偶数号结点链表 oddTail-&gt;next = evenHead; evenTail-&gt;next = nullptr; return oddHead; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>单向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode725分隔链表]]></title>
    <url>%2F2020%2F07%2F31%2FLeetCode725%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/split-linked-list-in-parts/ 题解 这题我做了好久 该题抽象出来的话，就是要将n个物体分成k组，要求每组物体数量的差异不超过1。 思路就是先均分成k组，每组n/k（忽略小数位）个元素，剩下了n%k个物体，就把剩下的n%k个物体均分放入n%k个组（在本题中是前n%k个组）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Problem: LeetCode 725// URL: https://leetcode-cn.com/problems/split-linked-list-in-parts/// Tags: Linked List// Difficulty: Medium#include&lt;vector&gt;using namespace std;struct ListNode&#123; int val; ListNode* next;&#125;;class Solution&#123;private: int getLen(ListNode* root)&#123; int len = 0; while(root != nullptr)&#123; len++; root = root-&gt;next; &#125; return len; &#125;public: vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123; vector&lt;ListNode *&gt; result; ListNode *temp = nullptr; // 遍历求链表长度 int n = this-&gt;getLen(root); // 每个part至少quotient个结点 int quotient = n / k; // 剩余remainder个结点，将其平均分配至前remainder个part int remainder = n % k; // 前remainder个part各quotient+1个结点，后k-remainder个结点各quotient个结点 for (int i = 0; i &lt; k; i++)&#123; // 存储该part的头结点 result.push_back(root); // 该part中结点数量 int partCount = remainder &gt; 0 ? quotient + 1 : quotient; // 通过遍历，将root移动到下一个part，同时用temp保存该part的尾结点 for (int j = 0; j &lt; partCount; j++)&#123; temp = root; root = root-&gt;next; &#125; // 断开该part中尾结点与下一part的连接 if (temp != nullptr) temp-&gt;next = nullptr; remainder--; &#125; return result; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>单向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode234回文链表]]></title>
    <url>%2F2020%2F07%2F31%2FLeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/palindrome-linked-list/ 题解一 将链表元素存入数组，然后从首尾遍历 注意如果是空链表，结果也是true 12345678910111213141516171819202122232425262728293031323334// Problem: LeetCode 234// URL: https://leetcode-cn.com/problems/palindrome-linked-list/// Tags: Linked List Two Pointers Recursion// Difficulty: Easy#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode&#123; int val; ListNode* next;&#125;;class Solution&#123;public: bool isPalindrome(ListNode* head) &#123; // 存储链表中的结点 vector&lt;int&gt; vals; while(head != nullptr)&#123; vals.push_back(head-&gt;val); head = head-&gt;next; &#125; // 从首尾两侧遍历 int front = 0, back = vals.size()-1; while(front &lt; back)&#123; if(vals[front] != vals[back]) return false; front++; back--; &#125; return true; &#125;&#125;; 题解二 递归写法，有点牛的 1234567891011121314151617181920212223242526272829303132// Problem: LeetCode 234// URL: https://leetcode-cn.com/problems/palindrome-linked-list/// Tags: Linked List Two Pointers Recursion// Difficulty: Easystruct ListNode&#123; int val; ListNode* next;&#125;;class Solution&#123;private: ListNode* front; bool check(ListNode* node)&#123; if(node != nullptr)&#123; // 先检查尾部 if(!check(node-&gt;next)) return false; // 检查当前结点 if(node-&gt;val != this-&gt;front-&gt;val) return false; // 该结点检查完了，递归使node从后往前，手动从前往后更新front this-&gt;front = this-&gt;front-&gt;next; &#125; return true; &#125;public: bool isPalindrome(ListNode* head) &#123; this-&gt;front = head; return this-&gt;check(head); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>单向链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode445两数相加II]]></title>
    <url>%2F2020%2F07%2F31%2FLeetCode445%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/add-two-numbers-ii/ 题解一 使用了栈，遍历链表把结点存入栈中，然后弹栈将结点相加，注意进位 自己写的思路，代码有些长，应该有递归解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Problem: LeetCode 445// URL: https://leetcode-cn.com/problems/add-two-numbers-ii/description/// Tags: Linked List Stack Recursion// Difficulty: Medium#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;struct ListNode&#123; int val; ListNode* next; ListNode(int x=0) : val(x), next(nullptr) &#123;&#125;&#125;;class Solution&#123;private: int carry=0; // 进位 ListNode* addNode(ListNode* node1, ListNode* node2)&#123; int sum = node1-&gt;val + node2-&gt;val + this-&gt;carry; node1-&gt;val = sum%10; this-&gt;carry = sum / 10; delete node2; return node1; &#125;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; stack&lt;ListNode*&gt; s1; // 使用引用是为了避免不必要的内存开销 stack&lt;ListNode*&gt; s2; // 将两个链表中的结点存入栈中 while (l1!=nullptr)&#123; s1.push(l1); l1 = l1-&gt;next; &#125; while (l2!=nullptr)&#123; s2.push(l2); l2 = l2-&gt;next; &#125; ListNode *newHead; // 将两个链表等长的部分相加 while (!s1.empty() &amp;&amp; !s2.empty())&#123; newHead = this-&gt;addNode(s1.top(), s2.top()); s1.pop(); s2.pop(); &#125; // 如果两个链表不等长，则处理两个链表因不等长而剩余的结点 if (s1.empty()) s1 = s2; ListNode *tempNode; while(!s1.empty())&#123; // 取出一个结点 tempNode = s1.top(); s1.pop(); // 考虑进位 int sum = tempNode-&gt;val + this-&gt;carry; tempNode-&gt;val = sum%10; this-&gt;carry = sum/10; // 将该结点加入链表 tempNode-&gt;next = newHead; newHead = tempNode; &#125; // 考虑最后一次进位 if (this-&gt;carry &gt; 0)&#123; // 将该结点加入链表 tempNode = new ListNode(this-&gt;carry); tempNode-&gt;next = newHead; newHead = tempNode; &#125; return newHead; &#125;&#125;; 题解二 递归解法 需要向短链表中添加结点使其与长链表长度一致，然后递归使链表相加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Problem: LeetCode 445// URL: https://leetcode-cn.com/problems/add-two-numbers-ii/description/// Tags: Linked List Stack Recursion// Difficulty: Medium#include &lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode* next; ListNode(int x=0) : val(x), next(nullptr) &#123;&#125;&#125;;class Solution&#123;private: int carry = 0; // 进位 // 遍历求出链表l有几个结点 int getLen(ListNode* l)&#123; int len=0; while(l!=nullptr)&#123; len++; l = l-&gt;next; &#125; return len; &#125; // 为链表l添加num个值为0的结点 ListNode* addZeroNodes(ListNode* l, int num)&#123; if(num&lt;=0) return l; ListNode* temp; while(num--)&#123; temp = new ListNode(0); temp-&gt;next = l; l = temp; &#125; return l; &#125; // 递归函数 ListNode* addTwoLists(ListNode* l1, ListNode* l2)&#123; if(l1==nullptr || l2==nullptr) return nullptr; // 先使后面的结点相加 addTwoLists(l1-&gt;next, l2-&gt;next); // 将两个结点相加 int sum = l1-&gt;val + l2-&gt;val + this-&gt;carry; l1-&gt;val = sum%10; this-&gt;carry = sum/10; // 释放l2返回l1 delete l2; return l1; &#125;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; // 使两个链表等长 int len1=this-&gt;getLen(l1), len2=this-&gt;getLen(l2); l1 = this-&gt;addZeroNodes(l1, len2 - len1); l2 = this-&gt;addZeroNodes(l2, len1 - len2); // 通过递归使链表相加 l1 = addTwoLists(l1, l2); // 考虑最后一个进位 if(this-&gt;carry &gt; 0)&#123; ListNode* temp = new ListNode(this-&gt;carry); temp-&gt;next = l1; return temp; &#125; return l1; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>栈</tag>
        <tag>单向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode24两两交换链表中的结点]]></title>
    <url>%2F2020%2F07%2F30%2FLeetCode24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/swap-nodes-in-pairs/ 题解 递归解法，我自己写的 要明确函数的功能 函数中需手动处理空链表和链表中只有1个结点的情况；多个结点时，先手动交换前两个结点，然后通过递归交换其它结点 1234567891011121314151617181920212223242526// Problem: LeetCode 24// URL: https://leetcode-cn.com/problems/swap-nodes-in-pairs/// Tags: Linked List Recursion// Difficulty: Medium#include &lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode* next;&#125;;class Solution&#123;public: ListNode* swapPairs(ListNode* head) &#123; // 空链表或只有1个结点 if (head==nullptr || head-&gt;next==nullptr) return head; // 取第2和3个结点 ListNode *newHead=head-&gt;next, *subHead = head-&gt;next-&gt;next; // 交换第1个结点和第2个结点，递归交换其它结点并进行连接 newHead-&gt;next = head; head-&gt;next = swapPairs(subHead); return newHead; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>单向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode19删除链表的倒数第N个结点]]></title>
    <url>%2F2020%2F07%2F30%2FLeetCode19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 题解一 双指针：一个“快”，一个“慢” 快指针先到达链表末尾 具体思路见代码及注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Problem: LeetCode 19// URL: https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/// Tags: Linked List Two Pointers Recursion// Difficulty: Medium#include &lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode* next;&#125;;class Solution&#123;public: // 删除链表的倒数第N个结点 ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 快慢指针 ListNode* fast = head, *slow = head; // 快指针先移动N+1步，慢指针不移动 int i = 0; while (i &lt;= n &amp;&amp; fast != nullptr)&#123; fast = fast-&gt;next; i++; &#125; // 这个if语句和上个while循环中的fast!=nullptr都是为了处理一种特殊情况： // 假如链表只有N个元素且要删除倒数第N个元素，则快指针不能移动N+1步，这时应直接删除头结点 if(i!=n+1)&#123; // 删除头结点并返回新链表 head = head-&gt;next; delete slow; return head; &#125; // 快指针和慢指针一起移动直至快指针为空 // 因为快指针先移动了n+1步，所以循环结束后慢指针是指向待删除结点前面的那个结点 while(fast!=nullptr)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; // 删除待删除的结点并返回新链表 fast = slow-&gt;next; slow-&gt;next = fast-&gt;next; delete fast; return head; &#125;&#125;; 题解二 递归写法，很厉害，我参考了别人的 1234567891011121314151617181920212223242526272829// Problem: LeetCode 19// URL: https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/// Tags: Linked List Two Pointers Recursion// Difficulty: Medium#include &lt;iostream&gt;using namespace std;struct ListNode&#123; int val; ListNode* next;&#125;;class Solution&#123;private: int index=0;public: // 删除链表的倒数第N个结点 ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; // 递归表达式 head-&gt;next = removeNthFromEnd(head-&gt;next, n); // 该变量用来标记是倒数第几个结点，这条语句写在了递归表达式之后，这很关键 index++; // 此时head即为待删除结点前边的那个结点 if(index == n) return head-&gt;next; return head; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>单向链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode513找树左下角的值]]></title>
    <url>%2F2020%2F07%2F30%2FLeetCode513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/find-bottom-left-tree-value/ 题解一 层次遍历 求最后一层最左边的结点 我自己想的思路：层次遍历，保存每一层最左侧的结点，直到二叉树遍历结束 12345678910111213141516171819202122232425262728293031323334353637383940414243// Problem: LeetCode 513// URL: https://leetcode-cn.com/problems/find-bottom-left-tree-value/// Tags: Tree Queue BFS// Difficulty: Medium#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;public: // 求最后一层最左边的结点 int findBottomLeftValue(TreeNode* root) &#123; // 空树，题目已说明树不会为空 if (root==nullptr) return 0; // 存储当前层中的结点 queue&lt;TreeNode*&gt; parentNodes; parentNodes.push(root); // 按层遍历并保存每一层的第一个结点 TreeNode* leftBottomNode; while(!parentNodes.empty())&#123; queue&lt;TreeNode*&gt; childNodes; // 更新左下角结点指针 leftBottomNode = parentNodes.front(); // 获取下一层结点 while(!parentNodes.empty())&#123; root = parentNodes.front(); parentNodes.pop(); if (root-&gt;left!=nullptr) childNodes.push(root-&gt;left); if (root-&gt;right!=nullptr) childNodes.push(root-&gt;right); &#125; // 更新当前层 parentNodes = childNodes; &#125; return leftBottomNode-&gt;val; &#125;&#125;; 题解二 其他人的思路 也是按层遍历，但是会先遍历右子结点再遍历左子结点，这样遍历二叉树时最后一个结点就是最后一层最左侧的结点 1234567891011121314151617181920212223242526272829303132// Problem: LeetCode 513// URL: https://leetcode-cn.com/problems/find-bottom-left-tree-value/// Tags: Tree Queue BFS// Difficulty: Medium#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;public: // 求最后一层最左边的结点 int findBottomLeftValue(TreeNode* root) &#123; // 存储当前层中的结点 queue&lt;TreeNode*&gt; nodes; nodes.push(root); // 按层遍历，但先遍历右子结点再遍历左子结点 while(!nodes.empty())&#123; root = nodes.front(); nodes.pop(); if (root-&gt;right!=nullptr) nodes.push(root-&gt;right); if (root-&gt;left!=nullptr) nodes.push(root-&gt;left); &#125; return root-&gt;val; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>队列</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode637二叉树的层平均值]]></title>
    <url>%2F2020%2F07%2F30%2FLeetCode637%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/ 题解思路和层次遍历(点击查看)一样，没什么区别。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Problem: LeetCode 637// URL: https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/// Tags: Tree Queue// Difficulty: Easy#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;private: vector&lt;double&gt; result; double calcAverageOfLevel(vector&lt;double&gt;&amp; vec)&#123; double sum = 0; for (vector&lt;double&gt;::iterator it = vec.begin(); it!=vec.end(); ++it) sum += *it; return sum / vec.size(); &#125;public: vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123; // 空树，返回空数组 if (root==nullptr) return this-&gt;result; // 父层结点，即当前正在遍历的结点 queue&lt;TreeNode*&gt; parentNodes; parentNodes.push(root); // 遍历父层结点的同时获取下一层（子层）结点 while (!parentNodes.empty())&#123; // 子层结点，即下一层结点 queue&lt;TreeNode*&gt; childNodes; // 当前层的结点的值 vector&lt;double&gt; valOfLevel; // 遍历当前层 while (!parentNodes.empty())&#123; root = parentNodes.front(); parentNodes.pop(); valOfLevel.push_back(root-&gt;val); if (root-&gt;left!=nullptr) childNodes.push(root-&gt;left); if (root-&gt;right!=nullptr) childNodes.push(root-&gt;right); &#125; // 计算并存储当前层结点值的平均值 this-&gt;result.push_back(this-&gt;calcAverageOfLevel(valOfLevel)); // 更新当前层 parentNodes = childNodes; &#125; return this-&gt;result; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>队列</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode671二叉树中第二小的结点]]></title>
    <url>%2F2020%2F07%2F30%2FLeetCode671%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/ 题解一 自己想的思路，只用了函数本身，没有用其它函数 根据题目给的下面2个条件，又因为树是递归结构，可得到：根结点、左子结点和右子结点中根结点是最小的。 每个结点的子结点数量只能为 2 或 0。 如果一个结点有两个子结点的话，那么该结点的值等于两个子结点中较小的一个。 思路见代码和注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Problem: LeetCode 671// URL: https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/// Tags: Tree Recursion// Difficulty: Easy#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;public: int findSecondMinimumValue(TreeNode* root) &#123; // 如果结点为空或者无左右子树，则不存在第二小的结点 if(root==nullptr || root-&gt;left==nullptr || root-&gt;right==nullptr) return -1; // 如果左右子结点的值相等 if(root-&gt;left-&gt;val == root-&gt;right-&gt;val)&#123; // 求左右子树中第二小的结点的值 int leftSecondMin = findSecondMinimumValue(root-&gt;left); int rightSecondMin = findSecondMinimumValue(root-&gt;right); // 左右子树中不存在第二小的结点，则这整棵树中都不存在第二小的结点 if (leftSecondMin == -1 &amp;&amp; rightSecondMin == -1) return -1; // 左子树中不存在第二小的结点而右子树中存在第二小的结点，则右子树中第二小的结点即这整棵树中第二小的结点 if (leftSecondMin == -1) return rightSecondMin; // 右子树中不存在第二小的结点而左子树中存在第二小的结点，则左子树中第二小的结点即这整棵树中第二小的结点 if (rightSecondMin == -1) return leftSecondMin; return min(leftSecondMin, rightSecondMin); &#125; // 左子结点的值小于右子结点的值，而左子结点的值也等于根结点的值 else if(root-&gt;left-&gt;val &lt; root-&gt;right-&gt;val)&#123; int leftSecondMin = findSecondMinimumValue(root-&gt;left); // 左子树中不存在第二小的结点，则右子结点就是整棵树中第二小的结点 if(leftSecondMin==-1) return root-&gt;right-&gt;val; else // 左子树中存在第二小的结点，则其和右子结点中值较小的结点就是整棵树中第二小的结点 return min(leftSecondMin, root-&gt;right-&gt;val); &#125; // 和上个情况相似，不再注释说明 else&#123; int rightSecondMin = findSecondMinimumValue(root-&gt;right); if (rightSecondMin == -1) return root-&gt;left-&gt;val; else return min(rightSecondMin, root-&gt;left-&gt;val); &#125; &#125;&#125;; 题解二 其他人给的题解，速度很快 思路是：既然已经保证根结点的值最小，那就只需要遍历左右子树，遍历时一旦发现大于最小值的值（也就是第二小的值）就停止遍历并返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142// Problem: LeetCode 671// URL: https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/// Tags: Tree Recursion// Difficulty: Easy#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;private: int helper(TreeNode* root, int rootMin)&#123; // 空树则无第二小的结点 if (root==nullptr) return -1; // 如果找到大于最小值的值（第二小的值），则返回 if (root-&gt;val &gt; rootMin) return root-&gt;val; // 左右子树中第二小的值 int leftSecondMin = helper(root-&gt;left, rootMin); int rightSecondMin = helper(root-&gt;right, rootMin); // 左子树中不存在第二小的值，则结果取决于右子树 if (leftSecondMin == -1) return rightSecondMin; // 右子树中不存在第二小的值，则结果取决于右子树 if (rightSecondMin == -1) return leftSecondMin; // 左右子树都存在第二小的值，则取两者中的较小值 return min(leftSecondMin, rightSecondMin); &#125;public: int findSecondMinimumValue(TreeNode* root) &#123; return helper(root, root-&gt;val); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode337打家劫舍III]]></title>
    <url>%2F2020%2F07%2F30%2FLeetCode337%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/house-robber-iii/ 题解 递归写法 这个思路似乎是错的(不过我提交后是在某一个测试用例是超时了)，先把这份代码放这儿吧，后边补正确的解法 题目要求两个结点不能相连，这不等于隔层求和 123456789101112131415161718192021222324252627282930313233// Problem: LeetCode 337// URL: https://leetcode-cn.com/problems/house-robber-iii/// Tags: Tree DFS Recursion// Difficulty: Medium#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;public: int rob(TreeNode* root) &#123; // 空结点，结果为0 if(root==nullptr) return 0; // 抢当前结点及其隔层 int result1 = root-&gt;val; if(root-&gt;left!=nullptr) result1 += rob(root-&gt;left-&gt;left) + rob(root-&gt;left-&gt;right); if(root-&gt;right!=nullptr) result1 += rob(root-&gt;right-&gt;left) + rob(root-&gt;right-&gt;right); // 抢根结点下一层的两个结点及其隔层 int result2 = rob(root-&gt;left) + rob(root-&gt;right); return max(result1, result2); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode124二叉树中的最大路径和]]></title>
    <url>%2F2020%2F07%2F27%2FLeetCode124%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/ 题解 递归解法 路径：一条从树中任意结点出发，达到任意结点的序列。该路径至少包含一个结点，且不一定经过根结点。 这道题和LeetCode687最长同值路径和LeetCode543二叉树的直径很相似，都很难，每个题都做了很久 三道题的共性是dfs函数并非直接实现了目标功能，而是将目标功能拆解，实现目标功能的一部分，然后再利用某种关系（根结点、左子树、右子树之间的关系，需要结合题意）拼接出目标功能（求目标值） 思路见代码注释 需要高度注意dfs函数的功能 123456789101112131415161718192021222324252627282930313233343536373839404142// Problem: LeetCode 124// URL: https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/// Tags: Tree Recursion DFS// Difficulty: Hard#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; int val; TreeNode *left; TreeNode *right;&#125;;class Solution&#123;private: int maxSum = INT_MIN; // 全局最大路径和 // 功能：求一颗树的最大路径和，要求从根结点开始，在左子树或右子树结束，也可不经过左子树和右子树，即至多经过一个子树 int dfs(TreeNode *root) &#123; if (root == nullptr) return 0; int left = dfs(root-&gt;left); int right = dfs(root-&gt;right); // 过程中更新全局最大路径和：根结点必须经过，左右子树可经过可不经过 maxSum = max(maxSum, root-&gt;val + max(left, 0) + max(right, 0)); // 从根结点开始，在左子树或右子树结束，也可不经过左子树和右子树，即至多经过一个子树 return max(root-&gt;val, root-&gt;val + max(max(left, right), 0)); &#125;public: // 求一颗树的最大路径和，不要求经过根结点，起始和终止结点任意 int maxPathSum(TreeNode *root) &#123; dfs(root); return this-&gt;maxSum; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode687最长同值路径]]></title>
    <url>%2F2020%2F07%2F27%2FLeetCode687%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/longest-univalue-path/ 题解 这道题写了好久，然后参考了题解 递归解法 这道题和LeetCode543二叉树的直径(点击查看)非常相似，可以看一下 类似的题目还有LeetCode124(点击查看)，非常相似，难度是Hard 将一条路径分为左右两半，两个结点之间路径长度等于它们到根结点的距离之和 思路见代码注释，关键的代码是26-29行 需要高度注意dfs函数的功能 123456789101112131415161718192021222324252627282930313233343536373839404142// Problem: LeetCode 687// URL: https://leetcode-cn.com/problems/longest-univalue-path/// Tags: Tree Recursion DFS// Difficulty: Easy#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;private: int maxLen = 0; // 全局最长同值路径 // 功能：返回该树与根结点同值的路径（必须以根结点为起点，至多经过一个子树）的最大长度 int dfs(TreeNode* root)&#123; // 空树则长度为0 if (root == nullptr) return 0; // 该树根结点在左右方向上的最长同值路径的长度（从根结点开始，路径上的结点的值都与根结点一致） int left = dfs(root-&gt;left); int right = dfs(root-&gt;right); left = (root-&gt;left != nullptr &amp;&amp; root-&gt;val == root-&gt;left-&gt;val) ? left + 1 : 0; right = (root-&gt;right != nullptr &amp;&amp; root-&gt;val == root-&gt;right-&gt;val) ? right + 1 : 0; // 更新全局最长同值路径 maxLen = max(maxLen, left + right); // 将一条路径分为左右两半，两个结点之间路径长度等于它们到根结点的距离之和 // 经过左子树或者右子树，或者不经过子树（left和right都为0时） return max(left, right); &#125;public: // 求该树中的最长同值路径，可以经过也可以不经过根结点 int longestUnivaluePath(TreeNode* root) &#123; dfs(root); return this-&gt;maxLen; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode404左叶子之和]]></title>
    <url>%2F2020%2F07%2F27%2FLeetCode404%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/sum-of-left-leaves/ 题解 自己写的 递归解法 思路见代码注释 12345678910111213141516171819202122232425262728293031323334353637// Problem: LeetCode 404// URL: https://leetcode-cn.com/problems/sum-of-left-leaves/// Tags: Tree Recursion// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;private: // 判断一个结点是否为叶子结点：该结点非空且左右孩子为空 bool isLeaf(TreeNode* root)&#123; if(root==nullptr) return false; if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr) return true; return false; &#125;public: // 得到一颗树的所有左叶子结点的值的总和 int sumOfLeftLeaves(TreeNode* root)&#123; if(root==nullptr) return 0; // 如果左孩子是叶子，则该树的结果为左孩子的值+右子树的结果 if(isLeaf(root-&gt;left)) return root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;right); // 如果左孩子不是叶子，则该树对应的值为左子树的结果+右子树的结果 return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode111二叉树的最小深度]]></title>
    <url>%2F2020%2F07%2F26%2FLeetCode111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/ 题解一 递归解法 我写的 说明详见注释 1234567891011121314151617181920212223242526272829303132333435363738// Problem: LeetCode 111// URL: https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/// Tags: Tree Recursion DFS// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;private: int min=INT_MAX; // 深度优先遍历，在过程中记录最小路径 void dfs(TreeNode* root, int level)&#123; if(root==nullptr) return; level += 1; if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr &amp;&amp; level &lt; this-&gt;min) this-&gt;min = level; dfs(root-&gt;left, level); dfs(root-&gt;right, level); &#125;public: int minDepth(TreeNode* root)&#123; // 空树则最小路径为0 if(root==nullptr) return 0; dfs(root, 0); return this-&gt;min; &#125;&#125;; 题解二 递归解法 参考了官方的题解 说明详见代码注释，感觉有些地方比较不符合人的思维逻辑 123456789101112131415161718192021222324252627282930// Problem: LeetCode 111// URL: https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/// Tags: Tree Recursion DFS// Difficulty: Easy#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;public: int minDepth(TreeNode* root)&#123; // 空树则最小路径为0 if(root==nullptr) return 0; int left = minDepth(root-&gt;left); int right = minDepth(root-&gt;right); // 如果子树中有空树， 则该树的最小深度等于子树深度之和+1 if(left==0 || right==0) return left+right+1; // 如果子树都不为空，则该树的最小深度等于子树深度较小值+1 return min(left, right)+1; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode101对称二叉树]]></title>
    <url>%2F2020%2F07%2F26%2FLeetCode101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/symmetric-tree/ 题解 我写的 递归解法 具体方法见代码注释 123456789101112131415161718192021222324252627282930313233343536373839// Problem: LeetCode 101// URL: https://leetcode-cn.com/problems/symmetric-tree/// Tags: Tree Recursion DFS// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;private: // 判断两个树s和t是否互相对称 // 有3个要求： // ①根结点值相等 // ②s的左子树和t的右子树互相对称 // ③s的右子树和t的左子树互相对称 bool isSymmetric(TreeNode* s, TreeNode* t)&#123; if(s==nullptr &amp;&amp; t==nullptr) return true; if(s==nullptr || t==nullptr) return false; if(s-&gt;val == t-&gt;val) return isSymmetric(s-&gt;left, t-&gt;right) &amp;&amp; isSymmetric(s-&gt;right, t-&gt;left); return false; &#125;public: bool isSymmetric(TreeNode* root) &#123; // 如果该树为空，则为对称的 if(root==nullptr) return true; // 左子树和右子树对称 return isSymmetric(root-&gt;left, root-&gt;right); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode572另一个树的子树]]></title>
    <url>%2F2020%2F07%2F26%2FLeetCode572%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述https://leetcode-cn.com/problems/subtree-of-another-tree/ 题解 我写的 两层DFS、双重DFS 其它题解一般也是这个思路 1234567891011121314151617181920212223242526272829303132333435363738394041// Problem: LeetCode 572// URL: https://leetcode-cn.com/problems/subtree-of-another-tree/// Tags: Tree Recursion DFS// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right;&#125;;class Solution&#123;private: // 判断s和t两个树是否相同（同质） bool isSametree(TreeNode* s, TreeNode* t)&#123; // 两个树均为空 if(s==nullptr &amp;&amp; t==nullptr) return true; // 一个树为空 if(s==nullptr || t==nullptr) return false; // 两个树都不为空 if(s-&gt;val==t-&gt;val) // 如果根结点的val都相同，则递归比较子树 return isSametree(s-&gt;left, t-&gt;left) &amp;&amp; isSametree(s-&gt;right, t-&gt;right); return false; &#125;public: // 判断t是否为s的子树 bool isSubtree(TreeNode* s, TreeNode* t) &#123; // 如果s是空树，则t不可能是s的子树 if(s==nullptr) return false; // t为s的子树有3种可能：s==t、t是s左子树的子树、t是s右子树的子树 return isSametree(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode437路径总和III]]></title>
    <url>%2F2020%2F07%2F26%2FLeetCode437%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/path-sum-iii/ 题解 两个DFS，两个DFS作用不一样 我写的，其它人的题解大概也是这个思路 这道题是昨天那道题(点击查看)的扩展，建议先看一下昨天那道题的题解二。 昨天那道题中的路径是根结点到叶子结点之间的路径 今天这道题中的路径是任意结点到任意结点之间的路径，只要求是向下的（即从父结点到子结点） 可以按照下面2步修改昨天那道题，即可得到今天这道题并求解 Step1：求根结点到任意结点（而非叶子结点）之间的路径 处理这一差异，只需要将昨天那道题判断语句中的叶子结点条件删除即可，即只判断路径长度是否相等，不管是不是叶子结点 Step2：求任意结点（而非根结点）到任意结点之间的路径 处理这一差异，只需基于昨天那道题的解法，再套一层递归，即不止求根结点，还要递归求解其左右子树并将路径数相加 1234567891011121314151617181920212223242526272829303132333435// Problem: LeetCode 437// URL: https://leetcode-cn.com/problems/path-sum-iii/// Tags: Tree Recursion DFS// Difficulty: Medium#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;&#125;;class Solution&#123;private: // Step1：搜索当前子树中结点到根结点之间距离等于sum的路径数 int dfs(TreeNode* root, int sum)&#123; if (root == nullptr) return 0; int count = 0; if (root-&gt;val == sum) count++; return count + dfs(root-&gt;left, sum - root-&gt;val) + dfs(root-&gt;right, sum - root-&gt;val); &#125;public: int pathSum(TreeNode* root, int sum) &#123; if(root==nullptr) return 0; // Step2：结果为：以当前结点为根结点时的路径数+以左子结点为根结点时的路径数+以右子结点为根结点时的路径数； return dfs(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode112路径总和]]></title>
    <url>%2F2020%2F07%2F25%2FLeetCode112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/path-sum/ 题解一 我自己写的 在dfs过程中要记录当前结点与根结点之间的距离，并且回溯时也需要更新该值 注意要求是叶子结点到根结点之间的距离 详细思路见代码注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Problem: LeetCode 112// URL: https://leetcode-cn.com/problems/path-sum/// Tags: Tree Recursion DFS 回溯// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;class Solution&#123;private: bool existed = false; // 当前是否存在叶子结点到根结点的路径和等于给定sum int now = 0; // 当前结点的路径和 int sum = -1; // 给定的sum void dfs(TreeNode* root)&#123; // 如果当前已找到符合要求的结点，则不用再搜索 if(existed==true) return ; // 如果是空结点，则不用搜索 if(root==nullptr) return ; // 遍历当前结点，计算其到根结点之间的距离 this-&gt;now += root-&gt;val; // 如果是叶子结点并且其与根结点的距离等于给定sum，则该结点符合条件 if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr &amp;&amp; this-&gt;now == this-&gt;sum)&#123; existed = true; return; &#125; // 搜索左子树和右子树 dfs(root-&gt;left); dfs(root-&gt;right); // 该子树已搜索完毕，需要更新当前结点与根结点之间的距离（回溯） this-&gt;now -= root-&gt;val; &#125;public: bool hasPathSum(TreeNode* root, int sum) &#123; // 设置目标 this-&gt;sum = sum; // 深度搜索 dfs(root); // 返回搜索结果 return this-&gt;existed; &#125;&#125;; 题解二 别人的题解，用另外一种方式理解了sum，厉害 thumb up 12345678910111213141516171819202122232425// Problem: LeetCode 112// URL: https://leetcode-cn.com/problems/path-sum/// Tags: Tree Recursion DFS 回溯// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;&#125;;class Solution&#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root==nullptr) return false; if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr &amp;&amp; root-&gt;val==sum) return true; return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode617合并二叉树]]></title>
    <url>%2F2020%2F07%2F25%2FLeetCode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/merge-two-binary-trees/ 题解 递归解法 解法见代码注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Problem: LeetCode 617// URL: https://leetcode-cn.com/problems/merge-two-binary-trees/// Tags: Tree Recursion// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;&#125;;class Solution&#123;private: // 将树t1和t2合并至t1，并返回t1 TreeNode* heleper(TreeNode* t1, TreeNode* t2)&#123; // 两个空树，返回null if(t1==nullptr &amp;&amp; t2==nullptr) return nullptr; // 仅t2为空树，不需合并，直接返回t1即可 else if(t1!=nullptr &amp;&amp; t2==nullptr)&#123; return t1; &#125; // 仅t1为空树，不需合并，直接返回t2即可 else if(t1==nullptr &amp;&amp; t2!=nullptr)&#123; return t2; &#125; // t1和t2均非空 else&#123; t1-&gt;val += t2-&gt;val; // 合并根结点 t1-&gt;left = heleper(t1-&gt;left, t2-&gt;left); // 合并左子树 t1-&gt;right = heleper(t1-&gt;right, t2-&gt;right); // 合并右子树 delete t2; // 释放结点 return t1; &#125; &#125;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; return heleper(t1,t2); &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode226翻转二叉树]]></title>
    <url>%2F2020%2F07%2F25%2FLeetCode226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/invert-binary-tree/ 题解一 递归解法 我写的，不够简洁 12345678910111213141516171819202122232425262728293031// Problem: LeetCode 226// URL: https://leetcode-cn.com/problems/invert-binary-tree/// Tags: Tree Recursion// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; TreeNode* left; TreeNode* right; int val; TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;&#125;;class Solution&#123;public: TreeNode* invertTree(TreeNode* root) &#123; // 递归出口，空结点直接返回 if(root==nullptr) return nullptr; // 该结点交换左右子树 TreeNode *temp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = temp; // 递归翻转左右子树 invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;; 题解二 比我写的简洁一些，交换了最后两步的顺序，特别是利用了二叉树翻转后根结点不变的特点 123456789101112131415161718192021222324252627282930// Problem: LeetCode 226// URL: https://leetcode-cn.com/problems/invert-binary-tree/// Tags: Tree Recursion// Difficulty: Easy#include &lt;iostream&gt;using namespace std;struct TreeNode&#123; TreeNode* left; TreeNode* right; int val; TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;&#125;;class Solution&#123;public: TreeNode* invertTree(TreeNode* root) &#123; // 递归出口，空结点直接返回 if(root==nullptr) return nullptr; // 递归翻转左右子树 TreeNode* left = invertTree(root-&gt;left); TreeNode* right = invertTree(root-&gt;right); // 该结点交换左右子树 root-&gt;left = right; root-&gt;right = left; return root; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode543二叉树的直径]]></title>
    <url>%2F2020%2F07%2F25%2FLeetCode543%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/diameter-of-binary-tree/ 题解 一棵二叉树的直径长度是任意两个结点路径长度中的最大值，两结点之间的路径长度是以它们之间边的数目表示 将一条路径分为左右两半，两个结点之间路径长度等于根结点左右子树的深度之和 这条路径可能穿过也可能不穿过根结点，所以在DFS过程中记录路径长度的最大值 相似的题目有 LeetCode687最长同值路径 LeetCode124(点击查看) 要注意depth函数的功能 123456789101112131415161718192021222324252627282930313233343536373839404142// Problem: LeetCode 543// URL: https://leetcode-cn.com/problems/maxDiameter-of-binary-tree/// Tags: Tree DFS Recursion// Difficulty: Easy#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; TreeNode* left; TreeNode* right; int val; TreeNode(int x):val(x),left(nullptr),right(nullptr)&#123;&#125;&#125;;class Solution&#123;private: int maxDiameter=0; // 全局最大直径 // 返回该树的最大深度 int depth(TreeNode* root)&#123; // 空结点深度为0 if(root==nullptr) return 0; // 左右子树深度 int leftDepth = depth(root-&gt;left); int rightDepth = depth(root-&gt;right); // 更新最大直径：两个结点之间路径长度等于根结点左右子树的深度之和 if (leftDepth + rightDepth &gt; this-&gt;maxDiameter) this-&gt;maxDiameter = leftDepth + rightDepth; // 返回该树最大深度 return max(leftDepth, rightDepth) + 1; &#125;public: // 求一颗树的直径：任意两个结点路径长度中的最大值 int diameterOfBinaryTree(TreeNode* root) &#123; depth(root); return this-&gt;maxDiameter; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode110平衡二叉树]]></title>
    <url>%2F2020%2F07%2F25%2FLeetCode110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/balanced-binary-tree/ 题解 递归解法 平衡二叉树定义：一个二叉树每个结点的左右两个子树的高度差的绝对值不超过1 递归函数返回值：如果平衡则返回该树的高度，空树则返回0，不平衡（左右子树不平衡或该结点不平衡）则返回-1 12345678910111213141516171819202122232425262728293031323334353637383940414243// Problem: LeetCode 110// URL: https://leetcode-cn.com/problems/balanced-binary-tree/description/// Tags: Tree DFS// Difficulty: Easy#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; TreeNode* left; TreeNode* right; int val; TreeNode(int x):val(x), left(nullptr), right(nullptr)&#123;&#125;&#125;;class Solution&#123;private: int recursion(TreeNode* root)&#123;//若该树平衡则返回其高度，不平衡则返回-1 // 空树深度为0，也算平衡树 if(root==nullptr) return 0; // 计算左子树和右子树深度 int left=recursion(root-&gt;left); int right=recursion(root-&gt;right); // 若子树不平衡，则父树也不平衡(平衡二叉树定义：一个二叉树每个结点的左右两个子树的高度差的绝对值不超过1) if(left&lt;0||right&lt;0) return -1; // 左右子树平衡，则判断该树是否平衡 if (abs(left-right)&lt;=1) return max(left,right)+1; else return -1; &#125;public: bool isBalanced(TreeNode* root)&#123; return recursion(root)&gt;=0; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode104二叉树的最大深度]]></title>
    <url>%2F2020%2F07%2F24%2FLeetCode104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 题解 递归 递归出口是当前结点为空，则返回0 如果非空，则该结点深度为左子树和右子树深度的最大值+1 12345678910111213141516171819202122232425262728293031// Problem: LeetCode 104// URL: https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/// Tags: Tree Recursion// Difficulty: Easy#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct TreeNode&#123; TreeNode* left; TreeNode* right; int val; TreeNode(int x):val(x), left(nullptr), right(nullptr)&#123;&#125;&#125;;class Solution&#123;public: int maxDepth(TreeNode* root)&#123; if(nullptr==root) return 0; return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+1; &#125;&#125;;int main()&#123; cout &lt;&lt; "helloworld" &lt;&lt; endl; // system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode102二叉树层次遍历]]></title>
    <url>%2F2020%2F07%2F24%2FLeetCode102%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目链接https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 题解一：非递归BFS 用队列存储每层的结点 获取到一层结点后，则可以获得该层所有结点的val和下一层的所有结点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Problem: LeetCode 102// URL: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/// Tags: Tree BFS DFS Recursion Queue// Difficulty: Medium#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x): val(x), left(nullptr), right(nullptr)&#123;&#125;&#125;;class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)&#123; vector&lt;vector&lt;int&gt;&gt; result; // 最终结果 queue&lt;TreeNode*&gt; parentNodes; // 父层结点 if(root!=nullptr) parentNodes.push(root); while(!parentNodes.empty())&#123; // 找子层结点 queue&lt;TreeNode*&gt; childNodes; // 子层结点 vector&lt;int&gt; parentVals; // 父层结点元素 while (!parentNodes.empty())&#123; root = parentNodes.front(); parentNodes.pop(); parentVals.push_back(root-&gt;val); if (root-&gt;left != nullptr) childNodes.push(root-&gt;left); if (root-&gt;right != nullptr) childNodes.push(root-&gt;right); &#125; parentNodes = childNodes; result.push_back(parentVals); &#125; return result; &#125;&#125;;int main()&#123; cout &lt;&lt; "helloworld" &lt;&lt; endl; // system("pause"); return 0;&#125; 题解二：DFS递归 用变量level记录当前处于哪一层 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Problem: LeetCode 102// URL: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/// Tags: Tree BFS DFS Recursion Queue// Difficulty: Medium#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x): val(x), left(nullptr), right(nullptr)&#123;&#125;&#125;;class Solution&#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)&#123; vector&lt;vector&lt;int&gt;&gt; result; // 最终结果 dfs(result, root, 0); return result; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; result, TreeNode* root, int level)&#123; // 空指针，无动作 if(nullptr==root)&#123; return; &#125; // 如果该层第一次被遍历到，则为该层创建空数组 if(result.size()&lt;=level)&#123; result.push_back(vector&lt;int&gt;()); &#125; // 遍历该结点 result[level].push_back(root-&gt;val); // 遍历左子树 dfs(result, root-&gt;left, level + 1); // 遍历右子树 dfs(result, root-&gt;right, level + 1); &#125;&#125;;int main()&#123; cout &lt;&lt; "helloworld" &lt;&lt; endl; // system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>DFS</tag>
        <tag>队列</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树前序、中序、后序遍历（非递归统一解法）]]></title>
    <url>%2F2020%2F07%2F13%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%9F%E4%B8%80%E8%A7%A3%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言最近复习了二叉树的前序遍历、中序遍历和后序遍历，找到了一种统一的非递归的迭代方法。 思路思路本质上还是递归，只不过不通过递归函数显式递归，而是通过栈模拟递归。 该思路仅需要微小改动就可以通用于二叉树的先/中/后序遍历，也很容易理解。 注意： 该思路的核心是将nullptr作为可以遍历栈中下1个结点的标志（因此也就不能将空结点压入栈中），即栈中弹出nullptr时就可以遍历下1个栈顶结点，如果不是nullptr则根据遍历顺序入栈，当前根结点入栈时也要将nullptr压入栈中（后续遇到这个nullptr时就可以遍历到该根结点）。 遍历顺序和入栈顺序相反 前序遍历LeetCode题解：https://www.cnblogs.com/chouxianyu/p/13290758.html 12345678910111213141516171819202122vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; nodes; if (root!=nullptr) nodes.push(root); while(!nodes.empty())&#123; root = nodes.top(); nodes.pop(); if (root==nullptr)&#123; result.push_back(nodes.top()-&gt;val); nodes.pop(); &#125;else&#123; if (root-&gt;right!=nullptr) nodes.push(root-&gt;right); if (root-&gt;left!=nullptr) nodes.push(root-&gt;left); nodes.push(root); nodes.push(nullptr); &#125; &#125; return result;&#125; 中序遍历LeetCode题解：https://www.cnblogs.com/chouxianyu/p/13293153.html 12345678910111213141516171819202122vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; nodes; if(root!=nullptr) nodes.push(root); while(!nodes.empty())&#123; root=nodes.top(); nodes.pop(); if(root==nullptr)&#123; result.push_back(nodes.top()-&gt;val); nodes.pop(); &#125;else&#123; if (root-&gt;right!=nullptr) nodes.push(root-&gt;right); nodes.push(root); nodes.push(nullptr); if (root-&gt;left!=nullptr) nodes.push(root-&gt;left); &#125; &#125; return result;&#125; 后序遍历LeetCode题解：https://www.cnblogs.com/chouxianyu/p/13293152.html 12345678910111213141516171819202122vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; result; if (root!=nullptr) nodes.push(root); while(!nodes.empty())&#123; root=nodes.top(); nodes.pop(); if(root==nullptr)&#123; result.push_back(nodes.top()-&gt;val); nodes.pop(); &#125;else&#123; nodes.push(root); nodes.push(nullptr); if(root-&gt;right!=nullptr) nodes.push(root-&gt;right); if(root-&gt;left!=nullptr) nodes.push(root-&gt;left); &#125; &#125; return result;&#125; 参考链接https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/mo-fang-di-gui-zhi-bian-yi-xing-by-sonp/ 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>栈</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode94二叉树中序遍历]]></title>
    <url>%2F2020%2F07%2F13%2FLeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ 题目考点 二叉树中序遍历，递归，迭代，栈 题目难度 LeetCode Medium 题目大意 二叉树中序遍历（左中右） 输入 1个二叉树 输出 该二叉树中序遍历的结果 题解一解题思路 递归法 先通过递归遍历当前根结点的左子树，然后遍历当前的根结点，然后通过递归遍历当前根结点的右子树。 复杂度分析 假设该二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; result; void traversal(TreeNode* root)&#123; if(root!=nullptr)&#123; traversal(root-&gt;left); result.push_back(root-&gt;val); traversal(root-&gt;right); &#125; &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; traversal(root); return result; &#125;&#125;; 题解二解题思路 迭代法/栈法 通过显式栈模拟递归函数。该思路仅需要微小改动就可以通用于二叉树的先/中/后序遍历。该思路实现3种顺序遍历的介绍：https://www.cnblogs.com/chouxianyu/p/13293284.html 该思路的核心是将nullptr作为可以遍历下1个结点的标志（因此也就不能将空结点压入栈中），即遇到nullptr时就可以遍历下一个结点，如果不是nullptr则根据遍历顺序入栈，当前根结点入栈时也要将nullptr压入栈中（后续遇到这个nullptr时就可以遍历到该根结点）。 复杂度分析 假设二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; nodes; if(root!=nullptr) nodes.push(root); while(!nodes.empty())&#123; root=nodes.top(); nodes.pop(); if(root==nullptr)&#123; result.push_back(nodes.top()-&gt;val); nodes.pop(); &#125;else&#123; if (root-&gt;right!=nullptr) nodes.push(root-&gt;right); nodes.push(root); nodes.push(nullptr); if (root-&gt;left!=nullptr) nodes.push(root-&gt;left); &#125; &#125; return result; &#125;&#125;; 题解三解题思路 栈法/迭代法 中序遍历的顺序为：左子树、根结点、右子树。 对于1个根结点root，分3步操作： 将root压入栈中并不断更新为其左子树，直至root为空 可以想象下，中序遍历时就是这样并不遍历当前结点，而是一直往左下角延伸到底 更新root为栈顶结点并遍历它（第1步结束后，此时栈顶结点无左子树或其左子树已遍历完） 更新root为其右子树通过循环遍历其右子树 如果root非空或者栈非空则循环以上步骤 复杂度分析 假设二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; nodes; while(root!=nullptr || !nodes.empty())&#123; while(root!=nullptr)&#123; nodes.push(root); root=root-&gt;left; &#125; root=nodes.top(); nodes.pop(); result.push_back(root-&gt;val); root=root-&gt;right; &#125; return result; &#125;&#125;; 题解四Morris 遍历算法是另一种遍历二叉树的方法。 假设二叉树有n个结点，该算法的时间复杂度为$O(n)$、空间复杂度为$O(1)$。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>栈</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode145二叉树后序遍历]]></title>
    <url>%2F2020%2F07%2F13%2FLeetCode145%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/ 题目考点 二叉树，后序遍历，递归，迭代，栈 题目难度 LeetCode Medium 题目大意 后序遍历1颗二叉树 输入 1颗二叉树 输出 后序遍历的结果 题解一解题思路 递归法 后序遍历的顺序是“左右中”。先后通过递归遍历左子树和右子树，然后遍历当前根结点。 复杂度分析 假设该二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码1234567891011121314151617class Solution&#123;public: vector&lt;int&gt; result; void traversal(TreeNode* root)&#123; if(root!=nullptr)&#123; traversal(root-&gt;left); traversal(root-&gt;right); result.push_back(root-&gt;val); &#125; &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root)&#123; traversal(root); return result; &#125;&#125;; 题解二解题思路 栈法/迭代法 该思路是通过显式栈模拟递归函数。虽然该思路的复杂度稍高一些，但其仅需要微小改动就可以通用于二叉树的先/中/后序遍历。该思路实现3种顺序遍历的介绍：https://www.cnblogs.com/chouxianyu/p/13293284.html 该思路的核心是将nullptr作为可以遍历下1个结点的标志（因此也就不能将空结点压入栈中），即遇到nullptr时就可以遍历下一个结点，如果不是nullptr则根据遍历顺序入栈，当前根结点入栈时也要将nullptr压入栈中（后续遇到这个nullptr时就可以遍历到该根结点）。 复杂度分析 假设二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; result; if (root!=nullptr) nodes.push(root); while(!nodes.empty())&#123; root=nodes.top(); nodes.pop(); if(root==nullptr)&#123; result.push_back(nodes.top()-&gt;val); nodes.pop(); &#125;else&#123; nodes.push(root); nodes.push(nullptr); if(root-&gt;right!=nullptr) nodes.push(root-&gt;right); if(root-&gt;left!=nullptr) nodes.push(root-&gt;left); &#125; &#125; return result; &#125;&#125;; 题解三解题思路 栈法/迭代法 后序遍历的顺序为：左子树、右子树、根结点。 用prev保存上1个遍历过的结点。对于1个根结点，分3步操作： 将root压入栈中并不断更新为其左子树，直至root为空 可以想象下，后序遍历时就是这样并不遍历当前结点，而是一直往左下角延伸到底 更新root为栈顶结点 第1步结束后，此时栈顶结点无左子树或其左子树已遍历完 如果无右子树或右子树已遍历，则遍历root并更新prev为root、更新root为nullptr；否则root入栈并更新root为右子树。 如果root非空或者栈非空则循环以上步骤。 复杂度分析 假设二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; nodes; vector&lt;int&gt; result; TreeNode* prev=nullptr; while(root!=nullptr || !nodes.empty())&#123; while(root!=nullptr)&#123; nodes.push(root); root=root-&gt;left; &#125; root=nodes.top(); nodes.pop(); if(root-&gt;right==nullptr || root-&gt;right==prev)&#123; result.push_back(root-&gt;val); prev=root; root=nullptr; &#125;else&#123; nodes.push(root); root=root-&gt;right; &#125; &#125; return result; &#125;&#125;; 题解四Morris 遍历算法是另一种遍历二叉树的方法。 假设二叉树有n个结点，该算法的时间复杂度为$O(n)$、空间复杂度为$O(1)$。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>栈</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode144二叉树前序遍历]]></title>
    <url>%2F2020%2F07%2F12%2FLeetCode144%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/ 题目考点 二叉树先序遍历，递归，栈，迭代 题目难度 LeetCode Medium 题目大意 给出1个二叉树，要求先序遍历（中左右）。 输入 1个二叉树 输出 先序遍历的结果（vector） 题解一解题思路 递归法 先遍历当前根结点，再先后通过递归遍历左子树和右子树。 复杂度分析 假设二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码12345678910111213141516class Solution&#123;public: vector&lt;int&gt; result; void traversal(TreeNode* root)&#123; if (root != nullptr)&#123; result.push_back(root-&gt;val); traversal(root-&gt;left); traversal(root-&gt;right); &#125; &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123; traversal(root); return result; &#125;&#125;; 题解二解题思路 栈法/迭代法 显式地模拟递归函数的栈，每次结点出栈后相当于调用1次递归函数（处理1个根结点及其子树），出栈后根据遍历顺序对当前根结点及其左右子树进行操作（注意遍历顺序和入栈顺序是相反的）。 复杂度分析 假设二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; nodes; nodes.push(root); while(!nodes.empty())&#123; root = nodes.top(); nodes.pop(); if (root!=nullptr)&#123; result.push_back(root-&gt;val); nodes.push(root-&gt;right); nodes.push(root-&gt;left); &#125; &#125; return result; &#125;&#125;; 题解三解题思路 栈法/迭代法 该思路和题解二中的思路都是通过显式栈模拟递归函数。虽然该思路的复杂度稍高一些，但其仅需要微小改动就可以通用于二叉树的先/中/后序遍历。该思路实现3种顺序遍历的介绍：https://www.cnblogs.com/chouxianyu/p/13293284.html 该思路的核心是将nullptr作为可以遍历下1个结点的标志（因此也就不能将空结点压入栈中），即遇到nullptr时就可以遍历下一个结点，如果不是nullptr则根据遍历顺序入栈，当前根结点入栈时也要将nullptr压入栈中（后续遇到这个nullptr时就可以遍历到该根结点）。 复杂度分析 假设二叉树有n个结点，则时间复杂度为$O(n)$、最大空间复杂度为$O(n)$、平均空间复杂度为$O(log\ n)$。 代码12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; nodes; if (root!=nullptr)&#123; nodes.push(root); &#125; while(!nodes.empty())&#123; root = nodes.top(); nodes.pop(); if (root==nullptr)&#123; result.push_back(nodes.top()-&gt;val); nodes.pop(); &#125;else&#123; if (root-&gt;right!=nullptr) nodes.push(root-&gt;right); if (root-&gt;left!=nullptr) nodes.push(root-&gt;left); nodes.push(root); nodes.push(nullptr); &#125; &#125; return result; &#125;&#125;; 题解四还有个Morris遍历，其时间复杂度为$O(n)$、空间复杂度为$O(1)$，其核心是利用树中的大量空闲指针，实现空间开销的缩减。该方法的论文名称为Traversing Binary Trees Simply and Cheaply。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>栈</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode83删除排序链表中的重复元素]]></title>
    <url>%2F2020%2F07%2F12%2FLeetCode83%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/ 题目考点 链表，递归，迭代 题目难度 LeetCode 题目大意 给出1个排好序的链表，删除其中的重复元素 输入 原链表 输出 删除重复元素后的链表 题解一解题思路 递归法 首先通过遍历删除与头结点同值的结点，后面1部分的链表通过递归删除其中的重复结点，然后将当前头结点与后面1部分链表（已删除重复结点）连接起来，最终返回当前头结点。 复杂度分析 假设链表有n个结点，则时间复杂度和空间复杂度都为$O(n)$。 代码123456789101112class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head==nullptr) return head; ListNode* cur=head; while(cur!=nullptr &amp;&amp; cur-&gt;val == head-&gt;val) cur = cur-&gt;next; head-&gt;next = deleteDuplicates(cur); return head; &#125;&#125;; 题解二解题思路 递归法 首先取出头结点，然后通过递归删除剩余链表中的重复结点并将其与头结点连接，然后判断当前头结点和第2个结点是否重复（如果重复则删除）。 复杂度分析 假设链表有n个结点，则时间复杂度和空间复杂度都为$O(n)$。 代码123456789101112class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head==nullptr) return head; head-&gt;next = deleteDuplicates(head-&gt;next); if (head-&gt;next!=nullptr &amp;&amp; head-&gt;val==head-&gt;next-&gt;val) return head-&gt;next; return head; &#125;&#125;; 题解三解题思路 迭代法 整体思路为用哨兵sentry保存当前最后1个不重复结点，当发现新的不重复结点时将哨兵与该结点连接（这样就是一次性删除多个重复结点）。 具体方法为：遍历链表，当发现cur和sentry异值时则一次性删除多个重复结点并更新最后1个不重复结点为当前结点（sentry-&gt;next=cur;sentry=cur;），直到整个链表遍历结束。最后将最后1个不重复结点的下1个结点置空。 复杂度分析 假设链表长度为n，则时间复杂度为$O(n)$、空间复杂度为$O(1)$。 代码1234567891011121314151617class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head==nullptr) return nullptr; ListNode* sentry=head, *cur=head; while(cur!=nullptr)&#123; if(sentry-&gt;val != cur-&gt;val)&#123; sentry-&gt;next = cur; sentry = cur; &#125; cur = cur-&gt;next; &#125; sentry-&gt;next=nullptr; return head; &#125;&#125;; 题解四解题思路 迭代法 遍历链表，如果当前结点与下1个结点通知则删除下1个结点，否则更新下1个结点。 该思路与题解三的思路有相同也有不同，相同之处是都保存当前最后1个不重复结点，区别是题解三是一次性删除多个重复结点，而该方法是遇到1个重复结点则直接删除（1次删除1个结点）。 复杂度分析 假设链表长度为n，则时间复杂度为$O(n)$、空间复杂度为$O(1)$。 代码1234567891011121314class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head==nullptr) return head; ListNode* cur=head, *next; while((next=cur-&gt;next)!=nullptr) if (cur-&gt;val==next-&gt;val) cur-&gt;next = next-&gt;next; else cur = next; return head; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>单向链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode21合并两个有序链表]]></title>
    <url>%2F2020%2F07%2F11%2FLeetCode21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://leetcode-cn.com/problems/merge-two-sorted-lists/description/ 题目考点 链表，递归，迭代 题目难度 LeetCode Easy 题目大意 给出2个升序链表，请合并成1个新的升序链表。 输入 2个升序链表的头结点 输出 新的升序链表的头结点 题解一解题思路 递归法 取出当前2个链表中头结点较小的那个链表的头结点，然后通过递归将2个链表合并（a-&gt;next和b）。 复杂度分析 假设3个链表分别有n和m个结点，则时间复杂度为$O(n+m)$、空间复杂度为$O(n+m)$。 代码1234567891011121314151617class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; // 边界和递归出口 if(nullptr==l1)&#123;return l2;&#125; if(nullptr==l2)&#123;return l1;&#125; // 递归表达式 if(l1-&gt;val&lt;l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else&#123; l2-&gt;next = mergeTwoLists(l2-&gt;next, l1); return l2; &#125; &#125;&#125;; 题解二解题思路 迭代法 用pre保存前1个结点，用2个指针分别遍历这2个链表每次取出值最小的结点，然后拼接成新的链表。当其中1个链表遍历结束，将另外1个链表直接拼接在新的链表的尾部。 复杂度分析 假设2个链表的长度分别是n和m，则最大时间复杂度为$O(n+m)$、空间复杂度为$O(1)$。 代码1234567891011121314151617181920212223242526272829303132class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; // 定义头结点，方便建立新链表 ListNode *head = new ListNode(-1); // 遍历链表用的指针 ListNode *l3 = head; // 同时遍历两个链表并拼接值较小的结点到新链表中，同步更新链表指针，直至某个链表遍历结束 while (l1 != nullptr &amp;&amp; l2 != nullptr)&#123; if (l1-&gt;val &lt; l2-&gt;val)&#123; l3-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; l3-&gt;next = l2; l2 = l2-&gt;next; &#125; l3 = l3-&gt;next; &#125; // 将未遍历完的链表拼接至新链表 if(l1!=nullptr)&#123; l3-&gt;next = l1; &#125; if (l2 != nullptr)&#123; l3-&gt;next = l2; &#125; // 释放无意义头结点并返回其next l3 = head-&gt;next; delete head; return l3; &#125;&#125;; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
        <tag>单向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode206反转链表]]></title>
    <url>%2F2020%2F07%2F11%2FLeetCode206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[[toc] 题目介绍 题目链接 https://leetcode-cn.com/problems/reverse-linked-list/description/ 题目考点 链表，递归，迭代（用到了双指针），栈 题目难度 LeetCode-Easy 题目大意 给定1个链表，请将其反转 输入 链表的头结点 输出 反转后链表的头结点 题解一解题思路 递归法 定义递归函数（函数功能是反转链表并返回链表反转后的头结点），将链表分成A（头结点）和B（头结点以外的其它结点）2部分，通过递归将链表B反转并得到其新的头结点，然后将A拼接在反转后链表B的尾部（注意链表B反转前其头结点正好是反转后的尾结点），最终返回新的链表（B）。 复杂度分析 假设链表有n个结点，则递归有n层，所以时间复杂度为$O(n)$，空间复杂度为$O(n)$。 代码12345678910111213141516171819class Solution&#123;public: ListNode *reverseList(ListNode *head) &#123; if (nullptr == head || nullptr == head-&gt;next) return head; // devide the nodes into A(the original head) and B(the nodes except the original head). ListNode *ptrA = head; // A:原先的head ListNode *ptrB = reverseList(head-&gt;next); // B:将原先head以外的结点逆序并返回它的新head，此时head-&gt;next已经为链表B反转后的尾结点 // 将A连接到B后面并将A的next设为空 head-&gt;next-&gt;next = ptrA; ptrA-&gt;next = nullptr; // 返回反转后的链表 return ptrB; &#125;&#125;; 题解二解题思路 迭代法 本质就是头插法，需要用到双指针（1个遍历该链表，1个保存新链表的head），每取到1个结点就将其插入新链表的头部。 复杂度分析 假设链表有n个结点，则时间复杂度为$O(n)$、空间复杂度为$O(1)$。 代码1234567891011121314151617class Solution&#123;public: ListNode *reverseList(ListNode *head)&#123; ListNode *newHead = nullptr, *next; while (head != nullptr)&#123; // 保存下一个结点 next = head-&gt;next; // 把当前结点插到头部 head-&gt;next = newHead; // 更新头结点 newHead = head; // 更新当前结点 head = next; &#125; return newHead; &#125;&#125;; 题解三解题思路 栈法 遍历链表并将结点压入栈中，然后出栈建立新链表。 复杂度分析 假设链表有n个结点，则时间复杂度为$O(2n)$、空间复杂度为$O(n)$。 代码123456789101112131415161718192021class Solution&#123;public: ListNode *reverseList(ListNode *head)&#123; // 链表结点入栈（包括nullptr） stack&lt;ListNode*&gt; s; s.push(nullptr); for (auto p=head; p!=nullptr; p=p-&gt;next) s.push(p); // 取出新的头结点 head = s.top(); s.pop(); // 将当前结点的next指向前一个结点（pre） ListNode *pre = head; while(!s.empty())&#123; pre-&gt;next = s.top(); s.pop(); pre = pre-&gt;next; &#125; return head; &#125;&#125;; 题解四解题思路 原地反转法（三指针法） 定义3个指针pre、cur、next，以2个结点（pre和cur）为单位遍历各个结点。对于每个当前结点cur将其与pre的顺序逆置（cur-&gt;next=pre）再分别先后将pre和cur更新为cur和next。 复杂度分析 假设链表有n个结点，则时间复杂度为$O(n)$、空间复杂度为$O(1)$。 代码12345678910111213141516class Solution&#123;public: ListNode *reverseList(ListNode *head)&#123; ListNode *pre=nullptr, *cur=head, *next; while(cur!=nullptr)&#123; // 保存next next = cur-&gt;next; // 逆序 cur-&gt;next = pre; // 更新结点 pre = cur; cur = next; &#125; return pre; // cur为nullptr时，此时的pre是原链表的尾结点，也是链表反转后的头结点 &#125;&#125;; 参考链接 https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/ https://leetcode-cn.com/problems/reverse-linked-list/solution/si-lu-fen-xi-n-duo-chong-fang-shi-chu-li-ajn6/ 作者：@臭咸鱼 转载请注明出处！ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>栈</tag>
        <tag>迭代</tag>
        <tag>单向链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode160相交链表]]></title>
    <url>%2F2020%2F07%2F10%2FLeetCode160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目介绍 题目链接 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 题目考点 链表、双指针 题目难度 LeetCode简单 题目大意 给定2个链表，请找出它们的相交结点。 读题可知：两个指针相同（并不是2个结点的值相同）即需要求得的结果，2个链表的长度不确定，2个链表可能没有相交结点，链表中无循环。 输入 2个链表的头指针 输出 相交结点的指针 题解一解题思路 双指针法 假如2个链表有交叉点（intersection），则可以设这2个链表彼此不重复的结点分别为d1和d2，重复的结点为d，即链表A=d1+d、链表B=d2+d。如果1个链表遍历完则使其从另外1个链表的头部重新开始，形成2条长度相等的路径：d1+d+d2, d2+d+d1，这2条路径走完之后2个指针就刚好遍历到相交结点。如果这2个链表没有交叉点，那最后2个指针都正好是空。 复杂度分析 假设2个链表的结点数分别为n和m，则时间复杂度为$O(n+m)$、空间复杂度为$O(1)$。这个思路是该题效率最高的算法。 代码123456789101112131415161718192021222324252627282930// Problem: Leetcode 160// URL: https://leetcode-cn.com/problems/intersection-of-two-linked-lists/// Tags: Linked List// Difficulty: Easystruct ListNode&#123; int val; ListNode* next; ListNode(int x):val(x),next(NULL)&#123;&#125;&#125;;class Solution&#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)&#123; // Deal with the border "nullptr" if (nullptr==headA || nullptr==headB) &#123; return nullptr; &#125; ListNode *ptrA = headA; ListNode *ptrB = headB; // d1+d+d2=d2+d+d1 while (ptrA != ptrB)&#123; ptrA = nullptr == ptrA ? headB : ptrA-&gt;next; ptrB = nullptr == ptrB ? headA : ptrB-&gt;next; &#125; return ptrA; &#125;&#125;; 题解二 暴力枚举法 写2层循环，外循环遍历链表A，内循环遍历链表B并判断此时链表A的当前结点是否与链表B中某个结点相同。 复杂度分析 假设2个链表的结点数分别为n和m，则时间复杂度为$O(nm)$、空间复杂度为$O(1)$。 代码略 题解三 哈希法 遍历链表A，将每个结点都放在哈希表中（可以用unordered_set，它底层就是哈希表。我看很多题解里用的set，它的底层不是哈希表而是二叉树），然后遍历链表B找到第1个在哈希表中的结点。 复杂度分析 假设2个链表的结点数分别为n和m，则平均时间复杂度为$O(n+m)$、空间复杂度为$O(m)$或$O(n)$。 代码略 题解四 栈法 将2个链表的结点压入栈中，然后弹栈找到最后1个相同结点，即为要找的相交节点。 复杂度分析 假设2个链表的结点数分别为n和m，则最小时间复杂度为$O(n+m)$、最大时间复杂度为$O(n+m+max(n,m))$、空间复杂度为$O(m+n)$。 参考链接 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/lian-biao-xiang-jiao-shuang-zhi-zhen-onshi-jian-fu/ https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/dao-tui-xun-zhao-lian-biao-jiao-dian-by-6gyav/ 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>单向链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算某天的下一天：黑盒测试之等价类划分+JUnit参数化测试]]></title>
    <url>%2F2020%2F04%2F28%2F%E8%AE%A1%E7%AE%97%E6%9F%90%E5%A4%A9%E7%9A%84%E4%B8%8B%E4%B8%80%E5%A4%A9%EF%BC%9A%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86-JUnit%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[题目要求测试以下程序：该程序有三个输入变量month、day、year（month、day和year均为整数值，并且满足：1≤month≤12、1≤day≤31和1900≤year≤2050)，分别作为输入日期的月份、日、年份，通过程序可以输出该输入日期在日历上隔一天的日期。例如，输入为2004年11月30日，则该程序的输出为2004年12月1日。 划分等价类，按照等价类划分法设计测试用例； 编写getNextDate函数； 掌握Junit4的用法，使用Junit4测试getNextDate函数。 等价类表假设输入格式为year,month,day，且三个输入变量year、month和day均被输入。 year要区分闰年和平年，其中闰年还可以分为世纪闰年和普通闰年，且year要属于[1900,2050]。 month要根据该月有几天来进行区分，并且需要考虑是否向year进位，且month要属于[1,12]。 day要根据月份来判断天数是否合法，并且需要考虑是否向month进位，且day要属于[1,31]。 等价类划分如下。 测试用例有效等价类测试用例共有5个有效等价类测试用例。 测试数据 期望结果 覆盖范围 2004/12/25 2004/12/26 2,10,14 2001/2/28 2001/3/1 3,7,15 2000/2/29 2000/3/1 1,7,16 2001/4/30 2001/5/1 3,8,17 2001/5/31 2001/6/1 3,9,18 无效等价类测试用例共有12个有效等价类测试用例。 测试数据 期望结果 覆盖范围 1899/6/1 year非法 4 2051/6/1 year非法 5 a/6/1 year非法 6 1999/0/1 month非法 11 1999/13/1 month非法 12 1999/a/1 month非法 13 1999/1/0 day非法 19 1999/1/32 day非法 20 1999/1/a day非法 21 2001/2/29 day非法 22 2000/2/30 day非法 23 2001/4/31 day非法 24 源代码项目结构如下图所示 DateUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206package com.company;public class DateUtil &#123; // 有31天的月份 private static int[] monthOfThirtyOne = new int[]&#123;1,3,5,7,8,10,12&#125;; // 有30天的月份 private static int[] monthOfThirty = new int[]&#123;4,6,9,11&#125;; // 年月日 private int year; private int month; private int day; // 最终实现的功能，输入是一个“年/月/日”格式的字符串； // 如果函数运行成功，输出则是相同格式的下一天，否则是错误信息 public String getNextDate(String dateStr)&#123; String updateResult = this.updateDate(dateStr); // 如果输入合法 if (updateResult.equals("success"))&#123; String checkResult = this.checkDate(); // 如果输入合法 if (checkResult.equals("valid"))&#123; // 计算明天的日期 return this.calcNextDate(); &#125; return checkResult; &#125; return updateResult; &#125; // 根据输入字符串转换并更新年月日 private String updateDate(String dateStr)&#123; // 获取年月日 String[] numbers = dateStr.split("/"); try&#123; this.year = Integer.parseInt(numbers[0]); &#125;catch (NumberFormatException e)&#123; return "year非法"; &#125; try&#123; this.month = Integer.parseInt(numbers[1]); &#125;catch (NumberFormatException e)&#123; return "month非法"; &#125; try&#123; this.day = Integer.parseInt(numbers[2]); &#125;catch (NumberFormatException e)&#123; return "day非法"; &#125; return "success"; &#125; // 检查日期是否合法 private String checkDate()&#123; String valid = "valid"; String yearInvalid = "year非法"; String monthInvalid = "month非法"; String dayInvalid = "day非法"; // year合法 if (year&gt;=1900&amp;&amp;year&lt;=2050)&#123; // month合法 if (month&gt;=1&amp;&amp;month&lt;=12)&#123; // day小于1 if (day&lt;=0)&#123; return dayInvalid; &#125; // 至此能保证day大于0 // 是2月 if (month==2)&#123; // 闰年 if (yearIsLeap(year))&#123; // 1-29 if (day&lt;=29)&#123; return valid; &#125;else&#123; return dayInvalid; &#125; &#125; // 平年2月 else&#123; // 1-28 if (day&lt;=28)&#123; return valid; &#125;else&#123; return dayInvalid; &#125; &#125; &#125; // 至此能保证不是2月 // 是否为31天的月 for(int i=0;i&lt;7;++i)&#123; if (month==monthOfThirtyOne[i])&#123; // 1-31 if (day&lt;=31)&#123; return valid; &#125;else&#123; return dayInvalid; &#125; &#125; &#125; // 至此能保证不是2月和31天的月 // 是否为30天的月 for(int i=0;i&lt;4;++i)&#123; if (month==monthOfThirty[i])&#123; // 1-30 if (day&lt;=30)&#123; return valid; &#125;else&#123; return dayInvalid; &#125; &#125; &#125; &#125; // month非法 else&#123; return monthInvalid; &#125; &#125; // year非法 return yearInvalid; &#125; // 计算下一天 private String calcNextDate()&#123; int yearNext; int monthNext; int dayNext=day+1; int dayCarry=0; int monthCarry=0; // 处理day // 是2月 if (month==2)&#123; // 闰年 if (yearIsLeap(year))&#123; // 1-29 if (day==29)&#123; dayNext = 1; dayCarry = 1; &#125; &#125; // 平年2月 else&#123; // 1-28 if (day==28)&#123; dayNext = 1; dayCarry = 1; &#125; &#125; &#125; // 不是2月 else&#123; boolean isThirtyOne= false; // 是否为31天的月 for(int i=0;i&lt;7;++i)&#123; if (month==monthOfThirtyOne[i])&#123; isThirtyOne = true; // 1-31 if (day==31)&#123; dayNext = 1; dayCarry = 1; &#125; break; &#125; &#125; // 至此能保证是30天的月 if (!isThirtyOne)&#123; // 1-30 if (day==30)&#123; dayNext = 1; dayCarry = 1; &#125; &#125; &#125; // 处理月 if (month+dayCarry&gt;12)&#123; monthNext = 1; monthCarry = 1; &#125;else&#123; monthNext = month+dayCarry; &#125; // 处理年 yearNext = year+monthCarry; return yearNext +"/"+ monthNext +"/"+ dayNext; &#125; // 判断某一年是否为闰年 private boolean yearIsLeap(int year)&#123; // 普通闰年和世纪闰年 if ((year%4==0&amp;&amp;year%100!=0)||(year%400==0))&#123; return true; &#125; // 平年 return false; &#125;&#125; DateUtilTest.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.test;import com.company.DateUtil;import static org.junit.Assert.*;import org.junit.Test;//1、参数化测试：引入相关的包和类import java.util.Collection;import java.util.Arrays;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;@RunWith(Parameterized.class) //2、参数化测试：更改测试运行器为RunWith(Parameterized.class)public class DateUtilTest &#123; //3、参数化测试：声明变量用来存放预期值与结果值 private DateUtil util = new DateUtil(); private String date; private String except; //4、参数化测试：声明一个返回值为 Collection 的公共静态方法，并使用@Parameters 进行修饰 @Parameters public static Collection data()&#123; return Arrays.asList(new Object[][]&#123; &#123;"2004/12/25", "2004/12/26"&#125;, &#123;"2001/2/28", "2001/3/1"&#125;, &#123;"2000/2/29", "2000/3/1"&#125;, &#123;"2001/4/30", "2001/5/1"&#125;, &#123;"2001/5/31", "2001/6/1"&#125;, &#123;"1899/6/1", "year非法"&#125;, &#123;"2051/6/1", "year非法"&#125;, &#123;"a/6/1", "year非法"&#125;, &#123;"1999/0/1", "month非法"&#125;, &#123;"1999/13/1", "month非法"&#125;, &#123;"1999/a/1", "month非法"&#125;, &#123;"1999/1/0", "day非法"&#125;, &#123;"1999/1/32", "day非法"&#125;, &#123;"1999/1/a", "day非法"&#125;, &#123;"2001/2/29", "day非法"&#125;, &#123;"2000/2/30", "day非法"&#125;, &#123;"2001/4/31", "day非法"&#125;, &#125;); &#125; //5、参数化测试：为测试类声明一个带有参数的公共构造方法，并在其中为声明变量赋值 public DateUtilTest(String date, String except)&#123; this.date = date; this.except = except; &#125; @Test public void testGetNextDate()&#123; assertEquals(except, util.getNextDate(date)); &#125;&#125; 测试结果如下图所示，17个测试用例均测试成功，程序实际输出与期望值相同。 实验总结本次实验的主要目的是巩固黑盒测试方法中的等价类划分法的知识，练习JUnit的参数化测试。在本次实验中，我认为我的getNextDate函数的实现并不是很优雅，比较过程化。写这个函数花了我很多时间，主要问题在于我没有抓住一些关键的、抽象的逻辑和子函数，比如天向月份进位和月份向年份完全可以参照加法器的循环、可以写一个函数根据年份和月份判断出天数的最大值等等。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>软件测试</tag>
        <tag>JUnit</tag>
        <tag>Java</tag>
        <tag>黑盒测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑盒测试之因果图法]]></title>
    <url>%2F2020%2F04%2F20%2F%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目要求设要对一个自动饮料售货机软件进行黑盒测试。该软件的规格说明如下：“有一个处理单价为1元5角的盒装饮料的自动售货机软件，若投入1元5角硬币，按下“可乐”、“雪碧”或“红茶”按钮，相应的饮料就送出来。若投入的是2元硬币，在送出饮料的同时退还5角硬币。“ 试利用因果图法，建立该软件的因果图； 设计测试该软件的全部测试用例。 具体步骤原因和结果 原因 中间原因 结果 c1：投入1元5角硬币 m1：已投币 e1：退还5角硬币 c2：投入2元硬币 c3：按下“可乐”按钮 e2：送出可乐 c4：按下“雪碧”按钮 m2：已按下按钮 e3：送出雪碧 c5：按下“红茶”按钮 e4：送出红茶 因果图 决策表 1 2 3 4 5 6 c1 0 0 0 0 1 1 c2 0 0 0 0 0 0 c3 0 1 0 0 0 1 c4 0 0 1 0 0 0 c5 0 0 0 1 0 0 m1 0 0 0 0 1 1 m2 0 1 1 1 0 1 e1 e2 √ e3 e4 7 8 9 10 11 12 c1 1 1 0 0 0 0 c2 0 0 1 1 1 1 c3 0 0 0 1 0 0 c4 1 0 0 0 1 0 c5 0 1 0 0 0 1 m1 1 1 1 1 1 1 m2 1 1 0 1 1 1 e1 √ √ √ e2 √ e3 √ √ e4 √ 测试用例 测试用例编号 输入 预期输出 1 不投币，不按按钮 无 2 不投币，按下“可乐”按钮 无 3 不投币，按下“雪碧”按钮 无 4 不投币，按下“红茶”按钮 无 5 投1元5角硬币，不按按钮 无 6 投1元5角硬币，按下“可乐”按钮 送出可乐 7 投1元5角硬币，按下“雪碧”按钮 送出雪碧 8 投1元5角硬币，按下“红茶”按钮 送出红茶 9 投2元硬币，不按按钮 无 10 投2元硬币，按下“可乐”按钮 送出可乐并退还5角硬币 11 投2元硬币，按下“雪碧”按钮 送出雪碧并退还5角硬币 12 投2元硬币，按下“红茶”按钮 送出红茶并退还5角硬币 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>软件测试</tag>
        <tag>黑盒测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑盒测试之等价类划分]]></title>
    <url>%2F2020%2F04%2F07%2F%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目要求某城市电话号码由三部分组成。它们的名称和内容分别是： 地区码：空白或三位数字； 前缀：非“0”或“1”的三位数字 要求不是很明确，所以将其理解为不包括“0**”也不包括“1”的三位数字** 后缀：4位数字。 假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的电话号码。根据该程序的规格说明，做等价类的划分，并设计测试用例。（按照上课例子列表格） 等价类表等价类的划分似乎没有统一的标准？比如我这里的无效等价类划分得挺简单的，可以划分得更细一些。 输入数据 有效等价类 无效等价类 地区码 1空白 3不是空白也不是三位数字 地区码 2三位的数字 无 前缀 4不包含0且不包含1的三位数字 5至少包含一个0或1 前缀 无 6不是三位数字 后缀 7四位数字 8不是四位数字 测试用例有效等价类测试用例 测试数据 期望结果 覆盖范围 地区码为空白 前缀为222 后缀为1234 程序将该输入判定为有效输入 1,4,7 地区码为123 前缀为222 后缀为1234 程序将该输入判定为有效输入 2,4,7 无效等价类测试用例 测试数据 期望结果 覆盖范围 地区码为22 前缀为222 后缀为1234 程序将该输入判定为无效输入 3 地区码为空白 前缀为123 后缀为1234 程序将该输入判定为无效输入 5 地区码为空白 前缀为22 后缀为1234 程序将该输入判定为无效输入 6 地区码为空白 前缀为222 后缀为123 程序将该输入判定为无效输入 8 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>软件测试</tag>
        <tag>黑盒测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现称重3次找到假球]]></title>
    <url>%2F2020%2F04%2F07%2FJava%E5%AE%9E%E7%8E%B0%E7%A7%B0%E9%87%8D3%E6%AC%A1%E6%89%BE%E5%88%B0%E5%81%87%E7%90%83%2F</url>
    <content type="text"><![CDATA[前言之前老师让写一个程序，就写了写，本文是我自己的写法。 这里有老师的Java实现代码，请点击 正文题目要求 程序要求 10个铅球中有一个假球（比其他铅球的重量要轻），用天平三次称出假球。 程序设计思路 第一次使用天平分别称5个球，判断轻的一边有假球；拿出轻的5个球，取出其中4个第二次称，两边分别放2个球：如果两边同重，则剩下的球为假球；若两边不同重，拿出轻的两个球称第三次，轻的为假球。 代码注释应该还算详细哈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Main &#123; // 计算数组中连续几个球的质量之和，区间是[startIndex,endIndex] public static int sum(int[] balls,int startIndex, int endIndex)&#123; int ret =0; for(int i=startIndex;i&lt;=endIndex;++i)&#123; ret+=balls[i]; &#125; return ret; &#125; // 输入balls是10个球的质量，该函数返回假球在该数组中的下标 public static int findFakeBall(int[] balls)&#123; // 第一次称重，十个，五五分，默认左边五个球中有假球 int fiveStartIndex = 0; // 如果右边五个球中有假球 if (sum(balls,5,9)&lt;sum(balls,0,4))&#123; fiveStartIndex = 5; &#125; // 第二次称重，五个，二一二分，默认左边两个球中有假球 int twoStartIndex = fiveStartIndex+0; // 五个球中左边两个球的质量之和和右边两个球的质量之和 int leftTwoSum = sum(balls,fiveStartIndex+0,fiveStartIndex+1); int rightTwoSum = sum(balls,fiveStartIndex+3,fiveStartIndex+4); // 如果右边两个球中有假球 if(rightTwoSum&lt;leftTwoSum)&#123; twoStartIndex = fiveStartIndex+3; // 如果左右两边的四个球中没有假球，则中间的球是假球 &#125;else if(rightTwoSum==leftTwoSum)&#123; return fiveStartIndex+2; &#125; // 第三次称重 // 如果两个球中左边是假球 if(balls[twoStartIndex]&lt;balls[twoStartIndex+1])&#123; return twoStartIndex; // 如果两个球中右边是假球 &#125;else&#123; return twoStartIndex+1; &#125; &#125; // 对函数findFakeBall()进行测试 public static void main(String[] args) &#123; int[] balls = &#123;5,10,10,10,10,10,10,10,10,10&#125;; // 所有球的质量 int fakeIndex =findFakeBall(balls); System.out.println(fakeIndex); &#125;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUnit白盒测试之基本路径测试：称重3次找到假球]]></title>
    <url>%2F2020%2F04%2F07%2FJUnit%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%EF%BC%9A%E7%A7%B0%E9%87%8D3%E6%AC%A1%E6%89%BE%E5%88%B0%E5%81%87%E7%90%83%2F</url>
    <content type="text"><![CDATA[前言记录一次软件测试课程的课后作业，作业内容是白盒测试中的基本路径测试，步骤如下 分析程序的控制流 计算环形复杂度 找出基本路径 设计测试用例 执行测试用例（要求使用JUnit） 作业要求使用白盒测试用例设计方法为下面的程序设计测试用例（基本路径测试）并用JUnit测试： 程序要求 10个铅球中有一个假球（比其他铅球的重量要轻），用天平三次称出假球。 程序设计思路 第一次使用天平分别称5个球，判断轻的一边有假球；拿出轻的5个球，取出其中4个第二次称，两边分别放2个球：如果两边同重，则剩下的球为假球；若两边不同重，拿出轻的两个球称第三次，轻的为假球。 递交材料 测试用例设计电子稿、源程序、JUnit测试截图。 程序代码及控制流图程序代码文件SearchBall.java内容如下。 注意不要让代码的行号变动，程序流图中结点的编号是根据这份代码里每条执行语句里的行号对应的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package module;public class SearchBall &#123; private static int x[]=new int[10]; public SearchBall()&#123;&#125; public void setBWeight(int w[])&#123; for(int i=0;i&lt;w.length;i++)&#123; x[i]=w[i]; &#125; &#125; public String BeginSearch()&#123; if(x[0]+x[1]+x[2]+x[3]+x[4]&lt;x[5]+x[6]+x[7]+x[8]+x[9])&#123; if(x[1]+x[2]==x[3]+x[4])&#123; return "1号是假球"; &#125; if(x[1]+x[2]&lt;x[3]+x[4])&#123; if (x[1]&lt;x[2]) &#123; return "2号是假球"; &#125;else &#123; return "3号是假球"; &#125; &#125;else &#123; if (x[3]&lt;x[4])&#123; return "4号是假球"; &#125; else&#123; return "5号是假球"; &#125; &#125; &#125;else &#123; if(x[6]+x[7]==x[8]+x[9])&#123; return "6号是假球"; &#125; if(x[6]+x[7]&lt;x[8]+x[9]) &#123; if (x[6]&lt;x[7]) &#123; return "7号是假球"; &#125;else &#123; return "8号是假球"; &#125; &#125;else &#123; if (x[8]&lt;x[9]) &#123; return "9号是假球"; &#125;else &#123; return "10号是假球"; &#125; &#125; &#125; &#125;&#125; 程序控制流图下图中结点中的数字是对应可执行语句在上面代码中的行号；边上的Y代表判定结果为真，N代表判定结果为假。 计算环形复杂度控制流图$G$的环形复杂度计算公式：$V(G)=E-N+2$，其中$E$为控制流图中边的数量，$N$是控制流图中的结点数量。 函数BeginSearch()的控制流图的环形复杂度为 V(G)=18-19+2=1基本路径从程序流图中可知，共有10条基本路径，具体如下 路径编号 经过结点 1 12-13-14 2 12-13-16-17-18 3 12-13-16-17-20 4 12-13-16-23-24 5 12-13-16-23-27 6 12-31-32 7 12-31-34-35-36 8 12-31-34-35-38 9 12-31-34-41-42 10 12-31-34-41-44 测试用例设计与执行测试用例设计 路径编号 用例输入 期待输出 1 {5, 10, 10, 10, 10, 10, 10, 10, 10, 10} “1号是假球” 2 {10, 5, 10, 10, 10, 10, 10, 10, 10, 10} “2号是假球” 3 {10, 10, 5, 10, 10, 10, 10, 10, 10, 10} “3号是假球” 4 {10, 10, 10, 5, 10, 10, 10, 10, 10, 10} “4号是假球” 5 {10, 10, 10, 10, 5, 10, 10, 10, 10, 10} “5号是假球” 6 {10, 10, 10, 10, 10, 5, 10, 10, 10, 10} “6号是假球” 7 {10, 10, 10, 10, 10, 10, 5, 10, 10, 10} “7号是假球” 8 {10, 10, 10, 10, 10, 10, 10, 5, 10, 10} “8号是假球” 9 {10, 10, 10, 10, 10, 10, 10, 10, 5, 10} “9号是假球” 10 {10, 10, 10, 10, 10, 10, 10, 10, 10, 5} “10号是假球” Junit执行测试用例基于JUnit生成的测试代码，我补充了测试函数BeginSearch()的代码，文件SearchBallTest.java内容如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package test.module; import org.junit.Test; import org.junit.Before; import org.junit.After; import module.SearchBall;import static org.junit.Assert.assertEquals;/** * SearchBall Tester. * * @author &lt;Authors name&gt; * @since &lt;pre&gt;4月 7, 2020&lt;/pre&gt; * @version 1.0 */ public class SearchBallTest &#123; @Beforepublic void before() throws Exception &#123; &#125; @Afterpublic void after() throws Exception &#123; &#125; /** * * Method: setBWeight(int w[]) * */ @Testpublic void testSetBWeight() throws Exception &#123; //TODO: Test goes here... &#125; /** * * Method: BeginSearch() * */ @Testpublic void testBeginSearch() throws Exception &#123; SearchBall obj = new SearchBall(); int[] input; int ballIndex; // 遍历测试各个基本路径 for(int i=0;i&lt;10;++i)&#123; // 生成用例输入 input = new int[]&#123;10, 10, 10, 10, 10, 10, 10, 10, 10, 10&#125;; input[i]=5; obj.setBWeight(input); // 测试用例输出 ballIndex = i+1; assertEquals(ballIndex+"号是假球", obj.BeginSearch()); &#125;&#125; &#125; 执行函数testBeginSearch()，得到如下图所示的结果（从下图也可以看到项目的结构） 其它 我自己实现的找到假球的程序 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>软件测试</tag>
        <tag>白盒测试</tag>
        <tag>基本路径测试</tag>
        <tag>JUnit</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用pymysql和Flask搭建后端，响应前端POST和GET请求，实现登录和注册功能]]></title>
    <url>%2F2020%2F04%2F05%2F%E7%94%A8pymysql%E5%92%8CFlask%E6%90%AD%E5%BB%BA%E5%90%8E%E7%AB%AF%EF%BC%8C%E5%93%8D%E5%BA%94%E5%89%8D%E7%AB%AFPOST%E5%92%8CGET%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%92%8C%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言这次作业不仅需要我建立一个数据库(详情请点击这里)，还需要我基于这个数据库写后端接口（注册和登录）供前端访问，接收前端的POST和GET请求，并将登录、注册是否成功传给前端。 本文介绍如何用Flask搭建后端，其中使用了pymysql操作mysql数据库，也会做这个部分的介绍。 正文需要为前端提供的接口有两个：注册和登录，为此我定义了四个函数，分别是 select_user(userid, password) insert_user(userid, password, phone, email, company) on_register() on_login() 前两个函数是操作数据库，被后两个函数调用；后两个函数是给前端的接口。 后端说明整个后端的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from flask import Flask, requestimport jsonimport pymysqlfrom flask_cors import CORS# 定义appapp = Flask(__name__)# 设置跨域CORS(app, supports_credentials=True)# 连接数据库，账号是root，密码是000，数据库名称是shopdatadb = pymysql.connect("localhost", "root", "000", "shopdata") # 连接数据库cursor = db.cursor() # 定义游标# select a user，根据userid和password获取一个用户是否存在，即判断登录是否成功def select_user(userid, password): # mysql语句 select_user_sql = 'select * from userinfo where userid="%s" and password="%s";' % (userid, password) # 执行mysql语句 result = cursor.execute(select_user_sql) db.commit() # 如果返回了一条数据，则登录成功，否则登录失败 if 1 == result: result = True else: result = False print('there is no user where userid="%s and password="%s"!!' % (userid, password)) return result# insert a user，根据userid、password等信息，生成一个元组，将其插入数据库shopdata的userinfo表def insert_user(userid, password, phone, email, company): # mysql语句 insert_user_sql = 'insert into userinfo(userid, password, phone, email, company)' \ 'values("%s", "%s", "%s", "%s", "%s");' % (userid, password, phone, email, company) # 执行mysql语句，如果插入成功，则注册成功，否则注册失败 try: cursor.execute(insert_user_sql) db.commit() print('insert user where userid="%s" and password="%s"!!' % (userid, password)) result = True except: print('can not insert user where userid="%s" and password="%s"!!' % (userid, password)) result = False finally: return result# on_register，提供给前端的注册接口@app.route("/api/register", methods=['POST']) # 路由，响应POST请求def on_register(): # 默认的用户名和密码（该用户不存在且非法） userid = '' password = '' phone = '' email = '' company = '' # 判断传入的参数是否为空，并取出前端传来的参数 data = request.get_data() # print(data) if data is not None: # 将bytes类型转化为字典。对应的，前端发过来的内容应该是JSON.stringify(一个对象) data = json.loads(data) # 转化为字典对象 # print(data) userid = data.get('userid') password = data.get('password') phone = data.get('phone') email = data.get('email') company = data.get('company') # 判断参数是否非法。若非法则直接判断出注册失败，若合法则尝试注册，再根据数据库操作结果判断。 if len(userid) &gt; 0 and len(password) &gt; 0 and len(phone) &gt; 0 and len(email) &gt; 0 and len(password) &gt; 0: return_dict = &#123;'success': insert_user(userid=userid, password=password, phone=phone, email=email, company=company)&#125; else: return_dict = &#123;'success': False&#125; # 返回结果（结果暂时简单点，只返回成功或失败） return json.dumps(return_dict) # 字典转json# on_login，提供给前端的登录接口@app.route("/api/login", methods=['GET']) # 路由，响应GET请求def on_login(): # 默认的用户名和密码（数据库中不存在该用户） userid = '' password = '' # 判断传入的参数是否为空，获取前端传来的参数 if request.args is not None: print(request.args) data = request.args.to_dict() userid = data.get('userid') password = data.get('password') # 查询数据库 result = select_user(userid=userid, password=password) if not result: print('user where userid="%s and password="%s" login!!' % (userid, password)) # 返回登录结果（暂时简单一点，成功或失败） return_dict = &#123;'success': result&#125; return json.dumps(return_dict) # 字典转jsonif __name__ == '__main__': # 运行app app.run() # 程序结束时释放数据库资源 cursor.close() db.close() # 关闭连接 值得注意的是，这里的两个接口分别响应POST请求和GET请求。 可以发现，两个接口获取前端传过来的参数的方式是不同的： GET 1data = request.args.to_dict() # 需from flask import request 这样拿到的data是一个python的字典对象 POST 12data = request.get_data() # 需from flask import requestdata = json.loads(data) # 转化为字典对象。需import json 这两行代码才拿到一个python的字典对象 接口获取前端传过来的参数的方式与其响应的请求类型（如POST、GET、POST和GET）是对应的。 对应地，前端发过来的参数类型也需要和后端进行匹配。 前端代码这里给出前端处理用户登录和注册请求的函数。 login 123456789101112131415161718192021222324252627282930function login() &#123; var url = "http://127.0.0.1:5000/api/login"; var userid = document.getElementById("userid"); var password = document.getElementById("password"); $.ajax(&#123; url: url, type: "GET", data: &#123; userid: userid.value, password: password.value, &#125;, success: function(data) &#123; var data1 = JSON.parse(data); // console.log(data1); if (data1.success) &#123; window.sessionStorage.setItem("userid", userid.value); alert("登录成功！进入主页面！"); window.location.href = 'index.html'; &#125; else &#123; alert("登录失败！请输入正确的账号和密码！"); &#125; &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; if (textStatus === 'timeout') &#123; alert('请求超时，请重试！'); &#125; &#125; &#125;)&#125; register 1234567891011121314151617181920212223242526272829303132333435363738function register() &#123; var password1 = document.getElementById("password1").value; var password2 = document.getElementById("password2").value; var userid = document.getElementById("userid").value; var phone = document.getElementById("phone").value; var email = document.getElementById("email").value; var company = document.getElementById("company").value; if (password1 !== password2) &#123; alert("两次输入的密码不相同,请重新输入！"); return; &#125; $.ajax(&#123; url: "http://127.0.0.1:5000/api/register", type: "POST", // 转成json data: JSON.stringify(&#123; userid: userid, password: password1, phone: phone, email: email, company: company &#125;), success: function(data) &#123; var data1 = JSON.parse(data); if (data1.success) &#123; alert("注册成功，请登录！"); window.location.href = 'login.html'; &#125; else &#123; alert("注册失败，请检查您输入的信息是否正确！"); &#125; &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; if (textStatus === 'timeout') &#123; alert("请求超时！"); &#125; &#125; &#125;)&#125; 可以注意到，用ajax发送GET请求和PSOT请求时，我发的数据类型是不一样的。 login是GET请求，发送了json字符串 1234567JSON.stringify(&#123; userid: userid, password: password1, phone: phone, email: email, company: company&#125;) register是POST请求，发送了javascript的类的对象 1234&#123; userid: userid.value, password: password.value,&#125; 至此，本文对这次作业中后端搭建的介绍就结束了。 这次作业算是我第一次写后端，也是我第一次接触Flask，如果我有写错的地方，请在评论区指正！ 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>python</tag>
        <tag>mysql</tag>
        <tag>Flask</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作业过程及其问题的记录：mysql建立数据库、建表、查询和插入等]]></title>
    <url>%2F2020%2F04%2F04%2F%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%85%B6%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%EF%BC%9Amysql%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E5%BB%BA%E8%A1%A8%E3%80%81%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8F%92%E5%85%A5%E7%AD%89%2F</url>
    <content type="text"><![CDATA[前言这次的作业需要我建立一个小的数据库。 这次作业我使用了mysql，进行了建库、建表、查询、插入等操作。 本文是对本次作业相关的mysql操作过程及过程中出现的问题的记录。 另一篇文章(详情请点击)介绍了如何使用pymysql连接该数据库并使用Flask搭建后端接口，响应前端的GET和POST请求。 正文作业中对数据库的要求是： 建立一个用户信息表，其包括用户名、密码、手机号、邮箱和手机号等属性，并向其中插入几条测试数据。 登录数据库因为挺久没用数据库，就先测试下自己之前装的mysql还能不能用，于是打开CMD运行如下指令： 1mysql 出现如下错误： 1ERROR 1045 (28000): Access denied for user 'ODBC'@'localhost' (using password: NO) 看起来是因为没输密码 所以输入密码，运行如下指令： 1mysql -u root -p -u参数是指username、user之类的，即用户名，我的用户名是root； -p参数是指password，运行下面这条指令后，会要求输入密码，输入正确密码即成功登录。 我的mysql环境还可以，直接登录成功。 建库执行如下指令，创建名为shopdata的数据库，会得到Query OK, 1 row affected (x.xx sec)。 1create database shopdata; 进入/选择数据库执行如下指令后，会看到Database changed的信息。 1use shopdata; 建表执行如下指令，创建名为userinfo的表。 我这里对userinfo的定义是： 主键是用户名userid password是非NULL的 phone和email是unique的 这5个属性的类型都是varchar(15) 最长15，对于email来说不太够用 1234567create table userinfo ( &apos;userid&apos; varchar(15) primary key, &apos;password&apos; varchar(15) not null, &apos;company&apos; varchar(15), &apos;phone&apos; varchar(15) unique, &apos;email&apos; varchar(15) unique); 执行上边这条命令后，得到了一个错误： 123ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''userid' varchar(15) primary key, 'password' varchar(15) not null, 'comp' at line 2 经查询，发现属性名应该用反引号`而不是单引号‘，所以将单引号改成反引号，执行如下命令： 1234567create table userinfo ( `userid` varchar(15) primary key, `password` varchar(15) not null, `company` varchar(15), `phone` varchar(15) unique, `email` varchar(15) unique); 这条命令执行成功，得到Query OK, 0 rows affected (x.xx sec)。 查看userinfo表执行如下命令，查看userinfo表的结构。 1describe userinfo; 执行后，得到如下结果： 12345678910+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| userid | varchar(15) | NO | PRI | NULL | || password | varchar(15) | NO | | NULL | || company | varchar(15) | YES | | NULL | || phone | varchar(15) | YES | UNI | NULL | || email | varchar(15) | YES | UNI | NULL | |+----------+-------------+------+-----+---------+-------+5 rows in set (0.57 sec) 插入3条数据执行如下命令，插入3条数据。 1234insert into userinfo values (&apos;user1&apos;,&apos;0000&apos;,&apos;zstu&apos;,&apos;13777860000&apos;,&apos;7746@qq.com&apos;), (&apos;user2&apos;,&apos;0000&apos;,&apos;zstu&apos;,&apos;13777860001&apos;,&apos;7747@qq.com&apos;), (&apos;user3&apos;,&apos;0000&apos;,&apos;zstu&apos;,&apos;13777860002&apos;,&apos;7748@qq.com&apos;); 执行后，得到如下信息： 12Query OK, 3 rows affected (0.11 sec)Records: 3 Duplicates: 0 Warnings: 0 查询数据执行如下语句，查询所有元组。 1select * from userinfo; 执行后，得到如下结果（在我做好作业后、写这篇博客前，我已经插入了一些其他的数据，所以有9条记录）： 1234567891011121314+------------+----------+---------+-------------+--------------+| userid | password | company | phone | email |+------------+----------+---------+-------------+--------------+| 111 | 111 | 111 | 111 | 111 || 112 | 000 | 111 | 000 | 000 || aa | 111 | 11 | 11 | 11 || test_1 | 00 | NULL | NULL | NULL || user_test2 | 0000 | NULL | NULL | NULL || user1 | 0000 | zstu | 13777860000 | 7746@qq.com || user2 | 0000 | zstu | 13777860001 | 7747@qq.com || user3 | 0000 | zstu | 13777860002 | 7748@qq.com || 232222 | 0000 | 城站 | 12306 | 12306@qq.com |+------------+----------+---------+-------------+--------------+9 rows in set (0.00 sec) 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Python的TypeError not all arguments converted during string formatting]]></title>
    <url>%2F2020%2F04%2F04%2F%E5%85%B3%E4%BA%8EPython%E7%9A%84TypeError-not-all-arguments-converted-during-string-formatting%2F</url>
    <content type="text"><![CDATA[前言在把yolov3的cfg文件转换为model_defs时，我忘记把str类型转换成int了，导致了一个错误，在此记录下来。 正文 如上图所示，&#39;32&#39;%2就是错误发生的地方。 我以为我拿到的是一个int类型的32，想判断它是偶数还是奇数。 实际上我拿到的是一个str类型的&#39;32&#39;，这时python的解释器并没有把%理解成取余，而是理解成了这种东西。 我不知道“这种东西”的定义，但知道其用法和语法，其语法是这样的： 12name = 'cxy'print('%s is handsome!' % name) 也就是说，解释器把%理解成了上面代码中print语句中的第二个%，因此出现了这个TypeError。 关于该TypeError，也有其他的原因，如https://blog.csdn.net/lvsehaiyang1993/article/details/80909984。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决GPU显存未释放问题]]></title>
    <url>%2F2020%2F04%2F04%2F%E8%A7%A3%E5%86%B3GPU%E6%98%BE%E5%AD%98%E6%9C%AA%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言今早我想用多块GPU测试模型，于是就用了PyTorch里的torch.nn.parallel.DistributedDataParallel来支持用多块GPU的同时使用（下面简称其为Dist）。 程序运行时，由于程序中其他部分的代码（与Dist无关的代码）出现了错误，导致程序退出。这次使用Dist时没有考虑和处理这种程序崩溃的情况，因此在程序退出前没有用Dist关闭生成的所有进程，最终导致本次进程运行后GPU显存未释放（经观察，发现是由于没有用Dist关闭所有进程，导致程序运行后还有一部分进程在运行）。 下面介绍这次我解决该问题的过程。 正文MVEMinimal Verifiable Examples，关于本问题的程序代码如下： 1234567891011121314import torch.distributed as dist# 一些代码：定义model等some code# 初始化并行训练dist.init_process_group(xxxx) # 函数参数省略model = torch.nn.parallel.DistributedDataParallel(model, find_unused_parameters=True)# 一些代码：训练、测试模型等some code # 我的程序在这个部分出错且程序直接退出，导致下面的关闭进程的代码没有运行# 关闭所有进程dist.destroy_process_group() 问题的出现如下图所示，程序退出后，并没有进程在使用0号GPU，但0号GPU的显存却被占用。原因是程序退出前没有用Dist关闭所有进程，一部分进程还在运行，这些进程占用0号GPU的显存。 占用7号GPU的进程是我的另外一个进程，与本文讨论的问题无关。 定位占用GPU显存的PID执行下面的指令 1fuser -v /dev/nvidia* 该命令执行后得到下图所示的结果，可以看到是PID为285448的进程占用了0号GPU。 下面的图中忘记打了马赛克，后来用黑色遮挡了一下信息，所以USER这一列是看起来是空的。 执行下面这条命令，查看该进程的信息，可以发现该进程的PPID（其父进程的PID）是1，说明该进程不是我占用7号GPU的进程生成的，并且现在只有它在使用0号GPU。可以推断出这个进程是因为程序运行错误导致其没有被关闭，因此可以手动关闭该进程。 1ps -f -p 285448 下面的图中忘记打了马赛克，后来用黑色遮挡了一下信息，所以图中的路径不是很清晰。 先后执行下面这两条命令，杀掉该进程，再查看GPU情况，可以看到0号GPU的显存已经被释放，现在的GPU显存占用情况是正常的。 12kill -9 2885448nvidia-smi 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>PyTorch</tag>
        <tag>linux</tag>
        <tag>GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HostwindsVPS购买、支付宝支付相关]]></title>
    <url>%2F2020%2F04%2F03%2FHostwindsVPS%E8%B4%AD%E4%B9%B0%E3%80%81%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[前言我前几天买了Hostwinds的VPS，当时买的时候支付宝支付就出了问题，最近这两天用支付宝支付又出了问题。 所以想记录一下Hostwinds支付宝支付的相关问题及解决方法，顺便也记录一下关于Hostwinds VPS的更多内容。 正文支付宝支付 我在第一次用支付宝支付（购买VPS）时的操作没有错误，但没有支付成功，最后发现原因是支付宝余额不足…暴露出自己的贫穷 解决方法：支付宝充钱就行，然后再支付 当时是看了这篇文章才知道的 https://www.vps234.com/usa-vps-hostwinds-alipay-paid-failed/ 这个网站中还是有很多关于VPS的知识的，挺好用的 正常情况下，如果开通了支付宝自动支付，那之后每个月（其实是我们选择的付费周期，我选的是每月）到时间的话会自动支付，如果余额够，一般不会出问题的。 我们选了付费周期之后，比如说是按月付费，3月2日、4月2日……，这里的日期其实是最后期限（Due Date），我们是可以提前付款的 在每一个付费周期内，大概中间的那天（比如3月19日）会生成Invoice（中文是发票、费用清单），订单生成后你就可以付费了。 这是后来和客服交流时才发现的，问客服之前我以为只能在3月2日、4月2日付费。 这两天又遇到支付宝无法支付的问题，我的支付宝里是有钱的，暂时不知道真正原因（可能是由于我提前支付了）。 然后我去问客服，客服说现在不要用支付宝的自动支付，而是手动支付，具体来说就是用Account Credits支付，在这个情景中的意思是存入金额，就像充Q币一样，然后用你充值后账号里的钱去支付。 很奇怪的是，充Account Credits时我也是用支付宝支付哈哈，这不是套娃了吗？ 虽然套娃了，但我用支付宝充值成功了，然后用Account Credits支付了这个无法用支付宝自动支付的Invoice。 Hostwinds中的支付宝不支持二次支付（Recurring Agreement），Alipay is unsupported for recurring payments，这是客服说的 We do not support recurring Alipay payments. All invoices through Alipay must be manually processed each billing cycle. 这一点似乎可以比较合理地解释上一个事情 不确定是什么原因（估计是因为我提前支付了）一个订单在用我的支付宝自动支付时出了问题。当我发现自动支付失败时，再去用支付宝支付，这就是二次支付了，客服说不支持。 当账户里有余额，也开通了支付宝的自动付费的话。每个付费周期的付费会先使用账户里的余额。 总结来说，使用支付宝支付时注意以下几点 确保支付宝里余额充足 Hostwinds网站里显示的付费日期是最后期限（Due Date），可以在订单（Invoice）生成后手动支付 如果支付宝自动支付时付费失败，可以手动充值，然后用账户余额付费 当账户里有余额，也开通了支付宝的自动付费的话。每个付费周期的付费会先使用账户里的余额。 客服 Hostwinds的客服似乎是24小时在线的。我个人觉得客服质量和态度还不错，每次去问问题都会有人给我比较及时的回复。 如果我问的问题比较简单，客服会直接回答我；如果是稍难一点的问题，客服会Open一个Ticket，让对应部门的人解决我的问题 ISP Block 客服说要想解决这个问题只能通过’Fix IP Block’，会给我们换一个IP 出现ISP Block问题主要还是由于自己的操作不当 我刚开始使用SS时，VPS的IP和端口经常被封 后来经@roadwide推荐，使用了v2RayN，IP和端口就没有被封过 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Hostwinds</tag>
        <tag>VPS</tag>
        <tag>支付宝</tag>
        <tag>ISP Block</tag>
        <tag>v2rayN</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorBoard中HISTOGRAMS和DISTRIBUTIONS图形的含义]]></title>
    <url>%2F2020%2F04%2F02%2FTensorBoard%E4%B8%ADHISTOGRAMS%E5%92%8CDISTRIBUTIONS%E5%9B%BE%E5%BD%A2%E7%9A%84%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[前言之前我都是用TensorBoard记录训练过程中的Loss、mAP等标量，很容易就知道TensorBoard里的SCALARS（标量）图是怎么看的（其中横纵轴的含义、Smoothing等）。 最近在尝试模型压缩，其中的一个步骤是对模型进行稀疏训练。 稀疏训练时需要记录模型中BN层的Gamma值的分布情况（取哪些值，这些值出现的次数/频度），这时用TensorBoard里的SCALARS之类的图就不合适了，而是应该用TensorBoard里的HISTOGRAMS（直方图）和DISTRIBUTIONS（暂未找到合适的译文）。 所以我昨天学习、了解了一点HISTOGRAMS和DISTRIBUTIONS，今天做了一部分简单记录，具体见下文。 正文HISTOGRAMS和DISTRIBUTIONS这两种图的数据源是相同的，只是从不同的视角、以不同的方式来表示数据的分布情况。 下面先介绍HISTOGRAMS，再介绍DISTRIBUTIONS。 HISTOGRAMS 上图是TensorBoard生成的一个直方图（OFFEST模式），下面介绍图中几个元素的含义。 数据源 数据源是多个一维数组 也在别处看到有人说可以是多维数组，但会被压缩成一维数组，有兴趣的小伙伴可以具体研究一下 如果你只有1个数组，也是可以的 当鼠标放在图上时出现的一条黑线和数字 鼠标放在图上出现的一条黑线，就对应数据源里的一个一维数组 上图中显示的黑线对应我的第41个数组的所有元素（index为40，因为index从0开始计数的）的取值的分布情况 图下方的横轴 横轴的值和数组内元素的取值对应 图右方的纵轴 纵轴的值对应着是哪一个数组，或者说对应了数组的id、index（上边提到的40） 颜色 可以看到上图中的颜色是渐变的，靠上（id小）的颜色深，靠下（id大）的颜色浅 上面的用词比较“学术化”，如果看不懂，就看下边的这个解释吧 我的数据有99个数组，index从0到98，但右侧的纵轴值只标到了90 数组元素的分布范围是横轴上的数字，可以看出我的每个数组中的元素的取值大约集中在0到0.2，超过1.5的元素很少 我的第40个数组（说法不严谨，准确地说是id为40）中大约有505个元素的值为0.536左右 如果还是不懂的话，建议先去看看直方图是什么 DISTRIBUTIONS 把HISTOGRAMS搞懂后，这个图就很好懂的，因为这个图的数据源和HISTOGRAMS一样。 横轴 横轴是对应哪个数组 纵轴 数组中元素的取值 颜色 颜色深代表对应值出现的频数高 如上图，我的99个数组从0到98，数组中元素的取值慢慢地趋近于0 参考链接剪枝Githubhttps://github.com/tanluren/yolov3-channel-and-layer-pruning HISTOGRAMS和DISTRIBUTIONShttps://www.cnblogs.com/rainydayfmb/p/7944224.html https://vimsky.com/article/3645.html https://www.jianshu.com/p/8fdc43e48c86 https://blog.csdn.net/wgj99991111/article/details/84708255 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>TensorBoard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中百度网盘BaiduPCS-Go的安装及简单使用]]></title>
    <url>%2F2020%2F04%2F01%2FUbuntu%E4%B8%AD%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98BaiduPCS-Go%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言今天用服务器训练模型时，服务器突然关机了，然后我的文件突然没了…昨天刚训练好的呀！ 没办法，只能把数据再传到服务器上，但是文件很大，用Xftp传肯定很慢，所以用了百度云。（后来发现文件没有丢，重新挂载一下文件夹就好了，但我这个过程记录也写好了…） 下面记录了Ubuntu上如何安装BaiduPCS-Go并用其下载百度网盘文件，安装成功后的具体使用方法请参考Github中的说明（Github里讲得比较详细了）。 正文 下载对应的BaiduPCS-Go Release，我用的下面这个，命令如下： 1wget https://github.com/iikira/BaiduPCS-Go/releases/download/v3.6.1/BaiduPCS-Go-v3.6.1-linux-amd64.zip 注意是下载发行版，而不是git clone。 解压上一步下载到的zip到当前文件夹，命令如下： 1unzip BaiduPCS-Go-v3.6.1-linux-amd64.zip 删除zip文件（也可以不删除该zip文件），命令如下： 1rm BaiduPCS-Go-v3.6.1-linux-amd64.zip 进入解压得到的文件夹，命令如下： 1cd BaiduPCS-Go-v3.6.1-linux-amd64/ 查看文件夹中的内容（也可以不查看），命令如下： 1ls 运行BaiduPCS-Go，命令如下： 1BaiduPCS-Go 登录并进入百度云盘中的某个目录（步骤请参考Github中的说明） 下载文件labels.zip并保存至当前文件夹，命令如下： 1d labels.zip --saveto ./ 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>linux</tag>
        <tag>BaiduPCS-Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA滚轮控制字体大小]]></title>
    <url>%2F2020%2F03%2F31%2FIDEA%E6%BB%9A%E8%BD%AE%E6%8E%A7%E5%88%B6%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[File-&gt;Setting-&gt;Editor-&gt;General，然后勾选Change font size (Zoom) with Ctrl+Mouse Wheel即可。 这个园子里洪水泛滥！ 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA插件搜索失败]]></title>
    <url>%2F2020%2F03%2F31%2FIDEA%E6%8F%92%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[前言今天要做软件测试的实验：用JUnit做白盒测试，所以昨天想在IDEA里安装JUnitGenerator V2.0，遇到了在IDEA的插件库里搜不到任何插件的问题。 这个问题也有其他描述： Marketplace plugins are not loaded. Search results are not loaded.Check the internet connection. 等等 问题详细描述IDEA搜索插件时搜不出结果，具体如下。 进入IDEA界面，点击File-&gt;Settings-&gt;Plugins-&gt;Marketplace。 （我的IDEA是IntelliJ IDEA Community Edition 2019.3.4 x64，其他版本可能界面不太一样，但不影响操作。） 不搜索时会出现： 1Marketplace plugins are not loaded. 搜索junit等任何插件，都会出现下面这个情况： 12Search results are not loaded.Check the internet connection. 经查询和测试，可以通过以下步骤解决： 关闭电脑的防火墙 我的系统是Windows10，关闭了Windows Defender的所有防火墙。（怎么关闭防火墙应该不用讲吧） 在IDEA中添加Plugin Repository 点击Manage Plugin Repositories，然后点击+按钮添加一个Plugin Repository，然后点击OK。 1http://plugins.jetbrains.com/ 然后就可以看到插件了。 如果还是不行，试试重启IDEA或重启电脑。 如果再不行的话，试试下面的方法。 其他说明在昨天我这么做的时候，上面的方法是OK的。 在今天写博客重新尝试这个方法的时候，又发现这个方法不行。在研究的过程中，还是用这个方法的情况下，这个方法突然又可以了。 也就是说，这个方法并不稳定……，原因..未知 经过查询，还有其他方法，比如用管理员模式打开IDEA、关闭IDEA的版本更新提示和代理等方法，详细见参考链接吧。 参考链接 我参考的方法 用代理proxy 应该是靠谱一点的方法。 管理员模式打开IDEA 关闭IDEA的版本更新提示 听起来不太靠谱。 关闭User Secure Connection 我这个版本的IDEA已经不能这样了 这个链接里的第二个参考链接挺不错的，跟我讲的几个方法差不多。如果问题还没有解决，可以看看。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>IDEA</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode生成HTML代码模板]]></title>
    <url>%2F2020%2F03%2F30%2FVSCode%E7%94%9F%E6%88%90HTML%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[用VSCode写HTML代码时，可以输入感叹号!，然后按Tab或Enter生成HTML代码的模板，估计SublimeText等编辑器也有这种功能。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>VSCode</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中nohup运行python程序无后台输出]]></title>
    <url>%2F2020%2F03%2F27%2Flinux%E4%B8%ADnohup%E8%BF%90%E8%A1%8Cpython%E7%A8%8B%E5%BA%8F%E6%97%A0%E5%90%8E%E5%8F%B0%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[之前，我都是使用下面这条命令在linux上运行python程序，并将程序输出（print）的内容存放至文件。 1nohup python helloworld.py &gt; helloworld.log 2&gt;&amp;1 &amp; 一般情况下，这条命令是可以将python程序的输出存放至指定文件的。 但我发现，用这条语句运行程序，偶尔会出现没有输出至指定文件（该文件被创建，但长时间不更新内容）的情况。 经过查询，我发现原因是： 默认情况下，python程序在执行时是有输出缓冲的（没有细究，个人理解是需要等输出的内容达到一定量才会输出，有兴趣的小伙伴可以研究一下） 解决该问题的一个方法是：使用python的-u参数，如下所示。 1nohup python -u helloworld.py &gt; helloworld.log 2&gt;&amp;1 &amp; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>python</tag>
        <tag>linux</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch余弦学习率衰减]]></title>
    <url>%2F2020%2F03%2F26%2FPyTorch%E4%BD%99%E5%BC%A6%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%A1%B0%E5%87%8F%2F</url>
    <content type="text"><![CDATA[前言今天用到了PyTorch里的CosineAnnealingLR，也就是用余弦函数进行学习率的衰减。 下面讲讲定义CosineAnnealingLR这个类的对象时输入的几个参数是什么，代码示例就不放了。 正文1torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max, eta_min=0, last_epoch=-1) optimizer 需要进行学习率衰减的优化器变量 T_max Cosine是个周期函数嘛，这里的T_max就是这个周期的一半 如果你将T_max设置为10，则学习率衰减的周期是20个epoch，其中前10个epoch从学习率的初值（也是最大值）下降到最低值，后10个epoch从学习率的最低值上升到最大值 eta_min 学习率衰减时的最小值，默认值为0 last_epoch （上次训练）最后一个epoch的索引值，默认值为-1。 我没有测试，猜测是：如果你将其设置为20，那定义出来的scheduler的第一次step就会到第21个epoch对应的学习率。 效果我的参数是： 12# optimizer学习率初值为0.0005，100个epoch，从第1个epoch（索引为0）开始训练scheduler = lr_scheduler.CosineAnnealingLR(optimizer, T_max=10, eta_min=5e-6) 效果图如下： 参考链接https://pytorch.org/docs/stable/optim.html?highlight=cosine#torch.optim.lr_scheduler.CosineAnnealingLR 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看pip缓存路径]]></title>
    <url>%2F2020%2F03%2F25%2F%E6%9F%A5%E7%9C%8Bpip%E7%BC%93%E5%AD%98%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[前言我们在安装python第三方库时，经常遇到下载速度慢的问题，即使换了源也不行。 好不容易下载到第三方库的文件（比如whl）后，我们可以把这些文件（比如whl）保存下来，然后可以发给同学、队友（团队开发时环境最好一致），还可以方便自己之后的重新安装。 那pip安装python第三方库时的缓存路径在哪呢？ 正文在安装一个库时，我注意到了pip的缓存路径，如下。 1C:\Users\Cxy\AppData\Local\pip\cache 其中Cxy是我电脑的用户名，在你自己的电脑上的话需要改成你自己的用户名（比如Administrator） 这个路径应该是pip的默认缓存路径，这个路径应该也是可以修改的，有兴趣的小伙伴可以研究一下。 该路径下有两个文件夹，一个是http，一个是wheels；还有一个文件selfcheck.json。 我没研究文件夹http和文件selfcheck.json是什么，有兴趣的小伙伴可以研究一下。 经过查看，发现文件夹wheels里面是.whl文件，不过这个文件夹里面的目录结构和命名我们一般看不懂，我没有具体研究，有兴趣的小伙伴可以研究一下。 为了找到我们想要的.whl文件，我们在wheels文件夹里直接搜索就好了，不需要第三方库的全名，只需要输入第三方库名称中的一些词就行了。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOAD DATA INFILE读取CSV中一千万条数据至mysql]]></title>
    <url>%2F2019%2F11%2F02%2FLOAD-DATA-INFILE%E8%AF%BB%E5%8F%96CSV%E4%B8%AD%E4%B8%80%E5%8D%83%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E8%87%B3mysql%2F</url>
    <content type="text"><![CDATA[作业要求构建一个关系模式和课本中的关系movies(title,year,length,movietype,studioname,producerC)一样的关系，名称自定，在这个关系中插入1000万条记录。 注：关系movies的主键为(title,year)。 要求如下： 在尽可能短的时间内完成； 只允许使用原生的SQL，不允许将SQL作为嵌入语言，也不允许使用其他语言如C#、Python等来完成； 提交你的详细解决方案和结果。 本文利用LOAD DATA INFILE将包含一千万条数据的CSV文件存入mysql。 实现除了newcsv.py，其他命令均为cmd命令。 生成包含1千万条数据的CSV文件用python生成与关系movies结构相同的包含1千万条数据的CSV文件。 newcsv.py如下： 该程序大概耗时18秒。 12345678910111213141516171819202122import csvimport time# num_value条数据num_value = 10000000# 开始计时time_start = time.time()# 生成文件with open(r'C:\ProgramData\MySQL\MySQL Server 8.0\Uploads\bigdata.csv', 'w', newline='') as f: f_csv = csv.writer(f) f_csv.writerow(['title', 'year', 'length', 'movieType', 'studioName', 'producerC']) for i in range(1, num_value+1): f_csv.writerow(['GoGoGo', i, 120, 'sicFic', 'MGM', 100])# 结束计时time_end = time.time()# 输出耗费时间（秒）print('Time Cost：', time_end - time_start) 登录mysql1mysql -uroot -p123456 上面root是我的mysql用户名，123456是我的mysql密码。 进入数据库moviesdb1use moviesdb; 创建关系mymovies只复制关系movies的结构，并不复制其数据 1CREATE TABLE mymovies LIKE movies; 将CSV文件存入数据库1LOAD DATA INFILE &apos;C:/ProgramData/MySQL/MySQL Server 8.0/Uploads/bigdata.csv&apos; INTO TABLE mymovies FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\n&apos; IGNORE 1 ROWS; 我的电脑上，该文件存入mysql耗时862.646秒，大概14分钟，如下图所示： 参考链接https://www.cnblogs.com/freefei/p/7679991.html https://blog.csdn.net/qq_22855325/article/details/76087138 https://blog.csdn.net/weixin_44595372/article/details/88723191 https://zhidao.baidu.com/question/185665472.html https://www.cnblogs.com/zhangjpn/p/6231662.html https://www.cnblogs.com/wangcp-2014/p/8038683.html https://blog.csdn.net/gb4215287/article/details/82669785 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L1与L2正则化]]></title>
    <url>%2F2019%2F10%2F22%2FL1%E4%B8%8EL2%E6%AD%A3%E5%88%99%E5%8C%96%2F</url>
    <content type="text"><![CDATA[过拟合机器学习中，如果参数过多、模型过于复杂，容易造成过拟合。 结构风险最小化原理在经验风险最小化（训练误差最小化）的基础上，尽可能采用简单的模型，以提高模型泛化预测精度。 正则化为了避免过拟合，最常用的一种方法是使用正则化，例如L1和L2正则化。 所谓的正则化，就是在原来损失函数的基础上，加了一些正则化项，或者叫做模型复杂度惩罚项。 L2正则化L2正则化即：$L=E_{in}+\lambda\sum_j\omega^2_j$，其中，$E_{in}$是原来的损失函数；$\lambda$是正则化参数，可调整；$\omega_j$是参数。 由上可知，正则化是为了限制参数过多，避免模型过于复杂。因此，我们可以令高阶部分的权重$\omega$为0，这样就相当于从高阶转换为低阶。然而，这是个NP难问题，将其适度简化为：$\sum_j\omega_j^2≤C$，令$\omega_j$的平方和小于$C$。这时，我们的目标就转换为：令$E_{in}$最小，但是要遵循$w$平方和小于$C$的条件，如下图所示： L1正则化L1正则化和L2正则化相似：$L=E_{in}+\lambda\sum_j|\omega_j|$，同样地，图形如下： L1与L2正则化满足正则化条件，实际上是求解上面图中红色形状与蓝色椭圆的交点，即同时满足限定条件和$E_{in}$最小化。 对于L2来说，限定区域是圆，这样得到的解$\omega_1$或$\omega_2$（以二元为例）为0的概率很小，且很大概率是非零的。 对于L1来说，限定区域是正方形，方形与蓝色区域相交的交点是顶点的概率很大，这从视觉和常识上来看是很容易理解的。也就是说，正方形的凸点会更接近 $E_{in}$最优解对应的$\omega$位置，而凸点处必有$\omega_1$或$\omega_2$为0。这样，得到的解$\omega_1$或$\omega_2$为零的概率就很大了。所以，L1正则化的解具有稀疏性。 扩展到高维，同样的道理，L2的限定区域是平滑的，与中心点等距；而 L1 的限定区域是包含凸点的，尖锐的。这些凸点更接近$E_{in}$的最优解位置，而在这些凸点上，很多$\omega_j$为0。 参考链接https://www.jianshu.com/p/76368eba9c90 https://segmentfault.com/a/1190000014680167?utm_source=tag-newest https://blog.csdn.net/red_stone1/article/details/80755144 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sklearn逻辑回归实战]]></title>
    <url>%2F2019%2F10%2F22%2Fsklearn%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[题目要求根据学生两门课的成绩和是否入学的数据，预测学生能否顺利入学：利用ex2data1.txt和ex2data2.txt中的数据，进行逻辑回归和预测。 数据放在最后边。 ex2data1.txt处理作散点图可知，决策大致符合线性关系，但还是有弯曲（非线性），用线性效果并不好，因此可用两种方案：方案一，无多项式特征；方案二，有多项式特征。 方案一：无多项式特征对ex2data1.txt中的数据进行逻辑回归，无多项式特征 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253""" 对ex2data1.txt中的数据进行逻辑回归（无多项式特征）"""from sklearn.model_selection import train_test_splitfrom matplotlib.colors import ListedColormapfrom sklearn.linear_model import LogisticRegressionimport numpy as npimport matplotlib.pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号# 数据格式：成绩1,成绩2,是否被录取（1代表被录取，0代表未被录取）# 函数（画决策边界）定义def plot_decision_boundary(model, axis): x0, x1 = np.meshgrid( np.linspace(axis[0], axis[1], int((axis[1] - axis[0]) * 100)).reshape(-1, 1), np.linspace(axis[2], axis[3], int((axis[3] - axis[2]) * 100)).reshape(-1, 1), ) X_new = np.c_[x0.ravel(), x1.ravel()] y_predict = model.predict(X_new) zz = y_predict.reshape(x0.shape) custom_cmap = ListedColormap(['#EF9A9A', '#FFF59D', '#90CAF9']) plt.contourf(x0, x1, zz, cmap=custom_cmap)# 读取数据data = np.loadtxt('ex2data1.txt', delimiter=',')data_X = data[:, 0:2]data_y = data[:, 2]# 数据分割X_train, X_test, y_train, y_test = train_test_split(data_X, data_y, random_state=666)# 训练模型log_reg = LogisticRegression()log_reg.fit(X_train, y_train)# 结果可视化plot_decision_boundary(log_reg, axis=[0, 100, 0, 100])plt.scatter(data_X[data_y == 0, 0], data_X[data_y == 0, 1], color='red')plt.scatter(data_X[data_y == 1, 0], data_X[data_y == 1, 1], color='blue')plt.xlabel('成绩1')plt.ylabel('成绩2')plt.title('两门课程成绩与是否录取的关系')plt.show()# 模型测试print(log_reg.score(X_train, y_train))print(log_reg.score(X_test, y_test)) 输出结果如下： 120.85333333333333340.76 方案二：引入多项式特征对ex2data1.txt中的数据进行逻辑回归，引入多项式特征。经调试，当degree为3时，耗费时间较长；当degree为2时，耗费时间可接受，效果与方案一相比好了很多 实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465""" 对ex2data1.txt中的数据进行逻辑回归（引入多项式特征）"""from sklearn.model_selection import train_test_splitfrom matplotlib.colors import ListedColormapfrom sklearn.linear_model import LogisticRegressionimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.preprocessing import PolynomialFeaturesfrom sklearn.pipeline import Pipelinefrom sklearn.preprocessing import StandardScalerplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号# 数据格式：成绩1,成绩2,是否被录取（1代表被录取，0代表未被录取）# 函数定义def plot_decision_boundary(model, axis): x0, x1 = np.meshgrid( np.linspace(axis[0], axis[1], int((axis[1] - axis[0]) * 100)).reshape(-1, 1), np.linspace(axis[2], axis[3], int((axis[3] - axis[2]) * 100)).reshape(-1, 1), ) X_new = np.c_[x0.ravel(), x1.ravel()] y_predict = model.predict(X_new) zz = y_predict.reshape(x0.shape) custom_cmap = ListedColormap(['#EF9A9A', '#FFF59D', '#90CAF9']) plt.contourf(x0, x1, zz, cmap=custom_cmap)def PolynomialLogisticRegression(degree): return Pipeline([ ('poly', PolynomialFeatures(degree=degree)), ('std_scaler', StandardScaler()), ('log_reg', LogisticRegression()) ])# 读取数据data = np.loadtxt('ex2data1.txt', delimiter=',')data_X = data[:, 0:2]data_y = data[:, 2]# 数据分割X_train, X_test, y_train, y_test = train_test_split(data_X, data_y, random_state=666)# 训练模型poly_log_reg = PolynomialLogisticRegression(degree=2)poly_log_reg.fit(X_train, y_train)# 结果可视化plot_decision_boundary(poly_log_reg, axis=[0, 100, 0, 100])plt.scatter(data_X[data_y == 0, 0], data_X[data_y == 0, 1], color='red')plt.scatter(data_X[data_y == 1, 0], data_X[data_y == 1, 1], color='blue')plt.xlabel('成绩1')plt.ylabel('成绩2')plt.title('两门课程成绩与是否录取的关系')plt.show()# 模型测试print(poly_log_reg.score(X_train, y_train))print(poly_log_reg.score(X_test, y_test)) 输出如下： 120.920.92 ex2data2.txt处理作散点图可知，这组数据的决策边界绝对是非线性的，所以直接引入多项式特征对ex2data2.txt中的数据进行逻辑回归。 代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465""" 对ex2data2.txt中的数据进行逻辑回归（引入多项式特征）"""from sklearn.model_selection import train_test_splitfrom matplotlib.colors import ListedColormapfrom sklearn.linear_model import LogisticRegressionimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.preprocessing import PolynomialFeaturesfrom sklearn.pipeline import Pipelinefrom sklearn.preprocessing import StandardScalerplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号# 数据格式：成绩1,成绩2,是否被录取（1代表被录取，0代表未被录取）# 函数定义def plot_decision_boundary(model, axis): x0, x1 = np.meshgrid( np.linspace(axis[0], axis[1], int((axis[1] - axis[0]) * 100)).reshape(-1, 1), np.linspace(axis[2], axis[3], int((axis[3] - axis[2]) * 100)).reshape(-1, 1), ) X_new = np.c_[x0.ravel(), x1.ravel()] y_predict = model.predict(X_new) zz = y_predict.reshape(x0.shape) custom_cmap = ListedColormap(['#EF9A9A', '#FFF59D', '#90CAF9']) plt.contourf(x0, x1, zz, cmap=custom_cmap)def PolynomialLogisticRegression(degree): return Pipeline([ ('poly', PolynomialFeatures(degree=degree)), ('std_scaler', StandardScaler()), ('log_reg', LogisticRegression()) ])# 读取数据data = np.loadtxt('ex2data2.txt', delimiter=',')data_X = data[:, 0:2]data_y = data[:, 2]# 数据分割X_train, X_test, y_train, y_test = train_test_split(data_X, data_y, random_state=666)# 训练模型poly_log_reg = PolynomialLogisticRegression(degree=2)poly_log_reg.fit(X_train, y_train)# 结果可视化plot_decision_boundary(poly_log_reg, axis=[-1, 1, -1, 1])plt.scatter(data_X[data_y == 0, 0], data_X[data_y == 0, 1], color='red')plt.scatter(data_X[data_y == 1, 0], data_X[data_y == 1, 1], color='blue')plt.xlabel('成绩1')plt.ylabel('成绩2')plt.title('两门课程成绩与是否录取的关系')plt.show()# 模型测试print(poly_log_reg.score(X_train, y_train))print(poly_log_reg.score(X_test, y_test)) 输出结果如下： 由图可知，分类结果较好。 120.79545454545454540.9 两份数据ex2data1.txt12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910034.62365962451697,78.0246928153624,030.28671076822607,43.89499752400101,035.84740876993872,72.90219802708364,060.18259938620976,86.30855209546826,179.0327360507101,75.3443764369103,145.08327747668339,56.3163717815305,061.10666453684766,96.51142588489624,175.02474556738889,46.55401354116538,176.09878670226257,87.42056971926803,184.43281996120035,43.53339331072109,195.86155507093572,38.22527805795094,075.01365838958247,30.60326323428011,082.30705337399482,76.48196330235604,169.36458875970939,97.71869196188608,139.53833914367223,76.03681085115882,053.9710521485623,89.20735013750205,169.07014406283025,52.74046973016765,167.94685547711617,46.67857410673128,070.66150955499435,92.92713789364831,176.97878372747498,47.57596364975532,167.37202754570876,42.83843832029179,089.67677575072079,65.79936592745237,150.534788289883,48.85581152764205,034.21206097786789,44.20952859866288,077.9240914545704,68.9723599933059,162.27101367004632,69.95445795447587,180.1901807509566,44.82162893218353,193.114388797442,38.80067033713209,061.83020602312595,50.25610789244621,038.78580379679423,64.99568095539578,061.379289447425,72.80788731317097,185.40451939411645,57.05198397627122,152.10797973193984,63.12762376881715,052.04540476831827,69.43286012045222,140.23689373545111,71.16774802184875,054.63510555424817,52.21388588061123,033.91550010906887,98.86943574220611,064.17698887494485,80.90806058670817,174.78925295941542,41.57341522824434,034.1836400264419,75.2377203360134,083.90239366249155,56.30804621605327,151.54772026906181,46.85629026349976,094.44336776917852,65.56892160559052,182.36875375713919,40.61825515970618,051.04775177128865,45.82270145776001,062.22267576120188,52.06099194836679,077.19303492601364,70.45820000180959,197.77159928000232,86.7278223300282,162.07306379667647,96.76882412413983,191.56497449807442,88.69629254546599,179.94481794066932,74.16311935043758,199.2725269292572,60.99903099844988,190.54671411399852,43.39060180650027,134.52451385320009,60.39634245837173,050.2864961189907,49.80453881323059,049.58667721632031,59.80895099453265,097.64563396007767,68.86157272420604,132.57720016809309,95.59854761387875,074.24869136721598,69.82457122657193,171.79646205863379,78.45356224515052,175.3956114656803,85.75993667331619,135.28611281526193,47.02051394723416,056.25381749711624,39.26147251058019,030.05882244669796,49.59297386723685,044.66826172480893,66.45008614558913,066.56089447242954,41.09209807936973,040.45755098375164,97.53518548909936,149.07256321908844,51.88321182073966,080.27957401466998,92.11606081344084,166.74671856944039,60.99139402740988,132.72283304060323,43.30717306430063,064.0393204150601,78.03168802018232,172.34649422579923,96.22759296761404,160.45788573918959,73.09499809758037,158.84095621726802,75.85844831279042,199.82785779692128,72.36925193383885,147.26426910848174,88.47586499559782,150.45815980285988,75.80985952982456,160.45555629271532,42.50840943572217,082.22666157785568,42.71987853716458,088.9138964166533,69.80378889835472,194.83450672430196,45.69430680250754,167.31925746917527,66.58935317747915,157.23870631569862,59.51428198012956,180.36675600171273,90.96014789746954,168.46852178591112,85.59430710452014,142.0754545384731,78.84478600148043,075.47770200533905,90.42453899753964,178.63542434898018,96.64742716885644,152.34800398794107,60.76950525602592,094.09433112516793,77.15910509073893,190.44855097096364,87.50879176484702,155.48216114069585,35.57070347228866,074.49269241843041,84.84513684930135,189.84580670720979,45.35828361091658,183.48916274498238,48.38028579728175,142.2617008099817,87.10385094025457,199.31500880510394,68.77540947206617,155.34001756003703,64.9319380069486,174.77589300092767,89.52981289513276,1 ex2data2.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171180.051267,0.69956,1-0.092742,0.68494,1-0.21371,0.69225,1-0.375,0.50219,1-0.51325,0.46564,1-0.52477,0.2098,1-0.39804,0.034357,1-0.30588,-0.19225,10.016705,-0.40424,10.13191,-0.51389,10.38537,-0.56506,10.52938,-0.5212,10.63882,-0.24342,10.73675,-0.18494,10.54666,0.48757,10.322,0.5826,10.16647,0.53874,1-0.046659,0.81652,1-0.17339,0.69956,1-0.47869,0.63377,1-0.60541,0.59722,1-0.62846,0.33406,1-0.59389,0.005117,1-0.42108,-0.27266,1-0.11578,-0.39693,10.20104,-0.60161,10.46601,-0.53582,10.67339,-0.53582,1-0.13882,0.54605,1-0.29435,0.77997,1-0.26555,0.96272,1-0.16187,0.8019,1-0.17339,0.64839,1-0.28283,0.47295,1-0.36348,0.31213,1-0.30012,0.027047,1-0.23675,-0.21418,1-0.06394,-0.18494,10.062788,-0.16301,10.22984,-0.41155,10.2932,-0.2288,10.48329,-0.18494,10.64459,-0.14108,10.46025,0.012427,10.6273,0.15863,10.57546,0.26827,10.72523,0.44371,10.22408,0.52412,10.44297,0.67032,10.322,0.69225,10.13767,0.57529,1-0.0063364,0.39985,1-0.092742,0.55336,1-0.20795,0.35599,1-0.20795,0.17325,1-0.43836,0.21711,1-0.21947,-0.016813,1-0.13882,-0.27266,10.18376,0.93348,00.22408,0.77997,00.29896,0.61915,00.50634,0.75804,00.61578,0.7288,00.60426,0.59722,00.76555,0.50219,00.92684,0.3633,00.82316,0.27558,00.96141,0.085526,00.93836,0.012427,00.86348,-0.082602,00.89804,-0.20687,00.85196,-0.36769,00.82892,-0.5212,00.79435,-0.55775,00.59274,-0.7405,00.51786,-0.5943,00.46601,-0.41886,00.35081,-0.57968,00.28744,-0.76974,00.085829,-0.75512,00.14919,-0.57968,0-0.13306,-0.4481,0-0.40956,-0.41155,0-0.39228,-0.25804,0-0.74366,-0.25804,0-0.69758,0.041667,0-0.75518,0.2902,0-0.69758,0.68494,0-0.4038,0.70687,0-0.38076,0.91886,0-0.50749,0.90424,0-0.54781,0.70687,00.10311,0.77997,00.057028,0.91886,0-0.10426,0.99196,0-0.081221,1.1089,00.28744,1.087,00.39689,0.82383,00.63882,0.88962,00.82316,0.66301,00.67339,0.64108,01.0709,0.10015,0-0.046659,-0.57968,0-0.23675,-0.63816,0-0.15035,-0.36769,0-0.49021,-0.3019,0-0.46717,-0.13377,0-0.28859,-0.060673,0-0.61118,-0.067982,0-0.66302,-0.21418,0-0.59965,-0.41886,0-0.72638,-0.082602,0-0.83007,0.31213,0-0.72062,0.53874,0-0.59389,0.49488,0-0.48445,0.99927,0-0.0063364,0.99927,00.63265,-0.030612,0 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sklearn线性回归实现房价预测模型]]></title>
    <url>%2F2019%2F10%2F19%2Fsklearn%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[题目要求建立房价预测模型：利用ex1data1.txt（单特征）和ex1data2.txt（多特征）中的数据，进行线性回归和预测。 作散点图可知，数据大致符合线性关系，故暂不研究其他形式的回归。 两份数据放在最后。 单特征线性回归ex1data1.txt中的数据是单特征，作一个简单的线性回归即可：$y=ax+b$。 根据是否分割数据，产生两种方案：方案一，所有样本都用来训练和预测；方案二，一部分样本用来训练，一部分用来检验模型。 方案一对ex1data1.txt中的数据进行线性回归，所有样本都用来训练和预测。 代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839""" 对ex1data1.txt中的数据进行线性回归，所有样本都用来训练和预测"""import numpy as npimport matplotlib.pyplot as pltfrom sklearn.linear_model import LinearRegressionfrom sklearn.metrics import mean_squared_error, r2_scoreplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号# 数据格式：城市人口,食品经销商利润# 读取数据data = np.loadtxt('ex1data1.txt', delimiter=',')data_X = data[:, 0]data_y = data[:, 1]# 训练模型model = LinearRegression()model.fit(data_X.reshape([-1, 1]), data_y)# 利用模型进行预测y_predict = model.predict(data_X.reshape([-1, 1]))# 结果可视化plt.scatter(data_X, data_y, color='red')plt.plot(data_X, y_predict, color='blue', linewidth=3)plt.xlabel('城市人口')plt.ylabel('食品经销商利润')plt.title('线性回归——城市人口与食品经销商利润的关系')plt.show()# 模型参数print(model.coef_)print(model.intercept_)# MSEprint(mean_squared_error(data_y, y_predict))# R^2print(r2_score(data_y, y_predict)) 结果如下： 由下可知函数形式以及$R^2$为0.70 1234[1.19303364]-3.895780878311858.9539427519503580.7020315537841397 方案二对ex1data1.txt中的数据进行线性回归，部分样本用来训练，部分样本用来预测。 实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243""" 对ex1data1.txt中的数据进行线性回归，部分样本用来训练，部分样本用来预测"""import numpy as npimport matplotlib.pyplot as pltfrom sklearn.linear_model import LinearRegressionfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import mean_squared_error, r2_scoreplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号# 数据格式：城市人口,食品经销商利润# 读取数据data = np.loadtxt('ex1data1.txt', delimiter=',')data_X = data[:, 0]data_y = data[:, 1]# 数据分割X_train, X_test, y_train, y_test = train_test_split(data_X, data_y)# 训练模型model = LinearRegression()model.fit(X_train.reshape([-1, 1]), y_train)# 利用模型进行预测y_predict = model.predict(X_test.reshape([-1, 1]))# 结果可视化plt.scatter(X_test, y_test, color='red') # 测试样本plt.plot(X_test, y_predict, color='blue', linewidth=3)plt.xlabel('城市人口')plt.ylabel('食品经销商利润')plt.title('线性回归——城市人口与食品经销商利润的关系')plt.show()# 模型参数print(model.coef_)print(model.intercept_)# MSEprint(mean_squared_error(y_test, y_predict))# R^2print(r2_score(y_test, y_predict)) 结果如下： 由下可知函数形式以及$R^2$为0.80 1234[1.21063939]-4.1954819659450555.9943626670476170.8095125123727652 多特征线性回归ex1data2.txt中的数据是二个特征，作一个最简单的多元（在此为二元）线性回归即可：$y=a_1x_1+a_2x_2+b$。 对ex1data2.txt中的数据进行线性回归，所有样本都用来训练和预测。 代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243""" 对ex1data2.txt中的数据进行线性回归，所有样本都用来训练和预测"""import numpy as npimport matplotlib.pyplot as pltfrom sklearn.linear_model import LinearRegressionfrom mpl_toolkits.mplot3d import Axes3D # 不要去掉这个importfrom sklearn.metrics import mean_squared_error, r2_scoreplt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号# 数据格式：城市人口,房间数目,房价# 读取数据data = np.loadtxt('ex1data2.txt', delimiter=',')data_X = data[:, 0:2]data_y = data[:, 2]# 训练模型model = LinearRegression()model.fit(data_X, data_y)# 利用模型进行预测y_predict = model.predict(data_X)# 结果可视化fig = plt.figure()ax = fig.gca(projection='3d')ax.scatter(data_X[:, 0], data_X[:, 1], data_y, color='red')ax.plot(data_X[:, 0], data_X[:, 1], y_predict, color='blue')ax.set_xlabel('城市人口')ax.set_ylabel('房间数目')ax.set_zlabel('房价')plt.title('线性回归——城市人口、房间数目与房价的关系')plt.show()# 模型参数print(model.coef_)print(model.intercept_)# MSEprint(mean_squared_error(data_y, y_predict))# R^2print(r2_score(data_y, y_predict)) 结果如下： 由下可知函数形式以及$R^2$为0.73 1234[ 139.21067402 -8738.01911233]89597.909542797484086560101.2056580.7329450180289141 两份数据ex1data1.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596976.1101,17.5925.5277,9.13028.5186,13.6627.0032,11.8545.8598,6.82338.3829,11.8867.4764,4.34838.5781,126.4862,6.59875.0546,3.81665.7107,3.252214.164,15.5055.734,3.15518.4084,7.22585.6407,0.716185.3794,3.51296.3654,5.30485.1301,0.560776.4296,3.65187.0708,5.38936.1891,3.138620.27,21.7675.4901,4.2636.3261,5.18755.5649,3.082518.945,22.63812.828,13.50110.957,7.046713.176,14.69222.203,24.1475.2524,-1.226.5894,5.99669.2482,12.1345.8918,1.84958.2111,6.54267.9334,4.56238.0959,4.11645.6063,3.392812.836,10.1176.3534,5.49745.4069,0.556576.8825,3.911511.708,5.38545.7737,2.44067.8247,6.73187.0931,1.04635.0702,5.13375.8014,1.84411.7,8.00435.5416,1.01797.5402,6.75045.3077,1.83967.4239,4.28857.6031,4.99816.3328,1.42336.3589,-1.42116.2742,2.47565.6397,4.60429.3102,3.96249.4536,5.41418.8254,5.16945.1793,-0.7427921.279,17.92914.908,12.05418.959,17.0547.2182,4.88528.2951,5.744210.236,7.77545.4994,1.017320.341,20.99210.136,6.67997.3345,4.02596.0062,1.27847.2259,3.34115.0269,-2.68076.5479,0.296787.5386,3.88455.0365,5.701410.274,6.75265.1077,2.05765.7292,0.479535.1884,0.204216.3557,0.678619.7687,7.54356.5159,5.34368.5172,4.24159.1802,6.79816.002,0.926955.5204,0.1525.0594,2.82145.7077,1.84517.6366,4.29595.8707,7.20295.3054,1.98698.2934,0.1445413.394,9.05515.4369,0.61705 ex1data2.txt12345678910111213141516171819202122232425262728293031323334353637383940414243444546472104,3,3999001600,3,3299002400,3,3690001416,2,2320003000,4,5399001985,4,2999001534,3,3149001427,3,1989991380,3,2120001494,3,2425001940,4,2399992000,3,3470001890,3,3299994478,5,6999001268,3,2599002300,4,4499001320,2,2999001236,3,1999002609,4,4999983031,4,5990001767,3,2529001888,2,2550001604,3,2429001962,4,2599003890,3,5739001100,3,2499001458,3,4645002526,3,4690002200,3,4750002637,3,2999001839,2,3499001000,1,1699002040,4,3149003137,3,5799001811,4,2859001437,3,2499001239,3,2299002132,4,3450004215,4,5490002162,4,2870001664,2,3685002238,3,3299002567,4,3140001200,3,299000852,2,1799001852,4,2999001203,3,239500 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>sklearn</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python+mysql:实现一千万条数据插入数据库]]></title>
    <url>%2F2019%2F10%2F18%2Fpython-mysql-%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%8D%83%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[作业要求构建一个关系模式和课本中的关系movies(title,year,length,movietype,studioname,producerC)一样的关系，名称自定，在这个关系中插入1000万条记录。 注：关系movies的主键为(title,year)。 要求如下： 在尽可能短的时间内完成； 只允许使用原生的SQL，不允许将SQL作为嵌入语言，也不允许使用其他语言如C#、Python等来完成； 提交你的详细解决方案和结果。 分析查资料得知 可以将多条insert语句合并为一句，即一条insert语句插入多个元组 可以通过事务，减少每条insert语句都建立新事务带来的时空消耗 可以通过load data infile将文件中的数据导入mysql，似乎很快的样子 虽然第三种似乎很快，但在此我采用了前两种方法，通过合并+事务实现。 我通过python模拟生成（只改变主键中的year，以生成不同元组）1千万条记录，将其组织为$10\times100\times10000$条记录添加进movies，分成10个事务，每个事务里有100条insert语句，每条insert语句插入10000个元组。 实现实现思路如下： 复制原数据库moviedb至newmoviedb 设置max_allowed_packet，以保证一条insert语句可以插入足够多的元组 用python生成一条一次插入10000个元组的insert语句 用python生成一个包含100条insert语句的事务，保存至sql文件 用navicat运行该sql文件 至此就可以实现一百万条记录的插入了（我的电脑耗时327s？好像很慢！？） 之后再套一层循环就可以继续完成1千万条记录的插入了。 下面给出可能用到的步骤（如未说明，代码默认为控制行或者mysql环境下的命令）： 复制数据库创建新数据库newmoviedb登录并创建数据库： 123mysql -u root -pCREATE DATABASE `newmoviedb` DEFAULT CHARACTER SET UTF8 COLLATE UTF8_GENERAL_CI; 复制moviedb至newmoviedb复制数据库 1mysqldump moviedb -u root -pchouxianyu --add-drop-table | mysql newmoviedb -u root -pchouxianyu 上面chouxianyu是我的mysql密码 进入newmoviedb1use newmoviedb; 设置max_allowed_packet设置max_allowed_packet为100M 1set global max_allowed_packet = 100*1024*1024; 删除movies中所有元素（调试用）1delete from movies; 生成一条insert语句下边是insert.py 12345678910111213141516171819202122insertStr = "INSERT INTO movies(title,year,length,movietype,studioname,producerC) VALUES"value1_str = "('mymovietitle',"# jvalue2_str = ",120,'sciFic','MGM',100)"# ,;num_value = 10000f = open(r'C:\Users\Cxy\Documents\Navicat\MySQL\Servers\MySQL\newmoviedb\insertRow.sql', 'w') # 清空文件内容再写f.write(insertStr)for j in range(1, num_value): f.write(value1_str) f.write(str(j)) f.write(value2_str) f.write(',')f.write(value1_str)f.write(str(num_value))f.write(value2_str)f.write(';')f.close() 生成一个事务以下是transaction.py 12345678910111213141516171819202122232425262728293031transaction_begin_str = "START TRANSACTION;\n"transaction_end_str = "COMMIT;\n"insertStr = "INSERT INTO movies(title,year,length,movietype,studioname,producerC) VALUES"value1_str = "('mymovietitle',"# jvalue2_str = ",120,'sciFic','MGM',100)"# ,;num_value = 10000num_sql = 100# 打开文件f = open(r'C:\Users\Cxy\Documents\Navicat\MySQL\Servers\MySQL\newmoviedb\transaction.sql', 'w') # 清空文件内容再写# 将SQL语句写入文件f.write(transaction_begin_str)for i in range(1, num_sql+1): f.write(insertStr) for j in range(1, num_value): f.write(value1_str) f.write(str(i*num_value*10+j)) f.write(value2_str) f.write(',') f.write(value1_str) f.write(str(i*num_value*10+num_value)) f.write(value2_str) f.write(';\n')f.write(transaction_end_str)# 关闭文件f.close() 参考链接https://www.cnblogs.com/freefei/p/7679991.html https://blog.csdn.net/qq_22855325/article/details/76087138 https://blog.csdn.net/weixin_44595372/article/details/88723191 https://zhidao.baidu.com/question/185665472.html https://www.cnblogs.com/zhangjpn/p/6231662.html https://www.cnblogs.com/wangcp-2014/p/8038683.html https://blog.csdn.net/gb4215287/article/details/82669785 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1044]]></title>
    <url>%2F2019%2F10%2F17%2FPAT%E4%B9%99%E7%BA%A71044%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805279328157696 题解需要注意的几个点： 题目有指出给出的数字范围是[0,169)，即0至13*13，所以可知火星文不超两个单词：高位 低位 这点我没注意（只是看了，没有细想） 火星数字低位数字是tret时（即是13的整数倍时），不用输出这个tret。 这一点样例中有暗示，我没完全体会出来，只是看到数字为13时不用输出tret 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// PAT BasicLevel 1044// https://pintia.cn/problem-sets/994805260223102976/problems/994805279328157696#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#define RADIX 13using namespace std;// 地球数字与火星数字的映射string mars0[] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec"&#125;;string mars1[] = &#123;"", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou"&#125;;void earthToMars(string line); // 地球数字转火星数字，line是一行输入void marsToEarth(string line); // 火星数字转地球数字，line是一行输入int main()&#123; int n; // n行输入 scanf("%d\n", &amp;n); // scanf默认不读取换行符，加上\n会读取换行符，或者使用getchar()读取换行符 string line; // 保存一行 // 获取n行输入并进行相应处理 while (n--) &#123; // 读取一行 getline(cin, line); // 分别处理并输出结果 if (isdigit(line[0])) &#123; earthToMars(line); &#125; else &#123; marsToEarth(line); &#125; &#125; system("pause"); return 0;&#125;void earthToMars(string line)&#123; int num = stoi(line); if (num &gt;= RADIX) &#123; if (num % RADIX == 0) &#123; cout &lt;&lt; mars1[num / RADIX] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; mars1[num / RADIX] &lt;&lt; ' ' &lt;&lt; mars0[num % RADIX] &lt;&lt; endl; &#125; &#125; else &#123; cout &lt;&lt; mars0[num] &lt;&lt; endl; &#125;&#125;void marsToEarth(string line)&#123; stringstream ss(line); // 用户输入的一行 string str; // 用户输入的一个字符串 vector&lt;string&gt; strVec; // 保存各位火星数字 int num; // 最终求得的地球数字 // 读取字符串 while (ss &gt;&gt; str) &#123; strVec.push_back(str); &#125; // 一行有两个字符串，可表示[157,158] if (strVec.size() == 2) &#123; str = strVec.front(); // 高位数字 for (int i = 0; i &lt; RADIX; ++i) &#123; if (str == mars1[i]) &#123; num = RADIX * i; break; &#125; &#125; // 低位数字 str = strVec.back(); for (int i = 0; i &lt; RADIX; ++i) &#123; if (str == mars0[i]) &#123; num += i; break; &#125; &#125; &#125; // 一行有一个字符串，可表示[0,156] else if (strVec.size() == 1) &#123; str = strVec.front(); for (int i = 0; i &lt; RADIX; ++i) &#123; // 小于RADIX，即[0,12] if (str == mars0[i]) &#123; num = i; break; &#125; // 大于等于RADIX，即[13,156] if (str == mars1[i]) &#123; num = i * RADIX; break; &#125; &#125; &#125; printf("%d\n", num);&#125; 参考链接https://blog.csdn.net/qq_22194315/article/details/54428678 https://blog.csdn.net/weixin_39345384/article/details/82317205 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1046]]></title>
    <url>%2F2019%2F10%2F16%2FPAT%E4%B9%99%E7%BA%A71046%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805277847568384 题解题目有几个点需要注意： 甲和乙同时赢或者同时输都算平局，甲和乙都不需要喝酒 游戏结束不用我们判断 123456789101112131415161718192021222324252627282930313233343536373839// PAT BasicLevel 1046// https://pintia.cn/problem-sets/994805260223102976/problems/994805277847568384#include &lt;iostream&gt;using namespace std;int main()&#123; // 变量定义 int N; // N次划拳 scanf("%d",&amp;N); int AYell, AOut; // A喊的数字和出的数字 int BYell, BOut; // B喊的数字和出的数字 bool AWin,BWin; // 此次划拳A和B的输赢 int ALose=0,BLose=0; // A和B输的次数 int yellSum; // 此次划拳喊的数字之和 // 统计杯数 for(int i=0;i&lt;N;i++) &#123; scanf("%d %d %d %d",&amp;AYell,&amp;AOut,&amp;BYell,&amp;BOut); yellSum = AYell + BYell; // 此次划拳喊的数字之和 AWin = (AOut == yellSum); // A的输赢 BWin = (BOut == yellSum); // 如果一人赢一人输 if(AWin!=BWin) &#123; ALose += !AWin; BLose += !BWin; &#125; &#125; // 输出结果 printf("%d %d",ALose,BLose); system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1005]]></title>
    <url>%2F2019%2F10%2F16%2FPAT%E4%B9%99%E7%BA%A71005%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805320306507776 题解题意很简单，我并没有理解错，但刚开始最后一个测试点过不了。 代码逻辑检查多次后问了室友，说是isKey数组会越界，因为在callatz(n)中使用了isKey[n]，这个n由于n=(3*n+1)/2导致n的范围变化，不再是小于100。 我真的呜了…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// PAT BasicLevel 1005// https://pintia.cn/problem-sets/994805260223102976/problems/994805320306507776#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define N 310 // 数组大小bool isKey[N]; // N个数字是否为关键数：isKey[i]==true，则i是关键数；否则i不是关键数bool isValid[N]; // N个数字是否被用户输入：isValid[i]==true，则i已被用户输入；否则i未被用户输入void callatz(int n); // 循环处理isKey[n]：n若被覆盖，则不必往下计算，函数结束；若n未被覆盖，则覆盖n并按规则更新n。循环以上过程int main()&#123; // 默认N个数字都未被覆盖，即N个数字是关键数 fill(isKey, isKey + N, true); // 记录k个正整数n；对于每个正整数n，调用callatz()函数（用户输入的正整数n，并不会被自己覆盖，所以传参时直接将n更新） int k, n; scanf("%d", &amp;k); // k个整数 for (int i = 0; i &lt; k; ++i) &#123; scanf("%d", &amp;n); isValid[n] = true; // 记录用户输入的正整数n callatz(n % 2 == 0 ? n / 2 : (3 * n + 1) / 2); &#125; // 输出结果 bool isFirstKey = true; for (int i = N - 1; i &gt;= 0; --i) &#123; if (isValid[i] &amp;&amp; isKey[i]) &#123; if (isFirstKey) &#123; printf("%d", i); isFirstKey = false; // 输出第一个关键数后，之后输出的关键数就不是第一个关键数了 &#125; else &#123; printf(" %d", i); &#125; &#125; &#125; system("pause"); return 0;&#125;void callatz(int n)&#123; while (n != 1) &#123; // n未被覆盖 if (isKey[n]) &#123; // 将n覆盖 isKey[n] = false; // 按照规则更新n if (n % 2 == 0) &#123; n = n / 2; &#125; else &#123; n = (3 * n + 1) / 2; &#125; &#125; // n已被覆盖，不必往下计算 else &#123; break; &#125; &#125;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库-关系代数作业]]></title>
    <url>%2F2019%2F10%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[题目现有一产品数据库，该数据库模式由四个关系组成，这四个关系的模式如下：$Product(maker,model,type)$$PC(model,speed,ram,hd,price)$$Laptop(model,speed,ram,id,hd,screen,price)$$Printer(model,color,type,price)$试写出下列查询的关系代数表达式，并针对下面数据样例，给出查询的结果。（你的答案应该在任何数据上都能正确工作，而不仅限于图中的数据）a)哪种PC模型具有最少3.00的速度？b)哪个生产厂商的笔记本电脑（笔记本）的硬盘容量至少100GB？c)查询厂商B生产的所有产品的型号和价格。d)查询所有彩色激光打印机的型号。e)查询那些只出售笔记本电脑，不出售PC的厂商。f)查询在一种或者两种PC机中出现过的硬盘的容量。g)查询有同样处理速度和同样内存大小的PC对。每对只被列表一次，即列表给出$(i,j)$但不给出$(j,i)$。h)查询那些至少生产两种处理速度大于2.80的PC或者笔记本电脑的厂商。i)查询平均处理速度（PC或者是笔记本电脑）最高的所有厂商。j)查询至少生产三种不同处理速度电脑的厂商。k)查询恰好出售三种型号的PC厂商。四个关系的数据样例如下图所示： a)哪种PC模型具有最少3.00的速度？1.要操作的表：$PC$2.要进行的操作：选择、投影3.各操作的对象和顺序 选择关系$PC$中$speed\ge3.0$的元组：$R_1:=\sigma_{speed\ge3.0}(PC)$ 将$R_1$投影到属性$model$上：$R_2:=\pi_{model}(R_1)$ 4.关系代数表达式 $\pi_{model}(\sigma_{speed\ge3.0}(PC))$ 5.数据样例查询结果 $model$ 1005 1006 1013 b)哪个生产厂商的笔记本电脑（笔记本）的硬盘容量至少100GB？1.要操作的表：$Laptop$、$Product$2.要进行的操作：选择、自然连接、投影、差3.各操作的对象和顺序 选择关系$Laptop$中$hd&lt;100$的元组$R_1$：$R_1:=\sigma_{hd&lt;100}(Laptop)$ 将关系$Product$和关系$R_1$自然连接：$R_2:=R_1\bowtie Product$ 将$R_2$投影到属性$maker$上：$R_3:=\pi_{maker}(R_2)$ 将关系$Product$和关系$Laptop$自然连接：$R_4:=Product\bowtie Laptop$ 将关系$R_4$投影到属性$maker$上：$R_5:=\pi_{maker}(R_4)$ 求关系$R_5$和关系$R_3$的差：$R_6:=R_5-R_3$ 4.关系代数表达式 $Product\bowtie Laptop-\pi_{maker}(\sigma_{hd&lt;100}(Laptop)\bowtie Product)$ 5.数据样例查询结果 $maker$ B G c)查询厂商B生产的所有产品的型号和价格。1.要操作的表：$Product$、$PC$、$Laptop$、$Printer$2.要进行的操作：选择、投影、自然连接、并3.各操作的对象和顺序 选择关系$Product$中$maker=’B’$的元组：$R_1:=\sigma_{maker=’B’}(Product)$ 将关系$R_1$投影到属性$model$上：$R_2:=\pi_{model}(R_1)$ 将关系$R_2$和关系$PC$自然连接：$R_3:=R_2\bowtie PC$ 将关系$R_2$和关系$Laptop$自然连接：$R_4:=R_2\bowtie Laptop$ 将关系$R_2$和关系$Printer$自然连接：$R_5:=R_2\bowtie Printer$ 将关系$R_3$投影到属性组$\{ model,price \}$上：$R_6:=\pi_{model,price}(R_3)$ 将关系$R_4$投影到属性组$\{ model,price \}$上：$R_7:=\pi_{model,price}(R_4)$ 将关系$R_5$投影到属性组$\{ model,price \}$上：$R_8:=\pi_{model,price}(R_5)$ 将关系$R_6$、$R_7$和$R_8$并起来：$R_9:=R_6\cup R_7\cup R_8$ 4.关系代数表达式 $R_9$，该表达式展开写会太长，因此省略其展开式。 5.数据样例查询结果 $model$ $price$ 1004 649 1005 630 1006 1049 2007 1429 d)查询所有彩色激光打印机的型号。1.要操作的表：$Printer$2.要进行的操作：选择、投影3.各操作的对象和顺序 选择关系$Printer$中$color=true$并且$type=’laser’$的元组：$R_1:=\sigma_{color=true\wedge type=’laser’}(Printer)$ 将关系$R_1$投影到属性$model$上：$R_2:=\pi_{model}(R_1)$ 4.关系代数表达式 $\pi_{model}(\sigma_{color=true\wedge type=’laser’}(Printer))$ 5.数据样例查询结果 $model$ 3003 3007 e)查询那些只出售笔记本电脑，不出售PC的厂商。20200320更新：经网友@我要我觉得提醒，发现下边的$R_1$和$R_2$有点错误，具体可看本文评论和我修改后的答案（想看修改后的答案的话继续往下看就找到了） 1.要操作的表：$Product$、$PC$、$Laptop$2.要进行的操作：自然连接、投影、差3.各操作的对象和顺序 将关系$Product$与关系$Laptop$自然连接：$R_1:=Product\bowtie Laptop$ 将关系$Product$与关系$PC$自然连接：$R_2:=Product\bowtie PC$ 将关系$R_1$投影到属性$maker$上：$R_3:=\pi_{maker}(R_1)$ 将关系$R_2$投影到属性$maker$上：$R_4:=\pi_{maker}(R_2)$ 求关系$R_3$和$R_4$的差：$R_5:=R_3-R_4$ 4.关系代数表达式 $\pi_{maker}(Product\bowtie Laptop)-\pi_{maker}(Product\bowtie PC)$ 5.数据样例查询结果 $maker$ F G 20200320将$R_1$和$R_2$的错误修改后，正确答案应该如下： 1.要操作的表：$Product$2.要进行的操作：选择、投影、差3.各操作的对象和顺序 选择属性$type$的值为$laptop$的$Product$：$R_1:=\sigma_{type=laptop}(Product)$ 选择属性$type$的值为$pc$的$Product$：$R_2:=\sigma_{type=pc}(Product)$ 将关系$R_1$投影到属性$maker$上：$R_3:=\pi_{maker}(R_1)$ 将关系$R_2$投影到属性$maker$上：$R_4:=\pi_{maker}(R_2)$ 求关系$R_3$和$R_4$的差：$R_5:=R_3-R_4$ 4.关系代数表达式 $\pi_{maker}(\sigma_{type=laptop}(Product))-\pi_{maker}(\sigma_{type=pc}(Product))$ 5.数据样例查询结果 $maker$ F G f)查询在一种或者两种PC机中出现过的硬盘的容量。1.要操作的表：$PC$2.要进行的操作：重命名、$\theta$连接、投影、差3.各操作的对象和顺序 将关系$PC$通过重命名复制：$R_1:=\rho_{PC1(model_1,speed,ram,hd,price)}(PC)$ 将关系$PC$通过重命名复制：$R_2:=\rho_{PC2(model_2,speed,ram,hd,price)}(PC)$ 将关系$R_1$和$R_2$进行$\theta$连接：$R_3:=R_1\bowtie_{R_1.hd=R_2.hd\wedge R_1.model_1\neq R_2.model_2}R_2$ 将关系$R_3$和$PC$进行$\theta$连接：$R_4:=PC\bowtie_{PC.hd=R_3.hd\wedge PC.model\neq R_3.model_1\wedge PC.model\neq R_3.model_2}R_3$，由此得到至少出现三次的$hd$值 将关系$R_4$投影到属性$hd$上：$R_5:=\pi_{hd}(R_4)$ 将关系$PC$投影到属性$hd$上：$R_6:=\pi_{hd}(PC)$ 求关系$R_6$和$R_5$的差：$R_7:=R_6-R_5$ 4.关系代数表达式 $R_7$，该关系代数表达式展开长度太长，略 5.数据样例查询结果 $hd$ 80 320 200 300 160 g)查询有同样处理速度和同样内存大小的PC对。1.要操作的表：$PC$2.要进行的操作：重命名、$\theta$连接、投影3.各操作的对象和顺序 将关系$PC$通过重命名复制：$R_1:=\rho_{PC1(model_1,speed,ram,hd,price)}(PC)$ 将关系$PC$通过重命名复制：$R_2:=\rho_{PC2(model_2,speed,ram,hd,price)}(PC)$ 将关系$R_1$和$R_2$进行$\theta$连接：$R_3:=R_1\bowtie_{R_1.speed=R_2.speed\wedge R_1.ram=R_2.ram\wedge R_1.model_1\neq R_2.model_2}R_2$ 将关系$R_3$投影到属性组$\{ model_1,model_2 \}$上：$R_4:=\pi_{model_1,model_2}(R_3)$ 4.关系代数表达式 $R_4$，该关系代数表达式展开长度太长，略 5.数据样例查询结果 $model_1$ $model_2$ 1004 1012 h)查询那些至少生产两种处理速度大于2.80的PC或者笔记本电脑的厂商。1.要操作的表：$PC$2.要进行的操作：选择、并、投影、自然连接、重命名、$\theta$连接3.各操作的对象和顺序 选择关系$PC$中属性$speed&gt;2.80$的元组：$R_1:=\sigma_{speed&gt;2.80}(PC)$ 选择关系$Laptop$中属性$speed&gt;2.80$的元组：$R_2:=\sigma_{speed&gt;2.80}(Laptop)$ 将关系$R_1$和$R_2$并起来，并求其在属性$model$上的投影：$R_3=\pi_{model}(R_1\cup R_2)$ 将关系$R_3$与$Product$自然连接，并求其在属性组$\{ maker,model \}$上的投影：$R_4:=\pi_{maker,model}(R_3\bowtie Product)$ 将关系$R_4$通过重命名复制：$R_5:=\rho_{R_5(maker,model_5)}(R_4)$ 将关系$R_4$通过重命名复制：$R_6:=\rho_{R_6(maker,model_6)}(R_4)$ 将关系$R_5$和$R_6$进行$\theta$连接：$R_7:=R_5\bowtie_{R_5.maker=R_6.maker\wedge R_5.model_5\neq R_6.model_6}R_6$ 将关系$R_7$投影到属性$maker$上：$R_8:=\pi_{maker}(R_7)$ 4.关系代数表达式 $R_8$，该关系代数表达式展开长度太长，略 5.数据样例查询结果 $maker$ B i)查询平均处理速度（PC或者是笔记本电脑）最高的所有厂商。1.要操作的表：$PC$、$Laptop$、$Product$2.要进行的操作：投影、重命名、$\theta$连接、差、自然连接3.各操作的对象和顺序 将关系$PC$和$Laptop$投影到属性组$\{ model,speed \}$上并将两者并起来：$R_1:=\pi_{model,speed}(PC)\cup\pi_{model,speed}(Laptop)$ 通过重命名复制关系$R_1$：$R_2:=\rho_{R_2}(R_1)$ 关系$R_1$和$R_2$进行$\theta$连接：$R_3:=R_1\bowtie_{R_1.speed&lt;R_2.speed} R_2$，求出$speed$小于最大值的元组 求关系$R_1$和$R_3$的差：$R_4:=R_1-R_3$ 关系$R_4$和$Product$自然连接：$R_5:=R_4\bowtie Product$ 4.关系代数表达式 $R_5$，该关系代数表达式展开长度太长，略 5.数据样例查询结果 $maker$ B j)查询至少生产三种不同处理速度电脑的厂商。1.要操作的表：$PC$、$Product$2.要进行的操作：自然连接、投影、重命名、$\theta$连接3.各操作的对象和顺序 关系$Product$和$PC$自然连接并投影到属性组$\{ maker,speed \}$上：$R_1:=\pi_{maker,speed}(Procuct\bowtie PC)$ 复制并重命名关系$R_1$：$R_2:=\rho_{R_2(maker,speed_2)}(R_1)$ 复制并重命名关系$R_1$：$R_3:=\rho_{R_3(marker,speed_3)}(R_1)$ 关系$R_1$和$R_2$进行$\theta$连接：$R_4:=R_1\bowtie_{R_1.maker=R_2.maker\wedge R_1.speed\neq R_2.speed_2}R_2$ 关系$R_3$和$R_4$进行$\theta$连接：$R_5:=R_3\bowtie_{R_3.maker=R_4.maker\wedge R_4.speed\neq R_3.speed_3 /wedge R_4.speed_2\neq R_3.speed_3}R_4$ 将关系$R_5$投影到属性$maker$上：$R_6:=\pi_{maker}(R_5)$ 4.关系代数表达式 $R_5$，该关系代数表达式展开长度太长，略 5.数据样例查询结果 $maker$ A D E k)查询恰好出售三种型号的PC厂商。1.要操作的表：$PC$、$Product$2.要进行的操作：自然连接、投影、重命名、$\theta$连接、差3.各操作的对象和顺序 关系$Product$和$PC$自然连接并投影到属性组$\{ maker,model \}$上：$R_1:=\pi_{maker,model}(Procuct\bowtie PC)$ 复制并重命名关系$R_1$：$R_2:=\rho_{R_2(maker,model_2)}(R_1)$ 复制并重命名关系$R_1$：$R_3:=\rho_{R_3(marker,model_3)}(R_1)$ 复制并重命名关系$R_1$：$R_4:=\rho_{R_4(marker,model_4)}(R_1)$ 关系$R_1$和$R_2$进行$\theta$连接：$R_5:=R_1\bowtie_{R_1.maker=R_2.maker\wedge R_1.model\neq R_2.model_2}R_2$ 关系$R_3$和$R_5$进行$\theta$连接：$R_6:=R_3\bowtie_{R_3.maker=R_5.maker\wedge R_5.model\neq R_3.model_3 /wedge R_5.model_2\neq R_3.model_3}R_5$ 关系$R_4$和$R_6$进行$\theta$连接：$R_7:=R_4\bowtie_{R_4.maker=R_6.maker\wedge R_6.model\ne R_4.model_4 \wedge R_6.model_2\ne R_4.model_4 \wedge R_6.model_3\ne R_4.model_4}R_6$ 求关系$R_6$和$R_7$的差：$R_8:=R_6-R_7$ 将关系$R_8$投影到属性$maker$上：$R_8:=\pi_{maker}(R_8)$ 4.关系代数表达式 $R_8$，该关系代数表达式展开长度太长，略 5.数据样例查询结果 $maker$ A B D E 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-线性回归与梯度下降]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[线性回归linear regression 符号定义notation，仅为本教程中的符号定义。 $m$ 训练集中样本的数量 $x$ 输入值，features。 $x^{(i)}$，表示第$i$个样本的features $y$ 输出值，target $y^{(i)}$，表示第$i$个样本的label $\theta_i$ parameters，第$i$个模型参数 $h_\theta$ hypothesis（假设），这是一个在早期被用于机器学习的名称算法得到的函数（$x$到$y$） $h_\theta(x)=\theta_0+\theta_1x$ $(x,y)$代表一个样本，$(x^{(i)},y^{(i)})$代表第$i$个样本 代价函数cost function，有很多种。 符号是$J(\theta_1,\theta_2)$。 平方误差函数 square error function，最小二乘法。 对于大多数问题，特别是回归问题，平方误差函数都是一个合理的选择。 梯度下降gradient descent，可以用梯度下降法使各种各样的代价函数$J$最小化 它不仅被用在线性回归上，实际上被广泛地应用于机器学习的众多领域。 符号定义 $:=$ 赋值 $=$ 相等 $\alpha$ 是个数字，叫做学习速率，它控制以多大的幅度更新参数$\theta$ 注意 多个$\theta$需要同时更新（如果不同时，可能也能得到答案，但就并不是人们所指的梯度下降了，而是其他性质的其它算法），所以应该先计算，最后再同时更新$\theta$ 在梯度下降法中，当我们接近局部最低点时，梯度下降法会自动采取更小的幅度。 因为当我们接近局部最低点时，导数会变得越来越小，所以梯度下降将自动采取较小的幅度。 据上，可知实际上没有必要在接近局部最低点的时候减小$\alpha$。 梯度下降法求得的可能是局部最优解 但线性回归的成本函数总是一个凸函数（convex function），凸函数使用梯度下降法求得最小值就是全局最小值。 “Batch” Gradient Descent“Batch”指的是梯度下降的每一步都使用所有的训练样本。 矩阵和向量向量指的是列向量，4维的向量指的就是4行1列的矩阵。 按照惯例，通常用大写字母表示矩阵，用小写字母表示数字、标量或向量。 多元线性回归符号定义 $n$ 特征的数量，形成一个$m$行$n$列的矩阵 特征缩放features scaling 处理不同feature之间的数量级差异，使梯度下降收敛速度更快，否则可能会收敛得很慢 方法有很多种： $\frac{x}{x_{max}}$ $\frac{x-x_{mean}}{x_{max}}$ $\frac{x-x_{mean}}{标准差}$ $\frac{x-x_{mean}}{x_{max}-x_{min}}$ 学习率学习率$\alpha$的选取是十分重要的。 学习率太小，收敛会很慢；学习率太大，代价函数的值可能不会每步都在减小，或者无法收敛。 学习率一般都是试出来的。 可以用自动收敛测试来判断代价函数是否已经收敛；也可以以迭代次数为横轴，代价函数的最小值为纵轴作图，通过观察判断。 自动收敛测试当某步时，代价函数的减小值很小（比如小于$10^{-3}$，这个阈值也是不好确定的）时，则认为代价函数已经收敛。 多项式回归基于已有特征构造新的特征（乘积或次方） 正规方程nomal equation 线性方程组有解的话，使用该方法即可，可以一次性求得最优解，不需使用梯度下降法之类的迭代算法，求得的是解析解。 正规方程法不需要特征缩放。 \theta=(X^TX)^{-1}X^Ty$X^TX$不可逆的情况很少出现，如果不可逆，就用它的伪逆。 梯度下降与正规方程对比 梯度下降 正规方程 不需要选择学习率 需要选择学习率 需要多次迭代 不需要迭代 $n$很大时效果也很好 需要计算矩阵的逆，$n$很大时速度很慢 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-绪论]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[简介机器学习是一门多领域交叉学科，涉及概率论、统计学、逼近论等多门学科。它是人工智能的核心。 机器学习暂无一个被广泛认可的定义来准确定义机器学习是什么或不是什么。 机器学习算法的分类按照学习方式来分，主要可以分为两类（这两类算法也是最常使用的）： 监督学习（supervised learning） 会教计算机如何去完成任务 无监督学习（unsupervised learning） 让计算机自己学习如何完成任务 其他学习方法还有强化学习（reinforcement learning）和推荐系统（recommender systems）等。 监督学习监督学习：数据集中的每个样本的正确答案（label）是有给出的。 回归问题regression problem，预测一个连续的输出值 分类问题classification problem，预测一个离散的输出值 （支持向量机可以处理无限多的features） 无监督学习无监督学习：数据集中的每个样本是没有正确答案（label）的。 聚类算法cluster algorithm 将个例分为几类，比如新闻的专题分类、基因分类、组织计算机集群、社交网络分析、市场细分和天文数据分析等。 聚类只是无监督学习的一种。 鸡尾酒会算法cocktail party problem algorithm 两个声源同时发声，两个收音器收音，用算法分离两个声源发出的声音。 利用Octave和Matlab这样的软件，一行代码就可以实现这样的算法。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1043]]></title>
    <url>%2F2019%2F08%2F11%2FPAT%E4%B9%99%E7%BA%A71043%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805280074743808 题解这次再次体会到题意理解的正确性，理解正确的话其实就是用代码实现自己的想法。 难的是，刚开始想错了，然后再去改，这样完全没有思路，很麻烦的。 这道题的意思是：按照PATest的顺序去字符串里找，找得到就输出，找不到就找下一个，直至字符串里找不到PATest中的任意一个字符。 123456789101112131415161718192021222324252627282930313233// PAT BasicLevel 1043// https://pintia.cn/problem-sets/994805260223102976/problems/994805280074743808#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 用户输入 string str,PATest="PATest"; cin &gt;&gt;str; int i=0; int notFoundCount=0; while (notFoundCount &lt; 6)&#123; // 找到了想要的字符 if (str.find_first_of(PATest[i]) != string::npos)&#123; cout &lt;&lt; PATest[i]; str.erase(str.begin() + str.find_first_of(PATest[i])); notFoundCount = 0; &#125; // 找不到该字符 else &#123; notFoundCount++; &#125; // 找下一个 i = (i + 1) % 6; &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1042]]></title>
    <url>%2F2019%2F08%2F10%2FPAT%E4%B9%99%E7%BA%A71042%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805280817135616 题解用数组count存储字母出现次数，数组下标代表字母，数组元素是次数。遍历字符串，统计各字母出现次数，最后遍历count寻找出现次数最多的字母。 12345678910111213141516171819202122232425262728293031323334353637383940// PAT BasicLevel 1042// https://pintia.cn/problem-sets/994805260223102976/problems/994805280817135616#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 26个字母计数 int count[26]; fill(count,count+26,0); // 获取字符串 string str; getline(cin, str); // 字符串可能包含空格 // 统计字符出现次数 for(int i=0;i&lt;str.length();++i)&#123; if(isalpha(str[i]))&#123; count[tolower(str[i])-'a']++; &#125; &#125; // 寻找出现最频繁的英文字母（其实可以在统计的时候进行） int maxCount=-1; int maxIndex=0; for(int i=0;i&lt;26;++i)&#123; if(count[i]&gt;maxCount)&#123; // 用于实现数量并列则输出字母序最小的那个字母 maxCount = count[i]; maxIndex = i; &#125; &#125; // 输出结果 cout &lt;&lt; char('a' + maxIndex)&lt;&lt; ' ' &lt;&lt; maxCount; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1041]]></title>
    <url>%2F2019%2F08%2F10%2FPAT%E4%B9%99%E7%BA%A71041%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805281567916032 题解简单的信息录入和查询而已。 根据需求，使用试机座位号作为学生的标识进行信息录入和查询。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// PAT BasicLevel 1041// https://pintia.cn/problem-sets/994805260223102976/problems/994805281567916032#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 学生类class Student&#123;public: string zhunkaozhenghao; int kaoshizuoweihao; Student() &#123;&#125; Student(string zhunkaozhenghao, int kaoshizuoweihao)&#123; this-&gt;zhunkaozhenghao = zhunkaozhenghao; this-&gt;kaoshizuoweihao = kaoshizuoweihao; &#125; void print()&#123;cout &lt;&lt; zhunkaozhenghao &lt;&lt; ' ' &lt;&lt; kaoshizuoweihao &lt;&lt; endl;&#125;&#125;;int main()&#123; // n个学生 int n; Student stuArr[1001]; // 学生信息 string zhunkaozhenghao; // 准考证号 int kaoshizuoweihao; // 考试座位号 int shijizuoweihao; // 试机位号 // 录入学生信息 cin &gt;&gt; n; for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; zhunkaozhenghao &gt;&gt; shijizuoweihao &gt;&gt; kaoshizuoweihao; stuArr[shijizuoweihao]=Student(zhunkaozhenghao,kaoshizuoweihao); &#125; // 查询m个学生的信息并输出 int m; cin &gt;&gt; m; for(int i=0;i&lt;m;++i)&#123; cin &gt;&gt;shijizuoweihao; stuArr[shijizuoweihao].print(); &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1039]]></title>
    <url>%2F2019%2F08%2F10%2FPAT%E4%B9%99%E7%BA%A71039%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805283241443328 题解用两个字符串表示两个箱子，一个装有的珠子，一个装想要的珠子。 如果发现两个箱子里都有某个珠子，则把这两个珠子都取出来，重复该操作至某个箱子中没有珠子了或者两个箱子里没有相同的珠子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// PAT BasicLevel 1039// https://pintia.cn/problem-sets/994805260223102976/problems/994805283241443328#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 有的珠子和想要的珠子 string have,want; cin &gt;&gt; have &gt;&gt; want; // 有想要的并且还有珠子 while(have.length()&gt;0 &amp;&amp; want.length()&gt;0)&#123; // 遍历想要的珠子在有的珠子里找 int i = 0; while (i &lt; want.length())&#123; char c = want[i]; if (have.find(c) != string::npos)&#123; want.erase(want.begin() +i); have.erase(have.begin()+have.find(c)); break; &#125; i++; &#125; // 没有想要的任意一个珠子 if(i==want.length())&#123; break; &#125; &#125; // 要的珠子都拿到了 if(want.length()==0)&#123; cout &lt;&lt; "Yes " &lt;&lt; have.length(); &#125; // 还有珠子没拿到 else&#123; cout &lt;&lt; "No " &lt;&lt; want.length(); &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1038]]></title>
    <url>%2F2019%2F08%2F10%2FPAT%E4%B9%99%E7%BA%A71038%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805284092887040 题解一这份代码最后一个点会超时 123456789101112131415161718192021222324252627282930313233// PAT BasicLevel 1038// https://pintia.cn/problem-sets/994805260223102976/problems/994805284092887040#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; // n个学生及其分数 int n; cin &gt;&gt; n; int *scores = new int[n]; for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; scores[i]; &#125; // k个查询的分数 int k,search; cin &gt;&gt; k; while(k--)&#123; cin &gt;&gt; search; cout &lt;&lt; count(scores, scores + n, search); if(k) cout &lt;&lt; ' '; &#125; // 释放内存 delete[] scores; //system("pause"); return 0;&#125; 题解二这个所有点都过了。用数组存储各分数学生数量，下标是分数，数组元素值是数量。 123456789101112131415161718192021222324252627282930313233343536// PAT BasicLevel 1038// https://pintia.cn/problem-sets/994805260223102976/problems/994805284092887040#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; // n个学生 int n,score; cin &gt;&gt; n; // 各分数人数 int count[101]; fill(count,count+101,0); // 各分数的学生数量统计 while(n--)&#123; cin &gt;&gt; score; count[score]++; &#125; // k个查询的分数 int k,search; cin &gt;&gt; k; while(k--)&#123; cin &gt;&gt; search; cout &lt;&lt; count[search]; if(k) cout &lt;&lt; ' '; &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1037]]></title>
    <url>%2F2019%2F08%2F10%2FPAT%E4%B9%99%E7%BA%A71037%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805284923359232 题解还算简单，就是模拟我们在生活中的计算，但我想应该会有一个通用性较高的方法，下边的代码还是有重复程度较大的代码的。 两个需要注意的点： 负数 借位 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// PAT BasicLevel 1037// https://pintia.cn/problem-sets/994805260223102976/problems/994805284923359232#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int str2num(string str);int getSum(int* p);int main()&#123; // 获取用户输入 string strP,strA; cin &gt;&gt; strP &gt;&gt; strA; // 应付 int p[3]; p[0] = str2num(strP.substr(0, strP.find_first_of('.') - 0)); p[1] = str2num(strP.substr(strP.find_first_of('.') + 1, strP.find_last_of('.') - strP.find_first_of('.') - 1)); p[2] = str2num(strP.substr(strP.find_last_of('.') + 1, strP.length() - strP.find_last_of('.') - 1)); // 实付 int a[3]; a[0] = str2num(strA.substr(0, strA.find_first_of('.') - 0)); a[1] = str2num(strA.substr(strA.find_first_of('.') + 1, strA.find_last_of('.') - strA.find_first_of('.') - 1)); a[2] = str2num(strA.substr(strA.find_last_of('.') + 1, strA.length() - strA.find_last_of('.') - 1)); // 判断符号 int flag=getSum(a)-getSum(p)&gt;=0?1:-1; // 如果少付了，就交换数组元素 if(flag&lt;0)&#123; for(int i=0,temp;i&lt;3;++i)&#123; temp=a[i]; a[i]=p[i]; p[i]=temp; &#125; &#125; // 被找钱数 int result[3]; int diff,borrow; // 第三个数 diff=a[2]-p[2]; if(diff&gt;=0)&#123; result[2] = diff; borrow=0; &#125;else&#123; result[2] = diff+29; borrow=-1; &#125; // 第二个数 diff=a[1]-p[1]+borrow; if(diff&gt;=0)&#123; result[1] = diff; borrow=0; &#125;else&#123; result[1] = diff+17; borrow = -1; &#125; // 第一个数 result[0]=a[0]-p[0]+borrow; // 结果 if(flag&lt;0)&#123; cout &lt;&lt; '-'; &#125; cout &lt;&lt; result[0] &lt;&lt; '.' &lt;&lt; result[1] &lt;&lt; '.' &lt;&lt; result[2]; //system("pause"); return 0;&#125;int getSum(int *p)&#123; // 以Knut为单位计算总钱数 return (p[0] * 17 + p[1])*29+p[2];&#125;int str2num(string str)&#123; // 不考虑负数，字符串转数字 int num=0; for(int i=0;i&lt;str.length();++i)&#123; num=num*10+(str[i]-'0'); &#125; return num;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1036]]></title>
    <url>%2F2019%2F08%2F10%2FPAT%E4%B9%99%E7%BA%A71036%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805285812551680 题解啊有个难题（1034）不会，自闭了，来刷个简单题。这题可简单了，注意一个四舍五入就行。 123456789101112131415161718192021222324252627282930313233343536373839// PAT BasicLevel 1036// https://pintia.cn/problem-sets/994805260223102976/problems/994805285812551680#include &lt;iostream&gt;using namespace std;int main()&#123; // 边长（列数）和字符 int column; char c; cin &gt;&gt; column &gt;&gt; c; // 行数 int row = column * 1.0 / 2 + 0.5; // 输出第一行 for(int i=0;i&lt;column;++i)&#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; // 输出中间的几行 for(int i=0;i&lt;row-2;++i)&#123; cout &lt;&lt; c; for(int j=0;j&lt;column-2;++j)&#123; cout &lt;&lt; ' '; &#125; cout &lt;&lt; c &lt;&lt; endl; &#125; // 输出最后一行 for (int i = 0; i &lt; column; ++i)&#123; cout &lt;&lt; c; &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1033]]></title>
    <url>%2F2019%2F08%2F09%2FPAT%E4%B9%99%E7%BA%A71033%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805288530460672 题解刚开始没有理解到，如果上档键坏的话，所有大写字母都不行（My bad），后来改代码思路就很乱，甚至还考虑过_和+是否输出之类的……所以理解题意很重要吧。这个题弄得我脑袋很累。 考虑到上档键坏的话，所有大写字母都不行之后，还是会有一个测试点不过。 另外有个坑是第一行可能是空行，即所有键都是可以使用的。 123456789101112131415161718192021222324252627282930313233343536// PAT BasicLevel 1033// https://pintia.cn/problem-sets/994805260223102976/problems/994805288530460672#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 用户输入的字符串、输出的字符串、坏掉的键（字符串形式） string strIn,wrongKeys; getline(cin, wrongKeys); cin &gt;&gt; strIn; // 上档键（大写）是否可用 bool upIsWrong = (wrongKeys.find('+') == string::npos) ? false : true; // 生成输出字符串 for(int i=0;i&lt;strIn.length();++i)&#123; // 处理坏掉的键导致对应键无法输出 if (wrongKeys.find(toupper(strIn[i]))!=string::npos)&#123; continue; &#125; // 处理上档键坏掉导致大写无法输出 if (isupper(strIn[i]) &amp;&amp; upIsWrong)&#123; continue; &#125; // 这个键没有问题 cout &lt;&lt; strIn[i]; &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1032]]></title>
    <url>%2F2019%2F08%2F08%2FPAT%E4%B9%99%E7%BA%A71032%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805289432236032 题解用数组的下标表示学校，数组元素表示分数。统计各校分数后，遍历求最大就好了。 做这道题遇到一个memset初始化数组元素的问题，具体见https://www.cnblogs.com/chouxianyu/p/11322984.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// PAT BasicLevel 1032// https://pintia.cn/problem-sets/994805260223102976/problems/994805289432236032#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; // n个参赛者 int n; cin &gt;&gt; n; // 最多n个学校 int* scores=new int[n+1]; // 各学校（下标为0的学校是无效的学校）分数初始化为-1，因为是百分制，有可能所以参赛者都是零分且是同一个学校 memset(scores, -1, sizeof(int) * (n + 1)); // 统计n个学校分数 int index,score; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; index &gt;&gt; score; scores[index] += score; &#125; // 有效的学校最低分数是0，所以遍历后结果肯定不会是下标为0的那个学校 int maxIndex=0,maxScore=scores[maxIndex]; for(int i=1;i&lt;n+1;++i)&#123; // 处理-1 scores[i]++; // 更新最大值 if (scores[i] &gt; maxScore)&#123; maxScore = scores[i]; maxIndex = i; &#125; &#125; // 输出结果 cout &lt;&lt; maxIndex &lt;&lt; ' ' &lt;&lt; maxScore; // 释放内存 delete[] scores; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[memset初始化数组的坑]]></title>
    <url>%2F2019%2F08%2F08%2Fmemset%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[memset函数常被我们用来初始化数组，然而有个坑可能会被我们踩到。 静态数组初始化一般情形是这样的： 12345678910111213141516#include &lt;cstring&gt;int main()&#123; // 静态数组arr int arr[10]; // 将数组所有元素初始化为0 memset(arr,0,sizeof(arr)); // 遍历输出数组元素 for(int i=0;i&lt;10;++i)&#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; return 0;&#125; 这样做是正确的，通过输出可以看到正确结果。 注意：这份代码中arr是个静态数组。 动态数组初始化12345678910111213141516#include &lt;cstring&gt;int main()&#123; // 动态数组arr int* arr=new int[10]; // 将数组所有元素初始化为0 memset(arr,0,sizeof(arr)); // 遍历输出数组元素 for(int i=0;i&lt;10;++i)&#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; return 0;&#125; 这份代码运行后，我们发现memset并没有把数组元素全部初始化为0。 注意：arr是个动态数组 原因如下： 我们可以在上面两份代码中输出sizeof(arr)，可以发现结果是不一样的。 因为在第一份代码中arr代表一个数组，第二份代码中arr代表一个指针。（关于数组名是什么这个问题可以参考我的另一篇文章：https://www.cnblogs.com/chouxianyu/p/11322951.html，其实这个问题我觉得是编译原理应该会学到的） 解决方案初始化数组（静态动态均可）时，把代码改成memset(arr,0,sizeof(int)*10);，int是数组元素的类型，10是数组元素个数。 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>数组</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1031]]></title>
    <url>%2F2019%2F08%2F07%2FPAT%E4%B9%99%E7%BA%A71031%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805290334011392 题解emmm。对于每个身份证号，判断前17位是否合法，并计算其与对应权重积之和，最后判断校验位是否合法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// PAT BasicLevel 1031// https://pintia.cn/problem-sets/994805260223102976/problems/994805290334011392#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 正确校验码 char M[] = &#123; '1','0','X','9','8','7','6','5','4','3','2'&#125;; // 前17位的比重 int weight[] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;; // 身份证号个数 int n; cin &gt;&gt; n; // 前17位乘以权重之和 int sum; // 合法身份证号的个数 int legalCount=0; // 当前身份证号是否合法 bool isLegal; // 当前身份证号 string str; // 获取每个身份证号并判断 for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; str; // 初始化 sum=0; isLegal=true; // 计算前17位乘以权重之和并判断前17位合法性 for(int i=0;i&lt;17;++i)&#123; if (isdigit(str[i]))&#123; sum += (str[i] - '0')*weight[i]; &#125; // 出现非数字，非法，结束sum的计算 else&#123; isLegal=false; break; &#125; &#125; // 如果前17位合法，判断校验码是否合法 if(isLegal)&#123; isLegal = (M[sum % 11]==str[17]); &#125; // 身份证号非法则输出 if(!isLegal)&#123; cout &lt;&lt; str &lt;&lt; endl; &#125; // 合法则计数 else&#123; legalCount++; &#125; &#125; // 全部身份证号合法 if(legalCount==n)&#123; cout &lt;&lt; "All passed"; &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1030]]></title>
    <url>%2F2019%2F08%2F07%2FPAT%E4%B9%99%E7%BA%A71030%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805292322111488 题解emm刚开始思路有点错误，我直接将从小到大排序后的数列首个元素作为数列的最小值，但其实不是，数列第一个元素的不同可能会导致更大的完美数列长度。(参考链接：https://blog.csdn.net/chenyvye/article/details/78701846) 要注意的有三点： 就是上边我错的那个 用long long类型保存这些整数（$10^9$） 移动序列时序列首位直接设为i+maxLen 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// PAT BasicLevel 1030// https://pintia.cn/problem-sets/994805260223102976/problems/994805291311284224#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; // 获取n和p int n; long long p; cin &gt;&gt; n &gt;&gt; p; // 获取数列 long long *nums = new long long[n]; for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; nums[i]; &#125; // 排序 sort(nums + 0, nums + n); // 寻找完美数列最大长度 int j,maxLen=0; for (int i = 0; i &lt; n; ++i)&#123; for(j=i+maxLen;j&lt;n;++j)&#123;// 至少要比之前求出来的最大长度长，所以j初始化为i+maxLen if (nums[j] &lt;= nums[i] * p)&#123; // 更新最长长度 if (j - i + 1&gt;maxLen)&#123; maxLen = j - i + 1; &#125; &#125; // 出现非完美数列，之后也一定都是非完美数列，所以直接跳出循环 else&#123; break; &#125; &#125; &#125; // 输出结果 cout &lt;&lt; maxLen; // 释放内存 delete[] nums; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1029]]></title>
    <url>%2F2019%2F08%2F07%2FPAT%E4%B9%99%E7%BA%A71029%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805292322111488 题解思路： 可以想到，没有坏键的话就是两个字符串是一样的。所以我们按下标进行比较，发现不一样的就是坏掉的，然后在错误字符串的该位置添加一个字符，以确保两字符串下标对应。 1234567891011121314151617181920212223242526272829303132333435363738394041// PAT BasicLevel 1029// https://pintia.cn/problem-sets/994805260223102976/problems/994805292322111488#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 正确和错误的字符串 string right,wrong; cin &gt;&gt; right &gt;&gt; wrong; // 坏掉的键 string wrongKeys=""; // 寻找坏掉的键 for(int i=0;i&lt;right.length();++i)&#123; if (right[i] != wrong[i])&#123; // 在wrong里占个位子，更新下标 wrong.insert(wrong.begin() + i, '#'); // 处理丢失的字符（小写转大写） if (islower(right[i]))&#123; right[i]-=32; &#125; // 记录新发现的未重复的坏键 if(wrongKeys.find(right[i])==wrongKeys.npos)&#123; wrongKeys+=right[i]; &#125; &#125; &#125; // 输出结果 cout &lt;&lt; wrongKeys; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1028]]></title>
    <url>%2F2019%2F08%2F07%2FPAT%E4%B9%99%E7%BA%A71028%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805293282607104 题解这题跟那个德才论（PAT乙级1015）什么的差不多。 因为我用了string和algorithm，所以整个代码实现比较简单。 值得注意的的是，刚开始第3个测试点没过，报错Segmentation fault。 网上查题解后，发现还是边界情况的问题（当所有输入都非法时就会数组越界，所以特殊处理一下即可，参考链接：https://blog.csdn.net/daniel960601/article/details/55261196） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// PAT BasicLevel 1028// https://pintia.cn/problem-sets/994805260223102976/problems/994805293282607104#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Person&#123;public: string name; string birthday; Person(string name, string birthday)&#123; this-&gt;name = name; this-&gt;birthday = birthday; &#125;&#125;;bool personCmp(Person &amp;p1, Person &amp;p2);int main()&#123; // 人数 int n; cin &gt;&gt;n; // 最早日期和最晚日期 string earliest = "1814/09/06"; string latest = "2014/09/06"; // 获取人的信息 vector&lt;Person&gt; personVec; string name,birthday; for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; name &gt;&gt; birthday; if (birthday &gt;= earliest &amp;&amp; birthday&lt;= latest)&#123; personVec.push_back(Person(name,birthday)); &#125; &#125; // 输出结果 cout &lt;&lt; personVec.size(); if (personVec.size() &gt; 0)&#123; // 对所有人进行排序 sort(personVec.begin(), personVec.end(), personCmp); cout &lt;&lt; ' ' &lt;&lt; personVec.front().name &lt;&lt; ' ' &lt;&lt; personVec.back().name; &#125; //system("pause"); return 0;&#125;bool personCmp(Person &amp;p1, Person &amp;p2)&#123; // 生日 升序（生日从小到大就是年龄从大到小） return p1.birthday &lt; p2.birthday; &#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1027]]></title>
    <url>%2F2019%2F08%2F07%2FPAT%E4%B9%99%E7%BA%A71027%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805294251491328 题解主要有两个内容： 获取第一行（最长行）字符的个数。这个与一般的菱形打印不同，该题的字符不一定用完。 通过循环输出空格与字符（末尾空格就不用输出了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// PAT BasicLevel 1027// https://pintia.cn/problem-sets/994805260223102976/problems/994805294251491328#include &lt;iostream&gt;using namespace std;int getLineMaxCount(int maxNum);int main()&#123; // 字符可用数量及字符 int n;char c; cin &gt;&gt; n &gt;&gt; c; // 获取第一行字符的个数 int maxNum = getLineMaxCount(n); // 已输出字符个数 int count=0; // 当前行输出字符个数 int num = maxNum; // 输出上半部分 while(num&gt;1)&#123; // 输出空格 for(int i=0;i&lt;(maxNum-num)/2;++i)&#123; cout &lt;&lt; ' '; &#125; // 输出字符 count+=num; for(int i=0;i&lt;num;++i)&#123; cout &lt;&lt; c; &#125; // 换行 cout &lt;&lt; endl; num-=2; &#125; while(num&lt;=maxNum)&#123; // 输出空格 for (int i = 0; i &lt; (maxNum - num) / 2; ++i)&#123; cout &lt;&lt; ' '; &#125; // 输出字符 count+=num; for (int i = 0; i &lt; num; ++i)&#123; cout &lt;&lt; c; &#125; // 换行 cout &lt;&lt; endl; num += 2; &#125; // 输出剩余字符个数 cout &lt;&lt; n-count; //system("pause"); return 0;&#125;// 根据字符可用数量获取第一行字符个数int getLineMaxCount(int maxNum)&#123; int sum=-1,count=1; while (sum + count * 2 &lt;= maxNum)&#123; sum += count * 2; count += 2; &#125; return count-2;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1026]]></title>
    <url>%2F2019%2F08%2F07%2FPAT%E4%B9%99%E7%BA%A71026%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805295203598336 题解就只有一个四舍五入需要注意一下，其他的没啥难度，都是简单的运算而已…… 123456789101112131415161718192021222324252627// PAT BasicLevel 1026// https://pintia.cn/problem-sets/994805260223102976/problems/994805295203598336#include &lt;iostream&gt;using namespace std;#define CLK_TCK 100int main()&#123; // 获取C1和C2，并计算时间差（不足一秒进行四舍五入） int c1,c2; cin &gt;&gt; c1 &gt;&gt; c2; int time = (c2 - c1)*1.0/CLK_TCK+0.5; // 计算小时、分钟、秒 int hour=time/3600; time%=3600; int min=time/60; int sec=time%60; // 按格式输出结果 printf("%02d:%02d:%02d",hour,min,sec); //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1025]]></title>
    <url>%2F2019%2F08%2F06%2FPAT%E4%B9%99%E7%BA%A71025%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805296180871168 题解第一遍没有全部AC，最后1个测试点没过，原因是题目给的结点中有可能有无效结点，所以需要重新统计结点个数。（参考链接：https://blog.csdn.net/m0_37285185/article/details/68936043） 修改后全部都AC了。 整体的思路是以地址为键形成一个map，根据从第一个结点开始遍历，统计出有效结点的地址顺序（存储在数组中），最后利用reverse函数将顺序反转，最后将反转的链表输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// PAT BasicLevel 1025// https://pintia.cn/problem-sets/994805260223102976/problems/994805296180871168#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;class Node&#123;public: int address; int data; int next; // 因为使用map，所以需要提供一个无参构造 Node()&#123;&#125;; Node(int address,int data,int next)&#123; this-&gt;address = address; this-&gt;data = data; this-&gt;next = next; &#125; void print()&#123; printf("%05d", address); cout &lt;&lt; ' ' &lt;&lt; data &lt;&lt; ' '; if(next==-1)&#123; printf("%d\n",next); &#125;else&#123; printf("%05d\n", next); &#125; &#125;&#125;;int main()&#123; // 获取n、k和首结点地址 int n, k, head; cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; // 利用map模拟链表，获取用户输入的结点 int address,data,next; map&lt;int,Node&gt; nodes; for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; address &gt;&gt; data &gt;&gt; next; nodes[address]=Node(address,data,next); &#125; // 获取结点地址的顺序并重新统计结点个数去除无效顶点 int * addressArr=new int[n]; addressArr[0] = head; address = nodes[head].next; int nodeCount=1; while(address!=-1)&#123; addressArr[nodeCount]=address; nodeCount++; address = nodes[address].next; &#125; n=nodeCount; // 将结点地址的顺序进行反转 if (k &gt; 1)&#123; int *p = addressArr; while ((addressArr + n) - p &gt;= k) &#123; reverse(p, p + k); p += k; &#125; &#125; // 更新各结点的next for(int i=0;i&lt;n-1;++i)&#123; nodes[addressArr[i]].next=addressArr[i+1]; &#125; nodes[addressArr[n - 1]].next=-1; // 输出反转后的链表 for (int i = 0; i &lt; n; ++i)&#123; nodes[addressArr[i]].print(); &#125; // 释放内存 delete[] addressArr; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1024]]></title>
    <url>%2F2019%2F08%2F06%2FPAT%E4%B9%99%E7%BA%A71024%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805297229447168 题解第一遍也是没有全部AC，有3个测试点没过，原因如下： 没有处理指数为0的情况 指数为正时，没有处理不需补充0而需插入小数点的情况。（经过https://blog.csdn.net/whenever5225/article/details/90454014提示才知道的） 修改后全部都AC了。 整体的思路是获取整数和小数数值部分，然后获取指数，最后进行小数点的移动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// PAT BasicLevel 1024// https://pintia.cn/problem-sets/994805260223102976/problems/994805297229447168#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int getExponent(string);int main()&#123; // 原始字符串和结果 string str,result; cin &gt;&gt; str; // 获取结果的符号 string flag = (str[0] == '-' ? "-" : ""); // E在原始字符串中的下标 int eIndex = str.find_last_of('E'); // 获得指数的值 int exponent = getExponent(str.substr(eIndex + 1, str.length())); // 从原始字符串获取整数和小数部分的数值，现在小数点在result中的下标为1 result = str[1]+str.substr(3, eIndex-3); // 根据指数进行小数点的移动 if(exponent&gt;0)&#123; // 判断是否需要补充0 int numOfZero = exponent - (result.length() - 1); // 在尾部补充0 if(numOfZero&gt;=0)&#123; for (int i = 0; i &lt; numOfZero; i++)&#123; result += '0'; &#125; &#125; // 不需补充0，而是需要插入小数点 else&#123; result.insert(result.begin()+exponent+1,'.'); &#125; &#125;else if(exponent&lt;0)&#123; // 在首部补充0（for循环少补了一个0，这个少补的0在添加小数点时补上） exponent*=-1; for(int i=0;i&lt;exponent-1;i++)&#123; result.insert(result.begin(),'0'); &#125; // 添加小数点 result="0."+result; &#125;else&#123; // 添加小数点 result.insert(result.begin()+1,'.'); &#125; // 输出结果 cout &lt;&lt; flag+result; //system("pause"); return 0;&#125;int getExponent(string str)&#123; int flag=str[0]=='+'?1:-1; int num=0; for(int i=1;i&lt;str.length();++i)&#123; num=num*10+str[i]-'0'; &#125; return flag*num;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1023]]></title>
    <url>%2F2019%2F08%2F06%2FPAT%E4%B9%99%E7%BA%A71023%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805298269634560 题解主要就是控制首位不能为0，其他的都很简单，就遍历然后往尾部加数字就好了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// PAT BasicLevel 1023// https://pintia.cn/problem-sets/994805260223102976/problems/994805298269634560#include &lt;iostream&gt;using namespace std;int main()&#123; // 结果 string res=""; // 获取数字零的数量 int zeroCount; cin &gt;&gt;zeroCount; // 标志是否为第一个数量超过0个的数字 bool isFirst=true; // 非零数字个数 int count; // 获取非零数字的数量并生成最终结果 for(char c='1';c&lt;='9';++c)&#123; // 获取非零数数量 cin &gt;&gt; count; // 该数字的数量超过0个时 if(count&gt;0)&#123; // 如果是第一个数量超过0的非零数字 if (isFirst)&#123; // 先把它加在最前边，因为首位不可以是0 res+=c; count--; // 把零加在前边 for(int i=0;i&lt;zeroCount;++i)&#123; res+='0'; &#125; // 更新标志 isFirst=false; &#125; // 加自己 for (int i = 0; i &lt; count; ++i)&#123; res += c; &#125; &#125; &#125; // 输出形成的最小数 cout &lt;&lt; res; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1022]]></title>
    <url>%2F2019%2F08%2F06%2FPAT%E4%B9%99%E7%BA%A71022%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344 题解很简单，参考十进制转二进制的方法，除二取余至商为0。 这里要注意：需要处理a+b等于0的情况（参考了https://blog.csdn.net/m0_37285185/article/details/68936069，我又没发现边界……My bad,this is not so me.） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// PAT BasicLevel 1022// https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;string numBaseConversion(int num,int base);int main()&#123; // 获取a、b和d int a,b,base; cin &gt;&gt; a &gt;&gt; b &gt;&gt; base; // 进制转换，输出结果 cout &lt;&lt; numBaseConversion(a+b,base); //system("pause"); return 0;&#125;// 将一个十进制数转换为base(1,10]进制的字符串string numBaseConversion(int num, int base)&#123; stack&lt;char&gt; charStack; string res=""; // 处理num为0的情况 if(num==0)&#123; return "0"; &#125; // 处理num非0的情况 while(num&gt;0)&#123; charStack.push(num%base+'0'); num/=base; &#125; while (!charStack.empty())&#123; res+=charStack.top(); charStack.pop(); &#125; return res;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1021]]></title>
    <url>%2F2019%2F08%2F06%2FPAT%E4%B9%99%E7%BA%A71021%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805300404535296 题解很简单，用string保存这个数字，用一个数组保存各数字出现的次数，然后遍历字符串统计各数字个数，最后按照格式输出各位数字的个数。 1234567891011121314151617181920212223242526272829// PAT BasicLevel 1021// https://pintia.cn/problem-sets/994805260223102976/problems/994805300404535296#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 用户输入数字 string str; cin &gt;&gt; str; // 统计各数字个数 int digitCount[]=&#123;0,0,0,0,0,0,0,0,0,0&#125;; for(int i=0;i&lt;str.length();i++)&#123; digitCount[str[i]-'0']++; &#125; // 输出各数字个数 for(int i=0;i&lt;10;i++)&#123; if(digitCount[i]&gt;0)&#123; cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; digitCount[i] &lt;&lt; endl; &#125; &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1020]]></title>
    <url>%2F2019%2F08%2F06%2FPAT%E4%B9%99%E7%BA%A71020%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805301562163200 题解很容易看出这是个背包（非01背包）问题，直接用贪心求解即可。 需要注意的是，这里涉及到单价的计算，要注意整数计算会损失精度的问题，所以月饼的总价、库存量、单价都使用了double进行定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// PAT BasicLevel 1020// https://pintia.cn/problem-sets/994805260223102976/problems/994805301562163200#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Mooncake&#123;public: double totalPrice; // 总价 double storage; // 库存量 double unitPrice; // 单价 Mooncake(double storage)&#123;this-&gt;storage=storage;&#125;&#125;;bool mooncakeCmp(Mooncake&amp;,Mooncake&amp;);int main()&#123; // 月饼种类数 市场最大需求量 int n;int demand; cin &gt;&gt; n &gt;&gt; demand; // n种月饼库存量和售价 vector&lt;Mooncake&gt; mooncakeVec; double storage,totalPrice; for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; storage; mooncakeVec.push_back(Mooncake(storage)); &#125; for (int i = 0; i &lt; n; ++i)&#123; cin &gt;&gt; totalPrice; mooncakeVec[i].totalPrice = totalPrice; mooncakeVec[i].unitPrice = totalPrice/mooncakeVec[i].storage; &#125; // 对商品进行排序 sort(mooncakeVec.begin(),mooncakeVec.end(),mooncakeCmp); // 购买商品 double profit=0.0; for(int i=0;i&lt;n;i++)&#123; // 单种月饼全部购买 if (demand &gt;= mooncakeVec[i].storage)&#123; demand -= mooncakeVec[i].storage; profit += mooncakeVec[i].totalPrice; &#125; // 单种月饼购买一部分库存 else&#123; profit += mooncakeVec[i].unitPrice * demand; break;//直接break了，就不把demand减成0了 &#125; &#125; // 输出最大收益 printf("%.2f",profit); //system("pause"); return 0;&#125;bool mooncakeCmp(Mooncake &amp;m1, Mooncake &amp;m2)&#123; // 单价降序排列 return m1.unitPrice &gt; m2.unitPrice;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
        <tag>背包</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1019]]></title>
    <url>%2F2019%2F08%2F06%2FPAT%E4%B9%99%E7%BA%A71019%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805302786899968 题解根据用户输入或者每次的计算结果，生成大数和小数，然后输出计算过程，一直循环该过程；当结果为0或6174时，循环终止。 刚开始我有一个测试点是没过的，参考了https://blog.csdn.net/qunqunstyle99/article/details/83189284才过了全部测试点。所以写ACM题我们得自己会猜一些边界条件，正确理解题意，然后写代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// PAT BasicLevel 1019// https://pintia.cn/problem-sets/994805260223102976/problems/994805302786899968#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define ARRSIZE 5#define ARRLEN 4int main()&#123; // 生成的大数和小数 char big[ARRSIZE]; char small[ARRSIZE]; // 大数-小数 int result;char res[ARRSIZE]; // 获取用户输入的数字 scanf("%d", &amp;result); while (true)&#123; // 生成大数和小数 sprintf(small, "%04d\0", result); sort(small, small + ARRLEN); strcpy(big, small); reverse(big, big + ARRLEN); // 计算大数-小数 result = 0; for (int i = 0, diff; i &lt; ARRLEN; i++) &#123; result = result * 10 + big[i] - small[i]; &#125; // 输出结果 printf("%s - %s = %04d\n", big, small, result); // 当结果为0或6174时程序结束 sprintf(res, "%04d\0", result); if (!(strcmp(res, "0000\0") &amp;&amp; strcmp(res, "6174\0"))) break; &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1018]]></title>
    <url>%2F2019%2F08%2F05%2FPAT%E4%B9%99%E7%BA%A71018%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805304020025344 题解刚开始做很懵逼，可能并不难吧，但就是感觉做出来的话代码会很不优雅，所以想了半天。 然后把这个题放了会儿，有了思路。现在第3个测试点没过，我又读了一遍代码，真的不是很懂哪里有错…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// PAT BasicLevel 1018// https://pintia.cn/problem-sets/994805260223102976/problems/994805304020025344#include &lt;iostream&gt;using namespace std;void PK(char ,char);int aWin[3]=&#123;0,0,0&#125;;int bWin[3]=&#123;0,0,0&#125;;int equalCount=0;int main()&#123; // 交锋回合数 int n; cin &gt;&gt;n; // 获取交锋信息 char a,b; for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; a &gt;&gt; b; PK(a,b); &#125; // 输出结果 int aWinMaxCount=0,bWinMaxCount=0;//甲和乙三种出手方式的最大胜利次数 int aWinMaxIndex=0,bWinMaxIndex=0;//甲和乙胜利最多的出手方式下标 int aWinCount=0; for(int i=0;i&lt;3;i++)&#123; // 更新甲的胜利次数 aWinCount+=aWin[i]; // 更新甲胜利最多的攻击方式 if (aWin[i]&gt;aWinMaxCount)&#123; aWinMaxCount=aWin[i]; aWinMaxIndex=i; &#125; // 更新乙胜利最多的攻击方式 if (bWin[i] &gt; bWinMaxCount)&#123; bWinMaxCount = aWin[i]; bWinMaxIndex = i; &#125; &#125; // 输出结果 char choice[]="BCJ"; cout &lt;&lt; aWinCount &lt;&lt; ' '&lt;&lt; equalCount &lt;&lt; ' ' &lt;&lt; n - aWinCount - equalCount &lt;&lt; endl; cout &lt;&lt; n - aWinCount - equalCount &lt;&lt; ' ' &lt;&lt; equalCount &lt;&lt; ' ' &lt;&lt; aWinCount &lt;&lt; endl; cout &lt;&lt; choice[aWinMaxIndex] &lt;&lt; ' ' &lt;&lt; choice[bWinMaxIndex] &lt;&lt; endl; //system("pause"); return 0;&#125;void PK(char a, char b)&#123; if(a==b)&#123; equalCount++; &#125;else&#123; switch (a)&#123; case 'B': if(b=='C') aWin[0]++; else bWin[2]++; break; case 'C': if (b == 'B') bWin[0]++; else aWin[1]++; break; case 'J': if (b == 'C') bWin[1]++; else aWin[2]++; break; &#125; &#125;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1016]]></title>
    <url>%2F2019%2F08%2F05%2FPAT%E4%B9%99%E7%BA%A71016%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805306310115328 题解很简单，遍历两个字符串，找到da或db，然后不断更新pa和pb即可。 123456789101112131415161718192021222324252627282930313233343536// PAT BasicLevel 1016// https://pintia.cn/problem-sets/994805260223102976/problems/994805306310115328#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 获取a、da、b和db string a,b; char da,db; cin &gt;&gt; a &gt;&gt;da &gt;&gt; b &gt;&gt; db; // 计算pa int pa=0; for(int i=0;i&lt;a.length();++i)&#123; if(a[i]==da)&#123; pa=pa*10+da-'0'; &#125; &#125; // 计算pb int pb = 0; for (int i = 0; i &lt; b.length(); ++i)&#123; if (b[i] == db)&#123; pb = pb * 10 + db - '0'; &#125; &#125; // 输出结果 cout &lt;&lt; pa+pb; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1015]]></title>
    <url>%2F2019%2F08%2F05%2FPAT%E4%B9%99%E7%BA%A71015%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805307551629312 题解思路比较简单，核心就是定义一个学生的排序规则：将考生分为4类（德和才分数都低于L的直接淘汰），先比较考生的类型，再比较分数或者准考证号，其中分数都是降序、准考证号是升序。 淘汰直接在获取考生信息时进行；分类由Student构造函数实现；考生排序由stuCmp实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// PAT BasicLevel 1015// https://pintia.cn/problem-sets/994805260223102976/problems/994805307551629312#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N, L, H, M;class Student&#123;public: string id; int de; int cai; int type; Student(string id,int de,int cai)&#123; this-&gt;id=id;this-&gt;de=de;this-&gt;cai=cai; if (de &gt;= H &amp;&amp; cai &gt;= H)&#123;//才德全尽 this-&gt;type=3; &#125;else if(de&gt;=H&amp;&amp;cai&lt;H)&#123;//德胜才 this-&gt;type = 2; &#125;else if(de&lt;H&amp;&amp;cai&lt;H&amp;&amp;de&gt;=cai)&#123;//“才德兼亡”但尚有“德胜才”者 this-&gt;type = 1; &#125;else&#123;//达到最低线L this-&gt;type = 0; &#125; &#125; void print()&#123; cout &lt;&lt; id &lt;&lt; ' ' &lt;&lt; de &lt;&lt; ' ' &lt;&lt; cai &lt;&lt; endl; &#125;&#125;;bool stuCmp(Student&amp;, Student&amp;);int main()&#123; // 考生数 最低录取线 优先录取线 cin &gt;&gt; N &gt;&gt; L &gt;&gt; H; // 获取考生信息 vector&lt;Student&gt; stuVec; string id;int de;int cai; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; id &gt;&gt; de &gt;&gt; cai; // 只存储cai和de不低于L的 if (de &gt;= L &amp;&amp; cai &gt;= L)&#123; stuVec.push_back(Student(id, de, cai)); M++; &#125; &#125; // 学生排序 sort(stuVec.begin(),stuVec.end(),stuCmp); // 输出结果 cout &lt;&lt; M &lt;&lt; endl; for (vector&lt;Student&gt;::iterator it = stuVec.begin(); it != stuVec.end(); ++it)&#123; it-&gt;print(); &#125; //system("pause"); return 0;&#125;bool stuCmp(Student &amp;s1, Student &amp;s2)&#123; if(s1.type==s2.type)&#123;// 同种type，比较总分 if (s1.cai + s1.de == s2.cai + s2.de)&#123; if(s1.de==s2.de)&#123; // id升序输出，其他都是降序输出的 return s1.id &lt; s2.id; &#125;else&#123; return s1.de&gt;s2.de; &#125; &#125;else&#123; return s1.cai + s1.de &gt; s2.cai + s2.de; &#125; &#125;else&#123; return s1.type&gt;s2.type; &#125;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1014]]></title>
    <url>%2F2019%2F08%2F05%2FPAT%E4%B9%99%E7%BA%A71014%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805308755394560 题解一（部分正确）这是我的方法，第2个测试点没有过，和正确的代码比较，目前没比较出来错误，可能是我map用错了？ 需要注意的点: 第一对是相同的大写字母A-G 第二对是相同的数字0-9和A-N 小时和分钟输出宽度为2，不足2位用零填充 不用map也行，可以用ASCII码和字符的对应关系 判断大小写字母、数字等函数C++已自带，不用自己写 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// PAT BasicLevel 1014// https://pintia.cn/problem-sets/994805260223102976/problems/994805308755394560#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;bool isUpperCase(char);bool isLowerCase(char);bool isAlpha(char);bool isNumber(char);bool isDay(char);bool isHour(char);int main()&#123; // 获取四个字符串 string strs[4]; for(int i=0;i&lt;4;++i)&#123; cin &gt;&gt; strs[i]; &#125; // 字母与周几的映射 map&lt;char,string&gt; dayMap; dayMap['A'] = "MON";dayMap['B'] = "TUE";dayMap['C'] = "WED"; dayMap['D'] = "THU";dayMap['E'] = "FRI";dayMap['F'] = "SAT";dayMap['G'] = "SUN"; // 字母（或数字）与小时的映射 map&lt;int, int&gt; hourMap; hourMap[0] = 0;hourMap[1] = 1;hourMap[2] = 2;hourMap[3] = 3;hourMap[4] = 4; hourMap[5] = 5;hourMap[6] = 6;hourMap[7] = 7;hourMap[8] = 8;hourMap[9] = 9; hourMap['A'] = 10;hourMap['B'] = 11;hourMap['C'] = 12;hourMap['D'] = 13; hourMap['E'] = 14;hourMap['F'] = 15;hourMap['G'] = 16;hourMap['H'] = 17; hourMap['I'] = 18;hourMap['J'] = 19;hourMap['K'] = 20;hourMap['L'] = 21; hourMap['M'] = 22;hourMap['N'] = 23; // 遍历前两个字符串 int index; int minLen1 = strs[0].length() &lt; strs[1].length() ? strs[0].length() : strs[1].length(); for (int i = 0; i &lt; minLen1; ++i)&#123; if (strs[0][i] == strs[1][i] &amp;&amp; isDay(strs[1][i]))&#123; cout &lt;&lt; dayMap[strs[1][i]] &lt;&lt; ' '; index=i; break; &#125; &#125; for(int i=index+1;i&lt;minLen1;i++)&#123; if (strs[0][i] == strs[1][i] &amp;&amp; isHour(strs[1][i]))&#123; printf("%02d:", hourMap[strs[1][i]]); break; &#125; &#125; // 遍历后两个字符串 int minLen2 = strs[2].length() &lt; strs[3].length() ? strs[2].length() : strs[3].length(); for (int i = 0; i &lt; minLen2; ++i)&#123; if (strs[2][i] == strs[3][i] &amp;&amp; isAlpha(strs[3][i]))&#123; printf("%02d", i); break; &#125; &#125; //system("pause"); return 0;&#125;bool isDay(char c)&#123; // A-G return c &gt;= 'A' &amp;&amp; c &lt;= 'G';&#125;bool isHour(char c)&#123; // 0-9 A-N return isNumber(c) || (c &gt;= 'A' &amp;&amp; c &lt;= 'N');&#125;bool isUpperCase(char c)&#123; // A-Z return c &gt;= 'A' &amp;&amp; c &lt;= 'Z';&#125;bool isLowerCase(char c)&#123; // a-z return c &gt;= 'a' &amp;&amp; c &lt;= 'z';&#125;bool isAlpha(char c)&#123; // a-z A-Z return isLowerCase(c)||isUpperCase(c);&#125;bool isNumber(char c)&#123; // 0-9 return c &gt;= '0' &amp;&amp; c &lt;= '9';&#125; 题解二网上找的，和我看起来思路一样啊…… 参考链接：https://blog.csdn.net/supremebuct/article/details/83105861 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt; //9.16#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;void deal(string ch1, string ch2);void deal1(string ch3, string ch4);int main()&#123; string ch1, ch2, ch3, ch4; cin &gt;&gt; ch1 &gt;&gt; ch2 &gt;&gt; ch3 &gt;&gt; ch4; deal(ch1, ch2); deal1(ch3, ch4); return 0;&#125;void deal(string ch1, string ch2)&#123; string day[] = &#123;"MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN"&#125;; int num, num1, i = 0; while (i &lt; ch1.length() &amp;&amp; i &lt; ch2.length()) &#123; if (ch1[i] == ch2[i] &amp;&amp; (ch1[i] &gt;= 'A' &amp;&amp; ch1[i] &lt;= 'G')) //一开始没有设定范围只是判断了其是否是大写，导致有的例子通不过 &#123; num1 = ch1[i] - 'A'; break; &#125; i++; &#125; i++; cout &lt;&lt; day[num1] &lt;&lt; ' '; int num2; while (i &lt; ch1.length() &amp;&amp; i &lt; ch2.length()) &#123; if (ch1[i] == ch2[i]) &#123; if (isdigit(ch1[i])) &#123; num2 = ch1[i] - '0'; break; &#125; else if (ch1[i] &gt;= 'A' &amp;&amp; ch1[i] &lt;= 'N') //一开始没有设定范围只是判断了其是否是大写，导致有的例子通不过 &#123; num2 = 10 + (ch1[i] - 'A'); break; &#125; &#125; i++; &#125; printf("%02d:", num2);&#125;void deal1(string ch3, string ch4)&#123; int i = 0; int num3; while (i &lt; ch3.length() &amp;&amp; i &lt; ch4.length()) &#123; if (ch3[i] == ch4[i] &amp;&amp; isalpha(ch3[i])) &#123; num3 = i; break; &#125; i++; &#125; printf("%02d", num3);&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1013]]></title>
    <url>%2F2019%2F08%2F05%2FPAT%E4%B9%99%E7%BA%A71013%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805309963354112 题解一从第一个素数开始找起，输出$P_M$至$P_N$即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// PAT BasicLevel 1013// https://pintia.cn/problem-sets/994805260223102976/problems/994805309963354112#include &lt;iostream&gt;using namespace std;bool isPrime(int num);int main()&#123; // 获取用户输入 int n,m; cin &gt;&gt; m &gt;&gt; n; // 素数数量 int count = 0; // 遍历判断是否为素数 for (int num = 1;count&lt;n;num+=1)&#123; // 是素数 if(isPrime(num))&#123; // 素数数量更新 count++; // 判断是否输出 if(count&gt;=m)&#123; // 输出素数 cout &lt;&lt; num; if(count&lt;n)&#123; // 输出空格或者换行 if ((count - m + 1) % 10 == 0)&#123; //每行的最后一个数字 cout &lt;&lt; endl; &#125;else&#123; // cout &lt;&lt; ' '; &#125; &#125; &#125; &#125; &#125; //system("pause"); return 0;&#125;// 判断是否为素数bool isPrime(int num)&#123; // 1不是素数 if (num &lt;= 1) return false; // 用这种方法找素数找的比较快，相当于i&lt;sqrt(num)，但这样精度可能损失，导致错误 for (int i = 2; i * i &lt;= num; i++) &#123; if (num % i == 0) return false; &#125; return true;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1012]]></title>
    <url>%2F2019%2F08%2F04%2FPAT%E4%B9%99%E7%BA%A71012%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805311146147840 题解就比较简单，判断每个数字是哪种情况，然后进行相应的计算即可。 下面的代码中其实数组是不必要的，每取一个数字就可以直接进行相应计算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// PAT BasicLevel 1012// https://pintia.cn/problem-sets/994805260223102976/problems/994805311146147840#include &lt;iostream&gt;using namespace std;int main()&#123; // 数字个数 int n; cin &gt;&gt; n; // 获取数字 int* numArr=new int[n]; for(int i=0;i&lt;n;++i)&#123; cin &gt;&gt; numArr[i]; &#125; // 遍历数组，计算A1至A5 int a1=0,a1Count=0; int a2=0,flag=1,a2Count=0; int a3=0,a3Count=0; double a4Sum=0,a4Count=0; int a5=0,a5Count=0; for(int i=0;i&lt;n;++i)&#123; switch(numArr[i]%5)&#123; case 0: if(numArr[i]%2==0)&#123; a1+=numArr[i]; a1Count++; &#125; break; case 1: a2+=flag*numArr[i]; flag=-flag; a2Count++; break; case 2: a3++; a3Count++; break; case 3: a4Sum+=numArr[i]; a4Count++; break; case 4: if(numArr[i]&gt;a5)&#123; a5=numArr[i]; a5Count++; &#125; break; &#125; &#125; // 输出A1至A5 if(a1Count&gt;0)&#123; cout &lt;&lt; a1 &lt;&lt; ' '; &#125;else&#123; cout &lt;&lt;"N "; &#125; if(a2Count&gt;0)&#123; cout &lt;&lt; a2 &lt;&lt; ' '; &#125;else&#123; cout &lt;&lt; "N "; &#125; if(a3Count&gt;0)&#123; cout &lt;&lt; a3 &lt;&lt; ' '; &#125;else&#123; cout &lt;&lt; "N "; &#125; if(a4Count&gt;0)&#123; printf("%.1lf ", a4Sum / a4Count); &#125;else&#123; cout &lt;&lt; "N "; &#125; if (a5Count &gt; 0)&#123; cout &lt;&lt; a5; &#125; else&#123; cout &lt;&lt; 'N'; &#125; delete[] numArr; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1011]]></title>
    <url>%2F2019%2F08%2F04%2FPAT%E4%B9%99%E7%BA%A71011%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805312417021952 题解很明显这题是考数值范围的，int占4个字节，范围正好是$ [−2^{31},2^{31}]$。 两个大的int相加会溢出，而long只保证不比int的位数少，所以使用long long较好。 1234567891011121314151617181920212223242526// PAT BasicLevel 1011// https://pintia.cn/problem-sets/994805260223102976/problems/994805312417021952#include &lt;iostream&gt;using namespace std;int main()&#123; // 获取测试用例个数 int t; cin &gt;&gt;t; // 三个整数 long long a,b,c; for(int i=1;i&lt;=t;i++)&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #"&lt;&lt; i &lt;&lt;": " &lt;&lt; (a + b &gt; c ? "true" : "false")&lt;&lt; endl; &#125; system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1010]]></title>
    <url>%2F2019%2F08%2F04%2FPAT%E4%B9%99%E7%BA%A71010%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805313708867584 我有点看不懂题目……，在网上找题解后，经测试推导题意发现： 如果输入的式子（一项或多项均可）中的常数是0时，输入是应该有0 0的。 而导数是多项时，如果最后一项是0，是不用输出0 0的；如果导数是一项时.. 反正极其奇怪，反正是5个测试点都过了，主要我不是很懂题目的要求。 我的方法（题解1）和网上的一个方法（题解2）也有可能是错的，因为当输入是1 1时，程序都会继续等待输入，而非终止。或者我没找到正确的题解。 题解一123456789101112131415161718192021222324252627282930313233343536373839404142434445// PAT BasicLevel 1010// https://pintia.cn/problem-sets/994805260223102976/problems/994805313708867584#include &lt;iostream&gt;using namespace std;int main()&#123; // 系数 int coefficient; // 指数 int exponent; // 获取第一项 cin &gt;&gt; coefficient &gt;&gt; exponent; // exponent==0说明是最后一项，即只有一项 if (exponent==0)&#123; cout &lt;&lt; "0 0"; &#125; // 多于一项 else&#123; // 输出第一项的导数 cout &lt;&lt; coefficient * exponent &lt;&lt; ' ' &lt;&lt; exponent - 1 ; // 输出后几项的导数 while (cin &gt;&gt; coefficient &gt;&gt; exponent) &#123; // 是最后一项 if (exponent == 0) &#123; break; &#125; // 不是最后一项 else &#123; cout &lt;&lt; ' ' &lt;&lt; coefficient * exponent &lt;&lt; ' ' &lt;&lt; exponent - 1; &#125; &#125; &#125; system("pause"); return 0;&#125; 题解二参考链接：https://blog.csdn.net/song68753/article/details/81710228 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; int a, b; int x = 1; while (cin &gt;&gt; a &gt;&gt; b) //输入 &#123; if (b == 0) break; //舍弃 if (!x) cout &lt;&lt; " "; else x = 0; cout &lt;&lt; a * b &lt;&lt; " " &lt;&lt; b - 1; &#125; if (x) cout &lt;&lt; "0 0"; system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://www.cnblogs.com/chouxianyu/ 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1009]]></title>
    <url>%2F2019%2F08%2F04%2FPAT%E4%B9%99%E7%BA%A71009%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805316250615808 题解一我的方法如下： 将这一行字符串格式看做：第一个单词( 单词)( 单词)( 单词) 利用循环输出所有( 单词) 输出第一个单词 12345678910111213141516171819202122232425262728// PAT BasicLevel 1009// https://pintia.cn/problem-sets/994805260223102976/problems/994805314941992960#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 获取用户输入的一行 string str; getline(cin,str); // 可读取空格，遇到换行停止，并不读取换行 // 将这一行字符串格式看做：第一个单词( 单词)( 单词)( 单词) // 从右边找空格然后一直输出( 单词) int indexOfSpace; while ((indexOfSpace = str.find_last_of(" ")) != str.npos) //length()和size()是一样的 &#123; cout &lt;&lt; str.substr(indexOfSpace + 1, str.length()) &lt;&lt; ' '; str=str.substr(0,indexOfSpace); &#125; // 输出第一个单词 cout &lt;&lt; str.substr(0,str.length()); //system("pause"); return 0;&#125; 题解二这个方法也挺不错的，我很喜欢。 利用到了栈先进后出的特点，以及cin遇到空格和回车停止，不读取换行的特点。 参考链接：https://www.cnblogs.com/cdp1591652208/p/7138046.html 1234567891011121314151617181920212223242526272829303132333435// PAT BasicLevel 1009// https://pintia.cn/problem-sets/994805260223102976/problems/994805314941992960#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;int main()&#123; // 保存所有单词 stack&lt;string&gt; strs; // 保存一个单词 string str; // 读取所有单词 while(cin&gt;&gt; str)&#123; strs.push(str); if(getchar()=='\n') break; &#125; // 输出所有单词 cout &lt;&lt; strs.top(); strs.pop(); while (!strs.empty())&#123; cout &lt;&lt; ' ' &lt;&lt; strs.top(); strs.pop(); &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1008]]></title>
    <url>%2F2019%2F08%2F04%2FPAT%E4%B9%99%E7%BA%A71008%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805316250615808 查了查网上的题解，情况如下： 一种方法是和我（题解一）一样的 这个方法真的奇葩，并不交换数组元素位置，只是根据n和m改变输出顺序，我个人觉得不可取 参考链接：https://blog.csdn.net/qq_35283188/article/details/77370798 这种方法应该是最符合题目要求的，三次逆置法（题解二），感觉很像上学期算法设计与分析考试里的一道题。 参考链接：https://www.cnblogs.com/cdp1591652208/p/7161684.html 还有一个方法，看起来挺玄乎的，没看懂就没怎么看 参考链接：https://blog.csdn.net/qq_22194315/article/details/52625679 题解一我这个方法应该是移了n+m次，看起来只用了一个数组，其实也是用了两个数组吧……惭愧惭愧 12345678910111213141516171819202122232425262728293031323334353637383940414243// PAT BasicLevel 1008// https://pintia.cn/problem-sets/994805260223102976/problems/994805316250615808#include &lt;iostream&gt;using namespace std;int main()&#123; // 获取用户输入的n和m以及n个整数 int n,m; int arr[200]; cin &gt;&gt; n &gt;&gt; m; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; arr[i]; &#125; // m==0则不用移动 if(m&gt;0)&#123; // 假如有10个数，右移13位其实相当于13%10=3位。 // 所以m一定小于n，所以把数组大小定义为200 m = m % n; // 整体右移m位 for(int i=n-1;i&gt;=0;i--)&#123; arr[i+m]=arr[i]; &#125; // 把最右侧的m个数字循环右移到左侧 for (int i = n-1; i &lt; n + m;i++)&#123; arr[i%n]=arr[i]; &#125; &#125; // 输出结果 cout &lt;&lt; arr[0]; for(int i=1;i&lt;n;i++)&#123; cout &lt;&lt; ' ' &lt;&lt; arr[i]; &#125; //system("pause"); return 0;&#125; 题解二这道题的参考链接里说这是链表，讲错了吧，这儿哪有链表……核心在于三次逆置 但时间（3ms）与内存占用（400KB左右）和题解一差不多，可能测试用例输入规模不够大吧。 1234567891011121314151617181920212223242526272829303132333435363738394041// PAT BasicLevel 1008// httarrs://arrintia.cn/arrroblem-sets/994805260223102976/arrroblems/994805316250615808#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; // 获取用户输入的n和m以及n个整数 int n,m; cin &gt;&gt; n &gt;&gt; m; int* arr=new int[n]; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; arr[i]; &#125; // m==0则不用移动 if(m&gt;0)&#123; // 假如有10个数，右移13位其实相当于13%10=3位。 // 所以m一定小于n，所以把数组大小定义为200 m = m % n; // 三次逆置 reverse(arr, arr + n - m); reverse(arr + n - m, arr + n); reverse(arr, arr + n); &#125; // 输出结果 cout &lt;&lt; arr[0]; for(int i=1;i&lt;n;i++)&#123; cout &lt;&lt; ' ' &lt;&lt; arr[i]; &#125; //system("pause"); delete[] arr; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1007]]></title>
    <url>%2F2019%2F08%2F04%2FPAT%E4%B9%99%E7%BA%A71007%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805318855278592 题解一根据题意，素数对有两个特点：差为2、相邻，所以我们可以从3开始枚举每一对数字，然后再判断它们两个是不是素数。 这道题刚开始还是有一个点超时（TLE）了，主要原因有三点： 枚举方法太low，没有利用偶数不可能是素数这一性质。（题解一已处理） 我刚开始是枚举的是3,5、4,6、……；后来改成了3,5、5,7、…… 判断素数方法太low，用sqrt较好，当然也有更快的方法。（题解一已处理） for循环中可能重复判断5是不是素数（让我想起来了动态规划..…），增加了时间复杂度（题解一未处理，在题解二中处理） 在网上查题解发现我在判断素数的时候也忘记了处理1不是素数和2是素数的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// PAT BasicLevel 1007// https://pintia.cn/problem-sets/994805260223102976/problems/994805317546655744#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isPrime(int num);int main()&#123; // 获取用户输入的数字 int N=0; cin &gt;&gt; N; // 判断素数对的个数 int count=0; for(int i=3;i+2&lt;=N;i+=2)&#123; // 偶数一定不是素数 if(isPrime(i)&amp;&amp;isPrime(i+2))&#123; count++; &#125; &#125; // 输出结果 cout &lt;&lt; count; //system("pause"); return 0;&#125;// 判断是否为素数bool isPrime(int num)&#123; // 并没有处理num为2的情况 // 用这种方法找素数找的比较快，相当于i&lt;sqrt(num)，但这样精度可能损失，导致错误 for (int i = 2; i*i &lt;= num; i++)&#123; if (num%i==0) return false; &#125; // 边界条件，1不是素数 return num == 1?false:true;&#125; 题解二针对题解一中重复判断5是否为素数的问题，我们至少有两种方法解决： 建一个数组存储所有素数 用一个变量存储上一个素数且不断更新 网上搜到的题解有方法一，也有方法二，这里采用后者。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// PAT BasicLevel 1007// https://pintia.cn/problem-sets/994805260223102976/problems/994805317546655744#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isPrime(int num);int main()&#123; // 获取用户输入的数字 int N=0; cin &gt;&gt; N; // 素数对的个数 int count=0; // 上一个素数 int lastPrime=2; // 计算素数对个数 for(int i=3;i&lt;=N;i+=2)&#123; // 偶数除了2一定不是素数 // 找到新的素数 if(isPrime(i))&#123; // 判断是否为素数对 if(i-lastPrime==2)&#123; //两个素数之差为2 count++; // 计数 &#125; // 更新上一个素数 lastPrime=i; &#125; &#125; // 输出结果 cout &lt;&lt; count; //system("pause"); return 0;&#125;// 判断是否为素数bool isPrime(int num)&#123; // 1不是素数 if(num&lt;=1) return false; // 用这种方法找素数找的比较快，相当于i&lt;sqrt(num)，但这样精度可能损失，导致错误 for (int i = 2; i*i &lt;= num; i++)&#123; if (num%i==0) return false; &#125; return true; &#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1006]]></title>
    <url>%2F2019%2F08%2F03%2FPAT%E4%B9%99%E7%BA%A71006%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805318855278592 题解一这道题其实很简单，获取用户输入后，判断数字的位数，根据位数的不同，再获取百位、十位、个位的数字，然后据其进行字符串拼接，最后输出。 啧，太久没有写C++代码了，下面代码里的numArr可以用string类型的，而且你看完题解二会觉得我是不是傻了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// PAT BasicLevel 1006// https://pintia.cn/problem-sets/994805260223102976/problems/994805318855278592#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int getbitnum(int num);int main()&#123; // 获取用户输入的数字 int num=0; cin &gt;&gt;num; // 获取数字位数 int numOfBits=getbitnum(num); // 存储输出内容 string str=""; // 十个数字，C++的字符串不能直接加数字进行拼接 char numArr[9] = &#123;'1', '2', '3', '4', '5', '6', '7', '8', '9'&#125;; // 生成输出内容所用的中间变量 switch (numOfBits) &#123; case 3:&#123; int bai = num / 100; for (int i = 0; i &lt; bai; i++) &#123; str += "B"; &#125; num %= 100; &#125; case 2:&#123; int shi = num / 10; for (int i = 0; i &lt; shi; i++) &#123; str += "S"; &#125; num %= 10; &#125; case 1: for(int i=0;i&lt;num;i++)&#123; str +=numArr[i]; &#125; &#125; // 输出结果 cout &lt;&lt; str; return 0;&#125;// 获取数字的位数int getbitnum(int num)&#123; // 默认一位数 int numOfBits=1; if(num&gt;99)&#123; // 三位数 numOfBits=3; &#125;else if(num&gt;9)&#123; //两位数 numOfBits=2; &#125; return numOfBits;&#125; 题解二这是网上搜到的题解，比题解一好多了。我傻了我傻了。 123456789101112131415161718192021222324252627282930313233343536// PAT BasicLevel 1006// https://pintia.cn/problem-sets/994805260223102976/problems/994805318855278592#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; // 获取用户输入的数字 int num=0; cin &gt;&gt;num; // 得到每位数字 int bai = num / 100; int shi = num % 100 / 10; int ge = num % 10; // 输出结果 for (int i = 0; i &lt; bai; i++)&#123; cout &lt;&lt; 'B'; &#125; for (int i = 0; i &lt; shi; i++) &#123; cout &lt;&lt; 'S'; &#125; for(int i=1;i&lt;=ge;i++)&#123; cout &lt;&lt; i; &#125; //system("pause"); return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1004]]></title>
    <url>%2F2019%2F07%2F22%2FPAT%E4%B9%99%E7%BA%A71004%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805321640296448 题解 获取用户输入 排序 输出 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// PAT BasicLevel T1004// https://pintia.cn/problem-sets/994805260223102976/problems/994805321640296448#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;/** * 学生类 */struct Student&#123; // 姓名 string name; // 学号 string id; // 分数 int score;&#125;;/** * 比较两个学生 */bool cmp(Student &amp;s1, Student &amp;s2);int main()&#123; // 学生个数 int numOfStu = 0; cin &gt;&gt; numOfStu; // 学生数组 vector&lt;Student&gt; students; students.resize(numOfStu); // 获取学生信息 for (int i = 0; i &lt; numOfStu; i++) &#123; cin &gt;&gt; students[i].name; cin &gt;&gt; students[i].id; cin &gt;&gt; students[i].score; &#125; // 把学生排序 sort(students.begin(), students.end(), cmp); // 输出成绩最好和成绩最差的学生的名字和学号 cout &lt;&lt; students.back().name &lt;&lt; " " &lt;&lt; students.back().id &lt;&lt; endl; cout &lt;&lt; students.front().name &lt;&lt; " " &lt;&lt; students.front().id &lt;&lt; endl; return 0;&#125;/** * 比较两个学生 */bool cmp(Student &amp;s1, Student &amp;s2)&#123; return s1.score &lt; s2.score;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mingw控制台中文乱码]]></title>
    <url>%2F2019%2F07%2F22%2Fmingw%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[乱码原因直接先用一段话讲乱码原因，看不懂老老实实就往下看吧 其实我用Sublime或者VSCode等编辑器写代码出现的控制台中文乱码问题是编译器mingw输出的数据使用的是UTF-8编码，而控制台用了GBK编码来解析它。 其实编码只要统一用UTF8或者GBK都行，但用了错误的编码去解析文件就会出错。 问题来源如果我们写轻量代码（比如写算法题）也用VS之类的IDE，就太不划算了；虽然也有Codeblocks、Dev C++这样的小一点的IDE，但用起来还是可以发现让人很不爽的缺点。 之前尝试用VS Code写C++代码，挺不错的，好看方便。但问题就是难配置，最大的问题是控制台中文乱码，我搞了好久都没搞好，今天终于解决了。 在网上找到一段话是这么讲的： Windows(中文)默认的字符集是Windows-936(GBK)，mingw的内部是GCC，而GCC编译器默认编译的时候是按照UTF-8解析和输出的，当未指定字符集时一律当作UTF-8进行处理，于是造成乱码。 根据上边这段话，我有点灵感，但还是有疑问，见下。 问题分析我电脑的CMD编码设置的是UTF-8，代码文件的编码也是UTF-8，如果mingw默认按UTF-8处理的话，可以看到这里用的编码全都是UTF-8，那应该不会出现乱码的。 但我们确实看到了乱码啊！？ 当我去看我的注册表（见下图），发现代码链接、编译后生成的可执行文件有一个单独的注册表，这似乎说明我们运行的可执行文件并不是我们口中的那个CMD（按Win+R、cmd打开的那个CMD）。所以@roadwide整理的网上的改CMD编码啊什么的，可能搞错了问题的方向，不过也算一个方法吧，但似乎对我不适用。我之前也是搞错了方向。 如下图所示，我们运行的可执行文件，也就是那个弹出来的控制台，它的编码是GBK。现在我们应该知道乱码的原因了。 整个过程是这样的： 我们代码的编码是UTF-8 把UTF-8编码的代码交给mingw，它也默认当做UTF-8处理（目前为止这是正确的） mingw处理后生成的数据还是UTF-8编码（目前为止还是正确的） 把mingw处理后的数据（UTF-8编码）给cmd（目前为止也是正确的） cmd按GBK编码处理它（UTF-8），这时出现错误，所以出现乱码 解决方案我们可以修改mingw的输出，让它在编译时使用GBK编码输出，然后再让CMD去显示。 处理中文乱码只需要设置两个（核心只有一个）编译参数，即在tasks.json中tasks中的args中添加-fexec-charset=GBK和-finput-charset=UTF-8，下边tasks.json中的第14、15行。 这个解决方案中代码文件的编码是UTF-8，控制台编码是GBK，令mingw实现编码转换。 下面的.vscode配置是我在网上找到的比较新的VS Code配置，可以作为参考，具体不做解释，想了解可以去看文章末的参考网址。 tasks.json1234567891011121314151617181920212223242526272829303132333435// 用来编译&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "2.0.0", "tasks": [&#123; "label": "Build", // 任务的名字叫Build（编译），注意是大小写区分的，等会在launch中调用这个名字 "type": "shell", // 任务执行的是shell命令 "command": "g++", // 命令是g++ "args": [ //参数 "-g", // 调试 // "-fexec-charset=GBK", // 处理mingw中文编码问题 "-finput-charset=UTF-8",// 处理mingw中文编码问题 // "$&#123;file&#125;", //当前文件路径，包括所在目录绝对路径和文件名 "-o", //对象名，不进行编译优化 "$&#123;fileDirname&#125;/exes/$&#123;fileBasenameNoExtension&#125;.exe", //当前目录下exes文件夹下的exe文件，exe文件名为 当前文件名（去掉扩展名）.exe ], // 所以以上部分，就是在shell中执行下面这行语句（以我E盘中一个main.cpp为例） // g++ -g -fexec-charset=GBK -finput-charset=UTF-8 e:\Study\Programming\Code\Algo\PTABasicLevelCPP\main.cpp -o e:\Study\Programming\Code\Algo\PTABasicLevelCPP/exes/main.exe "group": &#123; "kind": "build", "isDefault": true // 任务分组，tasks是个数组，意味着可以执行多个task // 在build组的任务们，可以通过在Command Palette(F1) 输入run build task来运行 // 当然，如果任务分组是test，你就可以用run test task来运行 &#125;, "problemMatcher": [ "$gcc" // 使用gcc捕获错误 ], &#125;]&#125; -fexec-charset=GBK是令mingw按GBK编码生成exe文件。 -finput-charset=UTF-8是令mingw按UTF-8编码处理。（经测试这个参数可以不设置） launch.json123456789101112131415161718192021222324252627282930313233&#123; "version": "0.2.0", "configurations": [ &#123; "name": "C++ Launch (GDB)", // 调试时程序员看到的名字 "preLaunchTask": "Build", // launch之前会运行的任务，这个名字一定要跟tasks.json中的任务名一致 "type": "cppdbg", // 经测试，不可删除 "request": "launch", // 经测试，不可删除 "program": "$&#123;fileDirname&#125;/exes/$&#123;fileBasenameNoExtension&#125;.exe", //运行当前打开文件的目录下exes文件夹中名字和当前文件相同，但扩展名为exe的程序 "args": [], // 运行程序是默认是没有参数的 "stopAtEntry": false, // 选为true则会在打开控制台后停滞，暂时不执行程序 "cwd": "$&#123;workspaceFolder&#125;",// 当前工作路径：当前文件所在的工作空间 "environment": [], "externalConsole": true, // 是否使用外部控制台， "MIMode": "gdb", "miDebuggerPath": "D:\\WorkingSoftware\\MinGW\\bin\\gdb.exe", //调试器路径 "setupCommands": [&#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125;] &#125;]&#125;// https://code.visualstudio.com/Docs/editor/debugging#_launch-configurations// author: huihut// Available variables which can be used inside of strings.// $&#123;workspaceRoot&#125;: the root folder of the team // $&#123;file&#125;: the current opened file // $&#123;fileBasename&#125;: the current opened file's basename // $&#123;fileDirname&#125;: the current opened file's dirname // $&#123;fileExtname&#125;: the current opened file's extension // $&#123;cwd&#125;: the current working directory of the spawned process 参考链接中文乱码参考1 中文乱码参考2 VS Code配置参考 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>VSCode</tag>
        <tag>mingw</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1003]]></title>
    <url>%2F2019%2F07%2F22%2FPAT%E4%B9%99%E7%BA%A71003%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805323154440192 题解1这个是我自己的方法，..…刚开始做题，还啥都不会啊。 只能过4个Case，Case5过不了，得19分，还不知道哪里错了（让强迫症很难受啊）。 第1个条件很简单，判断无非法字符即可。 第2个条件，是xPATx，易得：当字符串中有PAT时，PAT左右两边字符串应相等。 第3个条件，它依赖于前两个条件，特别是第2个，所以可以采取递归的形式。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.Scanner;/** * PTABasicLevel 1003 * https://pintia.cn/problem-sets/994805260223102976/problems/994805323154440192 */public class Main &#123; public static void main(String[] args) &#123; // 打开scanner Scanner scanner=new Scanner(System.in); // 用户输入的字符串 String str=null; // 获取测试组数 int T=scanner.nextInt(); // T组测试 while( T-- &gt; 1)&#123; // 获取用户输入的字符串 str=scanner.next(); // 输出结果 System.out.println(isValid(str)?"YES":"NO"); &#125; // 获取用户输入的字符串 str=scanner.next(); // 输出结果 System.out.print(isValid(str)?"YES":"NO"); // 关闭scanner scanner.close(); &#125; /** * 判断一个字符串是否有效 * @param str 一个字符串 * @return 结果 */ public static boolean isValid(String str)&#123; // 字符串长度 int strLength=str.length(); // 字符串中P和T首次出现的位置 int indexOfP=-1; int indexOfT=-1; // 字符串中P和T的数量 int numOfP=0; int numOfT=0; // 字符串应仅由P、A、T组成，且P和T各有一个，判断过程中记录P和T的位置和个数 for(int i=0;i&lt;strLength;i++)&#123; // 存在PAT以外的字母，字符串就是错误的 if(str.charAt(i)=='P')&#123; indexOfP=i; numOfP++; &#125;else if(str.charAt(i)=='T')&#123; indexOfT=i; numOfT++; &#125;else if(str.charAt(i)!='A')&#123; return false; &#125; &#125; // P或T不是1个，或者是P和T的位置有问题（应该是PxT，x是正整数个A拼成的字符串） if(numOfP!=1||numOfT!=1||indexOfT-indexOfP&lt;2)&#123; return false; &#125; // 在这一行已可以确定字符串只由1个P和一个T和一些A组成，且P和T位置正确 // 条件2 // P和T中间只有1个A if(indexOfT-indexOfP==2)&#123; String x=str.substring(0,indexOfP); // PAT左右是相等的x if(indexOfT+1==str.lastIndexOf(x))&#123; return true; &#125; // PAT左右不相等 else&#123; return false; &#125; &#125; // 条件3 else&#123; String a=str.substring(0,indexOfP); int indexOfRightA=str.lastIndexOf(a); // 剥掉Pb和T中间的A，以及Tc后的a String newStr=str.substring(0,indexOfT-1)+str.substring(indexOfT,indexOfRightA); return isValid(newStr); &#125; &#125;&#125; 题解2在网上找到的，其实和我的一样，都是找规律嘛，不过找到的规律不同。 aPbTc中a和b只能是若干个A或空字符串，且应满足length(a)*length(b)==length(c)&amp;&amp;length(b)&gt;1。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Scanner;/** * PTABasicLevel 1003 * https://pintia.cn/problem-sets/994805260223102976/problems/994805323154440192 */public class T1003 &#123; public static void main(String[] args) &#123; // 打开scanner Scanner scanner=new Scanner(System.in); // 用户输入的字符串 String str=null; // 获取测试组数 int T=scanner.nextInt(); // T组测试 while( T-- &gt; 0)&#123; // 获取用户输入的字符串 str=scanner.next(); // 输出结果 System.out.println(isValid(str)?"YES":"NO"); &#125; // 关闭scanner scanner.close(); &#125; /** * 判断一个字符串是否有效 * @param str 一个字符串 * @return 结果 */ public static boolean isValid(String str)&#123; // 字符串长度 int strLength=str.length(); // 字符串中P和T首次出现的位置 int indexOfP=-1; int indexOfT=-1; // 字符串中P和T的数量 int numOfP=0; int numOfT=0; // 字符串应仅由P、A、T组成，且P和T各有一个，判断过程中记录P和T的位置和个数 for(int i=0;i&lt;strLength;i++)&#123; // 存在PAT以外的字母，字符串就是错误的 if(str.charAt(i)=='P')&#123; indexOfP=i; numOfP++; &#125;else if(str.charAt(i)=='T')&#123; indexOfT=i; numOfT++; &#125;else if(str.charAt(i)!='A')&#123; return false; &#125; &#125; //在这一行，已知字符串仅由P、A、T组成 if(numOfP==1&amp;&amp;numOfT==1&amp;&amp;indexOfT-indexOfP&gt;1&amp;&amp;indexOfP*(indexOfT-indexOfP-1)==strLength-indexOfT-1)&#123; return true; &#125; else&#123; return false; &#125; &#125;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1002]]></title>
    <url>%2F2019%2F07%2F22%2FPAT%E4%B9%99%E7%BA%A71002%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805324509200384 题解先以字符串形式读取用户输入的数字，然后计算各位之和，再把这个和的每一位以拼音形式输出。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Scanner;/** * PTABasicLevel 1002 * https://pintia.cn/problem-sets/994805260223102976/problems/994805324509200384 */public class T1002 &#123; public static void main(String[] args) &#123; //保存自然数 String numStr; //用字符串保存用户输入的数字 Scanner scanner=new Scanner(System.in); numStr=scanner.next(); //计算每位之和并输出对应汉语 printSum(calcSum(numStr)); //关闭scanner scanner.close(); &#125; /** * 计算字符串形式的数字的各位之和 * @param str 用户输入的数字的字符串形式 * @return int类型，用户输入的数字各位之和 */ public static int calcSum(String str) &#123; //保存各位数字之和 int sum = 0; //计算各位数字之和 int length = str.length(); for (int i = 0; i &lt; length; ++i) &#123; sum += str.charAt(i) - '0'; &#125; //返回各位数字之和 return sum; &#125; /** * 输出一个数字对应的汉语 * @param sum 用户输入的各位数字之和 * 输出这个和对应的汉语 */ public static void printSum(int sum) &#123; //拼音 String[] chineseArr = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; //int类型的sum转成字符串 String sumStr=Integer.toString(sum); //输出 System.out.print(chineseArr[sumStr.charAt(0)-'0']); int length=sumStr.length(); for(int i=1;i&lt;length;i++)&#123; System.out.print(" "+chineseArr[sumStr.charAt(i)-'0']); &#125; &#125;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级1001]]></title>
    <url>%2F2019%2F07%2F22%2FPAT%E4%B9%99%E7%BA%A71001%2F</url>
    <content type="text"><![CDATA[题目链接https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528 题解emm就很简单了，考简单的循环和分支。 代码如下： 123456789101112131415161718192021222324252627282930313233343536//PTABasicLevel 1001//https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528#include&lt;iostream&gt;using namespace std;int main()&#123; //存储正整数n int n=0; //存储步数 int count=0; //获取输入 cin&gt;&gt; n; //计算步数 while(n!=1)&#123; //n是奇数 if(n%2==1)&#123; n=(3*n+1)/2; &#125; //n是偶数 else&#123; n=n/2; &#125; //步数加一 count++; &#125; //输出步数 cout &lt;&lt; count; cout &lt;&lt; "你好"; return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法时间复杂度]]></title>
    <url>%2F2019%2F07%2F19%2F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[函数的渐近的界$O$定义如下： 设$f$和$g$是定义域为自然数集$N$上的函数，若存在正数$c$和$n_0$，使得对一切$n\geq n_0$有 0 \leq f(n)\leq c\,g(n)成立，则称$f(n)$的渐进上界是$g(n)$，记作 f(n)=O(g(n)) $f(n)$的阶不高于$g(n)$的阶 可能存在多个正数$c$，只要指出一个即可 对前面有限个$n$值可以不满足不等式 常函数的渐进上界可以写作$O(1)$ $\Omega$定义如下： 设$f$和$g$是定义域为自然数集$N$上的函数，若存在正数$c$和$n_0$，使得对一切$n\geq n_0$有 0 \leq c\,g(n)\leq f(n)成立，则称$f(n)$的渐进下界是$g(n)$，记作 f(n)=\Omega (g(n)) $f(n)$的阶不低于$g(n)$的阶 可能存在多个正数$c$，只要指出一个即可 对前面有限个$n$值可以不满足不等式 $o$定义如下： 设$f$和$g$是定义域为自然数集$N$上的函数，若对于任意正数$c$都存在$n_0$，使得对一切$n\geq n_0$有 0 \leq f(n)< c\,g(n)成立，则记作 f(n)=o(g(n)) $f(n)$的阶低于$g(n)$的阶 对不同正数$c$，$c$越小$n_0$越大 对前面有限个$n$值可以不满足不等式 $\omega$定义如下： 设$f$和$g$是定义域为自然数集$N$上的函数，若对于任意正数$c$都存在$n_0$，使得对一切$n\geq n_0$有 0\leq c\,g(n)]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法设计与分析基础]]></title>
    <url>%2F2019%2F07%2F17%2F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[问题求解的关键 问题建模 对输入参数和解给出形式化或半形式化的描述 设计算法 选择什么算法？如何描述这个方法？ 这个方法是否对所有实例都得到正确的解？如何证明？ 如果不是，能否找到反例？ 分析算法 分析算法的效率 NP难问题 NP-hard问题有数千个，大量存在于各个应用领域。NP-hard问题举例：TSP问题、0-1背包、双机调度 目前还没有找到有效算法，有效算法指的是运行时间是输入规模$n$的指数或更高阶函数，即输入规模$n$的多项式时间。 至今没有人能证明这类问题不存在多项式时间的算法。 从是否存在多项式时间算法的角度来看，这些问题是彼此等价的（如果其中一个问题存在多项式时间的算法，则其它问题也都存在；如果其中一个不存在，则其它问题也不存在多项式时间算法）。这些问题的难度处于可有效计算的边界。 问题定义需要回答的一般性提问，通常含若干参数 问题描述 定义问题参数（可以是集合、变量、函数、序列等等） 说明每个参数的取值范围和参数间的关系 定义问题的解 说明解满足的条件（优化目标或约束条件） 问题实例参数的一组赋值可得到问题的一个实例 算法定义有限条指令的序列，这个指令序列确定了解决某个问题的一系列运算或操作。 要求若算法A解问题P，则应满足： 把问题P的任何实例作为算法A的输入，都可输出该实例的正确解 每步计算是确定性的 A能够在有限步停机 基本运算可以是比较、加法、乘法、置指针、交换等等操作。 基本运算的确定往往和输入规模相关，算法基本运算的次数可表示为输入规模的函数。 排序 元素之间的比较 检索 被检索元素$x$与数组元素的比较 整数乘法 每位数字相乘（位乘）1次，$m$位和$n$位整数相乘要做$mn$次位乘 矩阵相乘 每对元素乘1次 $i\times j$矩阵与$j\times k$矩阵相乘要做$ijk$次乘法 图的遍历 置指针 时间复杂度针对指定的基本运算，算法所做基本运算的次数。 对于相同输入规模的不同实例，算法的基本运算次数也不一样，我们可定义以下两种时间复杂度。 最坏情况下的时间复杂度$W(n)$ 算法求解输入规模为$n$的实例所需要的最长时间 平均情况下的时间复杂度$A(n)$ 在给定同样规模为$n$的输入实例的概率分布下，算法求解这些实例所需要的平均时间 设$S$是规模为$n$的实例集，实例$I\in S$的概率是$P_I$，算法对实例$I$执行的基本运算次数是$t_I$，则$A(n)=\sum_{I\in S}P_It_I$ 输入规模通常用数组元素多少、调度问题的任务个数、图的顶点数和边数等表示 排序 数组中元素个数$n$ 检索 被检索数组的元素个数$n$ 整数乘法 两个整数的位数$m$和$n$ 矩阵相乘 矩阵的行列数$i,j,k$ 图的遍历 图的顶点数$n$，边数$m$ 给定问题和基本运算就决定了一个算法类 比如排序问题，以元素间的比较为基本运算，就确定了一个算法类。 伪码描述 赋值语句 $\leftarrow$ 分支语句 if…then..…[else..…] 循环语句 while，for，repeat，until 转向语句 goto 输出语句 return 调用 直接写过程的名字 注释 //..… 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化模型概论]]></title>
    <url>%2F2019%2F07%2F17%2F%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[最优化问题在一系列主观或客观限制条件下，寻求使所关注的某个或多个指标达到最大（或最小）的决策，这种决策问题通常称为最优化问题或优化问题，研究处理这类问题的数学方法称为最优化方法。 用最优化方法解决决策问题包括两个基本步骤： 优化建模 建立决策问题的优化模型 模型求解 选择、利用优化方法和工具求解模型 优化模型一般形式优化模型是一种特殊的数学模型，优化建模方法是一种特殊的数学建模方法。优化模型一般由以下三个要素： 决策变量 通常是该问题要求解的那些未知量，可用一个$n$行的列向量$x=(x_1,x_2,\ldots,x_n)^T$表示。当对$x$赋值后它通常称为该问题的一个解或一个点。 目标函数 通常是该问题要优化（最小或最大）的那个目标的数学的表达式，它是决策变量的函数，可抽象地记做$f(x)$。 约束条件 由该问题对决策变量的限制条件给出，即$x$允许取值的范围为$x \in \Omega$，$\Omega$称为可行域，常用一组关于$x$的等式和不等式来界定，分别称为等式约束和不等式约束。 优化模型中约束一般没有严格小于、严格大于关系。 一般数学形式如下： opt \ \ \ z=f(x)\\ s.t. \ h_i(x)=0 \ (i=1,2,\ldots,m_e),\\ \quad \ \ \ g_i(x)\leq0\ (j=m_e+1,m_e+2,\ldots,m_e+m)其中，$opt$是最优化（optimize）的意思，可以是$min$或$max$； $s.t.$是“受约束于”（subject to或such that）。 可行解与最优解满足约束条件的解$x$（即$x\in\Omega$）称为可行解，否则称为不可行解。 满足目标函数的可行解$x’$称为最优解。 如果在某个可行解$x^$的附近（$x^$的某个邻域），$x^$使目标函数达到最优，即$x^$是$x^$某个邻域中的最优解，但它不一定是整个可行域上的最优解，则$x^$称为一个局部最优解或相对最优解，它实际上只是极值点。 相对于局部最优解，我们把整个可行域上的最优解称为全局最优解或整体最优解。对于大多数优化问题，求全局最优解是很困难的，所以很多优化软件往往只能求到局部最优解。 基本类型若按模型中决策变量的取值范围以及目标函数和约束函数的特性进行分类，常见类型如下： 连续优化 当所有决策变量$x_i(i=1,2,\ldots,n)$取值均为连续数值（即实数）时，优化模型称为连续优化（continuous optimization），也就是通常所说的数学规划。 线性规划 此时，如果目标函数$f$和约束函数$h_i、g_j$都是线性函数，则优化模型称为线性规划（linear programming，LP）。 非线性规划 此时，如果目标函数$f$和约束函数$h_i、g_j$中至少有一个是非线性函数，则称为非线性规划（nonlinear programming，NLP）。 特别地，如果目标函数$f$是一个二次函数，而约束函数$h_i、g_j$都是线性函数，则称为二次规划（quadratic programming,QP），它是一种相对比较简单的非线性规划。 离散优化 若$x_i$至少有一个只取离散数值，则优化模型称为离散优化（discrete optimization），或称为组合优化（combinatorial optimization）。 这时通常$x$的一个或多个分量只取整数数值，则称为整数规划（integer programming，IP），并可以进一步明确地分为纯整数规划（pure integer programming，PIP，此时$x$的所有分量都只取整数数值）和混合整数规划（mixed integer programming，MIP，此时x的部分分量只取整数数值）。 特别地，若$x$的分量中取整数数值的范围还限定为只取0或1，则称为0-1规划（zero-one programming，ZOP）。 此外，与连续优化分成线性规划和非线性规划类似，整数规划也可以分成整数线性规划（ILP）和整数非线性规划（INLP）。 根据其他标准，优化问题还可以分为无约束优化（unconstrained optimization）和约束优化（constrained optimization）、确定性规划和不确定性规划（如随机规划、模糊规划等）、光滑优化和非光滑优化、单目标规划和多目标规划，此外还有目标规划、动态规划、多层规划等等。 一般来说，离散优化问题比连续优化问题难以求解，非线性规划问题比线性规划问题难以求解，非光滑优化比光滑优化难以求解。 敏感性分析考虑当模型中的参数发生变化时最优解是否变化、变化多少的问题，这种分析称为敏感性分析。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数学建模</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和数据库的初次相遇]]></title>
    <url>%2F2019%2F07%2F04%2F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%9D%E6%AC%A1%E7%9B%B8%E9%81%87%2F</url>
    <content type="text"><![CDATA[以下为一些SQL语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960-- 所有sql语句以分号结尾,sql不区分大小写-- 建库语句create database 库名;-- 查询已有库show databases;-- 删除库drop database 库名;-- 使用库use 库名;-- 创建表create table 表名(id int,name varchar(50),age int);-- 查询表结构desc 表名; -- describe-- 查询建表语句show create table user;-- 查询当前库中有哪些表show tables;-- 删除表drop table 表名;-- 显示表show tables;-- 向表中插入数据insert into 表名 (字段名1,字段名2) values(值1,值2); -- 字段与值一一对应，企业要求insert into 表名 values(值1,值2,值3); -- 要求是值的顺序和个数必须和表中字段的顺序和个数一致insert into user(name.age) values(&apos;Tom&apos;,18);insert into user values(&apos;Jerry&apos;,20);-- 从表中查询数据select 字段名 -- from 表名 where 查询限定条件select * from user; -- 查询全部数据select name,age from user; --仅显示表user中name和age字段的值select * from user where age=19; -- 查询表中age字段为19的表项-- 修改表中数据update 表名 set 字段名=值 where 限定条件; -- 如果不加where，就是对表中指定字段所有数据进行修改update user set age=22 where name=&apos;tom&apos;; -- 将name字段为&apos;tom&apos;的表项年龄字段改为22-- 删除表中数据delete from 表名 where 限定条件; -- 如果不加where，则删除所有-- 总结-- 库和表的CRUD，关键字分别是create,show,alter,drop-- 表中数据的CRUD，关键字分别是insert,select,update,delete 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理-课程设计]]></title>
    <url>%2F2019%2F06%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[目的与要求​ 深入了解计算机各种指令的执行过程，以及控制器的组成，指令系统微程序设计的具体知识，进一步理解和掌握动态微程序设计的概念；完成微程序控制的特定功能计算机的指令系统设计和调试。 ​ 要进行这项大型实验，必须清楚地懂得： TEC-2机的功能部件及其连接关系； TEC-2机每个功能部件的功能与具体组成； TEC-2机支持的指令格式； TEC-2机的微指令格式，AM2910芯片的用法； 已实现的典型指令的执行实例，即相应的微指令与其执行次序的安排与衔接； 要实现的新指令的格式与功能。 实验环境$TEC-2$模拟机 具体内容请选定指令格式、操作码，按照要求，设计三条指令。 指令一 说明 把用绝对地址表示的内存单元ADDR1中的内容与内存单元ADDR2中的内容相减，结果存于内存单元ADDR1中。 三字指令（控存入口110H）。 格式 D8××,ADDR1,ADDR2 功能 [ADDR1]=[ADDR1]-[ADDR2] 微程序设计与实现 执行顺序 微指令 说明 1 $PC\to AR,PC+1 \to PC$ 为读取第1个操作数的地址做准备 2 $MEM \to R6$ 读取第1个操作数的地址送入$R_6$ 3 $PC \to AR,PC+1 \to PC$ 为读取第2个操作数的地址做准备 4 $MEM \to AR$ 读取第2个操作数的地址送入$AR$ 5 $R6 \to AR,MEM \to R6$ 第1个操作数地址送$AR$，读取第2个操作数送入$R_6$ 6 $MEM-R6\to R6$ 第1个操作数-第2个操作数送入$R_6$ 7 $R6 \to MEM$ $R_6$送第1个操作数所在存储单元 $PC\to AR,PC+1 \to PC$ 10000 0E00 A0B5 5402 七 顺序执行，下址字段任意取值即可 六 $AM2910$命令码为14，即14号指令，顺序执行 五 $SCC、SC$ 顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值 $SST$ 此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可 四、三 $\bar{MIO}、REQ、\bar{WE}$ 不需要读写存储器或输入输出设备，所以为10X $MI_{8-6}$ 运算结果送$B$口，运算器Y输出$A$口 $MI_{5-3}$ 选择加法运算 $MI_{2-0}$ 运算数选择$B$口和0,（选$A$口和0也可以，因为$A$口和$B$口是同一个寄存器） $A$口 选$PC$，即$R_5$ 二 $B$口 选$PC$，即$R_5$ $SCI$ 最低位进位设置为1 $SSH$ 不移位 一 $SA、SB$ 选微指令中的$A$口、$B$口地址 $DC1$ 因为$AR$只能接收来自运算器的结果输出信号，所以$DC1$可以任意 $DC2$ 运算器输出送$AR$ $MEM \to R6$ 10000 0E00 30F0 6000 七 顺序执行，下址字段任意取值即可 六 $AM2910$命令码为14，即14号指令，顺序执行 五 $SCC、SC$ 顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值 $SST$ 此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可 四、三 $\bar{MIO}、REQ、\bar{WE}$ 读存储器 $MI_{8-6}$ 运算结果送$B$口，运算器Y输出运算结果（并没有使用） $MI_{5-3}$ 选择加法运算 $MI_{2-0}$ 运算数选择$D$和0 $A$口 任意 二 $B$口 选$R6$ $SCI$ 最低位进位设置为0 $SSH$ 不移位 一 $SA、SB$ $A$口任意，因为不使用$A$口；选择微指令中的$B$口地址 $DC1$ 任意 $DC2$ 不控制 $PC \to AR,PC+1 \to PC$ 10000 0E00 A0B5 5402 这条微指令和本机器指令的第一条微指令完全一样，不再做解释说明 $MEM \to AR$ 10000 0E00 10F0 0002 七 顺序执行，下址字段任意取值即可 六 $AM2910$命令码为14，即14号指令，顺序执行 五 $SCC、SC$ 顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值 $SST$ 此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可 四、三 $\bar{MIO}、REQ、\bar{WE}$ 读存储器 $MI_{8-6}$ 运算结果不送寄存器，运算器Y输出运算结果送$AR$ $MI_{5-3}$ 选择加法运算 $MI_{2-0}$ 运算数选择$D$和0 $A$口 任意 二 $B$口 任意 $SCI$ 最低位进位设置为0 $SSH$ 不移位 一 $SA、SB$ 都任意，因为不使用$A$口和$B$口 $DC1$ 任意 $DC2$ 运算器输出送$AR$ $R6 \to AR,MEM \to R6$ 10000 0E00 20F6 6002 七 顺序执行，下址字段任意取值即可 六 $AM2910$命令码为14，即14号指令，顺序执行 五 $SCC、SC$ 顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值 $SST$ 此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可 四、三 $\bar{MIO}、REQ、\bar{WE}$ 读存储器 $MI_{8-6}$ 运算结果送$B$口，运算器Y输出$A$口 $MI_{5-3}$ 选择加法运算 $MI_{2-0}$ 运算数选择$D$和0 $A$口 $R_6$ 二 $B$口 $R_6$ $SCI$ 最低位进位设置为0 $SSH$ 不移位 一 $SA、SB$ 使用微指令中的$A$口和$B$口 $DC1$ 任意 $DC2$ 运算器输出送$AR$ $MEM-R6\to R6$ 10000 0E01 22D6 6000 七 顺序执行，下址字段任意取值即可 六 $AM2910$命令码为14，即14号指令，顺序执行 五 $SCC、SC$ 顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值 $SST$ 此时是真正的运算，设置标志位 四、三 $\bar{MIO}、REQ、\bar{WE}$ 读存储器 $MI_{8-6}$ 运算结果送$B$口；运算器Y输出$A$口（并没有使用） $MI_{5-3}$ 选择减法运算 $MI_{2-0}$ 运算数选择$D$和$A$口 $A$口 $R_6$ 二 $B$口 $R_6$ $SCI$ 最低位进位设置为0 $SSH$ 不移位 一 $SA、SB$ 使用微指令中的$A$口和$B$口 $DC1$ 任意 $DC2$ 不控制 $R6 \to MEM$ 10029 0300 1046 0010 七 这是最后一条微指令，下一条微指令是A4H。 六 $AM2910$命令码为3，即3号指令，条件转移 五 $SCC、SC$ $\bar{CC}$设为0，进行转移 $SST$ 此时并不是运算，所以标志位不变 四、三 $\bar{MIO}、REQ、\bar{WE}$ 写存储器 $MI_{8-6}$ 运算结果不送寄存器；运算器Y输出​$A$口 $MI_{5-3}$ 选择加法运算 $MI_{2-0}$ 运算数选择0和$A$口 $A$口 $R_6$ 二 $B$口 任意 $SCI$ 最低位进位设置为0 $SSH$ 不移位 一 $SA、SB$ 使用微指令中的$A$口；$B$口任意 $DC1$ 运算器输出送$IB$ $DC2$ 不控制 指令测试如下图所示，[A00H]存储单元（$ADDR1$）存储了0045H，[A01H]存储单元（$ADDR2$）存储了0023H，最终指令运行后[A00H]为0022H，实现[ADDR1]=[ADDR1]-[ADDR2]。 指令二 说明 将一通用寄存器内容加上某内存单元内容，结果放在另一寄存器中。 双字指令（控存入口130H），$SR$和$DR$分别为源、目的寄存器（各4位）。 格式 E0 DR SR,ADDR 功能 DR=SR+ [ADDR] 微程序设计与实现 执行顺序 微指令 说明 1 $PC\to AR,PC+1 \to PC$ 为读取操作数的地址做准备 2 $MEM \to AR$ 操作数的地址送入$AR$ 3 $SR+MEM \to DR$ 计算$SR$与操作数的和存入$DR$ $PC\to AR,PC+1 \to PC$ 10000 0E00 A0B5 5402 这条微指令和第一条机器指令的第一条微指令完全一样，不再做解释说明 $MEM \to AR$ 10000 0E00 10F0 0002 这条微指令和第一条机器指令的第四条微指令完全一样，不再做解释说明 $SR+MEM \to DR$ 10029 0301 30D0 0088 七 这是最后一条微指令，下一条微指令是A4H。 六 $AM2910$命令码为3，即3号指令，条件转移 五 $SCC、SC$ $\bar{CC}$设为0，进行转移 $SST$ 此时进行了运算，需要对标志位进行设置 四、三 $\bar{MIO}、REQ、\bar{WE}$ 读存储器 $MI_{8-6}$ 运算结果送$B$口；运算器Y输出​运算结果（并没有使用） $MI_{5-3}$ 选择加法运算 $MI_{2-0}$ 运算数选择$D$和$A$口 $A$口 使用机器指令中设置的$SR$，微指令中不需要给$A$口地址 二 $B$口 使用机器指令中设置的$DR$，微指令中不需要给$B$口地址 $SCI$ 最低位进位设置为0 $SSH$ 不移位 一 $SA、SB$ 使用机器指令中的$SR、DR$ $DC1$ 任意 $DC2$ 不控制 指令测试如图示，$R_0$（$SR$）为0023H，A00H（$ADDR$）存储0023H，程序运行后$R_1$（$DR$）为0046H，实现DR=SR+ [ADDR] 。 指令三 说明 转移指令 判断两个通用寄存器内容是否相等，若相等则转移到指定绝对地址，否则顺序执行。 双字指令（控存入口140H），SR和DR分别为源、目的寄存器（各4位），ADDR为绝对地址。 提示 利用指令的CND字段，即$IR_{10-8}$，令$IR_{10-8}=101$，即$\bar{CC}=Z$。 当DR==SR​时Z=1，微程序不跳转，接着执行$MEM \to PC$（即$ADDR\to PC$）； 而当DR!=SR​时Z=0​，微程序跳转至A4H。 格式 E5 DR SR,ADDR 功能 if DR==SR goto ADDR else 顺序执行 微程序设计与实现 执行顺序 微指令 说明 1 $SR-DR$ 测试$SR$与$DR$是否相等 2 $PC \to AR,PC+1 \to PC，\ $如果$Z=0，$则微程序跳转到$A4H$ 为读取转移地址做准备 3 $MEM \to PC$ 程序转移到指定地址 $SR-DR$ 10000 0E01 9210 0088 七 顺序执行，下址字段任意 六 $AM2910$命令码为14，即14号指令，顺序执行 五 $SCC、SC$ 顺序执行，不需要条件测试 $SST$ 此时进行了运算，需要对标志位进行设置，来判断$SR$和$DR$是否相等 四、三 $\bar{MIO}、REQ、\bar{WE}$ 不进行存储器或IO操作 $MI_{8-6}$ 运算结果不送寄存器；运算器Y输出​运算结果（并没有使用） $MI_{5-3}$ 选择减法运算 $MI_{2-0}$ 运算数选择$A$口和$B$口 $A$口 使用机器指令中设置的$SR$，微指令中不需要给$A$口地址 二 $B$口 使用机器指令中设置的$DR$，微指令中不需要给$B$口地址 $SCI$ 最低位进位设置为0 $SSH$ 不移位 一 $SA、SB$ 使用机器指令中的$SR、DR$ $DC1$ 任意 $DC2$ 不控制 $PC \to AR,PC+1 \to PC$，如果$Z=0$，则微程序跳转到$A4H$ 10029 03E0 A045 5412 七 微程序转移，下址字段为A4H 六 $AM2910$命令码为3，即3号指令，条件转移 五 $SCC、SC$ 测试条件设置为$IR_{10-8}$，指令中将$IR_{10-8}$设为5，即$\bar{CC}=Z$ $SST$ 此时并不是计算，状态位保持即可 四、三 $\bar{MIO}、REQ、\bar{WE}$ 不进行存储器或IO操作 $MI_{8-6}$ 运算结果送$B$口；运算器Y输出$A$口 $MI_{5-3}$ 选择加法运算 $MI_{2-0}$ 运算数选择$A$口和0 $A$口 $A$口设置为$PC$，即$R_5$。 二 $B$口 $B$口设置为$PC$，即$R_5$。 $SCI$ 最低位进位设置为1 $SSH$ 不移位 一 $SA、SB$ 使用微指令中的$A$口和$B$口地址 $DC1$ 由于是写$AR$，这里把运算器输出送$IB$。经过前两条机器指令的试验，实际上$DC1$可以任意。 $DC2$ 写$AR$ $MEM \to PC$ 10029 0300 30F0 5000 七 微程序转移，下址字段为A4H 六 $AM2910$命令码为3，即3号指令，条件转移 五 $SCC、SC$ 测试条件设置为0，一定转移 $SST$ 此时并不是计算，状态位保持即可 四、三 $\bar{MIO}、REQ、\bar{WE}$ 读存储器 $MI_{8-6}$ 运算结果送$B$口；运算器Y输出运算结果（并没有使用） $MI_{5-3}$ 选择加法运算 $MI_{2-0}$ 运算数选择$D$和0 $A$口 $A$口任意，并不使用。 二 $B$口 $B$口设置为$PC$，即$R_5$。 $SCI$ 最低位进位设置为0 $SSH$ 不移位 一 $SA、SB$ 使用微指令中的$B$口地址，$A$口任意（因为不使用$A$口）。 $DC1$ 任意 $DC2$ 不控制 指令测试当$R_1$（$SR$）存储0023H、$R_2$（$DR$）存储0026H时，即$DR \neq SR$时，程序顺序执行，运行了MOV R1,0026，所以程序运行后$R_1$为0026H。 当$R_1$（$SR$）存储0023H、$R_2$（$DR$）存储0023H时，即$DR = SR$时，程序跳转至828H（$ADDR$），所以未运行MOV R1,0026，所以程序运行后$R_1$仍为0023H。 $DR \neq SR$时 $DR = SR$时 实验心得 磨刀不误砍柴工。在设计微程序前，我把实验书看了一遍，有些地方不是很懂；之后着手去设计微程序，然后再去看书，理解到的更多了；最终微程序设计完之后，我又把书看了一遍，又发现了很多之前理解不到位的地方，正所谓温故而知新。我想这最能说明实践和理论的关系吧，多动手多动脑，才能巩固对知识的理解。 通过本次对微指令码一位位的设计，我对于计算机的底层实现有了更深的理解，更进一步地了解了计算机的工作原理，特别是运算器、控制器、内存、寄存器等部件之间的协作。本学期也学了汇编语言，它几乎是最靠近计算机硬件的编程语言了，在本次课程设计中，自主设计硬件间的协作，又算是直接接触了硬件，巩固了汇编和计组两门学科的知识与其联系。 通过本次课程设计，我巩固了微程序设计的方法与思想，比如微指令、微操作、微命令、水平型微指令、微控存等基本概念，了解了微程序层次上程序员所看到的的计算机系统结构，加深了对程序员一词的理解。不同层次的程序员由于工作的“机器”不同，所以面对的问题以及其实现往往也是极为不同的。 附加材料以下为$TEC-2$部分知识点总结。 字长$TEC-2$机字长为16位，运算器、主存、数据与地址总线均为16位。 指令$TEC-2$机指令有6位操作码，故支持64条指令，其中53条已实现，用于写出该机的监控程序。 $IR$：指令寄存器，存储当前正在执行的指令。 指令最高6位（$IR_{15-10}$）是操作码，之后两位$IR_{9-8}$是条件码，把它用作条件转移指令的判断条件，因此可以认为这两位是指令的扩展操作码。除条件转移指令之外，其余指令不使用这两位。 主存主存支持$64K$字，$4K\times8$的$ROM(2732)$存放监控程序，$2K\times8$的$RAM(2716)$存放用户数据及数据。 运算器运算器主要由4片$AM2901$级联而成，可实现8种运算功能，16个双端口（$A$、$B$）读出、单端口（$B$）写入的通用寄存器（$R_{0-15}$，其中$R_{4-6}$作为$SP$、$PC$、$IP$），另配有1片$AM2902$实现快速进位。 $IP$ 保存当前正在运行的指令的地址，用于转移变址的目的。 所以在课设第一条指令中可以使用$R_6$暂存数据，因为此时不需要转移变址，用不到$IP$。 $I_{8-6}$ 进行寄存器结果选择和Y输出选择 $I_{5-3}$ 进行运算功能选择 $I_{2-0}$ 进行数据来源选择 引脚信号 $D_{3-0}$ 外部送给$AM2901$的数据信号，比如从内存读出来的数据 $Y_{3-0}$ $AM2901$向外送出的数据，受​$\bar{OE}$控制。但在​$TEC-2$中，​$\bar{OE}$已接地 $A、B$ 选择寄存器组中的源与目的寄存器。 当$A$、$B$同值时，被选中的同一个寄存器的内容将被同时送到$A$、$B$两个数据输出端口 控制器 控制器主要由一片$AM2910$、7片$6116(RAM,2K\times8)$（微控存）、16位的指令寄存器$IR$和2片$2716$（存储用于实现53条机器指令的微程序，加电后读取送入微控存）等组成。 程序计数器$PC$用运算器中的通用寄存器$R_5$代替，保存下一条指令的地址。 指令地址寄存器$IP$由运算器中的$R_6$代替。 控存字长56位，已实现的53条指令的微程序存放在2片单独的8位$ROM$中，加电的过程自动调入控存（装入微码）。 地址总线的输入信号仅有一组，即地址寄存器（$AR$），而AR只能接收来自运算器的结果输出信号。 $AM2910$$AM2910$，微程序定序器，作用：形成下一条微指令的地址。 三个输出使能信号作用：决定直接输入D的来源 $\bar{MAP}$ 当其有效时，$D$来源于$MAPROM$，用于实现从机器指令到相应的微程序段的转移。 $\bar{VECT}$ 当其有效时，原意为$D$来源于中断向量，现用于接收手拨微地址。 $\bar{PL}$ 当其有效时，$D$来源于微指令的下地址字段，用于实现微程序转移。 引脚定义 $\bar{CC}$ 条件测试，当其为低电平时，测试成功，转移（使用下址字段）；否则，顺序执行。 $\bar{OE}$ Y输出允许信号，低电平有效，已接地 $\bar{CCEN}$ $\bar{CC}$允许信号，已接地 16条命令 2号命令 指令功能分支，无条件转$MAP$ 3号命令 条件转移，条件测试$\bar{CC}$为1时顺序执行，否则按下地址$D$转移。 14号命令 顺序执行下一条微指令 微程序微指令格式每位的用处已在EXCEL表格中说明。 $DC1$和$DC2$ 关于这两个控制位我还有两个问题 $DC2$为​$2$时 写$AR$时应把$DC2$设为2，即$AR$接收来自$IB$的数据；但$DC1$课本上都是设为0，即微型开关送$IB$。 这样不就是把微型开关送到了$AR$嘛？这不太对啊！？以下是我的猜测： 我猜在这里$DC1$应该是任意的。因为$AR$只能接收运算器的输出，所以当$DC2$设置为写$AR$时，就忽略$DC1$的设置，硬件应该可以实现。 $DC2$为​$0$时 此时代表$NC$，即无寄存器接收$IB$的数据，所以此时$DC1$应该也是任意，书上写的是0。 $SSH$ 常用微指令 19H 取指令，$PC$增量。 该条微指令公用于所有指令。 1AH 按新取来的指令的操作码找到该条指令本身的微程序段的入口地址。 19H之后一定是1AH。 A4H 根据有无中断请求，决定是进入中断处理过程，还是顺序执行。 任何一条机器指令执行完都要去A4H检测中断 程序调试以第一条指令为例 前期准备 $S_2S_1S_0$ 设为100 $FS_1FS_2FS_3FS_4$ 设为1010 $STEP/CONT$ 设为CONT 输入并查看微码 E900 将微码输入到900H开始的内存单元中 D900 查看内存 将微码加载到微控存 A800 输入加载微码的程序 123450800: MOV R1,900 ; 900是微码在内存中地址0802: MOV R2,7 ; 共7条微指令0804: MOV R3,110 ; 微码在微控存中的首地址0806: LDMC ;加载微码0807: RET G800 运行上边的代码，把微码装入微控存110H开始的单元中 测试指令 A820 输入测试指令的程序到820H开始的内存单元中 123456780820: MOV R0,0045 0822: MOV [A00],R0 ; [A00]单元存储45H0824: MOV R1,00230826: MOV [A01],R1 ; [A01]单元存储23H0828: NOP ; 占一个字0829: NOP082A: NOP082B: RET E826 把新指令写到826H开始的内存单元 10828 0000:D800 0000:0A00 0000:0A01 U820 反汇编，查看我们输入的测试指令的程序 123456780820: 2C00 0045 MOV R0, 00450822: 3400 0A00 MOV [0A00], R00824: 2C10 0023 MOV R1, 00230826: 3401 0A01 MOV [0A01], R10828: D800 DW D8000829: 0A00 ADC R0, R0 ; 高8位为000010XX，对应指令为ADC，实际上是我们自己设计的指令082A: 0A01 ADC R0, R1082B: AC00 RET G820 运行从820H开始的程序 观察运算结果DA00 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理-第七章复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[三层次存储系统三层次存储系统指CACHE-主存-辅存存储系统。 目的：解决高速度、大容量和低成本间的矛盾。 主存-辅存层次解决容量和成本间的矛盾。 CACHE-主存层次解决速度和成本间的矛盾。 CACHE工作原理工作原理也就是层次存储系统能发挥效用的原因，如下： 根据程序访问的局部性，如果当前正在执行的程序和数据存放在CACHE中，当程序运行时，不必从主存储器取指令和数据，访问CACHE即可。 程序访问的局部性： 在一个较短的时间间隔内，程序访问的地址（程序、指令的地址和数据的地址）往往集中制存储器逻辑地址空间的很小范围内。 三种地址映像方式地址映像：主存地址映像到Cache 直接映像 优点 实现简单，只需利用主存地址按某些字段直接判断，即可确定所需字块是否已在cache中 缺点 不够灵活，不能用替换算法 全相联映像 优点 最灵活，可以使用任何替换算法，理论上命中率高 缺点 成本最高，每个Cache块都要用一个运算器 组相联映像组间直接映像，组内全相联映像。 优缺点 是直接映像和全相联映像的折衷方案，性能处于前两种之间。 替换算法FIFO把最先调入cache的字块替换出去 LRU把近期最少使用的字块替换出去。 这需要一张表来记录cache中各字块的使用情况，把最近使用的字块放到表的最上边，其他的向下顺移。 虚拟存储器虚拟存储器拥有辅存的容量，接近主存的速度和辅存的单位成本。 存储管理段式管理利用程序的模块化形状，把主存按段分配 优点 段的分界和程序的自然分界相对应 段的逻辑独立性使它易于编译、管理、修改和保护，也易于重复调用。 缺点 容易在段间留下许多零碎的存储空间，造成空间浪费。 页式管理主存物理空间被划分为等长的页 优点 与段式管理相比，空间浪费要小得多 缺点 处理、保护和共享都不如段式来得方便 段页式管理程序按模块分段，段内再分页，出入内存仍以页为单位，用段表和页表进行两级管理（每段一个页表） 页式存储器虚地址高位字段为虚页号，低位字段为页内字地址。 假设页表保存在内存中，那么访问存储器时首先要查页表（需要访问主存），得到实地址后，再次访问主存才能完成读写操作，这样相当于主存速度降低了一半。 解决办法：使用快慢表，快表是慢表（主存中的页表）的小小的副本。 查表时，用虚页号同时去查快表和慢表，如果在快表中找到，就将对应的实页号送入实主存地址寄存器，并使慢表的查找作废；找不到时，就要花费一个访问主存时间查慢表，从中查到实页号送入实存地址寄存器，并将此虚页号和对应的实页号送入快表，替换快表中某一行内容（这也使用替换算法）。 段页式虚拟存储器 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理-第六章复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[控制器作用 控制程序的执行 即协调并控制计算机各部件执行程序的指令序列。 控制器功能 取指令 分析指令 又叫指令译码。 执行指令 控制程序和数据的输入与结果输出 对异常情况和某些请求的处理 控制器组成PC程序计数器/指令地址寄存器，存放当前指令或下一条指令的地址（TEC-2中PC存储下一条指令的地址）。 在一条无条件跳转指令的指令周期内，PC的值被修改2次。 取指令周期结束后，PC值自动加1；执行周期中，PC值修改为要跳转到的地址，故在这个指令周期内，PC值被修改两次。 程序计数器（PC）的位数取决于主存的容量。 程序计数器的内容为指令在主存中的地址，所以程序计数器的位数与主存地址的位数相等，而主存地址位数取决于主存的容量。 指令周期、间址周期 IR指令寄存器，存放当前正在执行的指令 指令寄存器（IR）的位数取决于指令字长 指令寄存器的内容为正在执行的指令，所以位数取决于指令字长。 CPU中的通用寄存器不能替代指令寄存器（IR） 指令寄存器是专门用于存放指令的专用寄存器，不能由通用寄存器替代。 指令译码器又叫操作码译码器，对指令寄存器中的操作码进行分析解释。 脉冲源及启停电路 脉冲源 产生一定频率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号； 另外在开机时产生reset信号 启停电路 保证可靠地送出或封锁完整的时钟脉冲，控制时序信号的发生和停止 时序控制信号形成部件形成并调整时序。 产生控制信号一般有两种方法： 微程序控制方式硬布线控制方式几个周期指令周期从取指令开始到其执行完成所经过的时间。 一个指令周期包含若干个时钟周期。 时钟周期通常称为节拍脉冲或T周期。 时钟周期是计算机中最基本的、最小的时间单位。 数据通路结合课后习题6.1食用。 MAR主存地址寄存器；MDR主存数据寄存器；AC累加寄存器，简称累加器。 主存与CPU之间的连线有地址总线和数据总线。 地址总线的信息仅从CPU传送到主存MAR，数据总线则允许双向传送（CPU和MDR）。 指令从主存取出到产生控制信号的数据通路 指令地址从PC经地址总线送到MAR，数据从主存经数据总线送到IR。 数据在运算器和主存直接进行读/写的数据通路 读写地址由IR中指令的地址字段经地址总线送主存MAR；读时数据从主存经数据总线送到MDR，然后送ALU，然后送AC；写时数据从AC送MDR，再送主存。 微程序控制的基本概念把机器指令拆分成微指令，再把微指令拆分成微操作。 微指令把机器指令拆分成微指令。 机器指令与微指令的关系：用微指令解释机器指令 微指令长度一般要比机器指令长得多。 微操作一个微指令中，由同时发出的控制信号所执行的各个操作称为微操作。 微命令微命令和微操作一一对应。 微命令是微操作的控制信号，微操作是微命令的执行过程。 微程序微指令序列。 控制存储器用来存放微程序，其容量取决于实现指令系统所需的微程序长度（或者说其容量取决于微指令的条数）。 $AM2910$微程序定序器 作用形成下一条微指令的地址 三个输出使能信号作用：决定直接输入D的来源 $\bar{MAP}$ 当其有效时，$D$来源于$MAPROM$，用于实现从机器指令到相应的微程序段的转移。 $\bar{VECT}$ 当其有效时，原意为$D$来源于中断向量，现用于接收手拨微地址。 $\bar{PL}$ 当其有效时，$D$来源于微指令的下地址字段，用于实现微程序转移。 16条命令 2号命令 指令功能分支，无条件转$MAP$，此时$\bar{MAP}为0$，根据指令的操作码形成用来解释执行该机器指令的微程序的入口地址 3号命令 条件转移，条件测试$\bar{CC}$为1时顺序执行，否则按下地址$D$转移。 14号命令 顺序执行下一条微指令 CPU如何区分指令和数据可以从时间和空间上来区分 取指令周期中从内存中读出的信息流是指令流，它流向控制器； 执行指令周期中从内存读出或送入内存的信息流是数据流，它由内存流向运算器或由运算器流向内存。 微程序控制的基本工作原理机器指令取入IR后，对操作码进行译码，得到相应指令的第一条微指令的地址。 MAPROM 指令译码器可用只读存储器组成，将操作码作为MAPROM的地址输入，该单元的内容即相应指令第一条微指令的地址，之后由微指令的下址字段指出下一条微指令的地址。 根据微指令地址从控制存储器中取出微指令，并将它存放在微指令寄存器中。控制字段各位直接与受控门相连，由此生成控制信号。 微指令格式水平型微指令在一条微指令中定义并执行多个并行微命令，所以速度比垂直型微指令快。 直接控制法、字段编译法经常应用在同一条水平型微指令中。 垂直型微指令在微指令中设置有微操作码字段，由其规定微指令的功能。 不强调微指令的并行控制功能 两者比较从实现原理和性能两个方面比较。 水平型微指令并行操作能力强，效率高，灵活性强 水平型微指令实现一条机器指令的执行时间短 水平型微指令字长较长，但微程序短 水平型微指令用户难以掌握 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理-第四章复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[存储器分类按在计算机中的作用（层次）分类主存储器简称主存，又称内存储器（内存）。 CPU可直接随机对其进行访问，也可以和Cache交换数据。 特点：容量较小、存取速度较快、单位价格较高。 辅助存储器简称辅存，又称外存储器（外存）。 不能与CPU直接交换信息。 特点：容量极大、存取速度较慢、单位成本低。 高速缓冲存储器简称Cache，位于主存和CPU之间。 特点：存储容量小、价格高。 按存储介质分类磁表面存储器比如磁盘、磁带。 磁心存储器半导体存储器TTL集成度低，功耗高，速度快 MOS集成度高，功耗低，速度慢。 所以现在内存主要用的MOS型存储器。 光存储器比如光盘。 按存取方式分类RAM随机读写存储器。存取时间与存储单元物理地址无关。 优点：读写方便、使用灵活，断电后内容丢失。 主要用作主存或Cache。 静态RAM以触发器原理寄存信息。 动态RAM以电容充电原理寄存信息。 ROM只读存储器。（Read Only） 只能随机读出而不能写入，断电后内容不会丢失。 可与RAM共同作为主存的一部分。 串行访问存储器读写时，需按其物理位置的先后顺序寻址。 顺序存取存储器如磁带。 特点：只能按某种顺序存取，存取速度慢。 直接存取存储器如磁盘。 存取方式介于RAM和顺序存取存储器，通常先寻找整个存储器中的某个区域（如磁盘上的磁道），再在小区域内顺序查找。 按信息可保存性分类易失性存储器断电内容丢失，如RAM。 非易失性存储器断电内容不丢失，如ROM、磁表面存储器和光存储器。 又可分为 E代表可擦写（Erase），P代表可编程（Programming） $ROM$ $PROM$ $EPROM$ $E^2PROM$，多出来的这个E代表电（Electric） $Flash\ Memory$ 补充 CD-ROM是只读型光盘存储器。 磁盘是直接存取存储器。 相联存储器是按内容指定方式和地址指定方式相结合进行寻址的寄存器。 相联存储器的基本原理：把存储单元的一部分内容作为检索项去检索存储器，并将存储器中与该检索项符合的存储单元内容进行读或写。 若OS在硬盘上，则内存储器应用RAM和ROM。 需将外存中的OS（部分）引导进内存，而引导程序通常用ROM存放。 另外ROM还经常存放操作系统等需要频繁使用，尤其是停电后不允许丢失的程序或数据。 RAMSRAM6管结构。TTL 读出时，根据两条位线中哪一条有负脉冲来判断触发器的状态。 写入时，根据两条位线电平来写入1或0。 DRAMMOS电容 DRAM采用地址复用策略（地址时分复用）。 目的：使DRAM芯片的地址管脚减少一半，从而减小器件尺寸。 刷新（再生）DRAM通过读出方式实现再生，读出放大器作为一个再生放大器。 DRAM刷新的单位是行，每列都有自己的读放。 原因 破坏性读出：某个存储单元被读出时，原存储信息被破坏。 破坏性读出的存储器，每次读出后，必须紧接一个再生的操作，以恢复被破坏的信息。 另外由于电容漏电阻的存在，也需要进行再生。 常见方式 集中刷新 在一个刷新周期内，利用一段固定时，依次对存储器所有行进行刷新，在此期间停止对存储器的读写操作，成为访存“死区”。 分散刷新 把对每行的刷新分散到各个工作周期内，增加了存储周期，但没有死区。 分布式刷新（异步刷新） 介于集中刷新和分散刷新。 对比六个方面：集成度、速度、功耗、价格、容量、原理、刷新 DRAM价格便宜（因此一般容量大，用作内存；而SRAM则用作Cache），集成度高，功耗低；但速度慢，还需要时间和电路进行再生（刷新）。 SRAM利用触发器保存信息，DRAM利用电容存储电荷保存信息。 DRAM需要刷新，SRAM不用刷新。 DRAM采用地址复用策略，SRAM不采用。 存储器的性能指标主要有3个性能指标，三者相互制约。 目标：大容量、低成本和高速度。 存储容量存储字数$\times$字长，如1M$\times$8位。 单位成本总成本/总容量。 存储速度存取时间完成一次存储器操作的时间，分为读取时间和写入时间。 存取周期又称读写周期或访问周期。连续两次操作存储器之间的最小时间间隔。 通常存取周期大于存取时间，因为它多了个复原时间。 复原时间： SRAM 存取信息的稳定时间。 DRAM 刷新的又一次存取时间，刷新是通过读出实现的。 对于破坏性读出的存储器，存取周期往往比存取时间大得多。 主存带宽又称数据传输率，每秒从主存进出信息的最大数量。 存储器容量扩展读写控制线可以是一根（$\bar{WE}$），也可以是两根（$\bar{WE}$和$\bar{RD}$）。 字扩展、位扩展和字位扩展是重点（两种操作，如何画图），看PPT上作业及答案。 方法 顺序 位扩展 字扩展 1 地址线与各芯片并联，CPU$\bar{WE}$与各芯片$\bar{WE}$并联 低位地址线与各芯片并联，CPU$\bar{WE}$与各芯片$\bar{WE}$并联 2 各芯片$\bar{CS}$并联接地 高位地址经译码器各输出分别连接各芯片$\bar{CS}$ 3 各芯片数据引到数据线（算是串行） 各芯片数据引到数据线（算是并行） 四个要素：$\bar{WE}$、$\bar{CS}$、地址线、数据线 多体交叉存储器 解决的主要问题是提高主存储器的数据传输率 采用低位交叉编址方式 低位地址选择不同的存储模块，高位地址指向相应的模块内部的存储字。因此，连续的地址分部在相邻的不同模块中。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理-第三章复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[进制转换2进制转8进制从小数点开始向左向右，3个一组换算成8进制，缺位补0。 如例3.4 8进制转2进制将一位8进制数换算成3位2进制数。 如例3.6 2进制转16进制从小数点开始向左向右，4个一组换算成16进制，缺位补0。 16进制转2进制将一位16进制数换算成4位2进制数。 8进制转16进制(拓展)从小数点开始向左向右，2个一组换算成16进制，缺位补0。可以先变成2进制，再变成16进制。 如表3.1 2进制转10进制每位2进制数乘以它的权重，再求和。8421 如例3.1 10进制转2进制整数部分除2取余至商为0，先求出来的余数靠近小数点（低位）。 如例3.7 小数部分小数部分 乘2取整至小数部分为0或满足精度要求，先求出来的整数靠近小数点（高位）。 如例3.8 机器数的表示 机器数有三种表示方式：原码、反码和补码。 我们先假设机器数为小数，符号为放在最左边，小数点置于符号位和数值之间。 真值 即±绝对值，用$X$表示，正号有时可省略。 原码 最高位为符号位，0表示正数，1表示负数，绝对值跟随其后。 小数点的位置默认在符号位之后，书写时可以将小数点保留或省略。 0的原码有两种表示形式： $[+0]_原=00000=0.0000$ $[-0]_原=10000=1.0000$ 补码 正数的补码与其原码一样 补码零的表示形式唯一：$[+0]_补=[-0]_补=00000=0.0000$ 负数原码补码互求 符号位不变 数据位按位取反 末位+1 加法若加法运算不超过机器范围时： 加法结果仍为补码 $[X+Y]_补=[X]_补+[Y]_补$ $[X-Y]_补=[X]_补+[-Y]_补$ 符号位也参与运算 由$[Y]_补$求$[-Y]_补$ $[Y]_补$所有位取反 末位+1 证明$[X+Y]_补=[X]_补+[Y]_补$补码定义： [X]_补=\begin{cases} X,0\leq X]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理-第二章复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[两种电路组合逻辑电路输出只和当前输入有关 时序逻辑电路输出不仅和当前输入有关，还和原来状态有关。 译码器$n$位输入，最多$2^n$个输出。 给定$n$位输入后，输出中仅有对应的那一个为1（或0），其他都为0（或1）。 数据选择器从多个输入中选择某一个作为输出。 181和182 181实现了位间快速进位。（4位，AM2901也是） 182实现了组间快速进位。（4组，AM2902也是） 例题： 如果实现64位快速运算，需要多少个181和多少个182？ 181 $\frac{64}{4}=16$ 182 $\frac{16}{4}=4，\frac{4}{4}=1$ $4+1=5$ 如果是128位呢 181 $\frac{128}{4}=32$ 182 $\frac{32}{4}=8，\frac{8}{4}=2，\frac{2}{4}=1$ $8+2+1=11$ 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理-第一章复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[冯诺依曼型计算机特点存储程序(核心特点) 采用存储程序方式，程序和数据放在同一个存储器中，以二进制表示。 五部分组成各部分通过数据总线、地址总线、控制总线传递信息，进行联系。 运算器 对数据进行运算 控制器 实现程序的自动执行 存储器 存放程序和数据 输入设备 输入原始数据和处理这些数据的程序 输出设备 输出计算机的处理结果 指令的组成 由操作码和地址码组成 运算器为中心 输入输出设备与存储器间的数据传送都通过运算器 指令的存放和执行 指令在存储器中按执行顺序存放 电子计算机的发展 电子管计算机 晶体管计算机 集成电路计算机 大规模集成电路计算机 超大规模集成电路计算机 计算机组成软件系统硬件系统计算机性能指标==字长== ==容量== ==CIP== 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-域名系统DNS]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS%2F</url>
    <content type="text"><![CDATA[功能把互连网上的主机名转换为IP地址 要点当某一个应用进程需要把主机名解析为IP地址时，该应用进程就调用解析程序，并成为DNS的一个客户。 把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。 本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回，应用进程获得目的主机的IP地址。 若本地域名服务器不能回答该请求，则此域名服务器暂时成为DNS的另一个客户（递归查询），并向其他域名服务器发出查询请求（一般迭代查询），直至找到能够回答该请求的域名服务器。 域名结构采用层次树状结构的命名方法。 域：名字空间中一个可被管理的划分，域还可以划分为子域，子域还可以划分为子域，形成顶级域、二级域、三级域等等。 DNS不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。 域名是从右往左看的，越往右等级越高。 域名服务器DNS服务器的管辖范围是以区为单位，区可能等于或小于域，但一定不能大于域，即区是域的子集。 一个服务器所负责管辖（或有权限的）的范围叫做区。 一个区中的所有节点必须是能够连通的。 每个区设置响应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。 根域名服务器根域名服务器是最高层次的域名服务器。 所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。 顶级域名服务器负责管理在该顶级域名下注册的所有二级域名。 权限域名服务器负责一个区的域名服务器。 本地域名服务器当一台主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。 不管哪一个本地域名服务器，若要对一个域名进行解析，只要自己无法解析，就首先要求助于根域名服务器。 域名解析过程主机向本地域名服务器查询一般采用递归查询。 如果本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器会以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即替主机继续查询）。 递归查询的结果： 查到的IP地址 报错，表示无法查询到所需的IP地址 本地域名服务器向根域名服务器查询一般采用迭代查询。 根域名服务器收到本地域名服务器发出的迭代查询请求报文时，本地域名服务器收到的查询结果有两种： 查到的IP地址 下一步向哪个域名服务器查询 顶级域名服务器在收到本机域名服务器的查询请求后，收到的结果有两种： 查到的IP地址 下一步向哪个权限域名服务器查询 就这样，本地域名服务器就这样进行迭代查询，最终把得到的结果返回给发起查询的主机。 高速缓存域名服务器功能：用来存放最近查询过的域名以及从何处获得域名映射信息的记录。 好处：提高DNS查询效率，减轻根域名服务器的负荷和减少互联网上的DNS查询报文数量。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-运输层复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[解决的问题实现两台主机中进程之间的通信。 复用和分用 复用 多个应用层进程可使用同一运输层服务 分用 运输层把收到的信息分别交付上面应用层的相应进程 提供可靠性 TCP 面向连接 面向字节流 提供可靠性 不提供广播或多播服务 协议数据单元是TCP报文段 有拥塞控制 每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。 套接字：IP地址+端口号 UDP 无连接 面向报文（给什么数据，传什么数据） 尽最大努力交付 可以一对多、多对一、多对多 协议数据单元是UDP用户数据报 没有拥塞控制 停止等待协议 无差错情况：停止等待 每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。 出现差错：超时重传 每发送完一个分组时设置一个超时计数器。 如果超时还未收到确认，就重传分组；在超时前收到确认则撤销该超时计数器。 A发送完一个分组后必须暂时保留已发送到分组的副本，在收到响应确认后才能清除这个副本。 分组和确认分组必须进行编号，这样才能明确发送出去的分组是哪一个收到了确认，哪一个没有收到确认。 可以处理确认迟到的情况。 超时计数器设置的重传时间应当比数据在分组传输的平均往返时间长一些。如果设定得很长，通信效率就会降低；如果设定得太短，会导致不必要的重传，浪费了网络资源。 确认丢失 确认丢失时，发送方进行超时重传，而接收方丢弃这个重复的分组，向发送方发送确认。 确认迟到 确认迟到了，发送方进行超时重传，而接收方丢弃这个重复的分组，向发送方发送确认。 发送方收到迟到的确认什么也不做。 慢开始TCP进行拥塞控制的一种算法。 拥塞是运输层的概念。 发送方维持一个变量：拥塞窗口，让自己的发送窗口等于拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度。 判断网络拥塞的依据就是出现了超时。网络拥塞时就把拥塞窗口减小一些。 慢开始：由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。 发送方每收到一个对新报文段的确认就使发送方的拥塞窗口+1。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-网络层复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[主要解决的问题网络层讨论的问题是多个网络互连的问题，即分组如何从一个网络传送到另一个网络。 协议数据单元网络层协议数据单元就是IP数据报，又称为数据报、分组或包。 网络层的两种服务网络层的两种服务指的是向运输层提供无连接或面向连接的服务。 选用哪一种服务的实质是：在计算机通信中，可靠交付应当由谁来负责。是网络（网络层）还是端系统（网络层的上几层）？ 可靠：分组无差错按序到达终点，不丢失，不重复 互联网的设计思路：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。分组不进行编号。 虚电路和数据报网络对比7个方面 对比的方面 虚电路服务 数据报服务 可靠性由谁保证 可靠由网络来保证 可靠由用户主机来保证 是否面向连接 面向连接 无连接 是否有终点地址 仅在连接建立阶段使用，每个分组使用短的虚电路号 每个分组都有终点的完整地址 分组转发方式 属于同一虚电路的分组按同一路由转发 每个分组独立选择路由进行转发 结点故障对网络的影响 所有通过故障结点的虚电路均不能工作 出故障的结点可能会丢失分组，一些路由可能发生变化 分组到达终点顺序 按发送顺序到达 不一定按发送顺序到达 端到端的差错处理和流量控制 可以由网络负责，也可以由用户主机负责 用户主机负责 互联网的IP协议提供不可靠的无连接的服务。 中间设备 工作层次 中间设备 物理层 转发器 数据链路层 网桥/桥接器 网络层 路由器 网络层以上 网关 IP地址以32位IP地址为例，A、B、C类地址都是单播地址，都由两个固定长度的字段组成，第一个字段是网络号，第二个字段是主机号。一个网络号在整个互联网范围内是唯一的，一个主机号在其网络内必须是唯一的。 一个IP只能对应一个主机；一个主机可以有多个IP，比如路由器。 IP地址分类A、B、C类地址的网络号字段分别是1个、2个和3个字节长，其网络号字段前几位是类别号。 IP地址类型 类别号 可指派网络号 A类 0 1-126 B类 10 128.1-191.255 C类 110 192.0.1-233.255.255 网络号127被保留作为本地环回测试，全0被保留表示本网络。 既然有了MAC地址，为什么要用IP地址？全世界存在各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户主机来完成这项工作几乎是不可能的事。但IP编址把这个复杂问题解决了。 分组转发路由表指出到某个网络应该如何转发，每行对应于一个网络。 在互联网上转发分组时，是从一个路由器转发到下一个路由器。 每条路由主要信息：（目的网络地址，下一跳地址）。下一跳地址是路由器端口的IP地址。 使用子网时分组的转发 使用子网划分后，每条路由主要信息：（目的网络地址，子网掩码，下一跳地址）。 主机 要发数据包时先判断是直接交付还是间接交付：即发送的这个分组是在本子网上进行直接交付还是要通过本子网的路由器进行间接交付：将与本子网的子网掩码和目的IP地址相与求得目的网络地址与该子网地址比较，得出是否直接交付。 路由器 拿到目的IP地址后对路由器直接相连的网络逐个进行检查（直接相连的网络可以直接写在路由表的最前边），将各网络的子网掩码和目的IP地址相与求得目的网络地址，判断该网络地址是否和对应的目的网络地址匹配。若匹配则直接交付，转发任务结束；否则就是间接交付，进行下一步。 若有特定主机路由，则把数据传送给路由表中指明的下一跳，否则执行下一步。 用路由表每一行中的子网掩码和目的IP地址相与，若结果与该行目的网络地址匹配，则把数据传送给该行指明的下一跳路由器；否则执行下一步 若路由表中有一个默认路由，则把数据报传送给路由表指定的默认路由器；否则，执行下一步 报告转发分组出错。 ARP功能：从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。 操作：去ARP高速缓存里找，找不到就广播ARP请求分组获得目的硬件地址（可以是路由器或主机的）并记录在ARP高速缓存中。 ARP消息类型 ARP request ARP请求分组（1），用于请求某IP主机的硬件地址。 广播。 主要内容：我的IP是xxx，我的硬件地址是xxx，我想知道IP地址是xxx的地址。 ARP response ARP响应分组（2），用于指出某IP主机的硬件地址。 单播。 主要内容：我的IP是xxx，我的硬件地址是xxx 假设主机A发送ARP请求分组请求主机B的物理地址，不久之后很有可能B也要向A发送数据报。所以ARP请求分组包含了源IP，B收到ARP请求分组时会把A的IP地址和物理地址记录在其ARP高速缓存中。 ARP高速缓存如果没有ARP高速缓存，任何一台主机每次进行通信时都必须在网络上广播ARP请求分组，使网络上的通信量大大增加。 生存时间 ARP对保存在ARP高速缓存中的每一个映射地址项目都设置生存时间，凡超过生存时间的项目就从高速缓存中删除掉。这样可以及时更新各主机与其物理地址的映射关系，处理主机网络适配器故障或更新等情况。 生存时间设置得太长会使映射关系发生变化的主机迟迟无法通信，设置得太短会使ARP请求和响应分组的通信太频繁。 ARP属于网络层不能说“ARP向网络层提供了服务”，因为ARP本身是网络层的一部分。数据链路层使用硬件地址而不使用IP地址，因此ARP不在数据链路层。 不需要发送ARP请求分组的情况 源主机的ARP高速缓存中已有目的IP地址的项目 源主机发送广播分组 源主机和目的主机使用点对点链路 IP子网IP地址与子网掩码相与 同样的IP地址和不同的子网掩码可以得出相同的网络地址。但是不同的掩码效果是不同的：可划分的子网数和每一个子网中的最大主机数都是不一样的。 知道A和B的IP，想让他们在一个子网内，应如何给它们分配子网掩码？ 计算子网号个数时要去除全0和全1的情况，即减2。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-数据链路层复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[网桥在数据链路层进行互连。 数据链路层研究的问题在同一个局域网中，分组怎么从一台主机传送到另一台主机上（不经过路由器转发）。 分组是网络层的协议数据单元，数据链路层的协议数据单元是帧。 链路和数据链路链路也叫物理链路。 一个结点到相邻结点的一段物理线路，而没有其他的交换结点。 数据链路也叫逻辑链路。 链路加上实现协议的硬件和软件形成数据链路。 常用方法： 网络适配器，即网卡，既有软件，又包括硬件，其一般包括物理层和数据链路层两层的功能。 链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？所谓链路就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。在进行数据通信时，两个计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。 数据链路则是另外一个概念。这是因为当需要在一条线路上传输数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的方法是使用网络适配器（如拨号上网使用拨号适配器，以及通过以太网上网使用局域网适配器）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。 也可以把链路分为物理链路和逻辑链路。物理链路就是上面说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。 “电路接通了”表明物理连接已经能够传输比特流了。 而“数据链路接通了”是指在物理连通的基础上，建立数据链路，实现封装成帧、透明传输、差错检测等功能。 帧数据链路层的协议数据单元。 数据链路层三个基本问题封装成帧数据链路层在网络层交下来的IP数据报（即分组）前后分别添加首部和尾部形成帧。（OSI的数据链路层把传输的比特流划分成帧。） 只有数据链路层会添加尾部，除物理层外，即应用层、传输层、网络层、数据链路层都会为上边传下来的数据添加首部。 首部和尾部包括许多必要的控制信息（如同步信息、地址信息、差错控制等）， 问题来源为使接收端能从收到的比特流中准确地找到帧的开始和结束位置。 解决问题首部和尾部的一个重要作用就是帧定界（即确定帧的界限）： SOH（Start Of Header），放在帧的最前边，表示帧的开始。 EOT（End Of Transmission），放在帧的最后边，表示帧的结束。 透明传输问题来源由于帧开始和结束的标记使用专门指明的控制字符，所传输的数据中不能出现8比特的组合和用作帧定界的控制字符的比特编码一样，否则会出现帧定界错误。 解决问题 解决方法：字节填充 发送端的数据链路层在数据中控制字符和转义字符的前边插入一个转义字符ESC； 接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符ESC。 简单来说，（要注意：添加和删除ESC是对于数据中的ESC、SOH、EOT来说的） 发送端的数据链路层在数据中的ESC、SOH、EOT前添加ESC， 接收端的数据链路层把数据中ESC、SOH、EOT前的ESC去掉 差错检测问题来源 比特差错 现实的通信链路不是理想的，传输过程中可能出现比特差错（1变成0，或0变成1）。 比特差错并不是传输差错。 为保证数据传输的可靠性，必须进行差错检测。 CRC数据链路层广泛使用了循环冗余校验码CRC的检错技术。 若数据链路层仅仅使用CRC，则只能实现无差错接受、无比特差错的传输，这并不是可靠传输。 ==CRC可参考计组复习笔记，超链接== CRC和FCS不同 帧检验序列FCS，是数据后边的冗余码；而CRC是一种检错方法。 编码方法 数据左移几位（P的位数-1）后模2除以生成多项式P，则得应在数据后添加的余数 检错方法 拿到的数据加冗余码，模2除生成多项式P，求得余数 若余数为0，则无误，接受； 若不为0，则有误，就丢弃。 为什么三个问题必须加以解决封装成帧就是在一段数据的前后分别添加首部和尾部（在首部和尾部里面有许多必要的控制信息），这样就构成了一个帧。接收端在收到物理层上交的比特流，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。首部和尾部的一个重要作用就是帧定界，如果不进行封装成帧，那么数据链路层在收到一些数据时，就无法知道对方传输的数据中哪些是数据，哪些是控制信息，甚至数据中有没有差错也不知道，也无法知道数据传送结束了没有，因此不知道应该在什么时候把收到的数据给上一层。 上层交下来的数据，不管是什么形式的比特组合，都必须能够正确传送。由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何比特组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。数据链路层不应对传送的数据提出限制，即不应当规定某种形式的比特组合不能够传送。如果没有透明传输，就可能会出现帧定界错误。 如果数据链路层没有差错检测，那么当目的主机收到其他主机发送来的数据时，在交给高层后，如果应用程序要求收到的数据必须正确无误，那么目的主机的高层软件可以对收到的数据进行差错检测。如果发现数据中有差错，就可以请求源主机重传这些数据。这样做就可以达到正确接收数据的目的。但这种工作方式有一个很大的缺点，就是一些在传输过程中出现了错误的数据（这些已经是没有用处的数据）还会继续在网络中传送，这样就浪费了网络的资源。 点对点协议PPPPPP协议面向连接。 PPP控制字符：0x7E 主要特点简单 字节填充PPP使用异步传输时，转义符定义为0x7D，使用字节填充 处理情况 填充前 填充后 控制字符 0x7E (0x7D,0x5E) 转义字符 0x7D (0x7D,0x5D) ASCII码控制字符(小于0x20) 0x03 (0x7D,0x23) 零比特填充PPP使用同步传输时 保证信息字段中不会出现连续6个1，方法如下 发送端 扫描信息字段，发现连续5个1，在其后边添1个0 接收端 扫描信息字段，发现连续5个1，则删除其后边的1个0 局域网的数据链路层局域网的协议结构一般不包括网络层。 以太网以太网是典型的局域网，几乎成了局域网的同义词。 为了通信的简便，以太网采取了以下两种措施： 无连接、不可靠 以太网发送的数据都使用曼彻斯特编码 截断二进制指数退避算法以太网使用截断二进制指数退避算法来确定碰撞后重传的时机。 设碰撞次数为$k$，则$k=Min[重传次数，10]$，重传时间为$0$到$2^k-1$个时间片 局域网主要特点 网络为一个单位所拥有 地理范围和站点数目均有限 网络拓扑星形网现在主要用这个， 集线器星型拓扑： 易维护，物理上是星形，逻辑上是总线型 集线器工作在物理层 环形网一个电脑出问题，会影响整个局域网。 总线网所有的主机都连在一根总线上。 广播 一台计算机发送数据，总线上所有计算机都能检测到这个数据 一对一 给每个适配器一个独一无二的MAC地址，在发送数据帧时，在帧的首部写明接收站的地址。 当数据帧中的目的地址与适配器ROM中存放的MAC地址一致时，该适配器才接受这个数据帧，否则丢弃。 CSMA/CD协议载波监听多路访问/碰撞检测，协议的实质是载波监听和碰撞检测。 以太网扩展 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-物理层复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[物理层主要解决的问题进行信号和比特流的转换，实现透明传输比特流，尽量使数据链路层感觉不到传输媒体之间的差异。 物理层的主要任务机械特性接插件的形状、尺寸、引脚数目和排列等规格 电气特性电压范围 功能特性某电平电压的意义 过程特性不同功能的各种可能事件的出现顺序。 协议数据单元物理层上所传数据的单位是比特。 数据通信系统的模型源系统源点又称信源，源站。 产生要传输的数据（比特流）。 发送器对源点生成的比特流进行编码，然后在传输系统中进行传输。 传输系统可以是简单的传输线，也可以是复杂的网络系统。 目的系统接收器接收信号，转换为终点可以处理的信息。 比如解调器，把模拟信号还原为比特流。 终点又称目的站、信宿。 获取接收器传来的比特流。 通信常用术语通信的目的是传送消息。 消息消息是本质。 数据数据是运送消息的实体。 信号信号是数据的电气或电磁表现。 信号的分类根据信号中代表消息的参数的取值方式分类 模拟信号代表消息的参数取值是连续的。 数字信号代表消息的参数取值是离散的。 码元：承载信息的基本信号单位。 有两个要素：码元的取值个数$M$（$M$进制码元）和码元携带的信息量（即码元的位数）$n$。 $n\geq log_2^M$ https://zhidao.baidu.com/question/680218902599074452.html 调制 基带信号 带通信号 频率 低，甚至有直流成分 高 传播距离 短 远 许多信道并不能传输低频分量或直流分量。为解决这个问题，必须对基带信号进行调制。 基带调制作用又称编码。 仅对基带信号的波形进行变换，使其与信道特性相适应。 变换后的信号仍为基带信号。 方法 不归零制 归零制 曼彻斯特编码 差分曼彻斯特编码 载波调制作用使用载波，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号。 经过载波调制后的信号称为带通信号，带通指仅在一段频率范围内能够通过信道。 方法 调幅 调频 调相 信道信道指向某一个方向传送信息的媒体。 一条通信线路往往包含一条发送信道和一条接收信道。 三种通信基本方式从通信的双方信息交换的方式来看 单工通信 半双工通信 全双工通信 通信方向 通信只能有一个方向 双向交替通信 双向同时通信 信道数 一条 两条 两条 信道的极限容量信号在信道上传输会失真。 从概念上讲，限制码元在信道上的传输速率的因素有两个： 信道能够通过的频率范围码间串扰：接收端收到的信号波形失去了码元之间的清晰界限。 奈氏准则：指出在假定的理想条件下，为避免码间串扰，码元的传输速率的上限值。 在任何信道中，码元的传输速率是有上限的，超过上限，就会出现严重的码间串扰问题。 波特：Baud，码元传输速率的单位。1 Baud即每秒传送1个码元。 信噪比信噪比就是信号平均功率$S$和噪声平均功率$N$之比，常记为$S/N$，并用分贝$dB$作为度量单位。 信噪比(dB)=10log_{10}^{S/N}(dB)香农公式指出，信道的极限信息传输速率$C$是： C=W\ log_2^{1+S/N}(bit/s)式中，$W$为信道的带宽，单位为$Hz$。 香农公式表明：信道的带宽或信噪比越大，信道的极限传输速率就越大。 其他因素对于频带宽度、信噪比和码元传输速率已确定的信道，我们可以通过让每一个码元携带更多的信息量提高信息的传输速率。 码元个数不是越多越好。 如果每个码元携带的信息量$n$越大，即码元取值的数量越多，则在接收端进行调解时要正确识别每一个码元就越困难，导致出错率增加。 奈氏准则和香农公式的主要区别 奈氏准则指出了，码元传输速率是受限的，不能任意提高，否则在接收端就无法正确判定码元是1还是0（因为有码元之间的相互干扰）。 奈氏准则是在理想条件下推导出的。在实际条件下，最高码元传输速率要比理想条件下得出的数值还要小些。电信工程技术人员的任务就是要在实际条件下，寻找出较好的传输码元波形，将比特转换为较为合适的传输信号。 需要注意的是，奈氏准则并没有对信息传输速率给出限制。要提高信息传输速率就必须使每一个传输的码元能够代表许多个比特的信息。这就需要很好的编码技术。 香农公式给出了信息传输速率的极限，即对于一定的传输带宽（以赫兹为单位）和一定的信噪比，信息传输速率的上限就确定了。这个极限是不能够突破的。要想提高信息的传输速率，或者必须设法提高传输线路的带宽，或者必须设法提高所传信号的信噪比，此外没有其他任何办法。 香农公式告诉我们，若要得到无限大的信息传输速率，只有两个办法：要么使用无限大的传输带宽，要么使信号的信噪比无限大（即采用没有噪声的传输信道或使用无限大的发送功率）。当然这都是不可能的。 物理层下面的传输媒体物理层的“连接”不一定是使用导线的“连接”，比如无线连接就不是使用导线的“连接”。 导引型传输媒体非导引型传输媒体信道复用技术复用：允许用户使用一个共享信道进行通信，降低成本，提高利用率。 频分复用所有用户在同一时间占用不同的带宽资源。 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 波分复用 就是光的频分复用。 时分复用又称同步时分复用。考过图2-15。 所用用户在不同时间内用同样的频度带宽。 由于计算机数据的突发性质，时分复用时一个用户对已经分配到的子信道的利用率一般是不高的。 统计时分复用 与同步时分复用相比，它按需动态分配时间。 频分复用和时分复用的优缺点 优点 技术比较成熟 缺点 不够灵活 码分复用又称码分多址。 各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。 每个用户可以在同样的时间使用同样的频带进行通信。 码片定义每一个比特用m个比特表示，这m个比特称为码片。 每个用户发送的是码片（代表1）、码片反码（代表0）或不发送。 接收方用想接收的发送方的码片与收到的信号进行规格化內积。 若规格化內积为1，则发送方发送了码片，即1；若为-1，则发送方发送了码片反码，即0。 码片特点內积：同位相乘之和 规格化內积：內积除以位数 正交：內积为0 分配给每个用户的码片必须各不相同，并且相互正交。 某用户码片与其他用户码片（或码片的反码）內积为0。 码片与自身规格化內积为1。 码片与自身反码规格化內积为-1。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-第一章复习]]></title>
    <url>%2F2019%2F06%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Internet如何翻译有两种翻译方式： 因特网国家推荐 互联网现实中大多使用这个词。 互联网的重要特点连通性世界各地的用户都可以交换信息，好像彼此之间直接连通一样。 共享即资源共享，如信息、软件、硬件共享等。 两个认识互联网的角度应用工作原理课本是从这个角度来讲解的，我们从这个角度来学习。 计算机网络的组成定义：计算机网络由若干结点（node）和连接这些结点的链路（link）组成。 结点可以是计算机、集线器、路由器、交换机等。 链路互连网与互联网互连网internet 定义 通用名词，泛指通过路由器将网络连起来形成的网络。 其中网络间的通信协议可以是任意的。 互连不仅是物理上，还要通过软件连接。 互联网Internet 定义 互联网是全球最大的、开放的、由众多网络相互连接而成的特定互连网。 采用TCP/IP协议族作为通信规则。 前身是美国的ARPANET。 三层ISP结构ISP，互联网服务提供者。 互联网现在采用三层ISP结构。 本地ISP地区ISP主干ISPIXP允许两个网络直接相连并交换信息。 互联网的组成边缘部分与网络相连的计算机常称为主机。 定义 连接在互联网上的所有主机。 由用户（个人、公司）控制。 进行通信和资源共享。 主机通信方式 对象 计算机通信的对象是应用层中的进程。 客户/服务器方式即C/S方式。 客户和服务器指通信中所涉及的两个应用进程。 客户/服务器模式描述的是进程之间服务和被服务的关系。 客户是服务请求方，服务器是服务提供方。 客户和服务器都要使用互联网核心部分提供的服务。 客户必须知道服务器程序的地址，服务器不需要知道客户程序的地址。 对等连接方式对等连接（peer to peer），P2P。 定义 两台主机在通信时并不区分谁是客户或服务器。 本质上还是C/S方式。 核心部分 定义 由大量网络和连接这些网络的路由器组成。 由ISP控制。 为边缘部分提供服务。 工作方式核心部分的工作方式就是路由器的工作方式。 存储转发 路由器间不断交换路由信息 三种交换方式 严格来讲，分组交换也是可以面向连接的 现在用的是分组交换 电路交换 并不是真正意义上的交换 主要特点：面向连接 建立连接、通信、释放连接 在通信的全部时间内，通信的两个用户始终占用端到端的通信资源。 优点 静态分配传输带宽，只要建立了连接，网络发生拥塞也不会影响通信质量。 缺点 计算机通信时，数据具有突发性，线路上真正用来传送数据的时间往往不到10%，造成通信线路资源的浪费。 如果通信链路是由多段链路组成的，只要有一段链路出现故障，就不能通信。 分组交换 主要特点：采用存储转发技术 将报文拆分成多个分组，加上头部 通过路由器以分组为单位进行存储转发 在接收端将分组组装成报文 优点 高效 动态分配传输带宽，逐段占用通信链路。 灵活 为每一个分组独立地选择最合适的转发路由。 迅速 不需要建立连接就可以向其他主机发送分组。 可靠 保证可靠性的网络协议、分布式多路由的分组交换网使网络有很好的生存性。 某个结点或者链路出现故障时，分组传送的路由可以自适应地动态改变。 缺点 存储转发时需排队，造成一定时延。当网络拥塞非常严重时，整个网络也可能会瘫痪。 分组的首部造成一定开销。 报文交换 主要特点： 采用存储转发技术，但报文不分组 适用于间歇式轻负载 与分组交换相比： 优点 省去了划分分组的步骤 省去了接收端组装分组的步骤 缺点 灵活性不如分组交换 哪个交换方式最好？不能说哪个方式一定好或坏 若需连续传送大量数据，且其发送时间远大于连接建立时间，则电路交换的传输速率较快。 报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。 由于一个分组的长度远远小于整个报文的长度，因此分组交换比报文交换的时延小；同时也具有更好的灵活性。 计算机网络性能指标速率 也称为数据率（data rate）或比特率（bit rate）。 定义 连接在计算机网络上的主机在数字信道上传输数据的速率。 单位是b/s，kb/s，Mb/s，Gb/s ==信道：一个发送端，一个接收端== 带宽 定义 数字信道所能传输的最高速率。 毫无疑问，带宽单位和速率一样。 吞吐量 定义 单位时间内通过某个网络（或信道、接口）的实际的数据量。 单位是b，Mb等。 时延$总时延=发送时延+传播时延+处理时延+排队时延$ 一般来说，小时延的网络优于大时延的网络 一个低速率、小时延的网络可以优于一个高速率、大时延的网络。 在总时延中，哪一种时延占主导地位，必须具体分析。 发送时延又叫传输时延，发送速率又叫传输速率。 $发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}$ 可见发送时延并非固定不变。 对于高速网络链路，我们提高的仅仅是数据的发送速率，而不是比特在链路上的传播速率。 传播时延$传播时延=\frac{信道长度(m)}{电磁波在信道上的传播速率(m/s)}$ 光纤与铜线相比降低了发送时延，光纤的传播速度反而不如铜线传播速度快。 处理时延主机或路由器在收到分组时要花费一定时间进行处理。 排队时延分组在路由器中可能要排队。 时延带宽积时延带宽积又称为以比特为单位的链路长度。 $时延带宽积=传播时延\times带宽$ 时延带宽积反映传输时线路上数据的多少，即线路上的比特数。 传播时延决定线路的长度 带宽决定每位的长度 往返时间RTT定义：双向交互一次所需的时间。 从发送方发送数据开始，到发送方收到接收方的确认。 ping www.baidu.com 利用率 信道利用率并非越高越好 信道或网络的利用率过高会产生非常大的时延。 令$D_0$表示网络空闲时的时延，$D$表示网络当前的时延，$U$为网络利用率， 则$D=\frac{D_0}{1-U}$。 信道利用率$信道利用率=\frac{有数据通过时间}{总时间}$ 网络利用率定义：信道利用率加权平均值 分层分层思想 相互通信的两个计算机系统必须高度协调，而这种协调是十分复杂的。 分层可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。 三种分层方法OSI是法律上的国际标准，TCP/IP是事实上的国际标准。 七层协议：OSI 概念清楚，理论较为完整。 但既复杂又不实用。 四层协议：TCP/IP 简洁，得到广泛应用。 实质内容只有上三层，网络接口层并没有什么具体内容。 五层协议 综合七层协议和四层协议的优点：既简洁又能将概念阐述清楚。 好处5个 各层间是独立的 每一层只实现一种相对独立的功能，上层仅知道下层的接口，而不需知道其如何实现。 灵活性好 只要层间接口关系保持不变，可以对各层进行修改。 结构上可分割开 各层都可以采用最合适的技术实现 易于实现和维护 整个系统被分解为若干个相对独立的子系统，每个子系统都易于实现和维护 能促进标准化工作 每一层的功能及其所提供的服务都已有了精确的说明 坏处分层应使每一层的功能非常明确，所以层次的划分并不容易。 层数太少，会使每一层的协议太复杂； 层数太多，会使各层在功能上有重叠，造成额外开销。 对等层在OSI参考模型中，位于同一水平行（同一层）上的系统构成了OSI的对等层。 协议定义：在ISO/OSI参考模型中，同层对等实体间信息交换时必须遵守的规则。 每层都有协议，有的层只能有一个协议，有的层可以有多个协议。 网络协议主要由以下三个要素构成： 语法数据与控制信息的结构和格式 语义需要发出何种控制信息，完成何种动作以及做出何种响应 同步事件实现顺序的详细说明 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述]]></title>
    <url>%2F2019%2F06%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[之前看韩利辉计网视频的笔记。 网络局域网覆盖范围小 自己花钱买设备 带宽固定 自己维护 比如学院的局域网： 机房的汇聚层交换机连接各教室的交换机，教室的接入层交换机连接各电脑。 两两之间的网线不超过100米，10M 100M 1000M 接入层交换机带宽为百兆，每个口都是百兆。汇聚层交换机带宽要比接入层交换机大。 规范的局域网应该是分层的 广域网超过100米，比如电话线拨号上网，带宽不固定，花钱买带宽、维护等服务 Internet由众多ISP组成，ISP是Internet Service Provider，因特网服务提供商。 各提供商都有自己的机房，对网民提供Internet连接。 各提供商之间最多有一根线相连，所以我用移动的网访问电信的服务器可能会很慢。 有的网站会在各运营商的机房都买一个服务器，或者双线机房（机房里有两种运营商）。 IP和MAC计算机有一个IP地址。 网段。 子网掩码，告诉计算机哪儿是网络部分，哪儿是主机部分。 路由器作用：负责在不同网段转发数据 路由器的端口也有MAC地址 路由器的端口相当于计算机的一个网卡，也有地址 网关：告诉计算机去哪个网段，==指向路由器==。 网卡：MAC地址（物理地址，唯一），出厂已经固定在网卡里，48位二进制。 MAC和IP分别是物理和逻辑上的概念 计算机上发数据包给DNS服务器（计算机配的有），DNS将域名解析成IP，返给计算机 数据包数据、源IP、目标IP 就像一封信 计算机数据包最大1500字节。 数据一次传不完的话，数据帧是有编号的。 数据帧数据包加上源MAC、目标MAC，就是数据帧。 想把数据包传给目标IP，需要路由器，用MAC找到路由器。 然后路由器根据目标IP更新源MAC和目标MAC，最短路径。 数据帧传给交换机，交换机传给路由器，路由器给路由器，最后给交换机，交换机给计算机。 客户机：给我数据 服务器：好的，给你 客户机：已接收，给我下一个数据 服务器：好的，给你 服务器不知道客户机的MAC地址，可以知道客户机的IP。 为什么不能只用MAC标识电脑？ 如果全球计算机都是用交换机连接的，不需要路由器，就可以只用MAC标识电脑。但这不可能。 网卡有缓存，发送缓存，接收缓存。 OSI参考模型7层，国际标准化组织分析计算机通讯得出的。 好处： 不同厂商生产设备可以一起用 各层较为独立，每一个模块有变化，不会影响另一个模块。这并不代表各层之间没有关系。 k层为k+1层提供服务。 分层的思想是使用网络的指导原则。 应用层所有能产生网络流量的程序，记事本就不是，QQ就是。 表示层在传输之前进行的东西。 比如在切割成数据包传输之前是否进行压缩、加密处理、编码 会话层session，规定哪个服务器和客户机哪个窗口交互。 cmd中输入netstat -n 可以查看会话。 只要和其他计算机有数据传输，就会建立会话。我们就可以查到它。 通过查看会话 可以查木马。木马和病毒不一样。 输入netstat -nb可以会话是谁建立的。 传输层实现可靠传输、流量控制、不可靠传输。 可靠传输：超时重传 流量控制：客户机给服务器一个数据包说慢点 不可靠传输：比如向DNS通过域名查IP，双方一个数据包就可以解决问题，这种通讯不需要建立会话，不需要给数据包编号。就不用超时重传，再来一次就好了。 网络层选择最佳路径、规划IP地址。 人工指定路径：通过静态路由 数据链路层定义帧的开始和结束、透明传输、差错校验。 用特殊位表示开始和结束，看到开始标志就接收 看到结束标志就结束 启动密码子 终止密码子 透明传输：一部分数据和结束位一样，会在数据那里插入一个特殊的位，表明这不是真正的结束。接收端接收以后再把插入的位去掉。 差错检验：查出错误，但不会纠正错误，纠正是传输层做的 物理层定义网络设备接口标准、电气标准、如何在物理链路上传输得更快 接口标准：不同公司生产的网线、网卡都能使用 电气标准：比如用几伏电压代表1。 OSI和网络排错应该从最底层开始查找。 物理层查看连接状态、查看发送和接受到的数据包大小。 数据链路层MAC地址冲突、ADSL欠费、网速没办法协商、计算机连接到错误的VLAN 网络层配置了错误的IP地址、子网掩码、网关 路由器上没有到达目标网络的路由 应用层应用层在这儿指网络层之上的 应用程序配置错误 OSI和网络安全物理层交换机不用的口 把网线拔掉 数据链路层ADSL账号密码、无线AP、VLAN、交换机端口绑定MAC地址 网络层在路由器上使用ACL控制数据包流量、Windows高级防火墙 应用层应用层在这儿指网络层之上的。 开发的应用程序没漏洞 SQL注入 OSI和TCP/IP协议 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相对论基础]]></title>
    <url>%2F2019%2F06%2F22%2F%E7%9B%B8%E5%AF%B9%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[狭义相对论两条基本原理狭义相对论基于惯性参考系 相对性原理物理定律在一切惯性参考系中都具有相同的数学表达形式，也就是所有惯性系对于描述物理现象都是等价的。 狭义相对论原理是伽利略力学相对性原理的推广 光的传播不需要介质 光速不变原理在彼此相对做匀速直线运动的任一惯性参考系中，所测得的光在真空中的传播速度都是相等的。 真空中的光速是个恒量 物体的速度不能超过真空中的光速 相对论速度变换公式 v=\frac{v'+u}{1+\frac{v'u}{c^2}} $v’$：$K’$系中的速度 $v$：$K$系中的速度 $u$：两坐标系的速度差 $\beta=\frac{u}{c}$ 狭义相对论的时空观“同时”的相对性在某个惯性系中同时发生的两个事件，在另一相对它运动的惯性系中，并不一定同时发生，这一结论叫做同时的相对性。 t_2'-t_1'=\frac{\frac{u}{c^2}(x_1-x_2)}{\sqrt{1-\beta^2}}只有当两个事件发生在同一地点时，“同时”才有绝对意义。 时间延缓又叫时间膨胀或时钟变慢 t=\frac{t_0}{\sqrt{1-\beta^2}} $t_0$：固有时，相对于过程发生的地点为静止的参考系中测得的时间间隔。 $t$：运动时，大于固有时。 长度收缩 l=l_0\sqrt{1-\beta^2} $l_0$：固有长度，观察者相对于物体静止时测得的物体长度。 $l$：运动长度，小于固有长度 相对性和绝对性在相对论时空中，运动的描述、时空的量度都是相对的，但因果关系是绝对的。 狭义相对论动力学基础质速关系式 m=\frac{m_0}{\sqrt{1-(\frac{v}{c})^2}} $m_0$：静质量 $m$：动质量 光子的静质量为$0$，速度为$c$ 质速关系式反映了物体与运动的不可分割性 质能关系式 E_0=m_0c^2 E=mc^2 E_k=E-E_0 $E_0$：静能 $E$：运动时的总能量（静能和动能之和） $E_k$：相对论动能 动量能量关系式 E^2=c^2p^2+{E_0}^2光速 3\times10^8\ m/s 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-标志位设置]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E6%A0%87%E5%BF%97%E4%BD%8D%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[所有标志位MOV、PUSH、POP、NOT、条件转移指令、非条件转移指令、类型转换指令不影响标志位 CF INC、DEC不影响CF ADD 若最高有效位向高位有进位，CF=1；否则CF=0 SUB 作为无符号数运算时，若减数大于被减数，有借位，CF=1；否则CF=0 移位指令 根据各指令移位特性，设置CF NEG 操作数为0，则CF=0；否则CF=1 NOT以外的逻辑运算指令 使CF=0 OF ADD 若两数同号，而结果与操作数符号相反，则OF=1；否则OF=0 SUB 若两数符号相反，结果与减数符号相同，则OF=1；否则OF=0 NOT以外的逻辑运算指令 使OF=0 SF 在指令影响SF的情况下，结果（二进制）最高位为0，则SF=0；否则SF=1 移位指令可影响SF ZF 移位指令可影响ZF 结果是0，ZF=1；否则，ZF=0 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-中断]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[数据传送方式程序控制方式中断方式DMA方式中断传送方式避免因反复查询外部设备的状态而浪费时间，从而提高CPU的效率。 非屏蔽中断非屏蔽中断不受中断允许标志IF的屏蔽，系统中只能有一个非屏蔽中断，其中断类型号为2。 中断过程 PUSH (FLAGS) IF&lt;-0 TF&lt;-0 AC&lt;-0 PUSH (CS) PUSH (IP) (IP)&lt;-(N*4) (CS)&lt;-(N*4+2) 中断指令INT，不给中断号的话，默认是3号中断 STI，设置中断允许位（IF=1） CLI，清除中断允许位（IF=0） 中断向量表各类型中断处理程序的入口地址表，其存放在内存低位处，每项占用4个字节，低位是(IP)，高位是(CS)。 每类中断向量的偏移地址可由中断类型号N乘以4计算出来。 子程序与中断的区别两者实现机制不同 中断程序是固定的(如果操作系统允许，程序员可以修改)； 而子程序是程序员动态编写的。 call func，根据func直接找到子程序入口，根据需求修改(IP)和(CS)； 而int 21h需要计算地址，通过中断向量表找到中断处理程序入口地址。 BIOS、DOS中断BIOS中断和DOS中断是两种特殊的中断。 BIOS比DOS更靠近硬件。 在某些情况下，既可选择DOS中断又可选择BIOS中断实现相应功能；某些情况下，必须使用BIOS才能实现相应的功能。 基本步骤 将调用参数装入指定寄存器中 如需功能号，将其装入AH 如需子功能号，将其装入AL 按中断号调用DOS或BIOS中断，INT 21H DOS常用功能1号功能 功能号 (AH)=1 功能 从键盘输入一个字符并回显在屏幕上 返回参数 (AL)=字符 2号功能 功能号 (AH)=2 功能 显示一个字符（检验Ctrl_Break），光标随字符移动 调用参数 (DL)=字符 9号功能 功能号 (AH)=9 功能 显示字符串，光标跟随字符移动 调用参数 (DS):(DX)为串地址，串必须以$结束 0A号功能 功能号 (AH)=0AH 功能 输入字符到缓冲区，缓冲区第一个字节保存最大字符数，第二个字节保存实际输入的字符数 返回参数 (DS):(DX)为缓冲区首址 常用ASCII码 字符 十六进制ASCII码 空格 20H 0 30H A 41H a 61H 换行 0AH 回车(归位) 0DH 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-汇编语言程序格式]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[上机过程 编辑汇编源程序：test.asm 编译：masm test 链接：link test 调试：debug test.exe 运行：test 汇编源程序组成 指令 伪操作 宏指令 段定义、assume、字符串定义123456789101112131415161718192021data segment buffer dw &quot;HELLO&quot; buffer db &quot;HELLO&quot;data endscode segmentmain proc farassume ds:data,cs:code push ds mov ax,0 push ax mov ax,data mov ds,ax ... retmain endpcode endsend main LABEL、DUP同一块内存可以具有不同的类型属性。 12BYTE_ARRAY LABEL BYTEWORD_ARRAY DW 50 DUP(?) EQU、=表达式赋值伪操作，给表达式赋一个名字，这个名字不占用内存，不允许重复定义 =也是赋值，但允许重复定义。 地址计数器$当前正在汇编指令的偏移地址 ORG设置当前地址计数器的值 数值回送操作符TYPE以字节数表示的类型 表达式是变量时 DB：1 DW：2 DD：4 DF：6 表达式是标号时 NEAR：-1 FAR：-2 表达式为常数时 0 LENGTH使用DUP时，回送该变量的单元数 其他情况，回送1 SIZE回送分配给该变量的字节数，SIZE=LENGTH*TYPE OFFSET回送变量或标号的偏移地址 SEG回送变量或标号的段地址 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-宏汇编]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%8F%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[与子程序比较 优点 缺点 子程序 模块化，省内存，程序只占用一份存储空间 保存及恢复寄存器、参数传递增加额外开销 宏汇编 参数传送简单 每调用一次就展开一次，内存消耗大 宏定义123macroname macro [dummy parameter list] ... endm &amp;宏展开时，合并前后两个符号形成一个符号 123LEAP MACRO COND,LAB J&amp;COND LAB ENDM %把跟在%之后的表达式的值转换成当前基数下的数。 LOCAL伪操作宏定义体内使用标号需要使用LOCAL伪操作，其必须是MACRO伪操作后的第一个语句，两者之间不允许有注释和分号标志。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-80x86指令系统]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-80x86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[数据传送指令通用数据传输指令MOV 格式 mov dst,src 执行操作 (dst)&lt;-(src) 注意 DST、SRC不能同时为段寄存器 立即数不能送段寄存器 DST不能是CS DST、SRC不能同时是存储器寻址 不影响标志位 相关指令 movsx 带符号扩展传送 movzx 带零扩展传送 PUSH 格式 push src 执行操作（16位指令） (sp)&lt;-(sp)-2，说明栈顶地址低 ((sp+1),(sp))&lt;-(src) 注意 堆栈操作必须以字为单位 push和pop不能用立即寻址方式 pop的dst不能是CS SP在任何时候都指向栈顶 push和pop不影响标志位 相关指令 pusha 16位通用寄存器依次进栈 popa 16位通用寄存器依次出栈 POP 格式 pop dst 执行操作（16位指令） (dst)&lt;-((sp+1),(sp)) (sp)&lt;-(sp)+2 累加器专用传送指令该组指令仅限于使用累加器EAX，AX或AL传送信息。 IN输入，即I/O传给CPU信息。 长格式 in al,port in ax,port 执行操作 (al)&lt;-(port)，字节 (ax)&lt;-(port)，字 短格式 in al,dx，字节 in ax,dx，字 执行操作 (al)&lt;-((dx))，字节 (ax)&lt;-((dx))，字 OUT输出，即CPU传给IO信息。 长格式 out port,al，字节 out port,ax，字 执行操作 (port)&lt;-(al)，字节 (port+1,port)&lt;-(ax)，字 短格式 out dx,al，字节 out dx,ax，字 执行操作 ((dx))&lt;-(al)，字节 ((dx)+1,(dx))&lt;-(ax)，字 s 当$端口号\geq256$时，只能使用短格式。 IN和OUT指令不影响标志位。 地址传送指令LEA源操作数的偏移地址送寄存器 格式 lea reg,src 执行操作 (reg)&lt;-src 注意 dst不能使用段寄存器 源操作数可以是除立即数和寄存器以外的任一种存储器寻址方式。 不影响标志位 标志寄存器传送指令LAHFFLAGS低字节送AH，load AH with FLAGS 格式 LAHF 执行操作 (AH)&lt;-(FLAGS的低字节) SAHFAH送FLAGS低字节，store AH into FLAGS 格式 SAHF 执行操作 (FLAGS的低字节)&lt;-(AH) PUSHF标志进栈指令 格式 PUSHF 执行操作 (SP)&lt;-(SP)-2 ((SP)+1,(SP))&lt;-(FLAGS) POPF标志出栈指令 格式 POPF 执行操作 (FLAGS)&lt;-((SP)+1,(SP)) (SP)&lt;-(SP)+2 类型转换指令不影响标志位 CBW字节转换为字，AL的内容符号扩展到AH，形成AX中的字 CWD字转换为双字，同理，AX扩展为DX:AX CDQ双字转换为4字，同理，EAX扩展为EDX:EAX 算术指令加法指令ADD加法 格式 ADD DST,SRC 执行操作 (DST)&lt;-(SRC)+(DST) ADC带进位加法 格式 ADC DST,SRC 执行操作 (DST)&lt;-(DST)+(SRC)+CF INC加1 格式 INC OPR 执行操作 (OPR)&lt;-(OPR)+1 注意 以上三条指令除INC不影响CF外，它们都影响条件标志位。 XADD交换并相加 格式 XADD DST,SRC 执行操作 TEMP&lt;-(SRC)+(DST) (SRC)&lt;-DST (DST)&lt;-TEMP 减法指令除DEC不影响CF标志外，它们都影响条件标志位。 SUB减法 格式 SUB DST,SRC 执行操作 (DST)&lt;-(DST)-(SRC) SBB带借位减法 格式 SBB DST,SRC 执行操作 (DST)&lt;-(DST)-(SRC)-CF DEC减1 格式 DEC OPR 执行操作 (OPR)&lt;-(OPR)-1 NEG求补指令 格式 NEG OPR 执行操作 (OPR)&lt;-(OPR)，操作数按位求反后+1 CMP 格式 CMP OPR1,OPR2 执行操作 (OPR1)-(OPR2) 乘法指令乘法指令对CF和OF以外的条件码无定义。 AX、DX,AX为隐含的乘数寄存器。 SRC不能是立即数。 MUL无符号数乘法 格式 MUL SRC 执行指令 (AX)&lt;-(AL)*(SRC) (DX,AX)&lt;-(AX)*(SRC) IMUL带符号数乘法 格式 IMUL SRC 执行操作 与MUL指令相同，但必须是带符号数，而MUL是无符号数 除法指令除法指令对所有条件码均无定义。 SRC不能是立即数。 目的操作数必须存放在AX或DX,AX中。 DIV无符号数除法指令 格式 DIV SRC 执行操作 (AL)&lt;-(AX)/(SRC)的商、(AH)&lt;-(AX)/(SRC)的余数 (AX)&lt;-(DX,AX)/(SRC)的商、(DX)&lt;-(DX,AX)/(SRC)的余数 IDIV带符号数除法指令 格式 IDIV SRC 执行操作 与DIV指令相同，但必须是带符号数 逻辑指令逻辑运算指令除了NOT外，其他4条逻辑运算指令使CF、OF为0，对AF无定义，对SF、ZF、PF根据运算结果设置。 AND逻辑与 格式 AND DST,SRC 执行操作 (DST)&lt;-(DST)∧(SRC) OR 格式 OR DST,SRC 执行操作 (DST)&lt;-(DST)∨(SRC) NOT按位取反 格式 NOT OPR 执行操作 略 注意 不允许使用立即数，不影响标志位 XOR异或 格式 XOR DST,SRC 执行操作 略 TEST两个操作数进行逻辑与，不保存结果 格式 TEST OPR1,OPR2 执行操作 (OPR1)∧(OPR2) 移位指令当CNT为1时，OF位才有效，否则无定义 指令格式：指令 OPR,CNT 非循环移位指令SA：Shift Arithmetic SH：Shift 根据移位后的结果设置SF、ZF和PF位，AF则无定义。 算术移位指令适用于带符号数运算，逻辑移位指令适用于无符号数运算。 SHL 逻辑左移指令，低位补0，CF存放移出去的最后一位 SAL 算术左移指令，和SHL相同 SHR 逻辑右移指令，高位补0，CF存放移出去的最后一位 SAR 算术右移指令，高位补符号位，CF存放移出去的最后一位 循环移位指令RC：Rotate Carry RO：Rotate 不影响除CF和OF外的其他条件标志。 ROL 循环左移指令，移出去的最后一位存入CF ROR 循环右移指令，移出去的最后一位存入CF RCL 带进位循环左移指令，CF参与循环移位 RCR 带进位循环右移指令，CF参与循环移位 串处理指令步骤 设置ES、DS 设置DI、SI 串长度存入CX 建立方向标志 CLD：正向，DF=0，Clear Direction STD：反向，DF=1，Set Direction 串处理，REP MOVSB REP格式：REP MOVS 如果CX为0，则结束；否则(CX)&lt;(CX)-1，执行串指令。LOOP也是先判断CX是不是0。 MOVS与REP、REPZ、REPNZ这三个前缀配合使用。 格式：MOVS DST,SRC 不影响条件码 控制转移指令无条件转移指令不影响标志位 条件转移指令不影响标志位 JL 测试条件 SF异或OF=1 JGE 测试条件 SF异或OF=0 条件设置指令STD CLD 等等 循环指令不影响条件码。 执行操作： (CX)&lt;-(CX)-1 检查是否满足测试条件 LOOP当计数器不为0时循环指令 格式 LOOP OPR 测试条件 (CX)!=0 LOOPZ当计数器不为0且结果为0（即ZF=1）时循环指令 格式 LOOPZ OPR 测试条件 ZF=1且(CX)!=0 LOOPNZ当计数器不为0且结果不为0（即ZF=0）时循环指令 格式 LOOPNZ OPR 测试条件 ZF=0且(CX)!=0 子程序均不影响条件码。 写IP和CS都是先写IP，再写CS。中断也是这样。所以压栈也应先压CS，再压IP。 CALL格式：CALL DST 段内：只需要PUSH(IP) 段间：先PUSH (CS)再PUSH (IP) 直接：偏移量D或DST指定的段地址和偏移地址 间接：根据(EA)去取(IP)和(CS) 段内直接近调用 执行操作 PUSH (IP) (IP)&lt;-(IP)+D，D为位移量。 段内间接近调用 由指定的寄存器或存储单元的内容给出转向地址 执行操作 PUSH (IP) (IP)&lt;-(EA) 段间直接远调用 执行操作 PUSH (CS) PUSH (IP) (IP)&lt;-DST指定的偏移地址 (CS)&lt;-DST指定的段地址 段间间接远调用 执行操作 PUSH (CS) PUSH (IP) (IP)&lt;-(EA) (CS)&lt;-(EA+2) RET段内：只需要(IP)&lt;-POP() 段间：先(IP)&lt;-POP()再(CS)&lt;-POP() 带立即数：最后(SP)&lt;-(SP)+D，D为位移量 段内近返回 格式 RET 执行操作 (IP)&lt;-POP() 段内带立即数近返回 格式 RET EXP 执行操作 (IP)&lt;-POP() (SP)&lt;-(SP)+D，D为位移量 段间远返回 格式 RET 执行操作 (IP)&lt;-POP() (CS)&lt;-POP() 段间带立即数返回 格式 RET EXP 执行操作 (IP)&lt;-POP() (CS)&lt;-POP() (SP)&lt;-(SP)+D，D为位移量 中断INT 格式 INT TYPE INT 执行操作 PUSH (FLAGS) IF&lt;-0 TF&lt;-0 AC&lt;-0 PUSH (CS) PUSH (IP) (IP)&lt;-(TYPE*4) (CS)&lt;-(TYPE*4+2) IRET 格式 IRET 执行操作 (IP)&lt;-POP() (CS)&lt;-POP() (FLAGS)&lt;-POP() 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-80x86寻址方式]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-80x86%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[物理地址 存储器以字节为单位存储信息。 每一个字节单元有一个惟一的存储器地址，称为物理地址。 一个字存入存储器要占有相继的两个字节，存放时低位字节存入低地址，高位字节存入高地址。 字单元的地址采用它的低地址表示。 画内存时下边是高地址，上边是高地址。栈底是高地址。 每个存储单元有惟一的物理地址，但它却可由不同的段地址和不同的偏移地址组成。 逻辑地址=段地址：偏移地址 物理地址=段地址左移四位+偏移地址与数据有关的寻址方式立即寻址方式操作数直接存放在指令中，这样的操作数称为立即数。 操作数=立即数 mov ax,3 注意： 立即寻址方式只能用于源操作数字段。 源操作数长度应与目的操作数长度一致。 寄存器寻址方式操作数存放在寄存器中，指令指定寄存器号。 mov ax,bx 操作数=指定寄存器中的内容 以上两种寻址方式都不涉及存储器。 以下各种寻址方式的操作数都存放在存储区中。 在80x86中，把操作数的偏移地址称为有效地址，EA(Effective Address)。 以下各种寻址方式通过不同途径求得操作数的有效地址，进而获得操作数。 有效地址=基址+变址\times比例因子+位移量有效地址可以有以下四种成分组成： 位移量 （displacement），是存放在指令中的数字，但它不是立即数，而是一个地址。 基址 （base），是存放在基址寄存器（BP、BX）中的内容，通常用来指向数据段中数组或字符串的首地址。 变址 （index），是存放在变址寄存器（SI、DI）中的内容，通常用来访问数组中的某个元素或字符串中的某个字符。 比例因子 （scale factor），其值可为1,2,4,8。（386及后继机型才有比例因子） &lt;center&gt;表1 16位寻址时有效地址三种成分的组成&lt;/center&gt; 成分 16位寻址 位移量 0,8,16位 基址寄存器 BX,BP 变址寄存器 SI,DI 表2 默认段选择规则 访存类型 所用段及段寄存器 缺省规则 指令 代码段 CS 用于取指令 堆栈 堆栈段 SS 进出栈，ESP、BP或ESP作为基址寄存器 局部数据 数据段 DS 除堆栈和串指令的目的串之外 目的串 附加数据段 ES 串处理指令的目的串 禁止使用段跨越前缀的三种情况： 串处理指令的目的串必须使用ES段 PUSH和POP指令的源必须使用SS段 指令必须存放在CS段 直接寻址方式 有效地址=位移量 mov ax,[0] 位移量可以用符号地址（变量）表示。 mov ax,table mov ax,[table] 默认段寄存器为DS。 该寻址方式适用于处理单个变量。 寄存器间接寻址方式 有效地址=基址寄存器或变址寄存器的内容 mov ax,[bp] mov ax,[bx] 有效地址就在某个寄存器（BX,BP,SI,DI）中。（不允许使用AX,CX,DX） BP的默认段寄存器为SS，其他三个寄存器的默认段为DS。 寄存器相对寻址方式又称直接变址寻址方式。 有效地址=一个基址寄存器或变址寄存器的内容+位移量默认段情况与寄存器间接寻址方式相同。 mov ax,count[si] mov ax,[count+si] 基址变址寻址方式 有效地址=一个基址寄存器的内容+一个变址寄存器的内容默认段情况参看表1和表2。 mov ax,[bx][di] mov ax,[bp][si] mov ax,[bx+di] 相对基址变址寻址方式 有效地址=一个基址寄存器的内容+一个变址寄存器的内容+位移量 mov ax,mask[bx][si] 与转移地址有关的寻址方式这种寻址方式用来确定转移指令与CALL指令的转向地址。 段内直接寻址有效地址=(IP)+位移量 平常用的jmp next等，都是这种寻址方式。 近转移： 位移量大小为16bit，如jmp near ptr next。 短转移： 位移量为8bit，如jmp short next，看看其他与转移地址有关的寻址方式会发现只有short没有ptr。 段内间接寻址有效地址=寄存器或存储单元内容。 该内容可以用除立即寻址方式以外的与数据有关的所有寻址方式。 jmp bx jmp word ptr[bp+table] word ptr说明是一个字，所以是段内转移。 段间直接寻址指令中直接提供了转向段地址和偏移地址。 jmp far ptr next 段间间接寻址取存储器中的两个相继字取代IP和CS中的原始内容，以达到段间转移的目的。 存储单元地址除立即数方式和寄存器方式外均可。 jmp dowrd ptr[table+bx]。 dword说明是双字，所以是段间转移。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编基础（二）]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[寒假看B站小甲鱼视频的笔记二 CPU概述一个典型的CPU由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连。 内部总线和外部总线内部总线实现CPU内部各个器件之间的联系。 外部总线实现CPU和主板上其他器件的联系。 寄存器概述8086CPU有14个寄存器，其中有8个通用寄存器。 通用寄存器8086CPU有14个寄存器，都是16位的，每个寄存器可以存放两个字节，即一个字。 什么是通用寄存器AX、BX、CX、DX通常用来存放一般性数据，称为通用寄存器。 8086上一代CPU中的寄存器都是8位的，所以为保证兼容性，这四个寄存器都可以分为两个独立的8位寄存器使用。 AX可以分为AH和AL，分别是高位和低位。其他三个通用寄存器同理。 如何兼容：AH都为0，单独拿个AL来用。 ==兼容应该是指编写的在8位寄存器上运行的汇编代码可以在16位寄存器上运行吧？== 通用寄存器的结构以AX为例 16位：从低地址到高地址分别是0-15。 16位数据在寄存器中的存放情况 数据 二进制表示 在寄存器AX中的存储 18 10010 0000000000010010 20000 100111000100000 0100111000100000 一个16位寄存器所能存储的数据的最大值：2^16-1 字在寄存器中的存储一个字是两个字节。 字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。 几条汇编指令汇编指令不区分大小写！ 汇编指令 高级语言描述 mov ax,18 ax=18 add ax,bx ax=ax+bx 在进行数据传送或运算时，要注意指令的两个操作对象的位数应该是一致的。 如果加法结果超出最大值，会存储低位，但多出来的位也没有扔掉。 AL也遵循上边的规则，多出来的位不会在AH里。 物理地址所有的内存单元构成的存储空间是一个一维的线性空间。 CPU访问内存单元时要给出内存单元的地址。 这个唯一的地址就是物理地址。 16位结构的CPU特征运算器一次最多可以处理16位的数据。寄存器的最大宽度为16位寄存器和运算器之间的通路是16位的8086地址加法器工作原理物理地址=段地址*16+偏移地址 段地址*16 二进制表示的话 ：段地址左移四位 十六进制表示的话 段地址左移一位 一个数的X进制左移n位，相当于乘以$X^n$。 段的概念看P9吧，没看呢 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编基础（一）]]></title>
    <url>%2F2019%2F06%2F22%2F%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[寒假看B站小甲鱼视频的笔记一 前言汇编语言特点机器语言以外最底层的语言所有语言中效率最高学习目标了解CPU、内存和其他硬件如何配合用计算机的思维操作计算机。研究重点：计算机思维如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作，重在思维。 机器语言机器语言是机器指令的集合机器语言是机器指令的集合。 机器指令是01串机器指令是计算机（CPU）唯一懂的指令，由0和1组成。 指令的三种表示方法机器指令01010000 汇编语言PUSH AX 电平脉冲按次序的8个脉冲 汇编语言的产生汇编指令和机器指令的差别在于指令的表示方法汇编指令和机器指令的差别在于指令的表示方法。 汇编语言是符号语言，和机器语言之间的对应关系基本上是一一对应的。 一条机器语言的指令对应一条汇编语言的指令。 ollydbg 汇编语言作用过程汇编指令，经过编译器处理（类似于替换作用，不完全是替换），变成机器码，交给计算机。 汇编语言的组成汇编语言的核心是汇编指令，它决定了汇编语言的特性。 伪指令和其他符号可以归为一类。 汇编指令机器指令的助记符。 伪指令由编译器执行。 其他符号由编译器识别。 存储器CPU的作用：控制整个计算机并进行运算CPU是计算机的核心部件，它控制整个计算机的运作并进行运算。 CPU工作的信息要求：指令+数据要想让一个CPU工作，就必须向它提供指令和数据。 提供指令提供数据CPU对存储器进行读写的信息要求CPU要进行数据的读写，必须和外部器件（标准说法是芯片）进行三类信息的交互： 地址信息存储单元的序号（地址）。 控制信息器件的选择，读或写命令。 数据信息读或写的数据。 存储器的分类按读写属性分类：RAM和ROM随机存储器RAM只读存储器ROMRAM和ROM的区别断电后，RAM中的数据将会遗失，而ROM中的数据不会。 按功能和连接分类：随机存储器RAM装有BIOS的ROM接口卡上的RAMBIOSBIOS是基本IO系统Basic Input/Output System，基本输入输出系统。 BIOS是由主板和各类接口卡（显卡、网卡等）厂商提供的软件系统。 主板和接口卡的知识在后边。 BIOS在主板和某些接口卡的ROM中不止主板才有BIOS，在主板和某些接口卡上插有存储相应BIOS的ROM。 BIOS的作用可以通过BIOS利用对应硬件设备进行最基本的输入输出。 开机时看到的界面就是BIOS在发生作用，它在检测CPU、内存、硬盘、键盘等等有没有插好。 如果病毒进入BIOS，杀毒软件也杀不掉的。 内部存储器内部存储器是内存，一个大的RAM平常所说的内存条、内存就是内部存储器，一个大的RAM。 内部存储器的作用PC机中内存的作用仅次于CPU，离开内存，再好的CPU也无法工作。 磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用。 显卡、网卡、BIOS等都是有它的（存储器）内存的。 CPU和内存读写很快，内存和磁盘读写的速度比较慢。 存储器存储的内容及其作用存储器存储了指令和数据。 指令指令告诉CPU怎么操作。 数据数据告诉CPU什么操作什么。 指令和数据的关系 指令和数据是应用上的概念。 在内存或磁盘中，指令和数据没有任何区别，都是二进制信息。 根据程序员如何应用，CPU处理的二进制信息 可以是汇编代码（指令），也可以是数据，如下： 1000100111011000 89D8H 数据，末尾的H表示Hex，十六进制。B表示二进制，十进制没有后缀。 MOV AX,BX 程序，将寄存器BX的内容粘贴到寄存器AX中。 寄存器寄存器是CPU中可以存储数据的器件，一个CPU中有多个寄存器。 寄存器是一种比内存和二级缓存更低一层，更接近CPU的存储器。 存储单元存储单元是存储器的一个个部分存储器被划分为若干个存储单元。 每个存储单元存储一个字节每个存储单元存储一个字节。 1字节（Byte）= 8位（bit） 1B=8b 存储单元从0开始编号存储单元从0开始顺序编号。计算机都从0开始计数。 例如： 一个存储器有128个存储单元。编号0-127。 显卡里面有个内存，叫显存，数据存在显存里面，显卡里的GPU把显存中的数据映射到屏幕上。GPU的速度比CPU快多了。3D游戏对于显卡的要求是很高的。 总线计算机传输、处理的信息都是电信号，电信号要用导线传送。 计算机中专门有连接CPU和其他芯片的导线，称作总线。 总线分类在物理层次上，总线是一根根导线的集合。 逻辑上的分类： 地址总线CPU是通过地址总线来指定存储器单元的。所以地址总线能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。 一个CPU有$N$根地址总线，则其地址总线宽度为$N$，它可以寻找$2^N$个内存单元。 寻址能力寻址能力为8KB，即能寻找到8*1024个字节，总线宽度为13。 数据总线有几根数据总线就最多可以传几位。 控制总线控制总线是一些不同控制线的集合。CPU通过控制总线控制外部器件。 有多少根控制总线就意味着CPU提供了对外部器件的多少种控制。 内存不只是内存条，还有显存，网卡内存等，它们线性排列。 主板每个PC机，都有一个主板。 主板上有核心器件（CPU、内存）和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。 接口卡计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制。 CPU对外部设备不能直接控制，如显示器、音箱、打印机等。 直接控制这些设备进行工作的是插在扩展插槽上的接口卡。 内存地址空间不同的计算机系统的内存地址空间分配情况是不同的。 各类存储器逻辑相同点各类存储器在物理上是独立的器件： 但它们在逻辑上有两点相同： 都和CPU总线相连CPU对它们进行读或写的时候都通过控制总线发出内存读写命令什么是内存地址空间一个CPU的地址总线宽度为10，那个可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。 将各类存储器在逻辑上合并成一个存储器： 对CPU来讲，系统中各类存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑上统一的存储器就是我们说的内存地址空间。 每个物理上的存储器在逻辑上占有一段地址段，CPU对其段进行操作，就是对物理存储进行操作。 最终运行程序的是CPU，我们用汇编语言编程时，必须要从CPU角度考虑问题。 小结 汇编指令是机器指令的助记符，同机器指令一一对应。 每一种CPU都有自己的汇编指令集。 CPU可以直接使用的信息在存储器中存放。 在存储器中指令和数据没有任何区别，都是二进制信息。 存储单元从0开始顺序编号。 一个存储单元可以存储一个字节，即8个bit（8b）、8位二进制。 1GB = 1024MB 1MB = 1024KB 1KB = 1024Byte 1Byte = 8bit 每个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说这些管脚引出总线。一个CPU可以引出三种总线的宽度标志了CPU的不同方面的性能。 地址总线宽度决定CPU寻址能力 数据总线宽度决定CPU与其他器件进行一次数据传输时的数据传输量 控制总线宽度决定CPU对系统中其他器件的控制能力 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双缝干涉]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%8F%8C%E7%BC%9D%E5%B9%B2%E6%B6%89%2F</url>
    <content type="text"><![CDATA[普通光源发光机理普通光源发光机理：激发态原子的自发辐射。 光波列：原子发射的光波是一段频率一定、振动方向一定、有限长的光波。 特点：间歇性、随机性 不同原子在同一时刻发出的波列各自独立。 波列越长，单色性越强。 相干光相干条件： 振动频率相同 振动方向相同 相位差恒定 相干光的获得方法获得相干光的基本原理： 根据普通光源的发光机理可知，我们只能通过某些装置将同一光源的同一部分发出的光，获得符合相干条件的相干光。 分波阵面法同一波阵面上各点的振动具有相同相位。 如杨氏双缝实验。 分振幅法一束光投射到两种介质分界面上时，一部分反射、一部分透射，光能就被分为两份或若干份，振幅同时被分成几份。 薄膜干涉实验，其中包括等倾干涉和等厚干涉，等厚干涉包括劈尖膜和牛顿环。 双缝干涉 \delta=r_2-r_1\approx dsin\theta \approx dtan \theta=\frac{xd}{D} 明纹 即相位差为$\pm2k\pi$，光程差$\delta$为$\pm k\lambda$。 \delta=\frac{xd}{D}=\pm k\lambda,\qquad k=0,1,2,... \Downarrow x=\pm k\frac{D\lambda}{d},\qquad k=0,1,2,... 暗纹 即相位差为$\pm(2k+1)\pi$，光程差$\delta$为$\pm (2k+1)\frac{\lambda}{2}$。 \delta=\frac{xd}{D}=\pm (2k+1)\frac{\lambda}{2},\qquad k=0,1,2,... \Downarrow x=\pm (2k+1)\frac{D\lambda}{d},\qquad k=0,1,2,...特点： 两明条纹或暗条纹的间距为$\Delta x=\frac{D\lambda}{d}$，所以干涉条纹等间距分布。 条纹平行，相邻明纹的间距是暗条纹的宽度。 中间级次低。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统结构作业]]></title>
    <url>%2F2019%2F06%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[说明： 大二下学期计算机系统结构课程课后作业，题目来源：课后题 1.1题目解释下列术语 层次结构；计算机系统结构；计算机组成；计算机实现；透明性；由上往下设计；由下往上设计；系列机；软件兼容；兼容机；模拟；仿真；虚拟机；宿主机；指令流；数据流；Amdahl定律；CPI；MIPS；MFLOPS 答层次结构 定义 层次结构在这里指计算机系统层次结构。计算机系统系统由硬件和软件组成，按功能划分为7级层次结构。 每一级对应一种机器（虚拟机器由软件实现，实际机器由硬件实现），从第0级到第6级，级数越低越靠近硬件，级数越高越靠近软件。 在某层次的观察者视角中，他只是通过该层次的语言了解和使用计算机，不必关心低层次的那些机器的工作原理，也就是对于高层来说低层是透明的。 个人理解 计算机系统层次结构是计算机领域分层思想的一种应用，计算机网络的体系结构（OSI七层协议等）也是。在层次结构中，每层负责解决一定的问题，即具有一定的功能。一般来说，底层为高层提供一定的服务。 示意图 计算机系统结构 定义 “计算机系统结构”这个名词来源于英文computer architecture，目前并无统一定义，现以Amdahl定义举例。 Amdahl等人在1964年提出计算机系统结构这个名词，他们将其定义为程序设计者所看到的一个计算机系统（也就是上边提到的机器）的属性，即概念性结构和功能特性，这是程序员为了使其编写的程序能在机器上正确运行，需要了解和遵循的计算机属性。 计算机系统结构主要研究软件、硬件功能分配和对软件、硬件界面的确定，即哪些功能由软件完成、哪些功能由硬件完成。 Amdahl等人对计算机系统结构定义的主要内容是指令系统及其执行模型，然而随着新器件的出现，计算机系统结构的定义还应包括功能模块的设计。 个人理解 如果把计算机这门科学涉及的知识进行分层，计算机系统结构则是软件和硬件的交界处，硬件是计算机组成原理的主要内容，软件则是操作系统等。 分类方法 Flynn分类法 按照指令流和数据流的不同组织方式进行分类，分为以下四类： 单指令流单数据流SISD 单指令流多数据流SIMD 多指令流单数据流MISD 多指令流多数据流MIMD 冯氏分类法 冯泽云提出用最大并行度对计算机系统结构进行分类，分为以下四类： 字串位串WSBS 字并位串WPBS 字串位并WSBP 字并位并WPBP Handler分类法 Wolfgan Handler在1977年根据并行度和流水线提出了一种分类法，其将计算机的硬件结构分为三个层次，并分别考虑它们的可并行-流水处理程度，以下为三个层次： 程序控制部件的个数 算术逻辑部件或处理部件的个数 每个算术逻辑部件包含基本逻辑线路的套数 计算机组成计算机组成是计算机系统结构的逻辑实现，包括机器内部的数据流和控制流的组成以及逻辑设计等。 其任务是在计算机系统结构确定分配给硬件子系统的功能及其概念结构之后，研究各组成部分的内部构造和相互联系，以实现机器指令级的各种功能和特性。 计算机实现计算机实现是指计算机组成的物理实现。 透明性透明指的是本来存在的事物和属性，从某种角度来看，它是不存在的。 个人理解： 计算机网络中物理层的实现对于网络层来说就是透明的，网络层并不知道物理层的内部实现，仅知道物理层的外部接口而已。 就像课堂上老师要收作业，他不知道课代表是怎么收的，课代表怎么收作业对于老师来说就是透明的。 由上往下设计与由下往上设计对应，根据计算机系统结构的分成，从最高层开始设计每层的功能与实现。 由下往上设计根据计算机系统结构的分层，从最低层开始设计每层的功能与实现。 这种方法以前较为适宜，因为那时硬件成本昂贵，硬件技术水平低，软件技术和硬件技术相比往往处于被动地位。 系列机系列机是指在一个厂家内生产的具有相同的系统结构，但具有不同组成和实现的一系列不同型号的机器。 软件兼容同一个软件可以不加修改地运行于系统结构相同的各档机器，可获得相同的结果，差别只在于不同的运行时间。 系列机的软件兼容分为向上兼容、向下兼容、向左兼容、向右兼容。 兼容机不同厂家生产的具有相同系统结构的计算机称为兼容机。它的思想与系列机的思想是一致的。 模拟模拟指用软件方法在一台现有的计算机上实现另一台计算机的指令系统。 通过解释方法把B机器的每一条指令用A机器的指令进行解释执行。 A机器称为宿主机，B机器称为虚拟机。 仿真用微程序直接解释另一种机器指令系统的方法称为仿真。 虚拟机模拟中已介绍。 宿主机模拟中已介绍。 指令流机器执行的指令序列。 数据流由指令流调用的数据序列，包括输入数据和中间结果。 Amdahl定律系统中某一部件由于采用某种更快的执行方式后整个系统性能的提高与这种执行方式的使用频率或占总执行时间的比例有关。 CPI每条指令的平均时钟周期。 CPI=CPU时钟周期数目/ICMIPS每秒百万条指令数。 MIPS=\frac{指令条数}{执行时间\times10^6}=\frac{时钟频率}{CPI\times10^6}MFLOPS每秒百万次浮点操作次数。 MFLOPS=\frac{程序中的浮点操作次数}{执行时间\times10^6}1.5题目硬件和软件在什么意义上是等效的？在什么意义上又是不等效的？试举例说明 答 个人理解 计算机系统结构的设计主要在功能这一层次上考虑问题。 在功能这个层次上考虑，软件和硬件是等效的，即软件和硬件都实现了同样的功能。 从功能实现的原理这个层次上考虑，软件和硬件是不等效的，两者的实现方式是不同的，成本、效率等指标也会有不同。 举例 比如存储器管理，不管用硬件还是软件，都可以实现相同的存储器管理功能，但两者的实现方法和性能都是不同的。 1.6题目试以实例说明计算机系统结构、计算机组成与计算机实现之间的相互关系和相互影响。 答 相互关系 一种系统结构可以有多种组成 比如系列机系统结构相同，指令的执行顺序既可以是顺序执行，又可以是重叠、流水线等执行顺序。 一种组成可以有多种物理实现 比如同样的组成，主存既可以使用双极型，又可以使用MOS型。 相互影响 系统结构不同，采用的计算机组成也不同，同样计算机组成也会影响系统结构。 1.12题目如果某一计算任务用向量方式求解比用标量方式求解快20倍，称可用向量方式求解部分所花时间占总的时间的百分比为可向量化百分比。 画出加速比与向量化比例两者关系的曲线。 答该题考察Amdahl定律， S_n=\frac{T_0}{T_n}=\frac{1}{(1-Fe)+\frac{Fe}{Se}}上式中$Sn$为加速比； $Fe$为$\frac{可改进部分占用时间}{改进前整个任务的执行时间}$； $Se$为$\frac{改进前改进部分的执行时间}{改进后改进部分的执行时间}$。 可知可向量化百分比即为$Fe$，且$Se=\frac{20}{1}=20$。（虽说快20倍，这里应该是21的，为简化计算，就这样吧..…） 由上，可得下式： S_n=\frac{1}{1-0.95Fe}MATLAB代码： 123456Fe=0:0.02:1;Sn=1./(1-0.95*Fe);plot(Fe,Sn);grid minor;xlabel('加速比Sn');ylabel('向量化比例Fe'); 作图如下： 1.13题目题1.12中为达到加速比2，可向量化的百分比应是多少？ 答解下式： 2=\frac{1}{1-0.95Fe}得$Fe\approx0.526$。 2.14问题一台模型机共有7条指令，各指令的使用频度分别为35%，25%，20%，10%，5%，3%，2%，有8个通用数据寄存器，2个变址寄存器。问题如下： 要求操作码的平均长度最短，请设计操作码的编码，并设计所设计操作码的平均长度。 设计8位字长的寄存器-寄存器型指令3条，16位字长的寄存器-存储器型变址寻址方式指令4条，变址范围不小于正、负127。请设计指令格式，并给出各字段的长度和操作码的编码。 答第1问由题可知，要求操作码平均长度最短，所以应使用哈夫曼编码，指令使用频度越高，其操作码长度应越短。 指令操作码设计如下 指令序号 使用频度 Huffman编码 操作码长度 1 0.35 0 1 2 0.25 10 2 3 0.20 110 3 4 0.10 1110 4 5 0.05 11110 5 6 0.03 111110 6 7 0.02 111111 6 指令操作码平均长度为： H=0.35\times1+0.25\times2+0.20\times3+0.10\times4+0.05\times5+0.03\times6+0.02\times6=2.4第2问 寄存器-寄存器型指令 指令序号 编码（2位） 通用寄存器（3位） 通用寄存器（3位） 1 00 R R 2 01 R R 3 10 R R 寄存器-存储器型变址寻址方式指令 指令序号 编码（4位） 通用寄存器（3位） 变址寄存器（1位） 地址偏移量（8位） 1 1100 R X A 2 1101 R X A 3 1110 R X A 4 1111 R X A 2.17问题在一般通用计算机中，按照指令所完成的功能来划分，应该有哪几类指令？各类指令的主要任务是什么？ 答一般来说，要有5类基本指令：数据传输类指令、运算类指令、程序控制类指令、输入输出指令、处理机控制和调试指令。 数据传送类指令 主要任务 在相同或不同的数据存储设备之间传送数据。 数据传输指令的种类有如下三个主要因素决定： 数据存储设备的种类 数据传送的单位 采用的寻址方式 运算类指令 主要任务 承担计算机的主要任务：运算（包括数据计算和符号处理） 设计运算类指令时主要考虑如下四个因素的组合 操作种类 数据表示 数据长度 数据存储设备 程序控制指令 主要任务 实现流程控制 程序控制指令主要包括三类 转移指令（包括无条件转移和有条件转移） 程序调用和返回指令 循环控制指令 输入输出指令 主要任务 启动、停止、测试设备 数据输入、输出 对设备进行控制 等等 处理机控制和调试指令一般计算机系统中，处理机有两个状态：管态和用户态，或称主态和从态。这两个状态需要相互切换，而且这两个状态下所能使用的指令应该有所区别 主要任务 对不同状态的处理机进行控制 3.9问题一个页式虚拟存储器的虚存空间大小为4GB，页面大小为4KB，每个页表存储字要占用4个字节。 计算这个页式虚拟存储器需要采用几级页表？ 如果要求页表所占的主存页面数最少，请分配每一级页表的实际存储容量各为多少字节？ 页表的哪些部分必须存放在主存中？哪些可以存放在辅存中？ 答第1问由题可知 $N_v=4GB$，$N_p=4KB$，$N_d=4B$ 可得页表级数： g=\lceil\frac{log_2N_v-log_2N_p}{log_2N_p-log_2N_d}\rceil=\lceil\frac{32-12}{12-2}\rceil=2所以需要采用2级页表 第2问一个页可存储的页表存储字的个数为：$\frac{N_p}{N_d}=1K=2^{10}$ 虚拟空间的总页数为：$\frac{N_v}{N_p}=1M=2^{20}$ 设第一级页表要用N个页表存储字 由第1问可得，使用2级页表，则$N\times\frac{N_p}{N_d}=\frac{N_v}{N_p}$，得$N=2^{10}$， 由上可得 第一级页表占用一个页面的大小，即$N_d\times\frac{N_p}{N_d}=4KB$。 第二级页表占用1K个页面的大小，即$N_d\times\frac{N_v}{N_p}=4MB$。 第3问为节省内存空间，第一级页表必须存放在主存中，第二级页表只需要把正在运行的程序的相关页表放在主存中，其他的可以放在外存中。 3.11问题一个页式虚拟存储器按字节编址，页面大小为1K个字节，每个数据的字长为4个字节。现有一个程序的页表如下： 虚页号 装入标志 主存（实）页号 修改标志 访问方式 0 1 2 0 RW 1 1 3 0 R 2 0 0 0 R 3 1 1 0 X 4 0 0 0 RW 5 1 0 0 R 6 0 0 0 X 表中的装入标志为‘1’表示该虚页已经装入主存，为‘0’则表示还未装入主存。修改标志为‘0’表示该页还没有被修改过，为‘1’则表示该页已经被修改过。访问方式‘RW’表示该页可以读可以写，但不能作为指令来执行；‘R’表该页只能读，不能写和执行；‘X’表示该页只能作为指令来执行，不能读和写。 虚地址经变址寻址和基址寻址（B）+（X）+D形成。现有一个程序，出现下列访问主存的操作： 序号 操作 （B） （X） D 1 取数 124 30 50 2 取数 2000 1000 60 3 存数 4000 2000 600 4 存数 1200 4600 60 5 取数 3000 640 100 6 取数 4096 500 20 7 加并存数 400 1200 80 8 加并存数 36 360 64 9 转移 2500 600 100 10 转移 3600 1200 56 列出产生主存页面失效的操作序号 如果不发生主存页面失效的话，计算访问主存的物理地址 列出被修改过的主存页面号 列出非法操作的序号 答由题可知，该页式虚拟存储器按字节编址，页面大小为1K个字节，每个数据的字长为4个字节。 地址0-999是0号虚/实页，地址1000~1999是1号虚/实页，以此类推 实页内的偏移地址和虚页内的偏移地址相同 操作序号 虚地址 虚页号 实页号 页内偏移 实（物理）地址 操作 合法性 1 204 0 2 50 2098 未改 合法 2 3060 3 1 60 1084 未改 非法 3 6600 6 未装入 600 无 失效 无 4 5860 5 0 60 0060 未改 非法 5 3740 3 1 100 1124 未改 非法 6 4616 4 未装入 20 无 失效 无 7 1680 1 3 80 3116 未改 非法 8 460 0 2 64 2128 修改 合法 9 3200 3 1 100 1124 未改 合法 10 4856 4 未装入 56 无 失效 无 第1问3、6、10 第2问表中已计算 第3问2 第4问2、4、5、7 3.14问题在页式虚拟存储器中，一个程序由P1~P5共5个页面组成。在程序执行过程中依次访问到的页面如下： P2，P3，P2，P1，P5，P2，P4，P5，P3，P2，P5，P2 假设系统分配给这个程序的主存有3个页面，分别采用FIFO、LFU、OPT三种页面替换算法对这3页主存进行调度。 画出主存页面调入、替换和命中的情况表。 统计三种页面替换算法的页命中率。 答 FIFO 把最先进来的替换走。 方法：向每行回看，出现次数最多的指令待换出 LFU 把最久没有使用的替换掉。 方法：向页地址流回看，最后出现的指令待换出 OPT 把最晚要使用的替换掉。 方法：向页地址流后看，最后访问的指令待换出 4.4问题有5个中断源D1、D2、D3、D4和D5，它们的中断优先级从高到低分别是1级、2级、3级、4级和5级。这些中断源的中断优先级、正常情况下的中断屏蔽码和改变后的中断屏蔽码见下表。每个中断源有5位中断屏蔽码，其中，‘1’表示该中断源被屏蔽，‘0’表示该中断源开放。 中断源名称 中断优先级 正常的中断屏蔽码D1 D2 D3 D4 D5 改变后的中断屏蔽码 D1 1 1 1 1 1 1 1 0 0 0 0 D2 2 0 1 1 1 1 0 1 0 0 0 D3 3 0 0 1 1 1 1 0 1 0 0 D4 4 0 0 0 1 1 1 1 0 1 1 D5 5 0 0 0 0 1 1 1 1 0 1 当使用正常的中断屏蔽码时，处理机响应各中断源的中断服务请求的先后次序是什么？实际的中断处理次序是什么？ 当使用改变后的中断屏蔽码时，处理机响应各中断源的中断服务请求的先后次序是什么？实际上中断处理的次序是什么？ 如果采用改变后的中断屏蔽码，当D1、D2、D3、D4和D5这5个中断源同时请求中断服务时，画出处理机响应中断源的中断服务请求和实际运行中断服务程序过程的示意图。 假设从处理机响应中断源的中断服务请求开始，到运行中断服务程序中第一次开中断所用的时间为1个单位时间，处理机运行中断服务程序的其他部分所用的时间为4个单位时间。当处理机在执行主程序时，中断源D3、D4和D5同时发出中断服务请求，过3个单位时间之后，中断源D1和D2同时发出中断服务请求。采用改变后的中断屏蔽码，画出处理机响应各中断源的中断服务请求和实际运行中断服务程序过程的示意图。 答第1问使用正常的中断屏蔽码，处理机的中断服务顺序将严格按照中断源的中断优先级进行。 中断服务请求的响应顺序是D1、D2、D3、D4、D5。 实际的中断处理次序是D1、D2、D3、D4、D5。 第2问中断服务请求的响应顺序是D1、D2、D3、D4、D5。 实际的中断处理次序是D4、D5、D3、D2、D1。 第3问 第4问 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机系统结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-实验（四）TCP抓包分析]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E5%9B%9B%EF%BC%89TCP%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[实验内容 学会安装使用自由软件SNORT 截获以太网数据包，并描述以太网数据包的各层的帧结构。 截获ARP，TCP协议数据包并进行分析 实验步骤实验需要两个主机A(192.168.1.104)和B(192.168.1.105)，A访问B，B进行TCP和ARP抓包，本实验报告为抓包主机B视角。 环境配置主机B需要进行环境配置：设置账户密码、打开FTP站点 设置账户密码控制面板——用户账户——设置密码 打开FTP站点控制面板——管理工具——Internet信息服务——FTP站点——属性——用户名——浏览——查找账户——选择ligong——应用——确认 A访问B ftp open 192.168.1.105 输入用户名(ligong)和密码(123，也就是刚才设置的密码) 一些操作，如dir quit，退出，断开连接 B进行抓包使用Snort软件进行抓包，进入D:/snort/bin目录。 输入snort -dev -l /snort/log，开始抓包，按下Ctrl+C停止抓包。 如果主机B抓到了A发出的FTP请求，在D:/snort/log目录下可以找到文件夹192.168.104，在其中可以看到名如TCP_1980-21.ids的文件，21为端口号。 数据包分析ARP抓包失败，原因未知，其他同学似乎也未抓到，抓到的都是3号机器广播的ARP包。下边进队TCP数据包进行分析。 TCP数据包分析 TCP是面向连接的协议，所以TCP运输连接的建立和释放时每一次通信中必不可少的过程。 运输连接分为三个阶段：连接建立、数据传送、连接释放。 每一次握手大概包括以下内容： 第一行数据包括了时间戳、源物理地址、目的物理地址、类型、长度； 第二行数据包括了源IP、目的IP、TCP、TTL、TOS、ID、IP长度、Dgm长度； 第三行数据包括SYN位、ACK位、序号、确认号、窗口大小、TCP长度； 第四行信息包括TCP选项等。 以下主要选取TCP数据包中连接建立（三次握手）和连接释放（四次握手）的相关内容进行分析。 连接建立12345601/01-01:40:15.948470 0:16:EC:D2:50:7D -&gt; 0:19:21:57:7:85 type:0x800 len:0x3E192.168.1.104:1980 -&gt; 192.168.1.105:21 TCP TTL:128 TOS:0x0 ID:11743 IpLen:20 DgmLen:48 DF******S* Seq: 0x75C7623D Ack: 0x0 Win: 0xFFFF TcpLen: 28TCP Options (4) =&gt; MSS: 1460 NOP NOP SackOK =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ 上边为连接建立的第一次握手，可以看到数据包从主机A（104）发往主机B（105）的21号端口； SYN位设置为1； 序号为0x75C7623D。 12345601/01-01:40:15.948524 0:19:21:57:7:85 -&gt; 0:16:EC:D2:50:7D type:0x800 len:0x3E192.168.1.105:21 -&gt; 192.168.1.104:1980 TCP TTL:128 TOS:0x0 ID:11647 IpLen:20 DgmLen:48 DF***A**S* Seq: 0xF085016 Ack: 0x75C7623E Win: 0xFFFF TcpLen: 28TCP Options (4) =&gt; MSS: 1460 NOP NOP SackOK =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ 上边为连接建立的第二次握手，可以看到数据包从105发往104， SYN位设置为1； ACK位设为1； 序号为0xF085016； 确认号为0x75C7623E，即确认号为上一次握手序号+1的值。 1234501/01-01:40:15.948661 0:16:EC:D2:50:7D -&gt; 0:19:21:57:7:85 type:0x800 len:0x3C192.168.1.104:1980 -&gt; 192.168.1.105:21 TCP TTL:128 TOS:0x0 ID:11744 IpLen:20 DgmLen:40 DF***A**** Seq: 0x75C7623E Ack: 0xF085017 Win: 0xFFFF TcpLen: 20=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ 上边为连接建立的第三次握手，可以看到数据包从104发往105， ACK位设为1； 序号为0x75C7623E，即序号为上一次握手的确认号，本质是A上一次向B发出的请求的序号+1； 确认号为0xF085017，即确认号为上一次握手序号+1的值。 数据传送 连接释放注意：这里是服务器主动释放连接，与教材上写的客户机主动释放情况不同。 12301/01-01:40:25.769622 0:19:21:57:7:85 -&gt; 0:16:EC:D2:50:7D type:0x800 len:0x36192.168.1.105:21 -&gt; 192.168.1.104:1980 TCP TTL:128 TOS:0x0 ID:11666 IpLen:20 DgmLen:40 DF***A***F Seq: 0xF085092 Ack: 0x75C7625B Win: 0xFFE2 TcpLen: 20 上边为连接释放的第一次握手，可以看到数据包从105发往104， ACK位设为1； FIN位设为1； 序号为0xF085092； 确认号为0x75C7625B。 12301/01-01:40:25.769759 0:16:EC:D2:50:7D -&gt; 0:19:21:57:7:85 type:0x800 len:0x3C192.168.1.104:1980 -&gt; 192.168.1.105:21 TCP TTL:128 TOS:0x0 ID:11763 IpLen:20 DgmLen:40 DF***A**** Seq: 0x75C7625B Ack: 0xF085093 Win: 0xFF84 TcpLen: 20 上边为连接释放的第二次握手，可以看到数据包从104发往105， ACK位设为1； 序号为0x75C7625B，即序号等于上次握手确认号； 确认号为0xF085093，即确认号等于上次握手序号+1。 12301/01-01:40:25.771844 0:16:EC:D2:50:7D -&gt; 0:19:21:57:7:85 type:0x800 len:0x3C192.168.1.104:1980 -&gt; 192.168.1.105:21 TCP TTL:128 TOS:0x0 ID:11764 IpLen:20 DgmLen:40 DF***A***F Seq: 0x75C7625B Ack: 0xF085093 Win: 0xFF84 TcpLen: 20 上边为连接释放的第三次握手，可以看到数据包从104发往105， ACK位设为1； FIN位设置为1； 序号为0x75C7625B，即序号等于上次握手序号； 确认号为0xF085093，即确认号等于上次握手确认号。 12301/01-01:40:25.771894 0:19:21:57:7:85 -&gt; 0:16:EC:D2:50:7D type:0x800 len:0x36192.168.1.105:21 -&gt; 192.168.1.104:1980 TCP TTL:128 TOS:0x0 ID:11667 IpLen:20 DgmLen:40 DF***A**** Seq: 0xF085093 Ack: 0x75C7625C Win: 0xFFE2 TcpLen: 20 上边为连接释放的第四次握手，可以看到数据包从105发往104， ACK位设为1； 序号为0xF085093，即序号等于上次握手确认号； 确认号为0x75C7625C，即确认号等于上次握手序号+1。 心得体会本次实验前在计算机网络课堂上还并没有学过TCP的连接过程如何建立与释放，仅仅听说过三次握手和四次握手。 通过这次实验，更加直观、具体地看到了TCP建立和释放连接的过程。在实验之后，又通过学习，对三次握手和四次握手的原理有了进一步的了解。 问：为什么建立连接是三次握手，释放连接是四次握手？ 答： 建立连接时，服务器收到客户的SYN连接请求报文，可以直接发送SYN+ACK报文，其中ACK报文是用来应答的，SYN报文是用来同步的。 当释放连接时，当服务器收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端：“你发的FIN报文我收到了”。只有等到服务器所有的报文都发送完了，它才能发送FIN报文，因此ACK报文和FIN报文不能一起发送，故需要四步握手。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-实验（三）ARP欺骗]]></title>
    <url>%2F2019%2F06%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%89%EF%BC%89ARP%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[实验目的 掌握常见ARP欺骗类型和手段 掌握ARP协议工作原理和格式 掌握防范ARP地址欺骗的方法和措施 掌握Sniffer Pro软件的使用 实验环境 硬件 交换机1 台、路由器1台、计算机数台 软件 Sinffer pro 实验原理ARP协议简介ARP(Address Resolve Protocol)，地址解析协议。 用途：用于寻找和IP 地址相对应的MAC地址。 ARP消息类型： ARP request 即ARP请求分组，用于请求某IP主机的硬件地址。 广播。 ARP response 即ARP响应分组，用于指出某IP主机的硬件地址。 单播。 ARP报文中各字段的意义 硬件类型 以太网接口类型为1。 协议类型 IP协议类型为080016。 操作 ARP请求分组为1，ARP响应分组为2。 硬件地址长度 MAC地址长度为6BH。 协议地址长度 IP地址长度为4BH。 源MAC地址 发送方的MAC地址。 源IP地址 发送方的IP地址。 目的MAC 地址 ARP 请求分组中该字段没有意义；ARP 响应分组中为接收方的MAC地址。 目的IP 地址 ARP 请求分组中为请求解析的IP 地址；ARP 响应分组中为接收方的IP地址。 ARP欺骗原理ARP请求分组以广播形式发送，网络上的主机可以自主发送ARP应答消息； 当其他主机收到ARP响应分组时，不会检测该报文的真实性，直接将其记录在本地的MAC地址转换表。 就可以发送伪ARP响应分组，从而篡改本地的MAC地址表。 举例： 攻击者甲通过冒充某IP主机丙，给出错误的物理地址，并向另一主机乙单播一个ARP响应分组，这样乙接收到这个错误的IP与物理地址的映射，更新了ARP缓存表。 之后，主机乙使用ARP缓存表中该项时，则会出现错误。 实验步骤设置账户控制面板——用户账户——设置用户名为ligong，并设置密码。 设置FTP站点控制面板——Internet信息服务——FTP站点——硬件——安全账户——浏览——高级——选中ligong——允许匿名——应用、确定。 禁止网络保护右击屏幕右下角盾牌，取消Enable Auto Protection。 所用主机说明我们需要三台主机，分别为甲、乙、丙。 甲为监听并攻击者，乙为Ping命令/FTP命令操作者，丙为IP地址提供者。 甲实现ARP欺骗后，乙无法Ping或无法通过FTP连接丙。 进行ARP欺骗在甲主机上进行操作。 打开Sniffer Pro，选中本机的网卡，并选中Log Off，点击确定。 点击菜单栏中File中的Log On，登录网卡。 打开菜单栏中display中的Define Filter； 选中Address选项卡，将Station1和Station2设置为Any（这样将监听网络上的所有消息，个人觉得可以只监听乙和丙）； 选中Advanced选项卡，选中ARP、IP、IP ARP、TCP、UDP和FTP。 打开菜单栏中Capture中的Start，开始监听。 点击左侧Connection，点击下侧的Objects选项。 在右侧找到乙对丙的ARP信息包，双击，再选择Decode选项，可以看到ARP分组的结构，我们对丙的MAC地址进行修改（右击——Edit）。 打开菜单栏中Tools中的Trace Route，实现ARP欺骗。 结果检验甲实现ARP欺骗后，乙Ping或通过ftp连接丙则会失败。 因为甲通过广播发出了错误的丙的物理地址，而乙接收到了这个错误的信息，在连接丙时则会使用这个错误的物理地址，造成无法连接。 实验心得ARP是建立在网络中各个主机互相信任的基础上的。 ARP欺骗可以导致计算机通信失败，更严重的是可以导致通信重定向，攻击者可以窃取被攻击者通信的数据，存在极大的安全隐患。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-80x86寄存器组]]></title>
    <url>%2F2019%2F05%2F31%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-80x86%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%2F</url>
    <content type="text"><![CDATA[寄存器可以分为程序可见的寄存器和程序不可见的寄存器两大类。 程序可见的寄存器可以分为以下三类： 通用寄存器 专用寄存器 段寄存器 通用寄存器数据寄存器AX、BX、CX、DX可称为数据寄存器，用来暂时存放计算过程中所用到的操作数。它们是16位，但也可以按字节访问，比如AH（高位字节）和AL（低位字节）。 AX（accumulator），作为累加器用，所以是算术运算的主要寄存器。 BX（base），在计算存储器地址时，常用作基址寄存器。 CX（count），常用来保存计数值，如在移位指令、循环指令和串处理指令中用作隐含的计数器。 DX（data），一般在作双字长运算时把DX和AX组合在一起存放一个双字长数，DX用来存放高位字。 指针寄存器可以存放操作数，但只能以字为单位使用。 SP（stack pointer），堆栈指针寄存器。 BP（base pointer），基址指针寄存器。可以和堆栈段寄存器SS联用来确定堆栈段中的某一存储单元的地址。 SI（source index），源变址寄存器，一般与数据段寄存器DS联用，用来确定数据段中某一存储单元的地址。 DI（destination index），目的变址寄存器，一般与数据段寄存器DS联用，用来确定数据段中某一存储单元的地址。 ※SI和DI有自动增量和自动减量的功能。 在串处理指令中，SI和DI作为隐含的源变址和目的变址寄存器，此时SI和DS联用，DI和附加段寄存器ES联用，分别达到在数据段和附加段中寻址的目的。 专用寄存器IP（instruction pointer），指令指针寄存器，它用来存放代码段中的偏移地址。 在程序运行的过程中，它始终指向下一条指令的首地址，它与段寄存器CS联用确定下一条指令的物理地址。 SP（stack pointer），堆栈指针寄存器，存放栈顶的偏移地址，与堆栈段寄存器SS联用来确定堆栈段中栈顶的地址。 FLAGS标志寄存器，又称为程序状态寄存器（program status word，PSW）。 条件标志 溢出标志 （overflow flag，OF），运算溢出时为1，否则为0。 符号标志 （sign flag，SF），运算结果为负时为1，否则为0。 零标志 （zero flag，ZF），运算结果为0时为1，否则为0。 进位标志 （carry flag，CF），记录运算时从最高有效位产生的进位值。有进位时为1，否则为0。 辅助进位标志 （auxiliary carry flag，AF），..… 奇偶标志 （parity flag，PF），结果操作数中1的个数为偶数时为1，否则置0。 控制标志方向标志（direction flag），在串处理指令中控制处理信息的方向用。 DF为1时，高地址到低地址，即倒着来。 DF为0时，低地址到高地址，即正着来。 系统标志 陷阱标志 （trap flag，TF），用于调试时的单步方式操作。 TF为1时，产生陷阱；否则不产生。 中断标志 （interrupt flag，IF），当其为1时，允许CPU响应中断；否则不允许。 段寄存器段寄存器也是一种专用寄存器，专用于存储器寻址，用来直接或间接存放段地址。 代码段 （code segment，CS），存放当前正在运行的程序。 数据段 （data segment，DS），存放当前运行程序所用的数据。 如果程序使用了串处理指令，则其源操作数也存放在数据段里。 堆栈段 （stack segment，SS） 附加段 （extra segment，ES），附加的数据段，作为辅助的数据区，也是串处理指令的目的操作数存放区。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-实验（三）]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[实验目的 掌握程序设计中的3种基本结构(顺序结构、选择程序、循环程序)。 熟练使用汇编语言的指令：数据传送类指令、数据运算类指令、逻辑判断类指令与转移指令、循环指令等。 初步了解系统功能调用的使用方法，尝试使用01H号功能调用进行字符输入的方法及使用02H号功能调用进行字符输出（显示）的方法。 程序说明 编写十进制到十六进制转换程序。要求从键盘取得一个十进制数，然后把该数以十六进制形式在屏幕上显示出来 已知从BUF开始存放了10个16进制字数据，编程求出这10个数中的最大数，（将最大数存入MAX字节单元），并将其以10进制数的形式在屏幕上显示出来。（提示：以上两题都要求采用子程序的方法） 从键盘上输入一行字符，如果这行字符比前一次输入的一行字符长度长，则保存该行字符，然后继续输入另一行字符;如果它比前一次输入的行短，则不保存这行字符。按下‘$’输入结束，最后将最长的一行字符显示出来。（选作） 设计思想题目一如下图所示，首先调用子程序getinput获取用户输入的十进制数字，然后调用子程序htoa以十六进制显示用户输入的数据。 题目二如下图所示，首先调用子程序getmax获取buf中的最大值，同时存储进max和(ax)，最后调用子程序display显示(ax)。 题目三​ 首先子程序getstr获取用户输入的字符串，每收到一个字符串之后，根据长度判断是否更新string，然后用户输入一个字符判断输入是否结束； ​ 然后子程序display显示字符串string。 程序代码题目一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889stack segment ; 数据段 dw 128 dup(?) ; 堆栈大小为128个字 tos label word ; 栈底地址为tosstack endscode segment ; 代码段 assume ss:stack,cs:codemain proc far; 初始化ss、sp寄存器 mov ax,stack mov ss,ax ; (ss)&lt;-stack lea sp,tos ; (sp)&lt;-tos，sp存储栈顶地址，当前栈顶即为栈底 ; 为返回DOS作准备 push ds mov ax,0 push ax ; 获取用户输入的十进制数 call getinput ; 调用子程序，在DOS中以十六进制输出(ax) call htoa retmain endpgetinput proc near mov bx,0 ; bx存储用户输入 mov cl,10 ; 乘法用 input:; 判断用户输入是否合法 mov ah,1 ; 调用1号功能，获取用户输入，保存至(al) int 21h ; 调用DOS sub al,30h ; ASCII码转二进制 cmp al,0 ; jl exit ; (al)&lt;0，则说明输入结束 cmp al,9 jg exit ; (al)&gt;9，则说明输入结束 ; (bx)&lt;-(bx)*10+(al) push ax ; 暂存(ax) mov al,bl ; (al)&lt;-(bl) mul cl ; (ax)&lt;-(al)*(cl) mov bx,ax ; (bx)&lt;-(ax)==(bx)*10 pop ax ; 恢复(ax)，(al)为用户输入的数字 and ax,00ffh ; (ax)高位设为0 add bx,ax ; (bx)&lt;-(bx)+(al) jmp input ; 继续获取用户输入exit: mov ax,bx ; (ax)&lt;-用户输入 ret ; 返回getinput endphtoa proc near cmp ax,15 ; 和15比较 jle blow ; 若(ax)小于等于15，则跳转至blow ; (ax)低4位（大小是一个字）进栈后，右移4位 push ax ; (ax)大于15，暂存ax push bp ; 暂存bp mov bp,sp mov bx,[bp+2] ; (bx)&lt;-(ax)，(bp)、(ax)都占一个字，栈底与栈顶相比为高地址 and bx,000fh ; 只保留低4位 mov [bp+2],bx ; 存入栈中 pop bp ; 恢复bp mov cl,4 shr ax,cl ; 逻辑右移4位 call htoa ; 递归调用子程序htoa pop ax ; 获取之前存入栈中的低4位blow: add al,30h ; (al)转换为ASCII码 cmp al,3ah ; jl printit ; 若(ax)小于10，则跳转至printit add al,7h ; (al)大于等于10，加7进位到高位printit: mov dl,al ; mov ah,2 ; 调用2号功能，DOS输出(dl) int 21h ; 调用DOS rethtoa endp code endsend main 题目二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110data segment buf dw 5,9,6,8,7,0,4,3,2,1 ; 定义10个字数据 max dw ? ; 存储最大值data endscode segment assume ds:data,cs:codemain proc far; 为返回DOS作准备 push ds mov ax,0 push ax ; 将(ds)设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax) ; max记录buf中的最大值 call getmax ; (ax)&lt;-max mov ax,max ; 十进制输出(ax) call display ; 返回DOS retmain endpgetmax proc near; 保存寄存器 push ax push cx push si ; 数据初始化 mov ax,[buf] mov max,ax ; 假设第0个元素为最大值 mov cx,9 ; buf还剩9个元素 mov si,2 ; 下标指向第一个元素，因为是字数据，所以为2compare: mov ax,buf[si] cmp max,ax jge loop1 mov ax,buf[si] mov max,ax ; 更新最大值loop1: add si,2 ; 下标+1 loop compare ; 继续比较 ; 恢复寄存器 pop si pop cx pop ax ; 返回 retgetmax endpdisplay proc near ; 将(ax)以十进制形式输出; 保存寄存器 push ax push bx push cx push dx push si ; 初始化 mov si,0 ; 数字的位数 mov bl,10 ; 数字之后除以bx,即10 ; 数字每位倒序压栈prepare: div bl ; 被除数默认为(ax)，除以10。 add ah,30h ; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h push ax ; 存储最后一位 and ax,00ffh; (ah)&lt;-0 mov cx,ax ; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环 inc si ; 更新数字位数 inc cx ; 如果为0，加一之后为1。loop判断前会将cx减一。 loop prepare; ; 弹栈，并用十进制显示 mov cx,si ; si为数字位数，即循环运行次数show: pop ax ; 获取要显示的数据 mov dl,ah ; 要显示的数据放在dl里 mov ah,2 ; 2号功能 int 21h ; 调用DOS loop show; 恢复寄存器 pop si pop dx pop cx pop bx pop ax ; 返回 ret display endp ; display子程序结束code endsend main 题目三123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110data segment string db 0 ; 存放字符的个数 db 80 dup(0),0dh,0ah,&apos;$&apos; ; 存放前一次输入的字符串，兼作显示缓冲区。0ah换行、0dh回车（归位） buffer db 80 ; 输入字符串的缓冲区，最多输入80个字符 db 0 ; 存放字符的个数 db 80 dup(0) ; 存放当前输入的字符串，20h为空格data endscode segment assume cs:code,ds:data,es:datamain proc far; 为返回dos作准备 push ds mov ax,0 push ax; (ds)&lt;-(ax) (es)&lt;-(ax) mov ax,data mov ds,ax mov es,ax; 调用子程序，获取用户输入的串，判断是否更新，最终输出 call getstr ; 显示最终串 call display ; 程序返回 retmain endpgetstr proc near; 保存寄存器 push ax push cx push dx push di push si; 获取用户输入的字符串存入bufferinput: lea dx,buffer ; dx存缓冲区首址 mov ah,0ah ; DOS调用0A号功能，输入字符到缓冲区DS:DX int 21h ; DOS调用; DOS光标换行（处理多组输入，因为按下Enter仅能使光标回车） mov ah,2 mov dl,0ah int 21h; 比较字符串长度 lea si,buffer+1 ; buffer+1是当前串长度的地址 lea di,string ; (string)存入di，(string+2)存入es，源操作数只能用存储器寻址方式，目的寄存器不允许使用段寄存器 mov al,[si] ; 当前串长度存入al cmp al,[di] ; 与之前的串长度进行比较 jbe next ; 如果当前串更短，跳转到next，接收下一个字符串; 更新之前串string mov cx,80+1 ; 当前串比之前串长，更新串 cld ; 正向处理字符串 rep movsb ; 重复串操作，di为目的串，si为源串; 处理$失效问题 mov ah,0 mov si,ax mov [string+si+1],&apos;$&apos;; 获取下一个串next: mov ah,1 ; 获取用户输入 int 21h ; DOS调用 cmp al,&apos;$&apos; ; 是结束符吗？ jne input ; 不是则继续输入; 恢复寄存器 pop si pop di pop dx pop cx pop ax; 子程序返回 retgetstr endpdisplay proc near; 保护寄存器 push dx push ax; DOS光标换行，处理用$结束输入后没有换行的问题 mov ah,2 mov dl,0ah int 21h; 显示最终串 lea dx,string+1 ; 串地址存入dx mov ah, 9 ; dos调用9号功能，显示串 int 21h ; 调用DOS; 恢复寄存器 pop ax pop dx retdisplay endpcode endsend main 结果分析前两题略 题目三遇到的问题及解决方法如下： 获取用户输入的字符串时，按下Enter之后，光标回车，由于题目是多个输入（用户只输入一个字符串时，也要用$作为一次输入，所以也算多个输入），所以要增加换行操作。 输出结果时string后边的`并没有起到作用，只能自己在更新string之后手动存储`。 出现吞字问题：除了第一次输入，之后的输入第一个字符都会被当做判断输入结束的字符而不是字符串的内容…所以会吞字。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-实验（二）]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[实验目的 掌握程序设计中的3种基本结构(顺序结构、选择程序、循环程序)。 熟练使用汇编语言的指令：数据传送类指令、数据运算类指令、逻辑判断类指令与转移指令、循环指令等。 初步了解系统功能调用的使用方法，尝试使用01H号功能调用进行字符输入的方法及使用02H号功能调用进行字符输出（显示）的方法。 程序说明 计算1+2+3+…+10，将结果显示在屏幕上。 利用01H号功能调用输入10个一位数字，并将其由ASCII码转换为二进制数，依此保存到变量BUF的10个字节中，变量BUF的形式为BUF DB 10 DUP（？）。编程求出这10个数中的最大数和最小数，将最大数存入MAX单元、最小数存入MIN单元，并将其在屏幕上显示出来。 设计思想题目一如下图所示，首先通过循环求出1+2+…+10，然后调用子程序display显示sum。 题目二如下图所示，首先调用子程序getinput获取用户输入，同时存储进数组，并更新max和min，最后调用两次子程序display显示max和min。 程序代码题目一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788;*********************************************************************data segment ; 定义数据段 sum dw 0 ; 存储和data ends;*********************************************************************code segment ; 定义代码段 assume cs:code,ds:data ;--------------------------------------------------------------------- main proc far ; 程序的主部分start:; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- 0 push ax ; ax压栈; ds设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax) mov cx,10 ; 从10加到1 next: add sum,cx ; sum &lt;- sum+(cx) loop next ; (cx) &lt;- (cx)-1 mov ax,sum ; (ax) &lt;- sum call display ; 调用子程序以十进制显示(ax); 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------display proc near ; 将(ax)以十进制形式输出; 保存寄存器 push ax push bx push cx push dx push si ; 初始化 mov si,0 ; 数字的位数 mov bl,10 ; 数字之后除以bx,即10 ; 数字每位倒序压栈prepare: div bl ; 被除数默认为(ax)，除以10。 add ah,30h ; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h push ax ; 存储最后一位 and ax,00ffh; (ah)&lt;-0 mov cx,ax ; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环 inc si ; 更新数字位数 inc cx ; 如果为0，加一之后为1。loop判断前会将cx减一。 loop prepare; ; 弹栈，并用十进制显示 mov cx,si ; si为数字位数，即循环运行次数show: pop ax ; 获取要显示的数据 mov dl,ah ; 要显示的数据放在dl里 mov ah,2 ; 2号功能 int 21h ; 调用DOS loop show; 恢复寄存器 pop si pop dx pop cx pop bx pop ax ; 返回 ret display endp ; display子程序结束code ends;********************************************************************* end start 题目二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143;*********************************************************************data segment ; 定义数据段 buf db 10 dup(-1) ; 存储10个输进来的数字 max db 0 ; 最大值，输入的数字一定大于等于0 min db 9 ; 最小值，输入的数字一定小于等于9data ends;*********************************************************************code segment ; 定义代码段 assume cs:code,ds:data;--------------------------------------------------------------------- main proc far ; 程序的主部分start:; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- 0 push ax ; ax压栈; ds设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax) ; 获取用户输入并进行存储，记录最大值最小值 call getinput ; 数字存入al，显示一下; 显示最大值 mov al,max ; 显示最大值 and ax,00ffh ; (ah)&lt;-0 call display ; 调用子程序以十进制显示(ax); 显示最小值 mov al,min ; 显示最小值 and ax,00ffh ; (ah)&lt;-0 call display ; 调用子程序 ; 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------getinput proc near ; 获取用户输入并进行存储，记录最大值最小值; 保存寄存器 push ax push bx push cx; 初始化 mov cx,10 ; 10个输入 lea bx,buf ; 存储数组地址，用来遍历数组; 获取用户输入savetoarray: mov ah,1 ; 1号功能，获取用户输入，保存至al int 21h ; 调用DOS; 存入数组 sub al,30h ; (al)减去30h由ASCII码转为十进制数，在计算机内自动用二进制表示 mov [bx],al ; 存入数组，相对寻址方式 inc bx ; 数组地址加一 ; 判断是否更新最大值updatemax: cmp al,max ; (ax)&lt;-max jl updatemin ; (ax)&lt;max，则不用更新 mov max,al ; 更新最大值 ; 判断是否更新最小值updatemin: cmp al,min ; (ax)&lt;-min jg loopp ; (ax)&gt;min，则不用更新 mov min,al ; 更新最小值 ; 循环savetoarrayloopp: loop savetoarray ; cx减一，循环至cx为0 ; 恢复寄存器 pop cx pop bx pop ax ; 返回 ret getinput endp ; getinput子程序结束;---------------------------------------------------------------------display proc near ; 将(ax)以十进制形式输出; 保存寄存器 push ax push bx push cx push dx push si ; 初始化 mov si,0 ; 数字的位数 mov bl,10 ; 数字之后除以bx,即10 ; 数字每位倒序压栈prepare: div bl ; 被除数默认为(ax)，除以10。 add ah,30h ; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h push ax ; 存储最后一位 and ax,00ffh; (ah)&lt;-0 mov cx,ax ; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环 inc si ; 更新数字位数 inc cx ; 如果为0，加一之后为1。loop判断前会将cx减一。 loop prepare; ; 弹栈，并用十进制显示 mov cx,si ; si为数字位数，即循环运行次数show: pop ax ; 获取要显示的数据 mov dl,ah ; 要显示的数据放在dl里 mov ah,2 ; 2号功能 int 21h ; 调用DOS loop show; 恢复寄存器 pop si pop dx pop cx pop bx pop ax ; 返回 ret display endp ; display子程序结束code ends;********************************************************************* end start 问题回答设计的程序包含了几个段题目一和题目二的程序各设计了两个段：数据段和代码段。 你的代码经过编译和链接之后，总共占用多少个字节题目一和题目二程序编译链接后大小均为1KB。 调用DEBUG进行反汇编，查看程序的第一条指令的地址码是多少？最后一条指令的地址码是多少？ 题目一第一条指令的地址码为076B:0000，最后一条指令的地址码为076B:0018。因为使用了一个子程序，所以主程序较短。 题目二第一条指令的地址码为076B:0000，最后一条指令的地址码为076B:001E。因为使用了两个子程序，所以主程序较短。 对于第2题，怎样修改程序可以同时实现将10个数字的累加功能 首先在数据段中定义变量，代码如：sum db 0； 然后在getinput子程序中savetoarray中sub al,30h后添加代码add sum,al。 对于第2题，若要求输入的是两位数，又该怎么办？ 首先(cx)改为20； 然后每两个数字一组：其中先得到的数字转换为十进制数字A暂存，后得到的数字转换成十进制数字B暂存； 可知我们要操作的数字为A*10+B（可以通过乘法和加法实现）； 其他程序不变。 结果分析题目一运行程序，可见输出了1+2+…+10=55。 题目二运行程序，输入9876543210共10个数字，可见输出了最大值9和最小值0。 查看数据段dds:0，结果如下，可知数字均已存入buf数组。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理课程介绍]]></title>
    <url>%2F2019%2F05%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[之前看哈工大计组视频时的笔记。 课程名称解释计算机：数字电子计算机组成：计算机硬件系统的逻辑实现organization：组成 用数字电路知识实现计算机硬件系统。 原理：一般原理数字电子计算机硬件系统逻辑实现的。 特色 不以具体机型为依托 自顶向下、层层细化 课程讲授内容基本部件的结构和组织方式用数电知识对计算机基本部件进行逻辑实现。 基本运算的操作原理如何用数电知识实现计算机的基本功能：加减乘除等运算的硬件电路。 基本部件和单元的设计思想基本部件和基本单元的设计思想以及如何将部件连接起来。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统概论]]></title>
    <url>%2F2019%2F05%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[之前看哈工大计组视频时的笔记。 计算机系统概论现代计算机由哪两部分组成？硬件计算机的实体，如主机、外设等。 软件由具有各类特殊功能的信息（程序）组成。 硬件通过每条指令的有序执行发挥作用。 系统软件管理整个计算机系统。 语言处理程序编译环境 操作系统管理软硬件资源、提供人机交互等。 服务性程序比如数学库。 数据库管理系统网络软件应用软件按照某个任务的需要编制成的各种程序。 硬件和软件逻辑关系硬件进行了相对的封装，为软件提供接口，比如指令集。 应用软件使用系统软件提供的接口，系统软件使用硬件提供的接口。 计算机系统的层次结构https://www.bilibili.com/video/av15123338/?p=3 11分55秒 物理抽象 程序员角度抽象 机器语言-实际机器M1- 操作系统-虚拟机器M2- 汇编语言-虚拟机器M3- 高级语言-虚拟机器M4-用编译程序翻译成汇编语言程序 微指令系统-微程序机器M0- 一条机器语言指令也是很复杂的，将机器指令进行细化。 计算机组成和计算机系统结构的区别从研究内容上来说 计算机系统结构计算机系统结构定义了计算机系统软硬件的交界面，定义了哪些功能由软件来实现吗，哪些功能由硬件来实现，提供上层软件进行编写的时候和硬件进行交互的接口。 计算机系统结构指程序员（机器语言程序员）所见到的计算机系统的属性、概念性结构和功能特性。 计算机系统属性：编写成能在计算机硬件系统上正确执行的程序他所必须了解的计算机系统的属性，比如指令集、寄存器文件的组织等等。 计算机组成计算机组成设计人员的任务是实现计算机系统结构所体现的属性，即具体指令的实现。 计算机的基本组成冯诺依曼计算机的特点冯诺依曼计算机是存储程序型的计算机。 问题是运算器是瓶颈和各部分的组成不具有层次化特征。 由五大部分组成运算器算数运算和逻辑运算。 计算机的功能主要是运算，比如加减乘除。 控制器指挥程序的运行。 控制器控制做什么运算。 存储器存放数据和程序。 指令和数据放在存储器中。（存储程序型的计算机） 输入设备将信息转换成机器能识别的形式。 程序和数据输入到计算机中。 输出设备将结果转换成人们熟悉的形式。 计算结果的输出。 指令和数据以同等地位存于存储器，可按地址访问指令和数据用二进制表示指令由操作码和地址码组成操作码：做什么操作，指出寻址方式、指出操作数类型等等 地址码：操作数在哪里 存储程序这是核心特征。程序存储在存储器中，具有存储程序的计算机都称为冯诺依曼计算机。 以运算器为中心运算器非常地繁忙，成为计算机系统的瓶颈。 改进：以存储器为中心现代计算机硬件框图计算机的解题过程存储器的基本组成存储体存储体由若干个存储单元组成。 存储单元存储单元由多个存储元件（0/1）组成。 指令存储在存储单元中。 每个存储单元有个地址，存储单元按地址寻访。 存储字：一个存储单元中二进制代码的组合。 MAR存储器地址寄存器：反映存储单元的个数，保存存储单元的地址（编号）。 MDR存储器数据寄存器：反映存储字长。 存储字长存储单元中二进制代码的位数。 运算器的基本组成及操作过程视频P8。 计算机硬件的主要技术指标作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之继承（二）]]></title>
    <url>%2F2019%2F05%2F01%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%BB%A7%E6%89%BF%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[构造函数与析构函数 派生类只能在构造函数初始化列表中为基类或对象成员进行初始化。 当基类没有默认构造函数的情况下，派生类必须定义构造函数，并通过它为基类构造函数提供初始化值。（编译器合成的构造函数也算默认构造函数） 子类构造函数只负责直接基类的初始化。 当存在虚基类时，所有虚基类都由最后的派生类负责初始化。如果没有，则报错。 子类继承基类的构造函数C++11允许子类继承基类的构造函数，带来的方便是： 当基类构造函数有较多参数，而派生类没有数据成员需要初始化，但它必须提供构造函数，且唯一目的是为基类构造函数提供初始化值。在这种情况下，它只需要继承直接基类的构造函数就可以了。 12345class Derived:public Base&#123; ... using Base::Base; //继承基类构造函数 ...&#125;; 这个using不受访问权限的控制，放在public、private和protected区域中没有区别。 但这个using与另外两种用法（见继承第一讲）有不同之处：这个会使编译器在子类中生成代码，而用using声明基类成员时，并不生成代码。 构造函数和析构函数的调用次序基类构造函数$\rightarrow$对象成员构造函数$\rightarrow$子类构造函数（体） 多继承时，基类构造函数调用次序为继承方式中声明次序。 有多个对象成员时，按它们在子类中的声明次序调用其构造函数。 析构函数与构造函数次序相反。 这个次序要和之后出现虚拟继承后构造函数的次序进行结合，例题可看课本P173。 基类与继承类的使用根据继承的定义，我们可知任何一个派生类对象的内部都包含一个基类子对象，所以可以通过截取的方法从派生类对象中复制其基类子对象并将之赋值给基类对象。 子类对象对基类对象的赋值和初始化有两种情况：赋值和初始化。如下： 赋值123Derived d1;Base b1;b1=d1; 在把子类对象赋值给基类对象时调用基类的赋值运算符函数。 初始化12Derived d1;Base b1(d1); 1234void func(Base b);//main中Derived d1;func(d1); 以上两种情况，在用子类对象初始化基类对象时，会调用基类的拷贝构造函数。 子类指针和基类指针在这里，在逻辑上引用与指针等价。 基类指针可以指向子类对象12Derived d1;Base* pb=&amp;d1; 子类指针不能指向基类对象12Base b1;Derived* pd=&amp;b1; //错误的 若想实现类似子类指针指向基类对象的功能，需要用强制类型转换，但也只能在逻辑上正确时才能使用，否则后续使用中绝对会出错的。如下： 123Derived d1;Base* pb=&amp;d1;Derived* pd=static_cast&lt;Derived*&gt;(pb); //这里是个模板函数 多继承定义多继承即一个类继承了多个类。 123class D:public A, B,protected C&#123; ... &#125;; 成员二义性多继承情况下，当多个（1个以上）基类拥有同名成员时，会产生成员二义性。 可以通过类域限定符解决该问题，明确指出成员所属的基类。 虚拟继承虚拟继承引入的原因解决多继承引出的二义性问题。 如Student、Employee继承Person，StuEmployee继承了Student、Employee，这样StuEmployee的对象中就有两份不同的Person的数据成员。 123class Student: public Person&#123;...&#125;class Employee: public Person&#123;...&#125;class StuEmployee: public Student,public Employee,&#123;...&#125; 语法123class Student:virtual public Person&#123;...&#125;class Employee:virtual public Person&#123;...&#125;class StuEmployee: public Student,public Employee,&#123;...&#125; 构造函数调用次序 先调用虚基类的构造函数，再调用非虚基类的构造函数。 同一继承层次中有多个虚基类时，就按照它们声明次序进行构造。 若某个虚基类的构造函数已被调用，就不再调用。 若虚基类有非虚基类派生而来，则先调用该虚基类的构造函数，再调用该非虚基类的构造函数。 成员函数优先级继承层次中越靠下优先级越高。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙江理工大学2019数学建模校赛B题记录]]></title>
    <url>%2F2019%2F04%2F29%2F%E6%B5%99%E6%B1%9F%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A0%A1%E8%B5%9BB%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[第一题数据1234567891011121314w=[... 0, 80, 150, 90, 140, 100, 120; 120, 0, 180, 100, 60, 70, 110; 100, 160, 0, 80, 90, 50, 70; inf, inf, inf, 0, 40, 70, 180; inf, inf, inf, 30, 0, 80, 150; inf, inf, inf, 80, 90, 0, 50; inf, inf, inf, 130, 140, 60, 0; ];% 设甲、乙、丙三个矿区为顶点v1，v2，v3，% A、B、C、D 三个冶炼厂为v4、v5、v6、v7。% 该矩阵表示7个顶点间的距离% 由于不是对称矩阵，第一行第二行的元素表示甲到乙还是乙到甲是有区别的。题目不严谨，而老师PPT里是前者。有待区分(TODO)% TODO:graphallshortestpaths函数中的图参数 inf用0表示也可以？% 该矩阵与题给数据是否完全一样，有待比较(TODO) 建立模型构造有向图，G=(V,E, W)，顶点、边、权重。甲、乙、丙三个矿区为顶点v1，v2，v3，% A、B、C、D 三个冶炼厂为v4、v5、v6、v7。TODO:这部分可以参考骆桦PPT或者相关书籍与论文。 xij&gt;0，肯定大于0。即负数用表示同样含义的正数表示（TODO：怎么说呢） 由于可以转运： IMPORTANT：为什么不是用该矩阵中的值作为顶点之间的距离，而是根据此矩阵计算最短路径？（因为题中说可以转运，而最短路径即包括了转运的含义） 问题中最优的定义： 矿区的矿物产量刚好达到（即等于）冶炼厂矿物需求量（TODO：矿物产量和矿物需求量这两个词是否合适，应参照题目或统一规定用词），这是两个约束条件。 IMPORTANT：因为题目是求矿区到各冶炼厂间矿石的最优调运方案，所以从最短路径中提取出两个矿区（甲乙）到四个冶炼厂（ABCD）的最短距离 分别用i =1, 2表示甲乙两个矿区，j =1，2，3，4表示A、B、C、D三个电厂， cij表示第i个矿区到第j个冶炼厂的最短距离，xij表示第i个矿区到第j个冶炼厂的调运量，ai表示第i个矿区的产量，bj表示第j个冶炼厂的需求量。 这里是产量和需求平衡的运输问题 一些假设 花费与路径长度和运送量相关，所以假设花费=路径长度*运送量。在这一点可以尝试讨论，优化？ 假设调运方案中从矿区到各冶炼厂间调运吨数为整数，试试改成小数？ matlab程序计算出的最短路径矩阵，前三行后四列是我们的结果，如下。 12390 130 100 12090 60 70 11080 90 50 70 1234567891011121314151617181920212223242526272829clc;clear;w=[... 0, 80, 150, 90, 140, 100, 120; 120, 0, 180, 100, 60, 70, 110; 100, 160, 0, 80, 90, 50, 70; 0, 0, 0, 0, 40, 70, 180; 0, 0, 0, 30, 0, 80, 150; 0, 0, 0, 80, 90, 0, 50; 0, 0, 0, 130, 140, 60, 0; ];W = sparse(w);d = graphallshortestpaths(W)NodeIDs = &#123;'甲', '乙','丙', 'A', 'B', 'C', 'D'&#125;; % 结点标签，也就是h.Nodes(i).ID属性值h = view(biograph(w, NodeIDs, 'ShowWeights', 'on'))set(h.Nodes, 'shape', 'circle'); % 顶点画成圆形h.EdgeType = 'segmented'; % 边的连接为线段h.LayoutType = 'radial';trydolayout(h) % 刷新图形 会报错，故放在try块中，不影响结果，待深究catch exceptionendh2 = view(biograph(d, NodeIDs, 'ShowWeights', 'on'));h2.EdgeType = 'segmented'; % 边的连接为线段h2.LayoutType = 'equilibrium';trydolayout(h2) % 刷新图形 会报错，故放在try块中，不影响结果，待深究catch exceptionend TODO:matlab的图不怎么样。修改matlab参数、图论工具箱、网络分析工具箱、NetworkX lingo程序矩阵x和Objective Value是我们的最终结果：各矿区到各冶炼厂最优调度方案。 1234567891011121314151617model:sets:kuang/1..3 /:a; !甲乙丙矿区的产量;chang/1..4 /:b; !ABCD四个冶炼厂的矿石用量;link(kuang,chang):c,x;endsetsdata:a = 700 500 500;b = 400 300 400 600;c = 90 130 100 120 90 60 70 110 80 90 50 70;enddatamin = @sum(link: c * x);@for(kuang(i):@sum(chang(j):x(i, j)) = a(i));@for(chang(j):@sum(kuang(i):x(i, j)) = b(j));end TODO：检验答案正确性 135000.0 1234结果：三个矿区到四个冶炼厂的调度方案400 0 200 1000 300 200 00 0 0 500 待解决主要问题图画的不行、论文（建立模型部分、假设部分），可能这只是第一题，不需要花太大精力。 第二题几乎不用假设和建模，而且老师也给了两个lingo程序。但现在问题是老师给的第二个lingo程序看不太懂，不知道怎么把B题里的数据套进去。 我借的matlab书上都有直接给代码，但很长。 最大流 12345678910111213141516171819202122model:sets:nodes/s,1,2,3,t/;arcs(nodes,nodes):c,f;endsetsdata:c=0;@text(&apos;fdata.txt&apos;)=f;enddatacalc:c(1,2)=20;c(1,3)=16;c(2,4)=4;c(2,5)=14;c(3,2)=10;c(3,4)=20;c(4,5)=8;endcalcn=@size(nodes);max=flow;@for(nodes(i)|i #ne# 1 #and# i #ne#n:@sum(nodes(j):f(i,j))=@sum(nodes(j):f(j,i))); @sum(nodes(i):f(1,i))=flow;@sum(nodes(i):f(i,n))=flow;@for(arcs:@bnd(0,f,c));end 最小费用最大流 1234567891011121314151617181920212223model:sets:nodes/s,1,2,3,t/:d;arcs(nodes,nodes):b,c,f;endsetsdata:d=22 0 0 0 -22;b=0;c=0;enddatacalc:b(1,2)=12;b(1,3)=3;b(2,4)=18;b(2,5)=3;b(3,2)=6;b(3,4)=9;b(4,5)=6;c(1,2)=20;c(1,3)=16;c(2,4)=4;c(2,5)=14;c(3,2)=10;c(3,4)=20;c(4,5)=8;endcalcmin=@sum(arcs:b*f);@for(nodes(i):@sum(nodes(j):f(i,j))-@sum(nodes(j):f(j,i))=d(i)); @for(arcs:@bnd(0,f,c));End 第三题可选方法数学实验13-树算法08PPT里的后三种方法： 改进的贪心 模拟退火 修改过的prim 英文论文阅读s commentary the outstanding Steiner tree papers准确解 暴力法 直接暴力，890+个可能位置。 Hanan的一个理论，被三个队伍引用，说只需要考虑和一个已知站x坐标相同并且和另外一个已知站y坐标相同的steiner点。可能的steiner点位置减少到63个。 在此基础上可以，删除角落里的点，可能的位置减少到31个。 动态规划 虽然它还是要计算已知点的所有子集，但它避免测试所有steiner点的子集。 通过该这样的方法，几个小时可以找到50个可能位置，但似乎没有人这样做。 电脑芯片设计者通常喜欢近似解，因为网络的长度并不总是操作速度的限制条件。 近似解一个近似算法是不用虚设点，直接使用最小生成树，Hwang证明这个长度不超过steiner树的150%，但这当然不满足题目的要求。 某队找到一个最好的steiner点，然后把它加进已知站，之后重复这个策略直到加了7个点或者不可能优化了。这个方法找到了一个可能解，但并不是每次都可以这样。 某队用了多种不同的启发式算法，并且用另外四个样例对他们的方法进行了测试。另外，他们在评估他们的算法时做了一个好的决定。关于最小生成树他们还给了一个优化方案，因为他们通常不能计算准确的steiner树。他们的启发式算法都用了贪心策略。他们想出了一种改进的克鲁斯卡尔算法，模仿克鲁斯卡尔但如果有利的话会使用steiner点。这个启发式算法找到了一种可能解。虽然这个算法在速度上优于上一队，但面对更大规模的问题时它不一定能找到相当好的解。 某队(也就是下边的这个论文)用了模拟退火，模拟退火根据当地重新排列规则随机从某种解移向某种解。移向一个解的概率取决于这两个解的花费和一个叫做温度的控制变量。通过一个合适的冷却速率，这个启发式算法最终停在一个几乎最优解。他们模拟了100次这个程序都得到了最优解。 总结最后简单总结一下，有两种方法： exact solution 求确切的最优解，有两种方法。 暴力枚举法 通过减少steiner点可能的位置来节约时间，仍然是在用这种方法。 动态规划 似乎没有人用这个。 近似解 通过启发式算法，求近似最优解，有几种方法。 单点贪心 每次先找到一个最好的steiner点，将其加入已知站，直至N-2或不可能有更好的解了。 改进克鲁斯卡尔算法 模仿克鲁斯卡尔，但考虑了steiner点。 模拟退火，这是最好的一个方法 还未具体去看那篇论文(1991 B Finding optimal Steiner trees) 1991 B Finding optimal Steiner trees模拟退火过程这是一种更有效的寻找所有可行的虚设点和已知点组合的方式。 我们从一个已给的虚设点和已知点组成的树开始，并且允许模拟退火程序创造一个新的配置。对每一个新配置来说，程序决定了最小生成树并且计算其长度。然后模拟退火程序在冷却计划的基础上决定是使用还是拒绝新配置。修改一个配置和评价这个修改方案都很简单。 这个方法很有普适性：任何初始配置都可能被使用，并且算法并不直接取决于固定的站点设置。 和暴力相反，模拟退火并不一定能产生绝对的最优解。然而，我们可以按照我们的希望控制其停在当前最小值（和绝对的最优解不同），同时与暴力相比，计算时间可得到很大的缩减。 虚设点有31个可能位置作为初始条件。该模拟退火程序的输入是已知点位置、steiner点的可能位置，还有一个初始路径。（我们手动找了一个最优解，并将其作为程序的输入。我们把已知网络按照三点一组的规则进行分组，每组添加一个虚设点使该组最优，然后使各组最优，得到的配置作为模拟退火的最小路径出现了几次。） 现在配置改变的方式随机从下边选择： 随机在可能位置添加一个steiner点 移除一个已加入的虚设点 将一个已加入的steiner点随机移到一个新的位置 （通过这三种方式，我们可以尝试所有可能的网络配置。如果是为了这样做，第三种方式并没有必要；但是为了给模拟退火步骤更大的自由性，我们包含了这种方法。） 使用存储起来的新配置，为了建立最小生成树和评价网络的花费，一个计算程序会被调用。这个花费然后会被程序的模拟退火部分（routine METROP from Press et al.）使用，以决定新的配置是否被保存或拒绝（根据一个意见一致的冷却计划）。 刚开始的前几次表明一个趋势：增加度为2的虚设点是没用的。虽然虚设点并不花费什么，我们决定在程序中排除这个多余，通过引入较小的虚设点花费，这个花费足够小，并不会影响在必要时加入虚设点，反而最终会处理没有必要的虚设点。 我们同时也添加了一个模拟退火中不经常出现的特点，借此这个程序可以存储测试出的最优解。（模拟退火一般只返回最终使用的配置） 结果平均迭代9800次退火，1.5min（在25-MHz 386-based PC） 用不同的种子形成不同的随机数生成器，给了5种不同的最优解，长度为94。 超过100个回合时，模拟退火总是收敛到5种中的1种，证明它适用于更大范围的steiner树的问题（当暴力是不可能的时候）。 扩展如果所有站点是有花费的 如果想用模拟退火，我们可以： 用一些暴力方法 模拟退火数量、位置、虚设点的度（嵌套退火） 修改最小生成树算法，找到花费最小（而不是路径长度最短）的树，并且用前边的模拟退火 似乎前两种方法太费时间而且效率不高，我们选择第三种。 虽然模拟退火不一定能给出最优解，但它在100次试验之后，确实给了最优解（暴力检查过）。 工作记录 2019.4.4 工作 尝试做第一题，写了一些假设，思路和需要注意的点等等。 感想 平常还是要做好充足的准备，不要等着题发下来了才去详细了解某些知识和算法。比如这次校赛，昨天出的题，B题就是课上讲过的东西，如果当时抽时间具体研究了，现在不是就已经会了吗？（虽然现在刚学习建模不久，而且当时好像没时间……当然是选择原谅自己） 2019.4.5 工作 实现第一题matlab程序，发现作的图好丑，不够清晰。寻求解决办法，了解到网络分析工具箱、NetWorkX等。 感想 擒贼先擒王。最终目的是写一篇好的论文。现在应该把整个思路给定下来，大体上进行实现。不是能因为这个图花费太多时间，应该在后期优化。 2019.4.6 工作 实现第一题lingo程序，得到答案。重新回顾第一题，整理思路、材料和之后需要做的相关工作。 看第二题，最小费用最小流，好像得出答案比较简单。了解steiner树，查阅文献。 感想 道阻且长，我应该对lingo、matlab极其熟悉吗？ 2019.4.7 工作 阅读英文论文点评并总结，着手查看比较好的一篇论文。 感想 类似的问题，可以直接去看论文。另一方面，更好的是去看论文点评，能够站在顶层往下学习还是很不错的一种体验。 问题让求steiner树，我们可能是要先证明每个图中steiner树是一定存在的？ 2019.4.8 工作 阅读英文论文模拟退火部分并总结，解决第二题最小费用最大流。 2019.4.9 工作 上完建模课和队友讨论，知道了凸包..…突然发现题目要求很变态的一点，管道必须是平行于x轴或y轴的。这个是求出结果后不证自明，还是过程中就要求判断呢。 2019.4.10 工作 知道凸包是什么了，知道了美赛91为什么用L距离，又了解了几种求近似解的方法。着手模拟退火算法 感想 啊..……不会………..…..…不想说话 2019.4.11 工作 学习模拟退火，学了一半吧 2019.4.12 工作 继续学习模拟退火，学完了，知道是什么，大概知道怎么用。 着手将题目与模拟退火结合，设计代码。 2019.4.13 工作 敲代码，整体结构敲出来了，差一个扰动函数 感想 matlab的基础还是不足，很多东西都需要搜着做 2019.4.14 工作 写扰动函数，尝试调参。难呐..… 2019.4.17 工作 通过暴力，发现这个题和普通的steiner树不一样，按普通的steiner树求解的话，是不符合题目要求的。 核心呐：它要求边水平或竖直，这样目标函数就应该改成合法性了。 设想了目标函数为合法性的算法如何实现。 2019.4.20 工作 实现目标函数为合法性的程序，最终可以求得合法的steiner树。但无用的steiner点太多了，需要优化。 2019.4.21 工作 在合法树的基础上进行长度和steiner点个数的优化。 遗留了一个问题：自己写的一个函数总是出问题，不符预期。 2019.4.22 工作 解决昨天遗留的问题，写函数优化无用的steiner点。（原因是在for循环中数组变小了，然后就越界了，python中也有这样的东西嘛我记得 求得最终答案（不知道强迫症还是什么，总感觉有隐患..…，不过本来的思路就是求近似最优解..） 整理代码，完善注释。 那个无用的steiner点即使写了优化函数之后还是有，原因是去掉无用点之后，调用最小生成树算法，这个算法导致有多余的steiner点的产生。 2019.4.23 工作 讨论结果和论文思路，分工 2019.4.24 工作 中午下课吃完饭回来就写论文，晚上剪头，吃麻辣烫看了两集BigBang，回来继续写，写到现在11点半了，写了2500+字。主体部分已经写了有四分之三了，一些细节写在了注释里。耶 2019.4.25 工作 上下午第四节都在写论文，算法设计与分析课上也在写论文..…整体上是写完了，剩下的工作是补充细节。 2019.4.26 工作 快中午的时候开始补充论文细节，一直到晚上，效率挺低的，可能是分工问题，另外是还有一些讨论的工作。 2019.4.27 工作 流程图、公式、标题、字体、程序代码等等都搞定了，差不多结束了，第一题代码太烂就先算了吧，那个不重要。 2019.4.28 工作 搞细节咯，还修改了个流程图。检查了几遍，结束咯~ 整个过程想来还是挺艰辛的，大多都是在尝试，不断地试错然后改进，可能建模都这样吧。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数学建模</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-第五章作业]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[5.6题目编写程序，将一个包含有20个数据的数组M分成两个数组：正数数组P和负数数组N，并分别把这两个数组中的数据个数显示出来。 流程图123456789101112131415161718flowstart=&gt;start: 开始getNum=&gt;operation: 取数组下个元素whetherNegative=&gt;condition: 是负数？isPositive=&gt;operation: 存入正数数组isNegative=&gt;operation: 存入负数数组whetherEnd=&gt;condition: 数组最后一个元素？showNegative=&gt;operation: 显示偶数个数showPositive=&gt;operation: 显示奇数个数end=&gt;end: 结束start-&gt;getNum-&gt;whetherNegativewhetherNegative(yes)-&gt;isNegativewhetherNegative(no)-&gt;isPositiveisNegative-&gt;whetherEndisPositive-&gt;whetherEndwhetherEnd(no)-&gt;getNumwhetherEnd(yes)-&gt;showPositive-&gt;showNegative-&gt;end 程序初始数组中存放20个数字：1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495data segment separator0 dw &apos;A&apos; ; 间隔符，方便查看内存内容 array dw 1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10 ; 存放数组 separator1 dw &apos;A&apos; ; 间隔符，方便查看内存内容 P dw 20 dup (?) ; 存放正数 separator2 dw &apos;A&apos; ; 间隔符，方便查看内存内容 N dw 20 dup (?) ; 存放负数 separator3 dw &apos;A&apos; ; 间隔符，方便查看内存内容 lenOfArray equ 20 ; 数组长度 lenOfP db 0 ; 存放正数的个数 lenOfN db 0 ; 存放负数的个数 positive db 0dh, 0ah, &apos;the positive number is：&apos;, &apos;$&apos; ; 正数的个数是： negative db 0dh, 0ah, &apos;the negative number is：&apos;, &apos;$&apos; ; 负数的个数是： crlf db 0dh, 0ah, &apos;$&apos; ;回车换行data ends; --------------------------------------------------------------------------code segment main proc far assume cs: code, ds: datastart: ; 为返回DOS做准备 push ds ; ds入栈 sub ax, ax ; ax置0 push ax ; 0入栈 ; ds存储数据段地址 mov ax, data mov ds, ax ; 给ds赋值 begin: mov cx, lenOfArray ; 遍历array，cx置为array的长度 lea bx, array ; 将array存入bx lea si, P ; 将P存入si lea di, N ; 将N存入di begin1: mov ax, [bx] ; ax指向array数组 cmp ax, 0 ; 判断是否为负数 js isnegative ; 结果为负则转移至isnegative mov [si], ax ; 是正数，存入正数数组 inc lenOfP ; 正数个数+1 add si, 2 ; si后移 jmp short next ; 判断array数组的下一个元素 isnegative: mov [di], ax ; 是负数，存入负数数组 inc lenOfN ; 负数个数+1 add di, 2 ; di后移next: add bx, 2 ; bx后移 loop begin1 ; cx为0是跳出循环，运行后边的代码 lea dx, positive ; 显示正数个数 mov al, lenOfP call display ; 调显示子程序 lea dx, negative ; 显示负数个数 mov al, lenOfN call display ; 调显示子程序 ret main endp ; -------------------------------------------------------------------------- display proc near ; 显示子程序 mov ah, 9 ; 调用9号DOS功能，显示一个字符串 int 21h ; DOS系统功能调用 aam ; 将(al)中的二进制数转换为二个非压缩bcd码 add ah, ‘0’ ; 变为 0～9 的 ASCII 码 mov dl, ah mov ah, 2 ; 调用2号DOS功能，显示一个字符 int 21h add al, ‘0’ ; 变为 0～9 的ASCII码 mov dl, al mov ah, 2 ; 调用2号DOS功能，显示一个字符 int 21h lea dx, crlf ; 显示回车换行 mov ah, 9 ; 调用9号DOS功能，显示一个字符串 int 21h ret display endp ; 显示子程序结束code ends ; 以上定义代码段; --------------------------------------------------------------------------end start 结果 5.7题目试编写一个汇编语言程序，求出首地址为array的100D字数组中的最小偶数，并把它存放在AX中。 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253data segment array dw 100 dup(?)data ends; --------------------------------------------------------------------------code segment main proc far assume cs: code, ds: datastart: ; 为返回DOS做准备 push ds ; ds入栈 sub ax, ax ; ax置0 push ax ; 0入栈 ; ds存储数据段地址 mov ax, data mov ds, ax ; 给ds赋值 begin: mov bx, 0 mov cx, 100 compare: mov ax, data[bx]; 取数组的第一个数 add bx, 2 test ax, 01h ; 是偶数吗？ loopnz compare ; 不是，则比较下一个数 jnz stop ; 没有偶数，退出 jcxz stop ; 最后一个数是偶数，即为最小偶数，退出 compare1: mov dx, data[bx]; 取数组的下一个数 add bx, 2 test dx, 01h ; 是偶数吗？ jnz next ; 不是，比较下一个数 cmp ax, dx ; (ax)&lt;(dx)吗？ jle next mov ax, dx ; (ax)&lt;(dx)，则置换(ax)为最小偶数 next: loop compare1stop: retmain endpcode ends ; 以上定义代码段; --------------------------------------------------------------------------end start 5.12题目有一个首地址为MEM的100D字数组，试编制程序删除数组中所有为0的项，并将后续项向前压缩，最后将数组的剩余部分补上0。 程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849data segment mem dw 100 dup (?)data ends; --------------------------------------------------------------------------code segment main proc far assume cs: code, ds: datastart: ; 为返回DOS做准备 push ds ; 设置返回 dos sub ax, ax push ax ; ds指向代码段 mov ax, data mov ds, ax ; 给ds赋值 begin: mov si, (100-1)*2 ; (si)指向 mem 的末元素的首地址 mov bx, -2 ; 地址指针的初值 mov cx, 100 comp: add bx, 2 cmp mem [bx], 0 jz cons loop comp jmp finish ; 比较结束，已无0，则结束 cons: mov di, bx cons1: cmp di, si ; 到了最后单元吗？ jae nomov mov ax, mem [di+2] ; 后面的元素向前移位 mov mem [di], ax add di, 2 jmp cons1 nomov: mov word ptr [si], 0 ; 最后单元补 0 loop comp finish: retmain endpcode ends ; 以上定义代码段; --------------------------------------------------------------------------end start 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火学习]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[与贪心的区别出现较好的解就使用，发现不了就形成解。缺点：跳不出局部最优解 模拟退火：与贪心类似，但可以以一定的概率跳出局部最优解，通过两个式子实现，Metropolis准则。玻尔兹曼分布 模拟退火算法和物理退火过程的对应 模拟退火算法 物理退火过程 解 粒子状态 目标函数 能量 最优解 能量最低态 设定初温 设置加温到几度 扰动 热涨落 metropolis采样过程 热平衡，粒子状态满足玻尔兹曼分布 控制参数的下降 冷却 伪代码缩进代表层级嵌套关系。 构造一个初始解，令当前解为该解。 设置初始温度，初始温度要设得比较高。 主要算法，while循环： 循环条件可以是温度的阈值或者是解不怎么变化了 for循环，设置一个步长 平衡过程，在该温度下，使达到平衡（metropolis），恒温下1到$T_L$步 根据当前解随机生成一个邻解，跟当前解非常接近（扰动，for循环就是多次扰动） 计算邻解的目标函数（花费、路程、大小、钱数等等），减去当前解的目标函数，求得目标函数变化量 如果变化量小于0（即优化了），使用该邻近解；如果没有优化，则用metropolis准则，看是不是要跳出坑，跳出则使用该邻解。（温度越高越容易跳出坑） 平衡后设置新温度，即降温。 模拟退火算法设计要素初始解的生成如果初始解比较好的话，收敛得就很快。 通常以一个随机解作为初始解，并保证理论上能生成解空间中任意的解。（一般要多做几次模拟退火，即试用不同的初始解，再取最优的） 也可以是一个挑出来的比较好的解。这种情况下，初始温度应当设置得较低（降低它扰动到其他不好的解的概率）。 初始解不宜“太好”，否则很难从这个解的邻域中跳出。 邻解生成函数应尽可能保证产生的候选解能遍布整个解空间。 邻域应尽可能的小，能够在少量循环内充分探测，但每次的改变不应该引起太大的变化。 初始温度如何设定初始温度应该尽可能的高，以确保最终解不受初始解影响，但过高又会增加计算时间。 均匀抽样一组状态，以各状态目标值的方差为初温。（随机生成一组解） 等等 ※ 正式开始退火算法前，可进行一个升温过程确定初始温度：逐渐增加温度，直到所有尝试运动都被接受，将此时的温度设置为初始温度。 等等 等温步数如何确定等温步数即同一个温度下，跑几个循环。 等温步数也称Metropolis抽样稳定准则，用于决定在各温度下产生候选解的数目，通常取决于解空间和邻域的大小。如果解空间小，步数可以小一点。 等温过程是为了让系统达到平衡，因此可通过检验目标函数的均值是否稳定（或连续若干步的目标值变化较小，这个可以写一个函数来检测）来确定等温步数。等温步数可以长，也就是多平衡一会而已。 等温步数受温度的影响。高温时，等温步数可以较小；温度较小时，等温步数要大。随着温度降低，增加等温步数。（因为高温的时候比较混乱， 温度小的时候就在不停地收敛了），可以将等温步数设置成一个温度的函数。 有时为了考虑方便，也可以直接按一定的步数抽样。不区分高温和低温时的等温步数，大一点就好啦。 如何降温一般要慢慢地降 经典模拟退火算法降温方式 快速模拟退火算法降温方式 常用的其他降温方式 后边两种比较常用 花费函数不要太复杂，应该能被快速的计算，花费函数的计算是程序的可能瓶颈。 一般用目标函数构造花费函数即可。目标函数、目标函数的倒数/相反数经常直接作为花费函数 终止条件理论上温度降为0才终止退火算法，因为此时没有概率跳出坑了。但实际温度较低时，尝试的接受概率就几乎为0了。 设置终止温度的阈值，或设置外循环循环迭代次数。 算法搜索到的最优值连续若干步保持不变。 其他有人说这就是遗传算法+梯度下降。老师说这个算法属于一种蒙特卡洛算法，和蒙特卡洛算法类似。国赛和美赛几乎不会考TSP，太简单了，小比赛才有可能让选手练手。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>数学建模</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之继承（一）]]></title>
    <url>%2F2019%2F04%2F16%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[继承的概念继承源于生物界，指后代能够传承前代的特征和行为。 基类和子类继承使我们可以通过一个已有的类创建一个新类，新类自然获得已有类的全部功能。在某个继承关系中，已有的类在这个继承关系中作为基类、超类或父类，新类称为派生类或子类。 具体来讲，子类复制了基类的全体数据成员和成员函数。此外，子类还可以进行扩充、修改和重定义。 同一个类可以作为多个类的基类，一个子类也可以作为另一个类的基类。 基类和子类是继承关系中的概念，并不是本质的概念，而是关系上的概念。 继承与派生A作为基类，B作为子类时，我们称： B继承A A派生B 单继承和多继承只能从一个基类派生的继承称为单继承，即一个类一次最多继承一个基类。 可以从多个基类派生的继承称为多继承。 C++支持单继承和多继承。 Java只支持单继承，需要“多继承”时使用接口实现。（接口是什么，学了Java就知道了） 类成员访问权限C++类成员访问权限默认为private。 public语法正确的条件下，访问不受控制，在哪里都可以访问。 private只能在类内、友元函数访问。 protected只能在类内、子类内、友元函数访问。 继承方式注意：继承方式决定的是子类如何继承基类成员的访问权限。 不同继承方式会不同程度地改变基类成员在派生类中的访问权限。（个人觉得这句话不好，易让人误解） C++中继承方式默认为private。 public基类成员的访问权限在派生类中保持不变。 基类的private成员、public成员、protected成员在子类中保持他们在基类中相同的访问权限。 private基类成员的访问权限在派生类中全部变为private。 protected基类的public成员的访问权限在派生类中变为protected。 private成员和protected成员的访问权限不变。 派生类对基类的扩展派生类可以： 增加新的数据成员和成员函数 重载从基类继承到的成员函数 覆盖（重定义）从基类集成到的成员函数 改变基类成员在派生类中的访问属性（通过继承方式实现） 派生类不能继承基类的以下内容： 析构函数 基类的友元函数 静态成员 静态数据成员 静态成员函数 注意： 静态成员为整个继承体系公有。 C++11之前，派生类不能继承基类的构造函数，C++11之后可以，通过using实现。 成员函数的重定义、重载及隐藏派生类对继承到的基类成员函数的重定义或重载都会影响它们在派生类中的可见性。 派生类对基类函数进行重定义或重载时，由于继承和类作用域的原因，导致了隐藏，解决隐藏有三种方法。 影响可见性： 如果派生类重定义或者重载了基类中某个函数名为func的函数，则基类中的所有名字为func的函数都会被隐藏。（其中隐藏指的是在派生类中不能直接看到这个函数。） 解决： 通过基类名称访问被派生类重定义或重载隐藏的函数， 如基类::函数名(...)。 重载基类的所有同名函数，这些重载函数的代码与基类完全相同。 使用using。 前两种方法都很繁琐。 而C++11提供了using使基类中被隐藏的函数在派生类中可见，具体使用在后边的using部分讲解。 重定义是什么覆盖也称为重定义、重写。 重定义是指派生类定义与基类具有相同参数列表的同名成员函数。 （关于重定义的定义，我个人认为书上P147的说法是错的。） 隐藏及解决代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class Base &#123;public: void print() &#123; cout &lt;&lt; "Base::print()" &lt;&lt; endl; &#125; void print(int i) &#123; cout &lt;&lt; "Base::print()......" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived :public Base &#123;public: int print() //重定义Base类的void print() &#123; cout &lt;&lt; "Derived::print()" &lt;&lt; endl; return 0; &#125;&#125;;int main()&#123; Base b1; Derived d1; b1.print(); //Base类调用函数正常 b1.print(1);//Base类调用函数正常 d1.print(); //Base类中的print()被隐藏，调用Derived类的print() d1.print(1);//该行报错，编译不通过。原因是Derived类的int print()重定义了Base类的void print()，导致Base中所有同名函数被隐藏，即print(int)和print()被隐藏。 d1.Base::print(); //调用Base类的print() d1.Base::print(1); //调用Base类的print(int) return 0;&#125; 将第34行注释后，输出结果如下： 12345Base::print()Base::print()......1Derived::print()Base::print()Base::print()......1 重载是什么重载与重定义不同，重载要求成员函数名称相同，但具有不同的参数列表。 （关于重载的定义，我个人认为书上P147的说法是错的） 隐藏及解决123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class Base &#123;public: void print() &#123; cout &lt;&lt; "Base::print()" &lt;&lt; endl; &#125; void print(int i) &#123; cout &lt;&lt; "Base::print()......" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived :public Base &#123;public: void print(char i) //重载Base类的两个print函数，即print()、print(int i) &#123; cout &lt;&lt; "Derived::print()......" &lt;&lt; i &lt;&lt; endl; &#125; //int print(int i);//这个是重定义Base的void print(int i)，而非重载&#125;;int main()&#123; Base b1; Derived d1; b1.print(); //Base类调用函数正常 b1.print(1);//Base类调用函数正常 d1.print(); //该行报错，因为Derived的print(char i)重载了Base类的两个print函数，它们在Derived类中被隐藏了 d1.print('A');//调用Derived类的print(char i) d1.Base::print(); //调用Base类的print() d1.Base::print(1); //调用Base类的print(int) return 0;&#125; 将第33行注释后，输出结果如下： 12345Base::print()Base::print()......1Derived::print()......ABase::print()Base::print()......1 usingusing有三个用途： 使隐藏的函数重现 改变基类成员在派生类中的访问权限 使子类继承基类构造函数（在继承第二讲中讲解如何使用） 使隐藏函数重现方法：在派生类中用using 基类::函数名;声明基类的函数名，不需提供函数参数。 一条using可以把指定函数名的所有版本添加到派生类作用域中，它们的访问权限与using语句所在区域的访问权限相同。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Base &#123;public: void print() &#123; cout &lt;&lt; "Base::print()" &lt;&lt; endl; &#125; void print(int i) &#123; cout &lt;&lt; "Base::print()......" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived :public Base &#123;public: void print(char i) //重载Base类的两个print函数，即print()、print(int i) &#123; cout &lt;&lt; "Derived::print()......" &lt;&lt; i &lt;&lt; endl; &#125; using Base::print;&#125;;int main()&#123; Derived d1; d1.print(); //不加using的话该行报错 d1.print('A');//调用Derived类的print(char i) return 0;&#125; 改变基类成员在派生类中的访问权限在派生类的public、protected或private权限区域内，使用using再次声明基类的非private成员，就可以重新设置它们在派生类中的权限为using语句所在区域的权限。 继承和类作用域在存在继承关系时，派生类的作用域嵌套在基类作用域的内层。 因此，在解析类成员名称时，如果在本类的作用域内没有找到，编译器会接着在外层的基类作用域内继续寻找该成员名称的定义。 在这个寻找的过程中，一旦在某个作用域找到了，就停止查找，即使外层作用域内还有同名成员，也不找了。 形式如下： 12345678Base &#123; int print(int)&#123;&#125; ... Derived &#123; void print() ... &#125;&#125; 代码验证： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Base &#123;public: void print(int i) &#123; cout &lt;&lt; "Base::print()......" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived1 :public Base &#123;public: void print() &#123; cout &lt;&lt; "Derived::print()......" &lt;&lt; endl; &#125; &#125;;class Derived2 :public Derived1 &#123;&#125;;int main()&#123; Derived2 d; d.print(1); //该行代码报错，因为在Derived1中找到同名函数void print()，不会再向外层找，又因为参数列表不匹配，所以报错 return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目开发记录]]></title>
    <url>%2F2019%2F04%2F12%2F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一段旅程算是结尾了吧，以下为本学期开发记录： 2.26 晚上 整理项目里的代码和注释 2.27 中午至下午 解决先登录问题 2.28 下午 解决先登录问题 3.1 中午至下午 解决先登录后续问题：控制台warning，路由重复 尝试数据持久化，redux-persist 3.2 下午 数据持久化 redux-persist。combineReducer？ persistCombineReducer? 3.3 循环injectedReducers，发现有个root，还有动态的数据持久化配置不好实现，改用localStoreage 3.11 晚上 给后端分任务：规定用户名和密码格式要求，并检测其合法性，新的页面要显示什么内容，前后端交互 3.19 下午 总结项目，明确各自的任务 3.23 下午 和hyk讨论前后端合作。 3.25 下午 开发编辑/显示标准基本信息界面，定义与后端交互的接口内容 3.27 早上、晚上 开发修改密码页面，补充标准基本信息界面提交功能 3.30 上午 前后端交互测试成功。向老师汇报情况 3.31 项目上传至coding]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-实验（二）常用网络指令]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[实验目的 学会并掌握常用网络命令。 学会分析在不同参数下显示的数据。 实验仪器PC机、局域网 常用命令arp知识点扫盲：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。 功能：显示和修改IP地址与物理地址之间的转换表 -a功能：（Windows下）显示当前的ARP信息，可以指定网络地址。 Linux系统中，使用-g。 代码： 1arp -a # 显示当前所有的ARP信息 结果： Internet Address Physical Address Type 192.168.1.178 00-16-ec-a0-42-fa dynamic ..… ..… ..… 代码： 1arp -a 192.168.1.178 # 显示指定IP(即192.168.1.178)的ARP信息 结果： Internet Address Physical Address Type 192.168.1.178 00-16-ec-a0-42-fa dynamic -s功能：添加主机，并将网络地址跟物理地址相对应，这一项是永久生效的。 代码： 12arp -s 157.55.85.212 00-aa-00-62-c6-09 # 在IP和物理地址转换表中添加一项arp -a 157.55.85.212 # 显示指定IP(即157.55.85.212)的ARP信息 结果： Internet Address Physical Address Type 157.55.85.212 00-aa-00-62-c6-09 static 注意：这里添加的一个Type为static的。 -d功能：删除指定的主机，可以使用* 来删除所有主机。 代码： 12arp -d 157.55.85.212 # 删除指定IP(即157.55.85.212)arp -a 157.55.85.212 # 显示指定IP(即157.55.85.212)的ARP信息 结果： 1NO ARP Entries Found ftp知识点扫盲：文件传输协议，即FTP(File Transfer Protocol)。是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议。 ftp也是一种服务。一旦启动，将创建在其中可以使用ftp命令的子环境，通过键入 quit子命令可以从子环境返回到Windows命令提示符。当 ftp 子环境运行时，它由ftp命令提示符代表。 下边的指令除了ftp是在Windows命令提示符，其他都是在ftp的子环境里。 功能：控制文件的双向传输（老师说的..…）。 ftp功能：启动ftp服务。 在命令提示符下，直接输入ftp即可。 open代码： 1open 192.168.1.171 # 连接指定的ftp服务器（这里是老师的电脑） 结果： 12345678Connected to 192.168.1.171.220-Microsoft FTP Service220 张芳之家User (192.168.1.171:(none)): zf331 Password required for zf.Password:230-欢迎进入“张芳之家”230 User zf logged in. 注意：上边的第6行需要输入密码。我们输的时候，屏幕上并不会显示出来。 dir功能：查看本目录下的内容，目录可以理解成文件夹的意思。 代码： 1dir # 查看当前目录内容 结果： 12345200 PORT command successful. # 请求成功150 Opening ASCII mode data connection for /bin/ls. # ASCII传输方式连接/bin/ls04-26-13 08:22AM &lt;DIR&gt; 654 # 有个文件夹，名字是654226 Transfer complete.ftp: 收到 44 字节，用时 0.00 Seconds 44000.00Kbyte/sec. cd功能：更换远程目录。 12cd 654 # 进入文件夹654dir # 查看当前目录内容 结果： 12345200 PORT command successful. # 请求成功150 Opening ASCII mode data connection for /bin/ls. # ASCII传输方式连接/bin/ls04-26-13 08:22AM 70 qqq.txt # 有个文件，名字是qqq.txt226 Transfer complete.ftp: 收到 48 字节，用时 0.00 Seconds 44000.00Kbyte/sec. lcd功能：更换本地目录，若无参数，将显示当前目录。 代码： 1lcd e:\ 结果： 1Local directory now E:\. get功能：将远程文件复制到本地计算机。 代码： 1get qqq.txt 结果： 1234200 PORT command successful. # 请求成功150 Opening ASCII mode data connection for qqq.txt(70 bytes) # ASCII传输方式连接/bin/ls226 Transfer complete.ftp: 收到 70 字节，用时 0.00 Seconds 70000.00Kbyte/sec. quit功能：退出ftp服务。ftp子环境下输入quit即可。 结果： 1221 再见！欢迎下次“张芳之家” ipconfig功能：显示当前的TCP/IP配置的设置值。 代码： 1ipconfig 结果： 1234567Windows IP ConfigurationEthernet adapter 本地连接: Connection-specific DNS Suffix . : IP Address. . . . . . . . . . . . : 192.168.1.95 # IP地址 Subnet Mask . . . . . . . . . . . : 255.255.255.0 # 子网掩码 Default Gateway . . . . . . . . . : 192.168.1.3 # 缺省网关 telnet知识点扫盲：Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。 功能：远程连接另一台计算机 telnet功能：启动telnet。 在命令提示符下，直接输入telnet即可。 open功能：连接指定计算机。 代码： 1open 192.168.1.94 # 连接我同桌.. 结果： 12345正在连接到192.168.1.94... 您将要发送密码信息到 Internet 区域中的远程计算机。这可能不安全。是否还要发送(y/n): nlogin:ligongpassword: 注意：第四行和第五行输入账号和密码，密码并不会显示出来。 copy功能：复制文件到自己电脑上 代码： 1copy qqq.txt c:\ # 复制其e盘qqq.txt到其c盘，前提是此时已在E盘，使用cd e:\实现 quit退出，直接输入quit即可。 net知识点扫盲：它包含了管理网络环境、服务、用户、登陆等Windows 98/NT/2000 中大部分重要的管理功能。 send功能：将消息发送到网络上的其他用户、计算机或消息名。必须运行信使服务以接收邮件。 代码： 1net send * 123 # 给所有人发123 结果： 1消息已经送到域 2HJF 代码： 1net send s14 hello # 给s14机器发hello 结果： 1消息已经送到 S14 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-实验（一）]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目一问题在数据段DATA中有两个字数据X和Y, 假设X=1122H, Y=3344H, 编程求两个字的和,结果存放到Z单元中。 代码123456789101112131415161718192021222324252627282930313233;*********************************************************************data segment ; 定义数据段 x dw 1122h ; 字 X y dw 3344h ; 字 Y z dw ? ; 字 Zdata ends;*********************************************************************code segment ; 定义代码段 assume cs:code,ds:data;--------------------------------------------------------------------- main proc far ; 程序的主部分start:; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- 0 push ax ; ax压栈; ds设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax); z=x+y mov ax,x ; (ax) &lt;- x add ax,y ; (ax) &lt;- (ax)+y mov z,ax ; (z) &lt;- (ax) ; 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------code ends;********************************************************************* end start 题目二问题从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串传送到DEST_BUFFER开始的单元中。 代码123456789101112131415161718192021222324252627282930313233343536373839404142;*********************************************************************data segment ; 定义数据段 source_buffer db 20 dup(&apos;A&apos;); 串source_buffer，占20个字节，内容是20个字母Adata ends;*********************************************************************extra segment ; 定义附加段 dest_buffer db 20 dup(?) ; 串dest_buffer，占20个字节，内容未确定extra ends;*********************************************************************code segment ; 定义代码段 assume cs:code,ds:data,es:extra;---------------------------------------------------------------------main proc far ; 程序的主部分start: ; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- 0 push ax ; ax压栈 ; ds设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax) ; es设为extra mov ax,extra ; (ax) &lt;- extra mov es,ax ; (es) &lt;- (ax); 准备工作 lea si,source_buffer ; 存储源串首地址 lea di,dest_buffer ; 存储目的串首地址 cld ; 建立方向标志 mov cx,20 ; 20个字符; 移动串 rep movsb ; 移动串至CX为0，即移动整个串 ; 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------code ends;********************************************************************* end start 题目三问题从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串向下移10个单元。 代码1234567891011121314151617181920212223242526272829303132333435;*********************************************************************extra segment ; 定义附加段 source_buffer db 20 dup(&apos;A&apos;) ; 串source_buffer，占20个字节，内容是20个字母A dest_buffer EQU source_buffer+10; 串dest_buffer，结果串的首地址extra ends;*********************************************************************code segment ; 定义代码段 assume cs:code,es:extra;---------------------------------------------------------------------main proc far ; 程序的主部分start: ; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- 0 push ax ; ax压栈 ; es设为extra mov ax,extra ; (ax) &lt;- extra mov es,ax ; (es) &lt;- (ax) ; 准备工作 lea si,source_buffer+19 ; 存储源串末地址 lea di,dest_buffer+19 ; 存储目的串末地址 std ; 建立方向标志 mov cx,20 ; 20个字符; 移动串 rep movs es:byte ptr[di],es:[di] ; 移动串至CX为0，即移动整个串 ; 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------code ends;********************************************************************* end start BUG不小心，上边代码写错了,rep movs ds:byte ptr[di],ds:[di]，源地址和目标地址不小心都用了di。 按说这样不能进行后移，但却得到了正确的结果。 经过调试，发现可能是编译环境自行将我的错误代码改成了正确代码，进行了优化。 同时也发现：rep movs ds:byte ptr[si],ds:[di]，这个代码也是错的，但也得到了正确的结果。 正确的代码应该是这样：rep movs ds:byte ptr[di],ds:[si]。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之指针悬挂]]></title>
    <url>%2F2019%2F03%2F28%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E6%8C%87%E9%92%88%E6%82%AC%E6%8C%82%2F</url>
    <content type="text"><![CDATA[什么是指针悬挂指针悬挂是一种现象，出现了悬挂指针的现象。 悬挂指针即指向非法内存的指针，也叫野指针。 非法内存指的是我们不能使用的内存，比如我们没有申请过的内存。 123int* p = (int*)12345; //让p存一个随便的地址，这里以12345为例//int* p; //p未初始化，p的值随机，一般都会指向非法内存cout &lt;&lt; *p; //运行这行代码会出错 随便让p指向一块内存（一般都会指向非法内存）。 运行这段代码时我们使用了非法内存，所以会报错。 一些指针悬挂的情况课本中有两处提到指针悬挂，分别是：合成拷贝构造函数和合成赋值运算符函数。 如果类中有指针，这两个函数可能造成指针悬挂。（看完之后想想为什么只是可能？） 代码下面给出这两种函数造成指针悬挂的代码及注释： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: int * p; MyClass()&#123; p = new int;&#125; ~MyClass()&#123; delete p;&#125; void print()&#123; cout &lt;&lt; p &lt;&lt; endl;&#125;&#125;;int main()&#123; MyClass a; MyClass b(a); //调用合成拷贝函数 //MyClass b = a; //调用合成赋值运算符 a.print(); b.print(); //据两行输出可知，两个指针指向同一块内存 return 0;&#125;//最后，B会先析构，然后A析构。//B析构会释放p指向的内存，同时这块内存变为非法内存，//此时A的指针p指向非法内存，造成指针悬挂。//A析构时delete p,使用了非法内存，这时出错 解决如果这两个系统合成的函数造成指针悬挂，我们应显式定义（自己定义）这两个函数，并使用深拷贝而非像合成的两个函数一样使用浅拷贝。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值和线性回归]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%8F%92%E5%80%BC%E5%92%8C%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[插值根据现有数据，插的值一定在曲线上。 interpl，一维插值函数。 线性回归regress $Y=b_0+b_1x_1+b_2x_2+\cdots+b_kx_k$ 拟合$x_1\ x_2\ \cdots\ x_k$与$Y$的关系 [B, Bint, R, Rint, Status]=regress(Y, X) B：回归得到的自变量系数 Bint：B的95%的置信区间矩阵 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>线性回归</tag>
        <tag>插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传染病模型]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BC%A0%E6%9F%93%E7%97%85%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[简介该模型在数学建模中可以解决很多问题。 该模型由三个微分方程构成。 建立模型定义变量假设系统中有三种人： 易感染的人 数量用$S$表示，刚开始所有人都是易感染的人 感染的人 数量用$I$表示 康复的人 数量用$R$表示（假设该传染病不致命） 微分方程$\begin{equation} \left\{ \begin{array}{r1} \frac{dS}{dt}=-\beta SI\\ \frac{dI}{dt}=\beta SI-\gamma I\\ \frac{dR}{dt}=\gamma I\\ \end{array} \right.\end{equation}$ 其中$\beta$是接触率，$\gamma$是康复率。 代码函数odesir123456789function dy = odesir(t, y, beta, gamma)% 根据传染病模型者中的y和t求出dy/dt% y=[S; I; R]dy =[ -beta*y(1)*y(2); % dS/dt beta*y(1)*y(2) - gamma*y(2); % dS/dt gamma*y(2); % dR/dt] 计算12345678910N = 100;beta = 0.01;gamma = 0.1;tspan = [0,50];y0 = [99,1,0];[t y] = ode45(@odesir, tspan, y0, [], bata, gamma);plot(t,y);xlabel('time');ylabel('population');legend('S', 'I', 'R'); ode23和ode45的区别：精度不一样，ode45精度高。 结果 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runge-Kutta法解微分方程]]></title>
    <url>%2F2019%2F03%2F28%2FRunge-Kutta%E6%B3%95%E8%A7%A3%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[连续问题，微分方程或偏微分方程一定能表示。比如疾病传染、新闻传播等。 离散问题，可以用差分方程或者类似于差分的算法。 一阶微分方程求解方程$y’=cos\ t$ 代码123456789clear,clc;f = @(t,y) cos(t); % 定义函数 f(t,y) = cos(t) 表示的就是dy/dt=cos(t)tspan = [0,2*pi]; % 时间t范围y0 = 2; % y的初值，用来处理积分得到的C[t,y] = ode23(f,tspan,y0); % 注意调用格式plot(t,y);xlabel('t');ylabel('y'); @表示句柄，当把一个函数作为参数传给另外一个函数，这时候必须要用句柄。这里是把函数f传给函数ode23。 结果 高阶微分方程求解方程$\begin{equation} \left\{ \begin{array}{r1} y’’=-sin\ y+sin\ 5t\\ y(0)=1\\ y’(0)=0\\ \end{array} \right.\end{equation}$ 可以将该高阶微分方程转化为两个一阶的微分方程：$\begin{equation} \left\{ \begin{array}{r1} y_1=y\\ y_2=y’\\ y’_1=y_2\\ y’_2=-sin\ y_1+sin\ 5t\\ y_1(0)=1\\ y_2(0)=0\\ \end{array} \right.\end{equation}$ 代码12345678910clear,clc;f = @(t, y) [ y(2); -sin( y(1) ) + sin( 5*t ) ]; % 两个参数分别是y1和y2的导数tspan = [ 0, 20 ]; % 时间t范围y0 = [ 1; 0 ]; % 初值，分别对应y1，y2的初值[t, y] = ode23(f, tspan, y0); % 注意调用格式plot(t,y);xlabel('t');ylabel('y');legend('y1','y2'); 结果​ 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之类和对象]]></title>
    <url>%2F2019%2F03%2F27%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[简介如何理解类和对象？ 类是一种自定义数据类型，用类定义出来的变量就是对象。 格式： 数据类型 数据; int a; A a(); 这一章的主要问题就是如何设计、实现和使用类。 设计和实现分别对应类的抽象和封装；使用即最后一步，用类实现功能。 简单地说：面向对象就是将事物定义（包括抽象和封装）成类并使用。 类的抽象和封装抽象计算机软件开发采用的抽象方法主要有两种： 过程抽象 结果给出了函数的名称、接收的参数和能够提供的功能。 数据抽象 数据抽象是面向对象程序设计方法，以数据为中心。 结果形成某事物的类，其中包括成员变量和成员函数。 简单来说，就是找出一个类有哪些变量和功能，但不用封装。 比如这是一个点餐系统。 封装分为两部分： 接口 使用者看到的东西 实现 实现抽象出的类，写.cpp代码 简单地说，就是写代码。 比如：对老师来说，课代表就是接口，课代表怎么收作业就是实现。 提问12345678910111213141516class Cxy&#123;public: double height; void growTaller() &#123; cout &lt;&lt; "drinkMilk" &lt;&lt; endl; height+=2; &#125;;&#125;;int main()&#123; Cxy cbh; cbh.growtaller(); return 0;&#125; 请找出代码里的类、对象、抽象、封装。 成员函数常量成员函数C++中，为了禁止成员函数修改数据成员的值，可以使用常量成员函数。 语法： 123class X&#123; T f(T1, T1, ...) const;&#125;; 注意： 只有类的成员函数才能定义为常量函数，普通函数不能。 常量成员函数与const参数没有关系 对象 每个对象的数据成员都有自己独立的存储空间。就像int变量一样。 注意：一个类的成员函数只有一份，所有对象共用。 注意：类的static成员只有一份，它并不算对象的数据成员。 构造函数设计默认构造函数定义书上P97下边给的定义是最准确的。 想想之前讲的默认的含义。 简单来说：如果用类定义对象时，我们没有给参数的话，调用的就是默认构造函数。 分类默认构造函数有两种： 不带参数的构造函数 1A(); 可以是我们自己定义的，也可以是编译器合成的。 所有形参都提供了默认值的构造函数 这个当然是我们自己定义的。 构造函数与初始化列表初始化列表次序初始化列表中的成员初始化次序与他们在类中的声明次序相同，与初始化列表中的次序无关。 123456789class A&#123;public: int a; int b; int c; A(int aa,int bb,int cc):b(aa),a(bb),c(cc)&#123; cout &lt;&lt; "I am a handsome constructor yo" &lt;&lt; endl; &#125;&#125;; 提问：初始化次序是什么？ 初始化列表执行时间类内初始值$\rightarrow$构造函数初始化列表$\rightarrow$构造函数体 what必须采用初始化列表？C++11之前一个类的 常量成员 引用成员 类对象成员 子类构造函数对基类构造函数的调用 等等 必须通过初始化列表进行初始化。 C++11之后除了初始化列表，可以用类内初始值yo。 析构函数若有几个对象同时结束生存期，析构函数调用顺序与构造函数顺序相反。 静态成员关键字：static。 静态成员可以是变量，也可以是函数。 注意：静态成员函数不可以访问非静态成员。think why？ 意义表示这个成员是属于整个类的。 声明和定义示例： 123456class Boy&#123;public: static int boyNum; //男孩的数量&#125;;static int Boy::boyNum； //未初始化//static int Boy::boyNum = 0；//初始化 在类内static int number；，仅仅是声明， 原则上，定义必须写在类外：static int Boy::boyNum;，值默认为0，也可以进行初始化。 访问两种方式： 通过类名访问（非静态成员不能以这种这样访问） 1cout &lt;&lt; Boy::boyNum &lt;&lt; endl; 通过对象访问 12Boy cbh();cout &lt;&lt; cbhboyNum &lt;&lt; endl; 看看下边讲的this指针？ this指针含义this用来标识一个对象，是该对象的地址，类型是Boy* const，隐含在非静态成员函数的参数里。 应用静态成员函数没有this指针，所以不可以访问非静态成员。 常量成员函数的this，类型是const Boy *。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国人口指数增长模型拟合]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%BE%8E%E5%9B%BD%E4%BA%BA%E5%8F%A3%E6%8C%87%E6%95%B0%E5%A2%9E%E9%95%BF%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[假设美国人口数满足指数增长模型$x(t)=x_0e^{rt}$，其中$x(t)$表示第$t$年的人口数，$x_0$表示第0年的人口数，即人口数初值。 思路$ x(t) = x_0e^{rt} \ \Rightarrow \ ln \,x(t)=rt+ln\,x_0 \,\Rightarrow Y=ln \,x(t)a_1t+a_2$ ， 其中$Y=ln\,x(t)$，$a_1=r$，$a_2=ln\,x_0$。 如上，将指数函数转化为线性函数，利用线性函数进行拟合，再将线性函数转化为指数函数。 代码123456789101112131415t = 1790 : 10 : 1900; % 时间p = [3.9 5.3 7.2 9.6 ... 12.9 17.1 23.2 31.4 ... 38.6 50.2 62.9 76.0]; % 人口数 Y = log(p); % 转换为线性 X = t; % 不用X直接用t也可以 a = polyfit(X, Y, 1); % X,Y线性拟合 x0 = exp(a(2)); % r = a(1); ti = 1790:1900; % 曲线的横坐标 pti = x0*exp(r*ti); % 曲线纵坐标，即拟合结果 plot(t, p, 'o', ti, pti, 'm'); % 原数据与拟合结果对比 xlabel('Year'); ylabel('Population'); 结果 可以看到，前期拟合结果较好，但是1890年到1900年曲线与原数据相比偏高。 原因是人口数并不完全符合指数增长模型，人口并不能完全地按照“J”型曲线增长，而应该是“S”型曲线。物种竞争嘛，所以刚开始的假设是不合理的，可以再进行优化。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性方程组求解]]></title>
    <url>%2F2019%2F03%2F26%2F%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[定解方程组有一组解。 $\begin{equation} \left\{ \begin{array}{r1} 2x+3y+1z = 4\\ 4x+2y+3z=17\\ 7x+1y-1z=1\\ \end{array} \right.\end{equation}$ 1234% A*X=BA = [2 3 1; 4 2 3; 7 1 -1];B = [4 17 1]';X= A\B % 求得X 不定方程组有无数组解。 $\begin{equation} \left\{ \begin{array}{r1} 4x+5y+1z=3\\ 1x+2y+4z=15\\ \end{array} \right.\end{equation}$ 1234% A*X=BA = [4 5 1; 1 2 4];B = [3 15]';X= A\B % 得无数解中的一种 超定方程组无解。 $\begin{equation} \left\{ \begin{array}{r1} 4x+5y = 3\\ 1x+2y = 15\\ 3x+1y = 12\\ \end{array} \right.\end{equation}$ 1234% A*X=BA = [4 5; 1 2; 3 1];B = [3 15 12]';X= A\B % 本来是无解的，按最小二乘法得到最接近的解 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>线性方程组求解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性和非线性拟合]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[线性拟合一阶拟合：$y=a_1x+a_2$，这就是线性拟合了。 二阶拟合：$y=a_1x^2+a_2x+a_3​$，这就不是线性拟合了。 polyfita=polyfit(x,y,n) 最小二乘法计算拟合多项式系数 x,y为拟合数据向量 n为拟合多项式次数 通过a保存多项式系数，从最高次向最低次排列 polyvaly=polyval(a,x) 计算多项式的函数值 返回在x处多项式的值 a为多项式系数，元素按多项式降幂排序 代码12345678% 求拟合多项式系数，即ax = [1.0 1.5 2.0 2.5 3.0]';y = [0.9 1.7 2.2 2.6 3.0]';a = polyfit(x,y,1) % 1指一阶拟合，也就是指多项式次数% 求拟合结果xi = 1 : 0.1 : 3;yi = polyval(a, xi); % 求多项式的函数值plot(x,y,'o',xi,yi); % 作图对比原数据和拟合结果 结果 图中点是原始数据，线是拟合结果，线有点点弯。 指定形式拟合fittype定义拟合形式 fit根据数据向量，按照某种拟合形式拟合。 代码12345x = [1.0 1.5 2.0 2.5 3.0]';y = [0.9 1.7 2.2 2.6 3.0]';p = fittype('a*x+b*sin(x)+c'); % 定义拟合形式f = fit(x,y,p) % 向量x,y按照p的形式拟合plot(f,x,y); % 作图对比拟合结果 结果 图中代码没有定义x,y也可以运行，是因为工作区中已经有这两个变量了。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab作图]]></title>
    <url>%2F2019%2F03%2F24%2FMatlab%E4%BD%9C%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[二维作图plot 简单控制语句 sin(x) &amp; cos(x)12345678910x = -2 * pi : 0.1 : 2*pi; % 切片y1 = sin(x);y2 = cos(x);plot(x, y1,'-b'); % - 实线 b 蓝色hold on % 保持当前画的图形不被覆盖掉plot(x, y2, '-r'); % - 实线 r 红色xlabel('x'); % x轴上加标签ylabel('y'); % y轴上加标签text(0, 0, '(0,0)'); % 在(0,0)加文本legend('sin x', 'cos x'); % 图例 two hearts12345678910t = 0 : pi/180 : 4*pi; % 切片x = 16*sin(t).^3; % x,y用参数为t的方程表示y = 13*cos(t) - 5*cos(2*t)... % 本行未结束 -2*cos(3*t) - cos(4*t);plot(x-3, y, '-r', x+3, y, '-b');xlabel('x'); % x轴上加标签ylabel('y'); % y轴上加标签axis([-20, 20, -20, 15]); % 坐标范围：x [-20,20] y [-20,15]title('Two Hearts'); % 标题legend('U', 'I'); % 图例 对数坐标loglog，双对数坐标。 semilogx，只有x是对数。 12345678x = 10*2.^[0:6];y = [100 150 225 340 ... 510 765 1150];loglog(x, y, '.-r'); % 点实线 红色xlim([0.5e1, 0.8e3]); % x坐标范围ylim([0.8e2, 1.4e3]); % y坐标范围xlabel('x'); ylabel('y'); 极坐标polar 123theta = 0 : pi/180 : 4*pi; % 角度r = 1- sin(theta); % 长度polar(theta, r, '-r'); % 实线 红色 三维作图plot312345678910t = 0 : pi/50 : 10*pi; % 2pi是一圈 10pi转5圈 x = sin(t);y = cos(t);z = t;plot3(x, y, z); % 3维title('Helix');xlabel('sin t');ylabel('cos t');zlabel('t');grid on % 打开网格 三维曲面meshgrid，生成绘制3D图形所需的网格数据。 [x, y]=meshgrid(1:3, 1:3) mesh，surf 12345678[x, y] = meshgrid(-pi:0.1:pi); % 生成数据z = sin(x) .* cos(y);mesh(x, y, z); % 作图surf(x, y, z); % 使有颜色xlabel('x'); ylabel('y');zlabel('z');title('sin x sin y'); 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>可视化</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab基础]]></title>
    <url>%2F2019%2F03%2F24%2FMatlab%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本命令和语句clear clear y 删除y变量 clear 删除所有变量 clc清空屏幕输出 文件命名规则matlab文件命名规则和C语言变量命名规则类似。 help帮助文档，help functionname。 lookfor寻找含关键字的函数，lookfor keyword。 向量一行中的元素可以用逗号或者空格隔开。 分号表示一行向量的结束。 切片起点：步长：终点，步长可以省略，默认为1 转置A&#39; linespace类似切片，均匀生成几个数字，得到行向量。 常用矩阵zeros零矩阵，参数是行数和列数或者方阵行数。 ones1矩阵，参数同zeros。 eye单位矩阵 固定变量piπ i或者j虚数，$\sqrt{-1}$。 Inf无穷大 NaN不是一个数字，not a number。 矩阵运算矩阵指2维向量，向量指1维向量。 矩阵加法同型矩阵同位置元素相加。 若矩阵+向量，每行/列都会加该向量。 矩阵减法类似于矩阵加法。 矩阵乘法/除法点乘点除A.*B，对应位相乘。 次方A^2 点次方A.^2，每一位都次方。 矩阵取值双索引A(1,3)`，第一行第三列元素。 单索引matlab是竖着数的。 若A是三行三列的矩阵，则A(1,2)==A(4)。 取行/列向量A(2,:)，取A的第二行所有列，即第二行。 比较和逻辑运算同位置元素进行比较，&gt;、&lt;、&amp;、|、==、异或xor(x&gt;5,y&lt;7)。比如A==B。 x(x&lt;0)=0，将x中小于0的赋值为0 y(y(:,1)&lt;0,:)=0，如果某行第一列小于0，整行赋值为0 矩阵操作函数设A是矩阵，B是行向量，C是列向量。 flipud上下旋转 fliplr左右旋转 rot90沿副对角线旋转，与转置不同。 sum求和。 sum(B) 求该行的和 sum(A) 每列求和，得到一个行向量 sum(A，1) 等价于sum(A)，1代表维度，列是第一个维度。 sum(A，2) 每行求和，得到一个列向量。 sum(A(:)) 整个矩阵求和。A(:)将矩阵A拉成一个列向量。 max max(B) 求一行的最大值。 max(B,2) 每个元素与2比较，得最大值；若小于2，则结果为2；若大于2，则结果为该元素。 max(A) 与sum类似，每列求最大值，等价于max(A,[],1)。 max(A,[],2) 每行求最大值。 常用数学函数ceil向上取整 fix靠近0取整 floor向下取整 round四舍五入取整 modmod(i,2)，取i/2的余数。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之引用]]></title>
    <url>%2F2019%2F03%2F24%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于引用，讲一个同学问的题目。 代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using std::endl; //域限定符using std::cout; //域限定符int &amp;f(int&amp; a, int b = 20)//定义函数，为了规范，应该在main前边写函数声明，main后定义函数&#123; //a是main函数中j的引用 a = a * b; //j = j * b return a;&#125;int main()&#123; int j = 10; int &amp;m = f(j); //函数f返回引用a，即j的引用，所以m是j的引用 int *p = &amp;m; //p指向j cout &lt;&lt; j &lt;&lt; endl; //200 m = 20; //m是j的引用，j = 20 cout &lt;&lt; j &lt;&lt; endl; //20 f(j, 5); cout &lt;&lt; j &lt;&lt; endl; //100 *p = 300; cout &lt;&lt; j &lt;&lt; endl; //300&#125; 知识点引用引用分为左值引用和右值引用。 左值引用是某个变量的别名，作用类似于指针，提高效率。 右值引用是绑定到右值上的引用，只能绑定到即将销毁的对象上。 域限定符命名空间是为了解决全局命名空间污染问题。 通过限定符可以使用对应命名空间内的对象（变量、函数、类型、类等）。 函数默认参数默认参数又叫做缺省参数。如何理解？ 默认 小明：小红，你在干嘛? 小明：小红，你刚才在干嘛？ 缺省 可以缺少、省略。 所有默认参数都必须出现在无默认参数的最右边。 也就是说实参从左向右给形参赋值，默认参数从右向左给形参赋值。 函数位置函数应该写在代码的哪里？ 如果使用C语言，比较好的方式是将函数声明和函数定义分开放，即在main函数前声明函数，在main函数后定义函数。 如果使用C++，最好面向对象，使用头文件和源文件。 栈相关名词谈到这个，相关的名词有两个： 堆 new出来的内存空间是在堆中的 （堆）栈 如果在main函数中定义一个int变量，这个变量就存储在栈里。 在学数据结构时，会学到栈和堆，它们是两种数据结构。 栈和函数栈有一个应用就是处理函数的嵌套，比较典型的函数嵌套就是递归。 比如上边代码中的main运行到f函数时，先要保存现在main函数的状态（变量、代码执行到的位置等），将其压栈（PUSH）；然后再进入f函数，栈顶即为f函数的内容，f函数执行完后，出栈（POP）；然后继续执行main函数。 在调试时就可以看到函数调用栈。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之课程介绍]]></title>
    <url>%2F2019%2F03%2F24%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[应要求，周六晚上开了一个课，教C/C++，之后会把课件都放在博客里。 课程简介 关于我 班级，性别，年龄。 第一次教课，希望大家及时对课堂给予一定建议与反馈。 上课时间 周六晚上六点半，时长根据上课内容的多少和难度确定。 需求 大家的需求是什么？C/C++?（我需要讲得广一点吗？） 具体希望了解哪个方面呢？ 这可能跟你的年级、所上课程有关，也有可能你们也不知道。 课程定位 该课程主要起辅助作用 学习的主要战场应在个人课下的学习和学院老师的课堂上，这个课并不是冲刺课。 由于能力和精力有限，我不能保证谁上了这个课就一定可以考高分或者不挂科。 如果合作愉快，大家一定会有收获。 我的作用是帮助大家 毕竟大二了，与大部分大一的同学相比，写代码的经验和知识面会足一些，我会尽可能把我的知识、思路和方法讲给大家。 课程要求 课堂纪律 合乎公共礼仪即可，好好听课，该请假的要跟我请假。每次课要点名的。 希望大家能做到不懂就问。 每周作业：每人提一个问题给我 这个是为了更好地了解大家的学习上遇到的困难，大家给出问题后，我可以在课堂上有针对性地进行讲解。大家的问题可能会是课堂的主要内容。 课程目标 大家解决编程中遇到的问题的能力有一定提升，能够多思考为什么 更了解C/C++，扩展知识面 课堂之外给大家帮助 课余也可以 课程内容 C/C++课程重难点 面向正在上C++、C语言课程的同学，讲解一些重点。 大家的作业：提出的问题 可以是找到的题，可以是写作业遇到的问题，都可以。 这是使这门课最大程度地为大家服务的一个方式，可以提高这门课的效用。 我遇到的有意思的问题 大概想想有数组名，指针（包括指针赋值），面向对象，抽象，C++类的互相引用等等吧。 大家有什么问题吗？ 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之数组名]]></title>
    <url>%2F2019%2F03%2F24%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E6%95%B0%E7%BB%84%E5%90%8D%2F</url>
    <content type="text"><![CDATA[我们今天讨论数组名是什么东西，理解它有助于我们进一步理解和使用指针。 因为它涉及到了内存地址。 问题数组名是什么？含义是什么？ 思路前提一个值+1之后的变化可以反映出它的意义/含义。 前提的证明其实不证自明，计算机中就是这样的。 生活中 一个苹果+1，结果是两个，增加了一个苹果。 一箱苹果+1，结果是两箱，个数是2*每箱苹果数，增加了一箱苹果。 计算机中 int型变量的地址+1，增加了一个int的大小。 double型变量的地址+1，增加了一个double的大小。 思路根据前提，通过将数组名或数组名相关的值+1来判断它的含义。 验证编程中要了解一个东西，大多时候我们可以通过输出它来了解它。 代码123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; //注释指出array代表什么 int array[5] = &#123; 1,2,3,4,5 &#125;; printf(" &amp;array[0] = %p\n", &amp;array[0]); //首元素 printf(" array = %p\n", array); //数组 printf(" array+1 = %p\n", array + 1); //数组 printf(" &amp;array[0]+1 = %p\n", &amp;array[0] + 1); //首元素 printf(" &amp;array = %p\n", &amp;array); //数组 printf(" &amp;array+1 = %p\n", &amp;array + 1); //数组 printf("sizeof(array) = %zd\n", sizeof(array));//数组&#125; 为什么用printf不是cout？用cout其实也行，printf可能更方便，而且我忘了cout怎么控制位数了。 结果1234567 &amp;array[0] = 0000002A433FF628 array = 0000002A433FF628 array+1 = 0000002A433FF62C &amp;array[0]+1 = 0000002A433FF62C &amp;array = 0000002A433FF628 &amp;array+1 = 0000002A433FF63Csizeof(array) = 20 结论数组名是什么，有什么含义数组名是一个常量（所以不能被赋值），是一个地址。（&amp;array中array并不是地址，因为地址是一个值，我们并不能取一个值的地址吧） 在不同情况下，有着不同的含义。 代表整个数组 碰到&amp;、sizeof时，数组名代表整个数组，作用像是一个变量。 代表数组首元素 数组名单独出现或碰到[]、*时，数组名代表数组第一个元素，是一个地址。（这个下次会讲） 知识点IDE、编译器、编辑器 编辑器 文本编辑器，比如notepad++，sublime。 编译器 处理我们写的代码。 C/C++的比如有：gcc，mingw。 计算机语言可以分为两种：编译语言和解释语言。 IDE Integrated Development Environment，集成开发环境。 集合了编辑器和编译器的功能，还有一些辅助开发的功能。 Visual Studio 解决方案 项目 调试 查看源码 比如看sizeof、iostream，Ctrl+左键 查看类图 右击(项目)-查看-查看类图 十六进制https://tool.lu/hexconvert/ 地址+1核心在于单位。==见下篇== sizeof占用的字节数。基本数据类型、结构体（会字节对齐）。 不同环境下（32位、64位等）某种类型的变量占用字节数可能是不同的 比如指针，32位下是4个字节，64位下是8个字节， 正好是对应计算机的字长。（后边有讲计算机字长是什么） %zd、size_t ==后边还有一篇== %p %x两者有细微差别。 重视warningVS的warning还是比较全的，其他IDE的waring不一定全。 如果写代码出了问题却找不到原因，有可能是warning给出的潜在问题没有处理。 写代码时遇到waring一定要处理，不然很容易出问题。 混合编程C和C++还是不一样的。特别是函数的使用，如果要动态申请一个类对象的内存，可别用malloc，它和new还是不一样的。 一些重要名词值生活、编程中出现的数字、字符串、字符等等，都是值。 比如1,2,3，我爱你等等。 变量变量算是对值的一个替代（或者说抽象）吧，提高复用性。 地址地址是个值。 计算机有存储空间。我们将其一个个地编号，也就是给了它一个地址。 指针指针是个变量。 跟普通变量其实没什么本质区别，只不过它被用来存储地址而已。 运算符优先级* [] &amp;的优先级？ 计算机字长字长：字的长度（位数）。 计算机中有字节这个单位。1个字节等于8位。 多个字节组成字。 我们平常说的电脑32位，64位指的就是字长。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python批量下载邮件附件]]></title>
    <url>%2F2019%2F03%2F23%2Fpython%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E9%82%AE%E4%BB%B6%E9%99%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[背景由于同学每周要通过邮箱收数学建模作业，100多人给她发附件，她要一个个地点着下载。 太麻烦了，所以想用程序实现下载附件的功能。 在网上查资料后，最终实现了稍为简单的下载附件功能，代码有些细节还不是很了解。 2019.4.16更新： 过几天我也要用邮箱收文件，有了这份代码刚好能用！这再次印证知识不会没用处的，不学才会觉得知识没用呢。 2021.01.28更新 我又写了一份新的更详细、简洁的代码：python批量处理邮件：poplib和email快速上手教程 2021.01.29更新 和评论中的一样，我也遇到了同样的问题：在163邮箱开启POP3服务后，在登录时仍然遇到poplib.error_proto: b&#39;-ERR login fail&#39;的报错，解决方法为使用开启POP3服务时拿到的授权码作为密码登录。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import poplibimport emailimport timefrom email.parser import Parserfrom email.header import decode_headerdef decode_str(s):#字符编码转换 value, charset = decode_header(s)[0] if charset: value = value.decode(charset) return valuedef get_att(msg): attachment_files = [] for part in msg.walk(): file_name = part.get_filename() # 获取附件名称类型 contType = part.get_content_type() if file_name: h = email.header.Header(file_name) dh = email.header.decode_header(h) # 对附件名称进行解码 filename = dh[0][0] if dh[0][1]: filename = decode_str(str(filename, dh[0][1])) # 将附件名称可读化 print(filename) # filename = filename.encode("utf-8") data = part.get_payload(decode=True) # 下载附件 att_file = open('D:\\数模作业\\' + filename, 'wb') # 在指定目录下创建文件，注意二进制文件需要用wb模式打开 attachment_files.append(filename) att_file.write(data) # 保存附件 att_file.close() return attachment_fileswith open('D:\\config.txt', 'r') as f1: config = f1.readlines()for i in range(0, len(config)): config[i] = config[i].rstrip('\n')# print(config)# POP3服务器、用户名、密码host = config[0] # pop.163.comusername = config[1] # 用户名 password = config[2] # 密码# 连接到POP3服务器server = poplib.POP3(host)# 身份验证server.user(username)server.pass_(password) # 参数是你的邮箱密码，如果出现poplib.error_proto: b'-ERR login fail'，就用开启POP3服务时拿到的授权码# stat()返回邮件数量和占用空间:# print('Messages: %s. Size: %s' % server.stat())# 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]resp, mails, octets = server.list()# print(mails)# 倒序遍历邮件index = len(mails)for i in range(index, 0, -1): # lines存储了邮件的原始文本的每一行 resp, lines, octets = server.retr(i) # 邮件的原始文本: msg_content = b'\r\n'.join(lines).decode('utf-8') # 解析邮件: msg = Parser().parsestr(msg_content) # 获取附件 f_list = get_att(msg)print("文件已下载完成，10秒后关闭程序！")time.sleep(10) 打包使用pyinstaller，将该.py文件打包成.exe文件。 1pyinstaller -F xuer.py 这样她就不需要安装python，方便她使用。 为了保护她的密码隐私，程序通过她自己的文件获得她的用户名和密码，之后文件会自动下载到D盘中数学建模文件夹下。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>python</tag>
        <tag>下载邮件附件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageRank]]></title>
    <url>%2F2019%2F02%2F18%2FPageRank%2F</url>
    <content type="text"><![CDATA[用Matlab实现一个PageRank算法。 介绍PageRank是一种对网页进行排名的算法，通过引用来判断网页的排名。 具体介绍自寻，可以看一下https://baike.baidu.com/item/google%20pagerank#2 题目图中有六个明星，他们之间的箭头表示关注，比如Kim和Ryan互相关注，图片中间的数字是最终计算出的他们的PageRank。 Matlab实现12345678910111213141516171819202122232425262728293031323334353637383940% Find PageRank of network by finding dominant evec%% _ _ _ _% | (1-d)/N | | l11, ..., l1n |% R = | ... | + d | ..., ..., ... | R % |_(1-d)/N_| |_ln1, ..., lnn_| %% R = c + d * L*D * R% R = (I - d * L*D )\c% clc; %清屏d = 0.85; % damping factorname = &#123;'bill', 'ellen', 'jimmy', 'kim', 'paula', 'ryan'&#125;; % celebrities'name[bil, ell, jim, kim, pau, rya] = deal(1,2,3,4,5,6); % celebrities'id，bil=1,ell=2...n = length(name); % number of celebrities,n=6L = zeros(n); % 明星关注关系矩阵,一行是一个人，元素值表示他是否关注他人;一列也是一个人，元素值表示是否被他人关注% if user j follows user i, then L(i,j) = 1L(bil, [rya, ell]) = 1; % bil关注rya ell，下五行同理L(ell, [jim, rya]) = 1; L(jim, [rya, pau, ell]) = 1;L(kim, [jim, rya, ell]) = 1;L(pau, [rya, ell])=1;L(rya, [bil, jim, kim, pau, ell]) = 1;% ot = out-degree, in = in-degreeot = sum(L,1); % 对每1列求和，得行向量，每一列是一个人，元素值为被关注次数in = sum(L,2); % 对每1行求和，得列向量，每一行是一个人，元素值为他关注了多少人k = find(ot~=0); % 找到ot中不等于0的元素的下标,在此都不为0，返回行向量[1,2,3,..,6]D = full(sparse(k,k,1./ot(k),n,n)); %对角矩阵，对角元素表示每个人对其他人的关注的分成% L*D 是 6*6矩阵，一行、一列都是一个人，一行表示得到每个人的关注的分成，列表示对其他人关注的分成c = (1-d)/n*ones(n,1); % 值为(1-d)/n 的 n行列向量I = eye(n); % n*n单位矩阵R = (I - d*L*D)\c % 注意是左除,得到6个人的PageRank 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>算法</tag>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>PageRank</tag>
        <tag>线性方程组求解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多体问题]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%A4%9A%E4%BD%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题及分析 Matlab代码给出了核心逻辑的注释，作图暂时还不太了解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function SunEarthMoon % M函数文件load planets; % 将planets.mat中的变量mass、position、velocity加载过来[sun, earth, moon] = deal(18, 3, 25); % sun、earth、moon分别是18、3、25行list = [sun, earth, moon]; % 1行3列矩阵G = 6.67e-11; % gravitational constantdt = 24*3600; % 作图的时间间隔为一天，每天有24*3600秒N = length(list); % N=3，三个天体mass = mass(list); % N行1列矩阵，N个天体的质量position = position(list,:); % N行3列矩阵，N个天体的坐标，坐标是1行3列的行向量，三个方向的分量velocity = velocity(list,:); % N行3列矩阵，N个天体的速度，速度是1行3列的行向量，三个方向的分量h = plotplanets(position); %作图函数for t = 1:365 % 图中总时间为一年，一年365天 plotplanets(position,h); % force = zeros(N,3); % N行3列零矩阵，一行表示某个天体在三个方向上的受力 for i = 1 : N % 遍历计算各天体间的万有引力。组合数C（3，2） Pi = position(i,:); % 某天体坐标 Mi = mass(i); % 某天体质量 for j = (i+1):N %the i+1 is to create diagonal Mj = mass(j); % 另一天体质量 Pj = position(j,:); % 另一天体坐标 dr = Pj - Pi; % 两天体的相对，1行3列矩阵 forceij = G*Mi*Mj./(norm(dr).^3).*dr; % 两天体之间的力，1行3列的向量 force(i,:) = force(i,:) + forceij; % 规定正方向，将力计算进矩阵 force(j,:) = force(j,:) - forceij; % 反作用力与作用力方向相反，将力计算进矩阵 % 上两行可替换为force([i,j],:) = force([i,j],:)+[forceij; -forceij]; end end velocity = velocity + force ./ repmat(mass,1,3)*dt; % v=v+a*dt a=F/m position = position + velocity*dt; % r=r+v*dtend % -------------------------------------------------------------------------function h = plotplanets(pos,h) % scale = 50;total_planets = size(pos,1);[sun, earth, moon] = deal(1, 2, 3);radius = [50, 30, 20];marker = &#123;'.r', 'b.','m.'&#125;;pos(moon,:) = pos(earth,:) + scale*(pos(moon,:)-pos(earth,:));if nargin==1 hold on; axis image axis( [-2 2 -2 2]*1e11 ); for i = 1:total_planets if any(i == [sun, earth, moon]) h(i) = plot(pos(i,1),pos(i,2),marker&#123;i&#125;,'markersize',radius(i)); plot(pos(i,1), pos(i,2), marker&#123;i&#125;, 'markersize',5); else h(i) = plot(pos(i,1), pos(i,2), 'k.', 'markersize', 20); plot(pos(i,1), pos(i,2), 'k.', 'markersize',5); end endelse for i = 1:total_planets set(h(i), 'Xdata', pos(i,1) , 'Ydata', pos(i,2) ) if any(i == [sun, earth, moon]) plot(pos(i,1), pos(i,2), marker&#123;i&#125;, 'markersize',5); else plot(pos(i,1), pos(i,2), 'k.', 'markersize',5); end end drawnowend 结果 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[椅子能在不平的地面上放稳吗]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%A4%85%E5%AD%90%E8%83%BD%E5%9C%A8%E4%B8%8D%E5%B9%B3%E7%9A%84%E5%9C%B0%E9%9D%A2%E4%B8%8A%E6%94%BE%E7%A8%B3%E5%90%97%2F</url>
    <content type="text"><![CDATA[问题把椅子放在不平的地面上，通常只有三只脚着地，放不稳，然而只需稍挪动几次，就可以使四只脚同时着地而放稳。这个看来似乎与数学无关的现象能用数学语言表述，并用数学工具来证实吗？让我们来试试看！ 再次读题把椅子 放在 不平的地面上，通常只有三只脚着地，放不稳，然而只需稍挪动几次，就可以使四只脚同时着地而放稳。这个看来似乎与数学无关的现象能用数学语言表述，并用数学工具来证实吗？让我们来试试看！ 对象分析 椅子$\Longrightarrow$四个椅脚$\Longrightarrow$与地面有四个接触点$\Longrightarrow​$正方形（本质应该是长方形） 不平的地面$\Longrightarrow​$光滑曲面（光滑是根据讨论范围确定的，不连续的很陡的地面不在讨论范围之内） 条件分析 通常只有三只脚着地，放不稳$\Longrightarrow$假设至少三只脚着地$\Longrightarrow$$F(\theta)*G(\theta)=0$ 稍挪动几次$\Longrightarrow$位置的变化$\Longrightarrow$角度$\theta$的变化 结论分析 能不能$\Longrightarrow​$存在问题，0和1 放稳$\Longrightarrow$四个脚到地面距离都为0$\Longrightarrow$两对 对角椅脚 离地面的高度之和$F(\theta)=G(\theta)=0$ 2019.3.27补充： 昨天上课学得，在某些问题中，结果为离散的0或1的问题可以转化为结果为连续值的问题。 比如目标是得到最大产值，问题是A、B、C哪里需要建厂，这涉及到原料的生产、加工、运输，成品的销售等等。 如果直接根据问题进行离散的计算，会有$2^3=8\,$种情况。 如果进行连续的计算，将某地是否建厂转化为某地的原料产量。如果产量是0，则表示该地不建厂；如果产量大于0，则表示该地建厂。 数学模型已知F($\theta​$)、G($\theta​$)是$\theta​$的连续函数，对任意$\theta​$，$F(\theta){\times}G(\theta)=0​$，且$G(0)=F(\frac{\pi}{2})=0​$，$F(0)=G(\frac{\pi}{2})&gt;0​$，证明存在$\theta_0​$，使$F(\theta_0)=G(\theta_0)=0​$。 方法总结好好读题，根据题中所给信息，找到研究对象、条件、结论等现实元素转化为一个个数学元素。 讨论关于旋转的变量除了$\theta$，转轴也可以算一个，另外还可以把正方形改为长方形进行讨论。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎交流讨论!]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（十一）之兄弟组件间传值]]></title>
    <url>%2F2019%2F01%2F22%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%B9%8B%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[原理React传递数据是单向数据流，两个组件必须有关系才可以传值。 而兄弟组件间并无直接关系，所以需要借助父组件。 兄弟组件传值原理： 简单的逻辑是这样：子组件1传值给父组件，父组件再传给子组件2。 子组件1通过函数参数传值给父组件。 父组件利用子组件1传来的值改变自身state中的某个值。 由于父组件将自身state的那个值传给子组件2，而现在state发生改变 ，子组件2会重新渲染，实现子组件1传值到 这里用到了state和更新dom的知识，不知道的可以看看。前边的文章或百度。 代码实现现有三个组件，父组件App,子组件1Header，子组件2Home，Home比Header小2岁。 实现功能：改变Header的年龄，且同步更新Home的年龄。 App.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react'; //固定写法import Header from './components/Header';import Home from './components/Home';class App extends Component &#123; //ES6写法 constructor()&#123; super(); this.state=&#123; homeAge:10 &#125; &#125; onGreet(headerAge)&#123; //父组件定义回调函数 alert("App:Header is"+headerAge+"years old!"); this.setState(&#123; homeAge: headerAge-2 &#125;) &#125; render() &#123; const user=&#123; //定义一个对象，传给子组件Header name: "Anna", hobbies: ["Sports", "Reading"] &#125; return ( &lt;div&gt; &lt;div&gt; &lt;Header greet=&#123;this.onGreet.bind(this)&#125; name=&#123;"Max"&#125; age=&#123;12&#125; user=&#123;user&#125;&gt; &lt;p&gt;I am Header's children&lt;/p&gt; &lt;/Header&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;I am App&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;Home homeAge=&#123;this.state.homeAge&#125;/&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; Header.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import React, &#123; Component &#125; from 'react'; //固定写法import PropTypes from 'prop-types';class Header extends Component &#123; //ES6写法 constructor(props)&#123; super(props); //执行父类构造方法 this.state=&#123; age:props.age &#125; //this.age=this.props.age; &#125; onMakeOrder()&#123; this.setState(&#123; age:this.state.age+3 &#125;) //this.age+=3; console.log(this); //显示当前Header类的对象 &#125; handleGreet()&#123; this.props.greet(this.state.age); &#125; render() &#123; //console.log(this.props); //显示父组件传来的参数 return ( &lt;div&gt; &lt;h1&gt;I am Header&lt;/h1&gt; &lt;div&gt; props'name is &#123;this.props.name&#125;,my age is &#123;this.state.age&#125; &lt;/div&gt; &#123;/*&lt;button onClick=&#123;() =&gt; this.onMakeOrder()&#125; className="btn btn-primary"&gt;make me older&lt;/button&gt;*/&#125; &lt;button onClick=&#123;this.onMakeOrder.bind(this)&#125; className="btn btn-primary"&gt; make me older &lt;/button&gt; &lt;br /&gt; &lt;button onClick=&#123;this.handleGreet.bind(this)&#125; className="btn btn-primary"&gt; 告诉App我几岁 &lt;/button&gt; &lt;div&gt; &lt;h4&gt;props'hobbies如下：&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt;props's children如下：&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Header.propTypes=&#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, greet: PropTypes.function, children: PropTypes.element.isRequired&#125;export default Header; Home.js123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react'; //固定写法class Home extends Component &#123; //ES6写法 render() &#123; let content=""; let flag=false; if(flag)&#123; content="cbh"; &#125; else&#123; content="cxy"; &#125; return ( &lt;div&gt; &lt;h1&gt;I am Home&lt;/h1&gt; 动态数据：&#123;content&#125; &lt;h1&gt;I am &#123;this.props.homeAge&#125; year's old&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default Home; 具体过程两个子组件本来就是12岁和10岁，无法查看传值效果。 所以先点击makeolder按钮，可以看到Header年龄变为15。 再点击告诉App我几岁按钮。 子组件1Header通过一个回调函数将自己的年龄传给父组件App，父组件再用Header传来的年龄更新自己的state； 由于父组件App给子组件2Home传的参数是state中的一个值，所以子组件2变化的部分会重新渲染，实现子组件1传值给子组件2。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阮一峰React入门教程学习笔记]]></title>
    <url>%2F2019%2F01%2F22%2F%E9%98%AE%E4%B8%80%E5%B3%B0React%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[虽然已经看视频学了一些React基础，看完阮一峰的教程还是对React有了更多的理解。 他的教程感觉还是很简洁明了的，误区、重点都有讲到。 以下为阮一峰React入门教程学习笔记，记录了一些学到的新的或重要的知识点。 文中标题与阮一峰教程中章节标题对应。 安装React 可以在浏览器运行，也可以在服务器运行。 HTML模板模板1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src="../build/react.js"&gt;&lt;/script&gt; //react核心库 &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt; //提供dom相关功能 &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt; //将JSX转为JS，很耗时间，应用上线时应将这一步放在服务器完成 &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意JSX语法为React独有，与JS并不兼容，因此使用JSX语法的时候要加上type=&quot;text/babel&quot;。 ReactDOM.render()12345ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') //h1可看作一个组件，插入id为example的DOM结点。); ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点，即挂载组件。 JSX语法介绍可以看React官网。 JSX是JS的语法扩展，它为React提供了元素。 为何使用JSXReact认为页面的渲染逻辑和UI设计的逻辑是耦合的：事件如何处理，状态如何随时间变化，以及数据如何准备显示。 React通过包含标记和逻辑的组件实现 separation of concerns。 React不是必须使用JSX，但JSX使包含UI的JS代码更加容易处理，同时也可以暴露出更多有用的报错和警告信息。 基本语法遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 它允许HTML和JavaScript的混写。 JSX 允许直接在模板插入 JavaScript 变量，JSX中的大括号内可以放置任何有效的JavaScript表达式。 组件render所有组件类都必须有自己的 render 方法，用于输出组件。 组件名组件类的第一个字母必须大写，否则会报错。 一个顶层标签组件类只能包含一个顶层标签，否则也会报错。 传参组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;John&quot;&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 John。组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 保留字问题添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 PropTypes组件类的PropTypes属性，用来验证组件实例的属性是否符合要求。 getDefaultProps 方法可以用来设置组件属性的默认值。 获取真实DOM结点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。 有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 this.stateReact 的一大创新，就是将组件看成是一个状态机。 每次修改this.setState以后，自动调用 this.render 方法，再次渲染组件。 表单要获取用户输入，需要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。 组件的生命周期组件的三种状态组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 状态的处理函数will 函数在进入状态之前调用，did函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 特殊状态的处理函数 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 React 组件样式是一个对象。 Ajax==还没学== 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（十）之子组件向父组件传值]]></title>
    <url>%2F2019%2F01%2F20%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%EF%BC%89%E4%B9%8B%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[子组件向父组件传值，一般要通过回调函数的参数。这也是 父组件定义一个回调函数，并将其传递给子组件，然后子组件调用该函数，并将值通过回调函数的参数传给父组件。 这说明了React数据传递的单向性，虽然实现了子组件传值给父组件，但本质还是父组件传给了子组件一个函数。 父组件定义回调函数App.js中定义回调函数： 123onGreet(age)&#123; //父组件定义回调函数 alert("Son is"+age+"years old!");&#125; 父组件传回调函数给子组件App.js中将定义的回调函数传给子组件： 1234&lt;Header greet=&#123;this.onGreet&#125; name=&#123;"Max"&#125; age=&#123;12&#125; user=&#123;user&#125;&gt; &lt;p&gt;I am header's children&lt;/p&gt; &lt;p&gt;I am header's children&lt;/p&gt;&lt;/Header&gt; 子组件调用回调函数子组件定义处理回函的函数Header.js中定义： 123handleGreet()&#123; this.props.greet(this.state.age);&#125; 子组件调用处理回函的函数Header.js中定义： 123&lt;button onClick=&#123;this.handleGreet.bind(this)&#125; className="btn btn-primary"&gt; Greet&lt;/button&gt; 效果展示 点击Greet按钮 点击Older按钮 点击Greet按钮 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（九）之React如何更新DOM]]></title>
    <url>%2F2019%2F01%2F19%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8BReact%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0DOM%2F</url>
    <content type="text"><![CDATA[React只重新渲染HTML页面中改变的部分。 基本原理React有一个概念：虚拟DOM。 每次操作都会生成一个虚拟DOM，然后通过diff算法和上一次的虚拟DOM进行比较，通过比较可以找到需要重新渲染的组件，然后只重新渲染这些组件，其他不变。 验证使用chrome浏览器，检查元素，按下图操作 然后页面渲染的地方会被高亮（我这里是绿色）。 每次点击按钮，会发现your name is Max,your age is XX被高亮，而其他不变。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（八）之组件的state属性]]></title>
    <url>%2F2019%2F01%2F19%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84state%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[上次讲到state更新，DOM树才会更新，原理是React会监听组件的state。 现在来试一下。 Header代码变动修改Header.js,有如下三处变动,其中注释掉的代码是上一节的代码。 1234567constructor(props)&#123; super(props); //执行父类构造方法 this.state=&#123; age:props.age &#125; //this.age=this.props.age; &#125; 1234567onMakeOrder()&#123; this.setState(&#123; age:this.state.age+3 &#125;) //this.age+=3; console.log(this); //显示当前Header类的对象 &#125; 12&lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.state.age&#125;&lt;/div&gt; //表达式中上次是this.props.age Header.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from 'react'; //固定写法import PropTypes from 'prop-types';class Header extends Component &#123; //ES6写法 constructor(props)&#123; super(props); //执行父类构造方法 this.state=&#123; age:props.age &#125; //this.age=this.props.age; &#125; onMakeOrder()&#123; this.setState(&#123; age:this.state.age+3 &#125;) //this.age+=3; console.log(this); //显示当前Header类的对象 &#125; render() &#123; //console.log(this.props); //显示父组件传来的参数 return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.state.age&#125;&lt;/div&gt; &#123;/*&lt;button onClick=&#123;() =&gt; this.onMakeOrder()&#125; className="btn btn-primary"&gt;make me older&lt;/button&gt;*/&#125; &lt;button onClick=&#123;this.onMakeOrder.bind(this)&#125; className="btn btn-primary"&gt;make me older &lt;/button&gt; &lt;div&gt; &lt;h4&gt;hobbies&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Header.propTypes=&#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, children: PropTypes.element.isRequired&#125;export default Header; 效果页面中的age会更改哟。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（七）之事件]]></title>
    <url>%2F2019%2F01%2F19%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前组件的功能都是显示字样，现在来加个按钮试试处理事件。 这里用bootstrap写一个好看点的按钮，修改html文件是为了使用bootstrap，如果不使用则不需要修改index.html。 修改html文件百度找到bootstrap的cdn。 1&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt; 将其加入index.html的&lt;head&gt;&lt;/head&gt;里边。 处理事件添加按钮及其响应函数在组件Header中添加按钮，向Header.js中加入以下代码，二选一即可 1&lt;button onClick=&#123;this.onMakeOrder.bind(this)&#125; className="btn btn-primary"&gt;make me older&lt;/button&gt; 1&lt;button onClick=&#123;() =&gt; this.onMakeOrder()&#125; className="btn btn-primary"&gt;make me older&lt;/button&gt; Header.js代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; Component &#125; from 'react'; //固定写法import PropTypes from 'prop-types';class Header extends Component &#123; //ES6写法 constructor(props)&#123; super(props); //执行父类构造方法 this.age=this.props.age; &#125; onMakeOrder()&#123; this.age+=3; console.log(this); //显示当前Header类的对象 &#125; render() &#123; //console.log(this.props); //显示父组件传来的参数 return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.props.age&#125;&lt;/div&gt; &#123;/* &lt;button onClick=&#123;() =&gt; this.onMakeOrder()&#125; className="btn btn- primary"&gt; make me older &lt;/button&gt; */&#125; &lt;button onClick=&#123;this.onMakeOrder.bind(this)&#125; className="btn btn-primary"&gt; make me older &lt;/button&gt; &lt;div&gt; &lt;h4&gt;hobbies&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Header.propTypes=&#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, children: PropTypes.element.isRequired&#125;export default Header; 效果 从图中可以看到age在不断变大，但网页上的age没有更新，这涉及到react的一个机制。 react并不是对象的属性改变的时候，DOM会改变。而是对象的state变化的时候，DOM树才会更新。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（六）之父组件向子组件传值]]></title>
    <url>%2F2019%2F01%2F19%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[组件间的关系继续参考之前的代码App.js。 父子关系App是父，Header和Home相对于App是子。 兄弟关系Header和Home是兄弟关系。 父向子传值父传值父组件向子组件传值是父组件在调用子组件时，进行传值，以下两种方法都可以，App向Header传值，下边的代码是写在App.js里的。 1&lt;Header name=&#123;"Max"&#125; age=&#123;"12"&#125; user=&#123;user&#125;/&gt; 123&lt;Header name=&#123;"Max"&#125; age=&#123;12&#125; user=&#123;user&#125;&gt; &lt;p&gt;I am child&lt;/p&gt;&lt;/Header&gt; 这里使用第二种方法。 子使用值子组件使用父组件传过来的值通过props使用，例如： 1&lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.props.age&#125;&lt;/div&gt; App.js代码：注意第7行和16行 123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react'; //固定写法import Header from './components/Header';import Home from './components/Home';class App extends Component &#123; //ES6写法 render() &#123; //注意这里 const user=&#123; name: "Anna", hobbies: ["Sports", "Reading"] &#125; return ( &lt;div&gt; &lt;div&gt; &lt;Header name=&#123;"Max"&#125; age=&#123;"12"&#125; user=&#123;user&#125;/&gt; //传值 age=&#123;12&#125;也可以 &lt;/div&gt; &lt;div&gt; &lt;h1&gt;I am App&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;Home /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; Header.js代码：注意第6行和return的内容 this.props就是父组件传过来的值 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react'; //固定写法class Header extends Component &#123; //ES6写法 render() &#123; console.log(this.props); return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.props.age&#125;&lt;/div&gt; &lt;div&gt; &lt;h4&gt;hobbies&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Header; 参数类型检查JS是动态语言。 在这里我们对App传过来的值进行检查，理所当然要在Header中检查。 在Header.js中引入静态检查： 1import PropTypes from 'prop-types'; 现在开始检查，设置Header接收到的参数的类型： 123456Header.propTypes=&#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, children: PropTypes.element.isRequired&#125; 其中children是给Header传参时Header闭合标签里的东西。 最终Header.js代码是这样： 1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react'; //固定写法import PropTypes from 'prop-types';class Header extends Component &#123; //ES6写法 render() &#123; console.log(this.props); return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.props.age&#125;&lt;/div&gt; &lt;div&gt; &lt;h4&gt;hobbies&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Header.propTypes=&#123; //注意p是小写 name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, children: PropTypes.element.isRequired&#125;export default Header; 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（五）之输出动态数据]]></title>
    <url>%2F2019%2F01%2F18%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E8%BE%93%E5%87%BA%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[输出动态数据就是输出表达式。 表达式就是2+2，变量等等。 现在在Home.js中输出动态数据。 代码注意代码中的第19行 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react'; //固定写法export class Home extends Component &#123; //ES6写法 render() &#123; let content=""; let flag=false; if(flag)&#123; content="cbh"; &#125; else&#123; content="cxy"; &#125; return ( &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &#123;content&#125; &lt;/div&gt; ); &#125;&#125;export default Home; 效果 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（四）之多个组件]]></title>
    <url>%2F2019%2F01%2F18%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[新建组件在src目录下新建文件夹components，用来存放定义组件的JS代码。 在components文件夹中定义两个组件：Home.js和Header.js，代码几乎和App.js一样，只改变了类名和return的内容。 提示：由于某些原因，之后的代码中可能会有标签匹配出错的问题….. 文件目录结构注意Header.js、Home.js和App.js在目录中的位置。 Home.js显示Home字样。 12345678910111213import React, &#123; Component &#125; from 'react'; //固定写法export class Home extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default Home; Header.js显示Header字样。 12345678910111213import React, &#123; Component &#125; from 'react'; //固定写法export class Header extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default Header; 使用组件在App中使用定义的两个组件，先使用Header，接着显示I am App，接着再使用Home。 App.js 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react'; //固定写法import Header from './components/Header';import Home from './components/Home';class App extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;Header /&gt; //注意这里！ &lt;/div&gt; &lt;div&gt; &lt;h1&gt;I am App&lt;/h1&gt; //注意这里！ &lt;/div&gt; &lt;div&gt; &lt;Home /&gt; //注意这里！ &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 效果展示 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（三）之第一个组件]]></title>
    <url>%2F2019%2F01%2F18%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目结构之前通过create-react-app创建了一个hello-react项目，不知道的可以看博客里之前的的React文章。 暂时只关注三个文件：src\index.js、src\App.js和public\index.html。 文件说明App.js作用App.js定义页面中的一个组件，也就是定义页面中要放的一个零件。 代码定义了一个显示React的logo的组件。 注意下我加的代码注释 12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react'; //固定写法import logo from './logo.svg'; //图片import './App.css'; //cssclass App extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;header className="App-header"&gt; &lt;img src=&#123;logo&#125; className="App-logo" alt="logo" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className="App-link" href="https://reactjs.org" target="_blank" rel="noopener noreferrer" &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; ); &#125;&#125;export default App; index.html作用index.html进行页面内容的布局，也就是哪里放什么标签。 index.html是显示的页面，用户通过检查元素是可以看到html代码的，所以放在public文件夹下吧。 代码主要看body部分，只放了一个div。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /&gt; &lt;meta name="theme-color" content="#000000" /&gt; &lt;!-- manifest.json provides metadata used when your web app is added to the homescreen on Android. See https://developers.google.com/web/fundamentals/web-app-manifest/ --&gt; &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt; &lt;!-- Notice the use of %PUBLIC_URL% in the tags above. It will be replaced with the URL of the `public` folder during the build. Only files inside the `public` folder can be referenced from the HTML. Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will work correctly both with client-side routing and a non-root public URL. Learn how to configure a non-root public URL by running `npm run build`. --&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the &lt;body&gt; tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --&gt; &lt;/body&gt; &lt;/html&gt; index.js作用index.js连接App.js和index.html，通过将组件放入各个标签中，起到连接上边两个文件的作用。 代码主要内容是第11行那里。 注意下我加的代码注释。 1234567891011121314151617//导入reactimport React from 'react';import ReactDOM from 'react-dom';//导入css，.代表当前目录，..代表上一级目录import './index.css';//导入组件，变成App，其实下一行的'./App'省略了.js后缀，本来应该是'./App.js'import App from './App';import * as serviceWorker from './serviceWorker';//设置挂载点，把组件App挂到root上ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: http://bit.ly/CRA-PWAserviceWorker.unregister(); 自己的第一个组件也就是自己写一个组件嘛，组件是在App.js中定义的，所以修改App.js。 定义组件在这里将组件的默认内容删除，也就是render函数中return的东西，然后自己写。 12345678910111213141516171819import React, &#123; Component &#125; from 'react'; //固定写法import logo from './logo.svg'; //图片import './App.css'; //cssclass App extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 代码里div中用的是className是因为class是JS的保留字，所以要用className。 代码修改之后效果在此就不展示了，显示了一个hello world。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（二）之create-react-app]]></title>
    <url>%2F2019%2F01%2F18%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8Bcreate-react-app%2F</url>
    <content type="text"><![CDATA[安装create-react-app环境配置首先要确保你的电脑上有Nodejs和npm 。 检查方法：打开cmd(也就是命令行、终端)，输入node -v和npm -v。 可分别查看Nodejs和npm的版本，有版本环境肯定就配好啦。似乎现在的Nodejs会带着npm。 开始安装打开cmd，输入npm install -g create-react-app -g表示全局，我们可以在任意地方使用npm。 创建react项目我们可以通过create-react-app指令创建一个react项目。 终端中进入项目创建位置创建的项目的位置取决于在cmd中操作的位置。 最近在用VSCode，在VSCode中可以直接右击工作空间的文件夹，再点击在终端中打开，即可在终端中操作该文件夹。 创建项目 启动项目接着上一步 运行效果 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo不蒜子网站访问量统计失效]]></title>
    <url>%2F2019%2F01%2F17%2Fhexo%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[问题hexo博客的不蒜子网站访问量统计最近失效了。 解决原因不蒜子域名更改了，所以需要修改博客的配置文件。 方法进入博客目录下\themes\next\layout\_third-party\analytics，（我用的是next主题，如果用的是别的主题，就进入对应主题文件夹。） 打开文件busuanzi-counter.swig 将&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 修改为&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 不知道为什么空格显示的比较宽，但经验证，复制下来是一个正常的空格，可以复制下来使用。 其他不变。]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash: hexo: command not found]]></title>
    <url>%2F2019%2F01%2F17%2Fbash-hexo-command-not-found%2F</url>
    <content type="text"><![CDATA[问题很久没写博客了，今天用hexo新建文章时git报错： bash: hexo: command not found 解决办法百度之后，将D:\WorkingSoftware\GithubBlog\node_modules\.bin添加进PATH，问题解决。 加的时候发现path里确实没有这个路径……..不知道为什么会没有 路径中的GithubBlog是我的博客文件夹，你用的时候改成你的路径，即XXX你的Blog目录XXX\node_modules\.bin 原因可能是因为我今天更新npm了？ 或者是因为我这两天改了计算机用户名(用户名在其他地方用到了，中文是宽字符，会出错)，造成了很多麻烦，差点edge都坏了。 所以告诫大家用户名尽量一开始就用英文，不要用中文。]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（一）之Hello React]]></title>
    <url>%2F2019%2F01%2F17%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BHello-React%2F</url>
    <content type="text"><![CDATA[代码以下是html代码，复制代码到html文件，可直接运行。 (请关注&lt;body&gt;&lt;/body&gt;里的JS代码和注释)： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;helloReact&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( //代码块①开始 &lt;h1&gt;hello world!&lt;/h1&gt;, //代码块①结束，注意结束有个逗号 document.getElementById("app") //设置挂载点 //上一行代码(结尾没有分号)将代码块①放入上边的 &lt;div id="app"&gt;&lt;/div&gt;，F12检查元素可以看到效果。 ) &lt;/script&gt; //两个和react相关的脚本文件 &lt;script src="https://cdn.bootcss.com/react/16.7.0/umd/react.development.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/react-dom/16.7.0/umd/react-dom.development.js"&gt;&lt;/script&gt; //babel文件，作用是解码，详情请参考ES6 &lt;script src="https://cdn.bootcss.com/babel-standalone/7.0.0-beta.3/babel.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果 调试F12检查元素可以看到代码块①被添加进id为app的&lt;div&gt; 转码效果babel官网转码（进入官网后点击Try it out）。关于什么是babel，参看ES6（我还不会hh）。 左边是JSX语法，方便我们写代码。]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.NoSuchElementException]]></title>
    <url>%2F2018%2F11%2F03%2Fjava.util.NoSuchElementException%2F</url>
    <content type="text"><![CDATA[问题引入Java商店作业不同函数里需要获取用户输入，用Scanner的时候,出现了异常java.util.NoSuchElementException 作业中代码模式如下，func1和func2中都使用Scanner并关闭它。然后在main中依次调用func1和func2，func2产生异常。说func1和func2其实不合适，应该加个括号……..懒得加了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Demo.javaimport java.util.Scanner;class Test&#123; void func1() &#123; Scanner sc=new Scanner(System.in); //输出用户输入，替代作业里的使用Scanner System.out.print("Func1请输入内容："); System.out.println("Func1输出"+sc.next()); //关闭Scanner sc.close(); &#125; void func2() &#123; Scanner sc=new Scanner(System.in); //输出用户输入，替代作业里的使用Scanner System.out.print("Func2请输入内容："); System.out.println("Func2输出"+sc.nextInt()); //关闭Scanner sc.close(); &#125;&#125;public class Demo&#123; public static void main(String[] args) &#123; Test t=new Test(); t.func1(); t.func2(); &#125;&#125;/*Console输出如下：Func1请输入内容：小姐，请问你喜欢吃青椒吗？Func1输出：小姐，请问你喜欢吃青椒吗？Func2请输入内容：Exception in thread "main" java.util.NoSuchElementException at java.base/java.util.Scanner.throwFor(Unknown Source) at java.base/java.util.Scanner.next(Unknown Source) at java.base/java.util.Scanner.nextInt(Unknown Source) at java.base/java.util.Scanner.nextInt(Unknown Source) at Test.func2(Demo.java:21) at Demo.main(Demo.java:31)*/ 异常产生原因func1中sc.close();语句关闭了Scanner，func2中使用Scanner产生异常 因为System.in是System类的静态成员，所以不同Scanner对象内的in是同一个in` func1和func2中都用System.in创建了Scanner func1打开Scanner后将其关闭，这里间接地将System.in也关闭了 func1结束后运行func2，这时再调用nextInt，在System.in已经关闭了的情况下，不能读取到任何数据，就会产生 java.util.NoSuchElementException 解决方法系统资源一旦释放就不能再开启了，所以只有确定不在使用系统的时候，才能将流关闭 所以应该在整个程序结束时释放Scanner等资源，而不是某个函数中每次使用Scanner等资源后都释放一次 问题引入中的代码只是个模式，上边的两句话用在作业实际代码里就好了 代码分析Scanner()创建Scanner对象代码为Scanner sc=new Scanner(System.in);构造函数源码如下 123public Scanner(InputStream source) &#123; this(new InputStreamReader(source), WHITESPACE_PATTERN);&#125; 可看出是调用了另外一个构造函数，继续查看源码 123456789101112private Scanner(Readable source, Pattern pattern) &#123; assert source != null : "source should not be null"; assert pattern != null : "pattern should not be null"; this.source = source; //看这句 delimPattern = pattern; buf = CharBuffer.allocate(BUFFER_SIZE); buf.limit(0); matcher = delimPattern.matcher(buf); matcher.useTransparentBounds(true); matcher.useAnchoringBounds(false); useLocale(Locale.getDefault(Locale.Category.FORMAT)); &#125; 至少知道了Scanner内部还是用到了流，算是对流进行了封装吧，使用起来更方便一些 close()调用语句为sc.close();，查看close()源码，如下 1234567891011121314public void close() &#123; if (closed) //1.通过closed标志校验Scanner是否已关闭； return; if (source instanceof Closeable) &#123; //2.执行source的close()方法， try &#123; //将source关闭（这里为System.in）； ((Closeable)source).close(); &#125; catch (IOException ioe) &#123; lastException = ioe; &#125; &#125; sourceClosed = true; //3.将sourceClosed标志设置为true，表示source已关闭； source = null; //4.将source置为null，不再引用，处于可回收状态； closed = true; //5.将closed标志设置为true，表示Scanner已关闭；&#125; 可以知道关闭Scanner的时候，((Closeable)source).close();把System.in关闭了 关闭后下次想再使用就当然有错了~（除非构造函数里还再把in给打开，但这样也不太合理） 其实如果还可以再仔细看看Scanner的构造方法，和Scanner的next()，能力有限，点到为止 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/11/03/java.util.NoSuchElementException/#more 欢迎转发和评论]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字节流read函数]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E5%AD%97%E8%8A%82%E6%B5%81read%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题引入做Java作业从标准输入流获取用户输入，用到了System.in.read(),然后出现了bug。 1234567891011121314151617181920212223//随机生成一个小写字母，用户猜5次，读取用户输入，并判断是否猜对import java.io.IOException;public class LetterGuessing &#123; public static void main(String[] args) throws IOException &#123; char ch,answer; //随机生成字母 answer=(char)(Math.random()*26+'a'); System.out.print("请输入一个小写字母："); for(int i=1;i&lt;=5;i++) &#123; //获取用户输入，可能抛出异常 ch=(char)System.in.read(); //比较大小 if(ch == answer)&#123; System.out.println("恭喜，正确！用了"+i+"次猜对"); break; &#125; else if(ch &gt; answer) System.out.println("您猜大了，还有"+ (5-i) +"次机会"); else System.out.println("您猜小了，还有"+ (5-i) +"次机会"); &#125; &#125;&#125; 输入字符&#39;a&#39;，按下Enter,却没有等我下次输入，循环就运行了三次。 问题来源System.in.read()按字节读，一次读入一个字节。后边有详细讲解。 经调试，可知三次循环中ch分别为a,\r,\n。 为什么a+Enter,会变成a\r\n呢 Windows下存在两种文件读写方式，一个是二进制方式，另一种是文本方式。 文本方式中写时”换行”会变成”回车-换行”，即\r\n；读时”回车-换行”会变成”换行”。 二进制方式中读写是严格按照一个字节一个字节的方式进行的。 在这里虽然没有用到文件，但道理应该是一样的 用read()函数是按照一个字节一个字节读取的，即二进制方式。 可能可以推导出，我们向输入流中输入数据默认是按照文本方式。 解决方法方法一在代码第10行后，加两行System.in.read(); 目的是读取掉输入流中的/r和/n。 这种方法的局限性就是输入字母前后不能加空格，因为它不会使空格从输入流中删除。 方法二不用read()读取，用以下代码代替 123import java.util.Scanner;Scanner input=new Scanner(System.in);ch=input.next().charAt(0); 这种方法就比较好，读取字符串（忽略空格和换行，空格和换行不会留在输入流里），然后取字符串的第一个字符。 知识点System.in官方文档：https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#in System是个类，in是System的一个成员，官方介绍如下： 1public static final InputStream in The “standard” input stream. This stream is already open and ready to supply input data. Typically this stream corresponds to keyboard input or another input source specified by the host environment or user. in是一个InputStream类型的对象,所以只需要了解InputStream即可。 InputStream官方文档： https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html 123public abstract class InputStream //抽象类extends Object //继承Object类implements Closeable //实现Closeable接口 官方介绍如下： This abstract class is the superclass of all classes representing an input stream of bytes. 翻译为：这个抽象类是所有字节流类的父类。 字节流的含义：读取方式为一个字节一个字节地读取,而字符流是二个字节二个字节的读。 Applications that need to define a subclass of InputStream must always provide a method that returns the next byte of input. 翻译为：需要定义一个InputStream子类的应用必须提供一个返回输入下一字节的方法（函数）。 read()官方文档：https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html#read() 12public abstract int read() throws IOException Reads the next byte of data from the input stream. The value byte is returned as an int in the range 0 to255. 这个是重点，它返回下一字节的ASCII码 If no byte is available because the end of the stream has been reached, the value -1 is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown. A subclass must provide an implementation of this method. Returns: the next byte of data, or -1 if the end of the stream is reached. Throws: IOException - if an I/O error occurs. 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/09/22/Java字节流read函数/#more 欢迎转发和评论]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++获取文件夹下所有文件的路径]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[代码getFiles()函数的作用： path是一个文件夹路径，函数在path文件夹下寻找所有文件（包括子文件夹下的文件），然后将所有文件的路径存入files 12345678910111213141516171819202122232425#include &lt;io.h&gt; //实现功能需要包含头文件io.hvoid getFiles(string path, vector&lt;string&gt;&amp; files)&#123; intptr_t hFile = 0;//文件句柄，过会儿用来查找 struct _finddata_t fileinfo;//文件信息 string p; if ((hFile = _findfirst(p.assign(path).append("\\*").c_str(), &amp;fileinfo)) != -1) //如果查找到第一个文件 &#123; do &#123; if ((fileinfo.attrib &amp; _A_SUBDIR))//如果是文件夹 &#123; if (strcmp(fileinfo.name, ".") != 0 &amp;&amp; strcmp(fileinfo.name, "..") != 0) getFiles(p.assign(path).append("\\").append(fileinfo.name), files); &#125; else//如果是文件 &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); //能寻找到其他文件 _findclose(hFile); //结束查找，关闭句柄 &#125;&#125; 代码解读_finddata_t它是存储一个文件相关信息的结构体,查看其定义： 1234567#ifdef _USE_32BIT_TIME_T #define _finddata_t _finddata32_t #define _finddatai64_t _finddata32i64_t#else #define _finddata_t _finddata64i32_t #define _finddatai64_t __finddata64_t#endif 我这里是_finddata64i32_t，查看其定义 123456789struct _finddata64i32_t&#123; unsigned attrib; __time64_t time_create; // -1 for FAT file systems __time64_t time_access; // -1 for FAT file systems __time64_t time_write; _fsize_t size; char name[260];&#125;; attrib是该结构体的一个成员，是attribute（属性）的缩写。 它代表文件的属性，下边是相应的宏 123456#define _A_NORMAL 0x00 // Normal file - No read/write restrictions#define _A_RDONLY 0x01 // Read only file#define _A_HIDDEN 0x02 // Hidden file#define _A_SYSTEM 0x04 // System file#define _A_SUBDIR 0x10 // Subdirectory#define _A_ARCH 0x20 // Archive file 成员name就是文件名字嘛… _findfirst第一个参数是标明文件的字符串，可支持通配符：*.c代表后缀为.c的文件，*就代表所有文件 第二个参数是_finddata_t类型变量的地址。该变量用来保存文件信息。 这有坑 我跟网上有点不同的是，网上我看到的例子定义的hFile都是long型，我用long型打开文件就出问题了。 其实VS已经警告了warning C4244: “=”: 从“intptr_t”转换到“long”，可能丢失数据。 我没在意它，后来改掉了类型就成功了。（就冲这一点，VS天下第一！） 查看_findfirst定义 1234567891011#ifdef _USE_32BIT_TIME_T #define _findfirst _findfirst32 #define _findnext _findnext32 #define _findfirsti64 _findfirst32i64 #define _findnexti64 _findnext32i64#else #define _findfirst _findfirst64i32 #define _findnext _findnext64i32 #define _findfirsti64 _findfirst64 #define _findnexti64 _findnext64#endif 我这里用的是_findfirst64i32，查看其定义 1234_ACRTIMP intptr_t __cdecl _findfirst64i32( _In_z_ char const* _FileName, _Out_ struct _finddata64i32_t* _FindData ); 说明函数返回intptr_t 继续查看intptr_t定义，得到 12345678#ifdef _WIN64 typedef unsigned __int64 size_t; typedef __int64 ptrdiff_t; typedef __int64 intptr_t;#else typedef unsigned int size_t; typedef int ptrdiff_t; typedef int intptr_t; 所以intptr_t在我电脑上实际是__int64，转换成long可能会丢失数据。 _findnext查看其定义 1234567891011#ifdef _USE_32BIT_TIME_T #define _findfirst _findfirst32 #define _findnext _findnext32 #define _findfirsti64 _findfirst32i64 #define _findnexti64 _findnext32i64#else #define _findfirst _findfirst64i32 #define _findnext _findnext64i32 #define _findfirsti64 _findfirst64 #define _findnexti64 _findnext64#endif 我这里是_findnext64i32，查看其定义 1234_ACRTIMP int __cdecl _findnext64i32( _In_ intptr_t _FindHandle, _Out_ struct _finddata64i32_t* _FindData ); 没啥讲的，好好看看_findfirst部分就懂这个了。 位运算fileinfo.attrib &amp; _A_SUBDIR，代码中用到了按位与&amp;。在此表示是文件夹（subdirectory）。位运算经常用在表示属性。具体的这次先不讲。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针间的互相赋值]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%8C%87%E9%92%88%E9%97%B4%E7%9A%84%E4%BA%92%E7%9B%B8%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[本篇文章分为三个大的部分 大标题1提出权限”概念”，大标题2验证赋值规则 大标题3、4、5是我的个人理解。 大标题6是最直接的结论。 提醒 看懂这篇文章可能需要你知道并理解四种指针的定义，这是基础。当然如果真的不懂，可以直接去文尾记住结论。 四种指针详解戳这https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/#more 指针修改指向内容的权限普通指针=指针常量&gt;常量指针=四号指针 这个权限指的是通过该指针是否可以修改内存，情况只有两种：是和否。是的话就有权限，否的话就没有权限，这个大小是0和1，false和true，是有和没有，不是12345678的大和小。 普通指针很好说，四号指针也是个常量指针嘛，当然不可以修改内存 这个权限大小关系不难理解，前提是你有理解常指和指常这两个名词吧。 前边的普指和指常都可以修改内存中的内容，而常指和四号则不可以。 指针赋值规则指针间的赋值：权限大的可以赋值给权限小的（权限指操作内存即修改内存中的内容的权限） 权限大的可以赋值给权限小的，同级权限也可以，小赋值给大不行。 123456789101112131415161718192021222324252627282930313233const int n = 0; //常量nint m = 0; //变量mint* p1; //普通指针const int* p2; //常量指针 与int const* p2相同//int* const p3=nullptr; //指针常量//int const * const p4; //四号指针 既是常指又是指常，即自身不可修改，也不可通过它修改指向的内存p1 = p2; //error 普指=常指p1 = p3; //correct 普指=指常p1 = p4; //error 普指=四号p1 = &amp;n; //error 普指=常指p1 = &amp;m; //correct 普指=普指p2 = p1; //correct 常指=普指p2 = p3; //correct 常指=指常p2 = p4; //correct 常指=四号p2 = &amp;n; //correct 常指=常指p2 = &amp;m; //correct 常指=普指//p3是指常，是常量 赋值当然不行了，更别说权限了，所以上边不定义p3，//要讨论的是权限，在此定义并初始化以作示例，但定义只能有一个的啊，我在这提醒过了啊int* const p3 = p1; //correct 指常=普指int* const p3 = p2; //error 指常=常指int* const p3 = p4; //error 指常=四号int* const p3 = &amp;n; //error 指常=常指int* const p3 = &amp;m; //correct 指常=普指//p4是四号，是常量，同p3，不赘述int const * const p4 = p1; //correct 四号=普指int const * const p4 = p2; //correct 四号=常指int const * const p4 = p3; //correct 四号=指常int const * const p4 = &amp;n; //correct 四号=常指int const * const p4 = &amp;m; //correct 四号=普指 这个规则是我自己想出来的，可能书上云里雾里的背后就是这么个规律。我之前好像说过存在即合理..实际表述不太对，应该是存在就有原因。上边的代码应该囊括了所有“品种”指针的互相赋值，验证也都符合预期。如有错误，欢迎指出。 赋值规则的过程赋值得要满足被赋值方的要求，就像你想娶我（捂脸），我就需要你一米八，宠我，其他的都不需要，有的话我也一点不碰。但只要你这两点缺一点，我就不要，你是马云爸爸也不行！ 赋值就是那么个意思，我是指常或者普指，我要求有权限修改内存，所以就只有指常和普指能娶我，能给我赋值，因为常指和四号没有那个权限啊！反过来的话，我是常指和四号，我什么都不要，所以谁赋值都行，上面我们也能看到给常指和四号赋值的时候全都correct了。 赋值规则的必要性赋值规则前提是不同指针的权限不同我想多种指针是为了程序更好吧，不然只有一种指针能实现所有的功能，岂不是很可怕。给了程序员太大的权利，程序员一跑神犯错，程序就极有可能崩溃。给予指针权限之差就像c++里override吧，也是一种对程序员的友好？这是一方面,这应该能说明赋予指针不同权限的必要。 然后才有了赋值规则我们举个例子，如果没有这个规则，不同类型指针自由互相赋值：你定义一个常量n，然后再定义一个int* p，就是普指，普指按说是有修改内存的权利的，然后p=&amp;n，拿到n的地址，是不是就可以通过p改变n了？（在存在不同权限指针的前提下）。如果没有这个规则，我们可以很随意地改变常量了。干嘛自己造了一座木屋，然后又给它浇上油？ 斗胆扯内存不管是指针常量还是常量指针还有普通指针，它们本身和那块内存都是没有本质关系的。 它们（也包括普通类型的指针）只是一个带着镣铐或者没有镣铐的工具，我们可以通过const控制指针的权限以及它本身，同时我们在使用它们时也不能超出它们的权限范围和它们的个人承受力。 结论1234int* p1; //普通指针const int* p2; //常量指针 与int const* p2相同int* const p3=nullptr; //指针常量int const * const p4; //四号指针 既是常指又是指常 p1和p3可以互相赋值； p2和p4可以互相赋值； p1和p3可以给p2和p4赋值，反之不行； p3和p4在程序中只能在定义时被赋值一次，因为它们是const类型的量。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/09/01/指针间的互相赋值/#more 欢迎转发和评论]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物不知其数]]></title>
    <url>%2F2018%2F09%2F01%2F%E7%89%A9%E4%B8%8D%E7%9F%A5%E5%85%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[文章分为三个大的部分： 大标题1是物不知其数问题的引入，大标题2将问题抽象。 大标题3、4、5是物不知其数问题的三种解法及其代码实现。 大标题6是提出的一些问题及不太完善的解释。 提醒： 看文章最好先掌握文章整体结构，电脑会比较方便，可以点击标题跳到自己想看的部分。 看代码发现看不到后边的注释的话，调整网页显示比例（Ctrl+鼠标滚轮） 另外代码里的注释也是有规律的，单独一行的注释是解释下边的几行的功能的，写在代码右边的注释解释这一行代码功能。 问题引入秦王暗点兵和韩信乱点兵都是后人对物不知其数问题的一种故事化，有兴趣可以搜索一下。 物不知其数问题出自《孙子算经》。 原题为：”今有物不知其数，三三数之二，五五数之三，七七数之二，问物几何？” 这道题的意思是：有一批物品，不知道有几件。如果三件三件地数，就会剩下两件；如果五件五件地数，就会剩下三件；如果七件七件地数，也会剩下两件。 问：这批物品共有多少件？ 变成一个纯粹的数学问题就是：有一个数，用3除余2，用5除余3，用7除余2。求这个数。 拿到这个问题，我们可以发现用3和7除余数都是2，自然而然想到3*7=21,21+2=23,23%5=3。所以23就是答案之一，而后边问题中我们求最小值。 这个问题之所以简单，是由于有被3除和被7除余数相同这个特殊性。 问题抽象去除问题数据的特殊性之后，问题可以是像这样： 三人一组余两人，五人一组余三人，七人一组余四人。问：这队士兵至少有多少人？ 就是说我们要找到一个最小的数，使其除以3余2，除以5余3，除以7余4 数据变量化后真正的问题改成：一个数除以x余a，除以y余b，除以z余c，找到符合这三个条件的最小的数。 三个条件按顺序分别称为条件1，条件2，条件3。 暴力方法定义变量n，在范围内从头到尾递增，循环内判断条件为n%3==2&amp;&amp;n%5==3&amp;&amp;n%7==4，符合条件就break 代码实现123456789101112//找到一个最小的数，使其除以x余a，除以y余b，除以z余cint x,y,z; //除数int a,b,c; //余数scanf("%d %d %d %d %d %d",&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);for(int n=1;;n++) //在这里不设范围&#123; if(n%x==a&amp;&amp;n%y==b&amp;&amp;n%z==c) &#123; printf("%d",n); break; &#125;&#125; 合并方法题目中有三个条件，我们可以将前两个条件合并成条件A，再把条件A与第三个条件合并，最后得出结果。 过程条件1和条件2合并成条件A已知n除以3余2，可设n=3i+2(i是正整数)，使i从1变大，判断3i+2除以5是否余3。 我们发现当i=2时，3i+2=8除以5余数为3，即n=8时除以3余2，除以5余3。 然后前两个条件就被我们合并成了条件A：n=15i+8， 本质是：最小的符合前两个条件的数字8加上3和5的最小公倍数15的整数倍 用到的定理：若n除以a余b，n加上a的倍数再除以a余数仍然为b。我们加上的15i即为a的倍数 注意： 是最小公倍数，不要直接看做是两数乘积，因为只有在指出三个除数两两互质的情况下，两数乘积即为最小公倍数，在这里提醒一下，不要理解错误。 如果用的不是最小公倍数，我们下边n增加的单位就变大了，可能会求不到最小值，而题目要求是取得符合要求的最小值。 条件A和条件3合并成结果我们再使条件A和第三个条件合并，n=15i+8(i是正整数)，使i从1变大，判断15i+8除以7的余数是否为4。 我们发现当i=3时，15i+8=53除以7余4，53即为答案 拓展过程中条件合并了两次，让我想到定义一个函数。这个函数要调用两次 写一个比伪代码还伪的代码： 结果 合并(条件，条件) 代码实现最大公约数12345678910111213int Gcd(int a,int b) //Greatest Common divisior&#123; int c; //辗转相除法求最大公约数 Greatest Common Divisor /* 余数不为0，继续相除，直到余数为0 */ while(b!=0) &#123; c=a%b; a=b; b=c; &#125; return a;&#125; 最小公倍数12345int Lcm(int a,int b) //Least Common Multiple &#123; //最小公倍数等于乘积除以最大公约数 return a*b/Gcd(a,b);&#125; 求结果123456789101112131415161718//找到一个最小的数，使其除以x余a，除以y余b，除以z余cint x,y,z; //除数int a,b,c; //余数scanf("%d %d %d %d %d %d",&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);//合并条件1和条件2int i=1;while((x*i+a)%y!=b) //循环跳条件为(x*i+a)%y==b i++;//得到条件Aint d=x*i+a; //得到条件A//合并条件A和条件3int j=1;while((Lcm(x,y)*j+d)%z!=c) //while((Lcm(x,y)*j+d)%z !=c)求得的不一定是最小值 j++;//得到结果int result=Lcm(x,y)*j+d; //int result=x*y*j+d求得的不一定是最小值printf("%d",result); 中国剩余定理方法除数分别是3、5、7，用70(5乘7乘2)乘以用3除的余数，用21(3乘7)乘以用5除的余数，用15(3乘5)乘以用7除的余数，然后把这三个乘积相加。加得的结果如果比105(3乘5乘7)大，就除以105，所得的余数就是满足题目要求的最小正整数解。 过程除数两两结合得到公倍数对所得公倍数的目标(要求)：除以另外一个除数余1 这一步骤中，不用关注三个条件要求余几，条件中的余几会在下一步体现 条件一：用3除 这里是用3除，求另外两个除数的公倍数，并要求用3除余1,5*7=35除以3余2,5乘7乘2=70除以3余1，所以是70 条件二：用5除 3*7=21除以5余1，所以是21 条件三：用7除 3*5=15除以7余1，所以是15 公倍数乘以余数相加70*2+21*3+15*4=263 解读加法：设上式为q+p+r=n。只判断加法会不会影响满足条件1(用3除余2)即可推导出是否满足另外两个条件。 若n除以a余b，n加上a的倍数再除以a余数仍然为b，这里n为140，a为3，b为2，加上的p、r之和是3的倍数，所以余数仍为2，仍满足条件1。（发现百度百科这条定理写错了，嘻。我这数学水平也就能折腾折腾小学数学了吧） 【百度】您于2018-08-31提交的百科词条“秦王暗点兵”版本已通过，查看词条内容：（ http://dwz.cn/s4JsvyGW ）。感谢您参与编写百度百科，亿万网友因您的贡献受益。 9月1日跑步时收到这条短信，这比兴奋剂还兴奋剂，就想来段加速跑。wuhu~ 同理可得，通过加法之后我们得到了一个同时满足三个条件的数字 检验是否最小用上边得到的数字不断减去三个除数的最小公倍数直至数字小于最小公倍数(其实就是得到的数字除以公倍数取余了)，得到最终答案！ 解读：其实就是上边加粗定理的变式，若n除以a余b，n减去a的倍数再除以a余数仍然为b，只是可能说成余数是几不太合理，但要懂那个意思。 拓展个人感觉过程中的前两步完全可以合成一步，在代码实现中很容易就可以看出来，拆开反而更难理解…(差评) 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445//找到一个最小的数，使其除以x余a，除以y余b，除以z余cint x,y,z; //除数int a,b,c; //余数scanf("%d %d %d %d %d %d",&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);//求第二、三个除数的公倍数int i=1;while((Lcm(y,z)*i%x)!=1) i++;//求第一、三个除数的公倍数int j=1;while(((Lcm(x,z)*j%y))!=1) j++;//求第一、二个除数的公倍数int k=1;while((Lcm(x,y)*k%z)!=1) k++;//公倍数乘以对应余数后求和int sum=0;sum+=Lcm(x,z)*j*b;sum+=Lcm(y,z)*i*a;sum+=Lcm(x,y)*k*c;//确认最小值printf("%d\n",sum%Lcm(Lcm(x,y),z));/*拓展对应的代码~~~~~~~~可以替代5到23行int sum = 0;//求第二、三个除数的公倍数同时乘以相应余数求和int i = 1;while ((Lcm(y, z)*i%x) != a) i++;sum += Lcm(y, z)*i;//求第一、三个除数的公倍数同时乘以相应余数求和int j = 1;while (((Lcm(x, z)*j%y)) != b) j++;sum += Lcm(x, z)*j;//求第一、二个除数的公倍数同时乘以相应余数求和int k = 1;while ((Lcm(x, y)*k%z) != c) k++;sum += Lcm(x, y)*k;//确认最小printf("%d\n", sum % Lcm(Lcm(x, y), z));*/ 瑕不掩瑜如果输入 3 3 3 1 1 1(可能这有点刁钻啊) 合并法中，会发现结果是7，但按照我们给出的题目结果应该是1啊！？ 7的来源是： 第一次合并为3*1+1=4，除以3余1，符合条件2，所以得到4； 第二次合并为4*1+1=7，除以3余1，符合条件3，结果为7。 所以答案是7的原因是因为我们默认i是从1开始增长，它代表我们要求的数一定大于三个除数，算经中的问题其实也隐含了这个条件结果要大于三个除数。 如果i从0开始增长，最终答案会是1。 在中国剩余定理中，我们会发现无法跳出循环while ((Lcm(y, z)*i%x) != a) i++;， 原因可能就是定理不适用这种情况吧。我没有深入了解中国剩余定理及其使用。因为我是从韩信点兵的题目了解到这些知识的。搜了一下中国剩余定理，发现它是数论里的一个知识，似乎使用也有一些条件，这里不再过多探索。 emm还是去看了下，中国剩余定理用的时候已经假设了三个除数两两互质。所以输入3 3 3 1 1 1这种就没必要了。但如果能弄懂3 3 3 1 1 1，还是可以让我们对定理有个更好的理解。 (放过我吧，每次写完东西都会发现bug，让我不爽..再多的抽象，也得加点前提条件呐。哪有那么多适用于所有情况的东西，真理也是少之又少。但简单的东西又没那么值得写，最多算个记录罢了) 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/09/01/物不知其数/#more]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常量指针与指针常量]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[常量指针和指针常量是两个经常出现的概念，今天做个小小总结。 文章各部分的内容都是很容易理解的，并且附加代码说明，一切的前提是理解文章2.1和2.2部分，所以搞好基础再往后看呐。干货在嫌长的直接跳到结论去。 废话最近在看VC++，看到书里有提这两个概念，学C的时候也有这两个概念，学C++的时候也有顶层const和底层const（这个我懂是懂，但从理解层次上不是那么懂为什么叫做顶层和底层）。所以就是这个知识点很常见啦，但似乎很多人很迷惑，或者说理解着不舒服。于是我的“神逻辑”就来了。 我对它们的理解主要是翻译问题常量指针、指针常量这种名词是英文翻译过来的，所以中文会有点拗口。常量的、指针的，我们生活中是没有这样的词的。 英文里是这样的两个东西:pointer to const, const pointer。 pointer是指针的意思；const是constant的缩写，作名词是常量的意思，作形容词是不变的的意思。 这两个词：pointer to const, const pointer。中文有两种翻译方法： 翻译方法 pointer to const const pointer 第一种 指向常量的指针（常量指针） 不变的指针（指针常量） 第二种 指向常量的指针（指针常量） 不变的指针（常量指针） 说来说去都是翻译的问题。英文里很容易能看懂的意思，换成中文就有两种换法。 我赞成第一种翻译方法，因为它更符合中文习惯。 第二种方法确实不该有指针常量这个说法，太不合中文习惯。 所以要讨论中文版的话，如果出现指针常量，也应该是第一种方法。 下面是一篇讲常量指针和指针常量的文章： https://www.thegeekstuff.com/2012/06/c-constant-pointers换成英文就不用玩文字游戏了 所以呢，本质上应该用英语去讲。但本篇是讲中文版的一种方法。（去百度也会发现有两种说法，原因是翻译不同）。 基础本文用第一种说法，常指是pointer to const，指常是 const pointer。 常指、指常就是两个词而已，都是四个字。把前边的两个字当做形容词（是用来修饰后边的名词的），后边的名词才是重点。 指针就是地址嘛，常量就是不可以修改的量（初始化不算做赋值，不算做修改）。 注意区分指针本身（的内容）和指向的内存的内容。 修改指针即改变指针本身的内容，修改内存或者说修改内存内容就是修改指针指向的内存中的内容。这样讲的很清楚了吧…….. 常量指针常量指针中的常量呢，指的是这个指针的作用是常量性的、无权修改的，即不可以通过该指针修改内存中的内容，并不代表指向的内存不修改，注意前边有通过二字。 这个词也有指向常量的指针的叫法，我认为这个中文叫法是不准确的甚至是错误的。如果说常量指针是指向常量的指针，我认为这句话最直接的意思是说指针指向的内存是常量，这个意思是错误的，会误导他人，所以我不提倡这样叫它。证明参见文章3.3部分 在讨论问题的时候，互相知道对方说的是什么东西非常重要~，比如c++里的默认构造，没有构造函数这样的句子，不同人的理解方式不同，这些概念理解也是讨论进行的一个前提。 指针常量这里的指针呢，指的是这个常量是一个地址。 如何根据定义判断类型1234//代码1const char * p; //常量指针char const * p; //常量指针 跟上一句等效char * const p; //指针常量 根据const和*的相对位置const 在*左边=》常量指针；反之，指针常量。 根据谁离变量名近const近=》指针常量；反之，常量指针。（const就是不变嘛，就是指针，所以理解是很重要的，也就是*2.1） 代码验证常量指针123456789//代码2//char ch[] = "HelloWorld!";const char* pStr1=ch; //定义常量指针//1.常量指针本身的值可以修改pStr1 = nullptr; //correct//2.不能通过常量指针修改它所指向的内存中的内容（注意通过二字，不要误会常量指针）*pStr1 = 'h'; //error*(pStr1 + 1) = 'E'; //errorpStr1[2] = 'L'; //error 指针常量123456//代码3//char ch[] = "HelloWorld!";//指针常量（顶层const）char * const pStr2 = ch; //定义并初始化//1.是常量，不可以被赋值（不把初始化叫做赋值）pStr2 = nullptr; //error 常量指针容易被误解的地方1234567//代码4int n = 0; //定义变量nconst int * p1 = &amp;n; //常量指针p1int * const p2 = &amp;n; //指针常量p2*p1 = 3; //error 因为不能通过常量指针修改内存中的内容，划重点！：但这不是说指向内存中的内容不可修改n = 3; //correct 这是对的，因为n是变量啊*p2 = 3; //correct 指针常量部分的代码就有体现，不多说 123456//代码5const int n = 0; //定义变量nconst int * p1 = &amp;n; //常量指针p1int * const p2 = &amp;n; //error 错误的 原因见下-指针间的赋值*p1 = 3; //error 原因是常指不可修改内存n = 3; //error 原因是n是变量 代码4和代码5中的常量指针p1都不能改变内存中内容，但内存中内容是否可修改是不一定的。（代码4的第5第6行要好好看） 原因是：常量指针不可以修改内存是因为不可以通过常量指针修改内存所致（你不通过常量指针的话，变量是否可以修改就不一定了） 结论常量指针在这里指pointer to const。指针作用是常量性的，不可以通过它修改指向内存（容易被误会成内存一定不可修改）。 指针常量英文里指const pointer。指针是一个常量，指针本身不可以被修改。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/#more 欢迎转发和评论]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAI丢包掉帧处理]]></title>
    <url>%2F2018%2F08%2F22%2FJAI%E4%B8%A2%E5%8C%85%E6%8E%89%E5%B8%A7%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[问题时间戳停止变化/图像停止更新 描述本小白刚刚接触JAI，有很多不懂的地方。这次遇到问题是请教了YZ大哥（不知道年龄，暂时这么称呼），很感谢YZ大哥的耐心指导。因为我不仅不知道怎么调，连在哪里调也不知道╭(╯^╰)╮。以下是此次问题解决步骤，是YZ大哥跟我说怎么做，然后我照做，过程中又遇到问题，下边也给出了碰到的问题以及相应的解决方法。（8.21更） 刚刚又看了下JAI SDK Getting Started Guide，发现YZ讲的方法就是文档里那部分我觉得可以先跳过的内容，出现问题应该也是因为我没有按照文档进行配置…..可能我写的这个会有错误、遗漏、表述模糊，具体操作还可参加文档说明（8.22更） 4.4=》设置接收缓冲区 4.5=》设置中断调整 4.6=》打开巨型帧 4.7=》计算和设置包延迟 出现问题原因图像传输时丢包（掉帧） 解决方法使用 JAI Control Tool 采集图像 防止丢包如何使用JAI Control Tool 采集图像 如何查看是否丢包？ 除了通过搜索，也可以找到GigE Image Acquisition-Total missing packets其实观察刚开始采集图像时图片是否有撕裂的情况（出现水平黑线） 如果丢包 设置相机据包为8000左右（我是8196）如何设置相机数据包 设置相机数据包后用JAI Control Tool采图时黑屏，查看黑屏是是否有帧率如何查看帧率 有帧率则调整网卡巨型帧等如何找到相机连接的网卡网络和共享中心-以太网（就是相机那条网线）-属性-由勾选EBUS设置为不勾选EBUS 同时可以看到连接时使用的网卡 找到网卡右击-属性-高级-巨型帧（由关闭设为9KB MTU）接收缓冲区设为最大（我的最大只有512，只能这样了） 提醒：文档中指出当巨型帧打开的时候，相机数据包大小就可以大于1500bytes，但相机数据包必须小于巨型帧大小。 提醒：文档中指出典型的接收缓冲区最大值为2048，标准默认值为256，请结合自己的实际情况 是不是我的网卡太菜了，众筹给我买个好的可以吗？？？ 如果仍丢包则根据文档设置延时直至成功如何设置延时？参照文档设置延时（主要是帧率）我的Max Fps是2.00 ，Band Width是90% 修改最大帧率，调整带宽，点击calculate，点击ok。（文档指出当数据包大小或者像素格式改变时，数据包延迟都需要重新计算） 最后查看是否丢包 如有丢包可以再次调整数据包大小和延迟。另外有一点是，图像的传输是和你整个电脑的运行都有关系的，而不只是网卡和相机设置。]]></content>
      <tags>
        <tag>JAI</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstWriting]]></title>
    <url>%2F2018%2F08%2F16%2FFirstWriting%2F</url>
    <content type="text"><![CDATA[在很久很久以前，你拥有我我拥有你 《外面的世界》在很久很久以前我就有搞一个类似博客的东西的想法，不过一直都没有尝试着搞……某天（10号左右吧）刷知乎看到github和hexo可以搭建博客，于是我就来了hhh不过搞的时候也遇到了好多bug，跳了好多坑…博客一是分享，二是记录，三四五还没想起来。 这是第一次写博客，学习内容是一点点markdown语法，文末有这次学习的链接，之后应该会再好好学学markdown语法。 字体设置斜体1：文字两侧各一个星号_斜体2：文字两侧各一个下划线_粗体：文字两侧各两个星号粗斜体：文字两侧各三个星号删除线：文字两侧各两个波浪号 那就有个疑问了，如果星号、波浪号、下划线出现在文字中怎么处理…或者说这种情况很少吧，并且对内容没什么影响 标题怎么用二级标题三级标题四级标题五级标题六级标题超链接行内形式：我的博客参考形式：我的博客,github 自动链接：我的博客地址https://chouxianyu.github.io/ 列表无序列表 无序列表项1 无序列表项2 无序列表项3 有序列表1.有序列表项12.有序列表项23.有序列表项3 插入图片 表格 表头1 表头2 表头3 表头4 默认左对齐 显式左对齐 居中对齐 右对齐 默认左对齐 显式左对齐 居中对齐 右对齐 默认左对齐 显式左对齐 居中对齐 右对齐 默认左对齐 显式左对齐 居中对齐 右对齐 转载自https://www.jianshu.com/p/56d99a3049a5]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
