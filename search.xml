<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[80x86寻址方式]]></title>
    <url>%2F2019%2F05%2F31%2F80x86%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[与数据有关的寻址方式立即寻址方式操作数直接存放在指令中，这样的操作数称为立即数。 操作数=立即数 mov ax,3 注意： 立即寻址方式只能用于源操作数字段。 源操作数长度应与目的操作数长度一致。 寄存器寻址方式操作数存放在寄存器中，指令指定寄存器号。 mov ax,bx 操作数=指定寄存器中的内容 以上两种寻址方式都不涉及存储器。 以下各种寻址方式的操作数都存放在存储区中。 在80x86中，把操作数的偏移地址称为有效地址，EA(Effective Address)。 以下各种寻址方式通过不同途径求得操作数的有效地址，进而获得操作数。 有效地址=基址+变址\times比例因子+位移量有效地址可以有以下四种成分组成： 位移量 （displacement），是存放在指令中的数字，但它不是立即数，而是一个地址。 基址 （base），是存放在基址寄存器中的内容，通常用来指向数据段中数组或字符串的首地址。 变址 （index），是存放在变址寄存器中的内容，通常用来访问数组中的某个元素或字符串中的某个字符。 比例因子 （scale factor），其值可为1,2,4,8。（386及后继机型才有比例因子）\ &lt;center&gt;表1 16/位寻址时有效地址三种成分的组成&lt;/center&gt; 成分 16位寻址 位移量 0,8,16位 基址寄存器 BX,BP 变址寄存器 SI,DI 表2 默认段选择规则 访存类型 所用段及段寄存器 缺省规则 指令 代码段 CS 用于取指令 堆栈 堆栈段 SS 进出栈，ESP、BP或ESP作为基址寄存器 局部数据 数据段 DS 除堆栈和串指令的目的串之外 目的串 附加数据段 ES 串处理指令的目的串 禁止使用段跨越前缀的三种情况： 串处理指令的目的串必须使用ES段 PUSH和POP指令的源必须使用SS段 指令必须存放在CS段 直接寻址方式 有效地址=位移量 mov ax,[0] 位移量可以用符号地址（变量）表示。 mov ax,table mov ax,[table] 默认段寄存器为DS。 该寻址方式适用于处理单个变量。 寄存器间接寻址方式 有效地址=基址寄存器或变址寄存器的内容 mov ax,[bp] mov ax,[bx] 有效地址就在某个寄存器（BX,BP,SI,DI）中。（不允许使用AX,CX,DX） BP的默认段寄存器为SS，其他寄存器的默认段为DS。 寄存器相对寻址方式又称直接变址寻址方式。 有效地址=一个基址寄存器或变址寄存器的内容+位移量默认段情况与寄存器间接寻址方式相同。 mov ax,count[si] mov ax,[count+si] 基址变址寻址方式 有效地址=一个基址寄存器的内容+一个变址寄存器的内容默认段情况参看表1和表2。 mov ax,[bx][di] mov ax,[bp][si] mov ax,[bx+di] 相对基址变址寻址方式 有效地址=一个基址寄存器的内容+一个变址寄存器的内容+位移量 mov ax,mask[bx][si] 与转移地址有关的寻址方式这种寻址方式用来确定转移指令与CALL指令的转向地址。 段内直接寻址有效地址=(IP)+位移量 近转移： 位移量为16bit，如jmp near ptr next。 短转移： 位移量为8bit，如jmp short next，看看其他寻址会与转移地址有关的寻址方式会发现只有short没有ptr。 段内间接寻址有效地址=寄存器或存储单元内容。 该内容可以用除立即寻址方式以外的与数据有关的所有寻址方式。 jmp bx jmp word ptr[bp+table] word ptr说明是一个字，所以是段内转移。 段间直接寻址指令中直接提供了转向段地址和偏移地址。 jmp far ptr next 段间间接寻址取存储器中的两个相继字取代IP和CS中的原始内容，以达到段间转移的目的。 存储单元地址除立即寻址方式和寄存器方式外均可。 jmp dowrd ptr[table+bx]。 dword说明是双字，所以是段间转移。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[80x86寄存器组]]></title>
    <url>%2F2019%2F05%2F31%2F80x86%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84%2F</url>
    <content type="text"><![CDATA[寄存器可以分为程序可见的寄存器和程序不可见的寄存器两大类。 程序可见的寄存器可以分为以下三类： 通用寄存器 专用寄存器 段寄存器 通用寄存器数据寄存器AX、BX、CX、DX可称为数据寄存器，用来暂时存放计算过程中所用到的操作数。它们是16位，但也可以按字节访问，比如AH（高位字节）和AL（低位字节）。 AX（accumulator），作为累加器用，所以是算术运算的主要寄存器。 BX（base），在计算存储器地址时，常用作基址寄存器。 CX（count），常用来保存计数值，如在移位指令、循环指令和串处理指令中用作隐含的计数器。 DX（data），一般在作双字长运算时把DX和AX组合在一起存放一个双字长数，DX用来存放高位字。 指针寄存器可以存放操作数，但只能以字为单位使用。 SP（stack pointer），堆栈指针寄存器。 BP（base pointer），基址指针寄存器。可以和堆栈段寄存器SS联用来确定堆栈段中的某一存储单元的地址。 SI（source index），源变址寄存器，一般与数据段寄存器DS联用，用来确定数据段中某一存储单元的地址。 DI（destination index），目的变址寄存器，一般与数据段寄存器DS联用，用来确定数据段中某一存储单元的地址。 ※SI和DI有自动增量和自动减量的功能。 在串处理指令中，SI和DI作为隐含的源变址和目的变址寄存器，此时SI和DS联用，DI和附加段寄存器ES联用，分别达到在数据段和附加段中寻址的目的。 专用寄存器IP（instruction pointer），指令指针寄存器，它用来存放代码段中的偏移地址。 在程序运行的过程中，它始终指向下一条指令的首地址，它与段寄存器CS联用确定下一条指令的物理地址。 SP（stack pointer），堆栈指针寄存器，存放栈顶的偏移地址，与堆栈段寄存器SS联用来确定堆栈段中栈顶的地址。 FLAGS标志寄存器，又称为程序状态寄存器（program status word，PSW）。 条件标志 溢出标志 （overflow flag，OF），运算溢出时为1，否则为0。 符号标志 （sign flag，SF），运算结果为负时为1，否则为0。 零标志 （zero flag，ZF），运算结果为0时为1，否则为0。 进位标志 （carry flag，CF），记录运算时从最高有效位产生的进位值。有进位时为1，否则为0。 辅助进位标志 （auxiliary carry flag，AF），..… 奇偶标志 （parity flag，PF），结果操作数中1的个数为偶数时为1，否则置0。 控制标志方向标志（direction flag），在串处理指令中控制处理信息的方向用。 DF为1时，高地址到低地址，即倒着来。 DF为0时，低地址到高地址，即正着来。 系统标志 陷阱标志 （trap flag，TF），用于调试时的单步方式操作。 TF为1时，产生陷阱；否则不产生。 中断标志 （interrupt flag，IF），当其为1时，允许CPU响应中断；否则不允许。 段寄存器段寄存器也是一种专用寄存器，专用于存储器寻址，用来直接或间接存放段地址。 代码段 （code segment，CS），存放当前正在运行的程序。 数据段 （data segment，DS），存放当前运行程序所用的数据。 如果程序使用了串处理指令，则其源操作数也存放在数据段里。 堆栈段 （stack segment，SS） 附加段 （extra segment，ES），附加的数据段，作为辅助的数据区，也是串处理指令的目的操作数存放区。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请不要到处糊弄]]></title>
    <url>%2F2019%2F05%2F31%2F%E8%AF%B7%E4%B8%8D%E8%A6%81%E5%88%B0%E5%A4%84%E7%B3%8A%E5%BC%84%2F</url>
    <content type="text"><![CDATA[现在是凌晨三点，我并不想熬夜的，但我真的睡不着。 提交成果后，我觉得在这道题的参赛者中我是很有希望拿第一的。因为我花了很大的精力，从正确性、效率和适用性这三个层面上来看，做得很不错了，几乎完美。这并不是傲慢，仅仅是基于现实情况对自己能力和成果的肯定。 后来成绩出了，结果和想象中有点差距，我有些失望，第一反应是想知道各组的成绩，这样可以看到差距有多大和自己是差在哪里，问了问，无果。 今天，知道了另外一件事，更加失望，想象中是第一，然而现实却是这样。 我做得这么差吗？那以后好好努力吧。加油..… 凌晨一点左右，结合老师的评价，我看了名次好的同学的成果，嗯..….，结果稍微不太一样哈，嗯，再看看，看看结果的图片吧，这不是一样吗？ 奥奥，他算出来某神秘物体S的个数是3，我算的是6啊（这个数字是少一点比较好的）。诶，我验证过3是不可能的啊，嗯，再看看..… emm？那几个怎么没算上？他也是6啊。而且用他自己的理论都能把他说倒，这几个是S，另外几个怎么就不是S呢？ 我再去查查资料吧。嗯嗯，果然是当时我遇到的一个问题：是否使用L距离。这个问题只是表象，计算方法而已，并非实质，但它影响了S的定义，进而影响了3或6这个数字。如果按资料里的假设，这篇论文还可以，就是没明确写出来假设，S的定义也没有明确指出，所以刚才那个问题还是存在的。 在我的假设下，使用欧式距离，S也有明确定义，结果也是正确的，跟他们相比差别就在L距离了，书上都是说假设用L距离，而非一定是L距离，L距离并不是该类问题的固定假设，严格来讲，我这个并不是个所谓的问题。 看下来，好像评委也没认真研究这个题目吧？都没看出来两种方法的区别吧？ 这就让我很震惊、很气愤了。（或许是我真的菜吧，没真的懂这个问题？） 作为学习、研究学问的人，老师和学生都糊弄？这样糊弄哪来学问。 以下才算是正文。我就想这么写，写一堆一堆的废话。 这个比赛糊弄，其他的比赛也有糊弄的，昨天得知我刚树立好的目标也在糊弄，emmm真的多..… 我知道比赛是有评委的嘛，评委没有多少时间看，你得知道他想看什么，你要做得让他舒服。 这我当然不否认，各种各样的合作是需要让别人舒服，但我想讨论的是糊弄。 比赛之外，再算上其他时候遇见的糊弄..…..…啊，wsl，这也是我为什么睡不着了。 我们都懒，偶尔懒一懒、跑跑神还是可以的啊，但也别啥都糊弄 上课不听，玩游戏刷微博看小说，上课下课了自豪地说：我啥都没听懂，这老师讲得真烂；他讲的我听不懂，所以我才玩儿的；我书跟新买的一样干净哈哈哈。 上课你去得早，上课前你在玩游戏等着上课，上课你又不听，反正还是打游戏，那你刚才等啥呢？ 上实验课前边10分钟老师在讲，你坐那儿玩手机，到做实验了你就开始活跃了，我们要干嘛？怎么做？带带我？ 作业什么的有个问题问你，你是做出来了，但是问你你就不知道，在背答案呢还是做作业打工呢..…..… 让给你讲东西，给你讲了你说别扯了，你听不懂，不想听。 遇到的那些问题，随便想想办法都可以自己解决的。上边说的都是糊弄学习什么的，我是比较喜欢思考和科学的，有人说他不喜欢学习，当然可以啊。 emm那你问过你自己喜欢什么吗？你真的喜欢它吗？你了解它吗？为什么？这样可以吗？不喜欢学是不是你不想学的借口啊？自己现在过得充实有意义吗？ 要是你说，人生的每一次选择都是最好的，人生怎么样过都可以，那也行，你有这样的乐观、自信和准备就好。 如果你能跟自己说说话，多上一层思考，多想想自己的内核逻辑，换点思考内容，事情多问几个真的吗？是吗？为什么？怎么弄的？我的原因？他的原因？谁的原因？我做得还可以吗？他说的对嘛？他为什么这样想？我为什么这样想？我应该怎么想？这样做是否符合社会主义核心价值观？这样是最有效的方式吗？我在想什么？哈哈哈哈哈哈 以上内容个人觉得口吻过于讽刺，不要对号入座，看看就好，别天天糊弄着过就好了。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-实验（三）]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[实验目的 掌握程序设计中的3种基本结构(顺序结构、选择程序、循环程序)。 熟练使用汇编语言的指令：数据传送类指令、数据运算类指令、逻辑判断类指令与转移指令、循环指令等。 初步了解系统功能调用的使用方法，尝试使用01H号功能调用进行字符输入的方法及使用02H号功能调用进行字符输出（显示）的方法。 程序说明 编写十进制到十六进制转换程序。要求从键盘取得一个十进制数，然后把该数以十六进制形式在屏幕上显示出来 已知从BUF开始存放了10个16进制字数据，编程求出这10个数中的最大数，（将最大数存入MAX字节单元），并将其以10进制数的形式在屏幕上显示出来。（提示：以上两题都要求采用子程序的方法） 从键盘上输入一行字符，如果这行字符比前一次输入的一行字符长度长，则保存该行字符，然后继续输入另一行字符;如果它比前一次输入的行短，则不保存这行字符。按下‘$’输入结束，最后将最长的一行字符显示出来。（选作） 设计思想题目一如下图所示，首先调用子程序getinput获取用户输入的十进制数字，然后调用子程序htoa以十六进制显示用户输入的数据。 题目二如下图所示，首先调用子程序getmax获取buf中的最大值，同时存储进max和(ax)，最后调用子程序display显示(ax)。 题目三​ 首先子程序getstr获取用户输入的字符串，每收到一个字符串之后，根据长度判断是否更新string，然后用户输入一个字符判断输入是否结束； ​ 然后子程序display显示字符串string。 程序代码题目一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889stack segment ; 数据段 dw 128 dup(?) ; 堆栈大小为128个字 tos label word ; 栈底地址为tosstack endscode segment ; 代码段 assume ss:stack,cs:codemain proc far; 初始化ss、sp寄存器 mov ax,stack mov ss,ax ; (ss)&lt;-stack lea sp,tos ; (sp)&lt;-tos，sp存储栈顶地址，当前栈顶即为栈底 ; 为返回DOS作准备 push ds mov ax,0 push ax ; 获取用户输入的十进制数 call getinput ; 调用子程序，在DOS中以十六进制输出(ax) call htoa retmain endpgetinput proc near mov bx,0 ; bx存储用户输入 mov cl,10 ; 乘法用 input:; 判断用户输入是否合法 mov ah,1 ; 调用1号功能，获取用户输入，保存至(al) int 21h ; 调用DOS sub al,30h ; ASCII码转二进制 cmp al,0 ; jl exit ; (al)&lt;0，则说明输入结束 cmp al,9 jg exit ; (al)&gt;9，则说明输入结束 ; (bx)&lt;-(bx)*10+(al) push ax ; 暂存(ax) mov al,bl ; (al)&lt;-(bl) mul cl ; (ax)&lt;-(al)*(cl) mov bx,ax ; (bx)&lt;-(ax)==(bx)*10 pop ax ; 恢复(ax)，(al)为用户输入的数字 and ax,00ffh ; (ax)高位设为0 add bx,ax ; (bx)&lt;-(bx)+(al) jmp input ; 继续获取用户输入exit: mov ax,bx ; (ax)&lt;-用户输入 ret ; 返回getinput endphtoa proc near cmp ax,15 ; 和15比较 jle blow ; 若(ax)小于等于15，则跳转至blow ; (ax)低4位（大小是一个字）进栈后，右移4位 push ax ; (ax)大于15，暂存ax push bp ; 暂存bp mov bp,sp mov bx,[bp+2] ; (bx)&lt;-(ax)，(bp)、(ax)都占一个字，栈底与栈顶相比为高地址 and bx,000fh ; 只保留低4位 mov [bp+2],bx ; 存入栈中 pop bp ; 恢复bp mov cl,4 shr ax,cl ; 逻辑右移4位 call htoa ; 递归调用子程序htoa pop ax ; 获取之前存入栈中的低4位blow: add al,30h ; (al)转换为ASCII码 cmp al,3ah ; jl printit ; 若(ax)小于10，则跳转至printit add al,7h ; (al)大于等于10，加7进位到高位printit: mov dl,al ; mov ah,2 ; 调用2号功能，DOS输出(dl) int 21h ; 调用DOS rethtoa endp code endsend main 题目二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110data segment buf dw 5,9,6,8,7,0,4,3,2,1 ; 定义10个字数据 max dw ? ; 存储最大值data endscode segment assume ds:data,cs:codemain proc far; 为返回DOS作准备 push ds mov ax,0 push ax ; 将(ds)设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax) ; max记录buf中的最大值 call getmax ; (ax)&lt;-max mov ax,max ; 十进制输出(ax) call display ; 返回DOS retmain endpgetmax proc near; 保存寄存器 push ax push cx push si ; 数据初始化 mov ax,[buf] mov max,ax ; 假设第0个元素为最大值 mov cx,9 ; buf还剩9个元素 mov si,2 ; 下标指向第一个元素，因为是字数据，所以为2compare: mov ax,buf[si] cmp max,ax jge loop1 mov ax,buf[si] mov max,ax ; 更新最大值loop1: add si,2 ; 下标+1 loop compare ; 继续比较 ; 恢复寄存器 pop si pop cx pop ax ; 返回 retgetmax endpdisplay proc near ; 将(ax)以十进制形式输出; 保存寄存器 push ax push bx push cx push dx push si ; 初始化 mov si,0 ; 数字的位数 mov bl,10 ; 数字之后除以bx,即10 ; 数字每位倒序压栈prepare: div bl ; 被除数默认为(ax)，除以10。 add ah,30h ; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h push ax ; 存储最后一位 and ax,00ffh; (ah)&lt;-0 mov cx,ax ; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环 inc si ; 更新数字位数 inc cx ; 如果为0，加一之后为1。loop判断前会将cx减一。 loop prepare; ; 弹栈，并用十进制显示 mov cx,si ; si为数字位数，即循环运行次数show: pop ax ; 获取要显示的数据 mov dl,ah ; 要显示的数据放在dl里 mov ah,2 ; 2号功能 int 21h ; 调用DOS loop show; 恢复寄存器 pop si pop dx pop cx pop bx pop ax ; 返回 ret display endp ; display子程序结束code endsend main 题目三123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110data segment string db 0 ; 存放字符的个数 db 80 dup(0),0dh,0ah,&apos;$&apos; ; 存放前一次输入的字符串，兼作显示缓冲区。0ah换行、0dh回车（归位） buffer db 80 ; 输入字符串的缓冲区，最多输入80个字符 db 0 ; 存放字符的个数 db 80 dup(0) ; 存放当前输入的字符串，20h为空格data endscode segment assume cs:code,ds:data,es:datamain proc far; 为返回dos作准备 push ds mov ax,0 push ax; (ds)&lt;-(ax) (es)&lt;-(ax) mov ax,data mov ds,ax mov es,ax; 调用子程序，获取用户输入的串，判断是否更新，最终输出 call getstr ; 显示最终串 call display ; 程序返回 retmain endpgetstr proc near; 保存寄存器 push ax push cx push dx push di push si; 获取用户输入的字符串存入bufferinput: lea dx,buffer ; dx存缓冲区首址 mov ah,0ah ; DOS调用0A号功能，输入字符到缓冲区DS:DX int 21h ; DOS调用; DOS光标换行（处理多组输入，因为按下Enter仅能使光标回车） mov ah,2 mov dl,0ah int 21h; 比较字符串长度 lea si,buffer+1 ; buffer+1是当前串长度的地址 lea di,string ; (string)存入di，(string+2)存入es，源操作数只能用存储器寻址方式，目的寄存器不允许使用段寄存器 mov al,[si] ; 当前串长度存入al cmp al,[di] ; 与之前的串长度进行比较 jbe next ; 如果当前串更短，跳转到next，接收下一个字符串; 更新之前串string mov cx,80+1 ; 当前串比之前串长，更新串 cld ; 正向处理字符串 rep movsb ; 重复串操作，di为目的串，si为源串; 处理$失效问题 mov ah,0 mov si,ax mov [string+si+1],&apos;$&apos;; 获取下一个串next: mov ah,1 ; 获取用户输入 int 21h ; DOS调用 cmp al,&apos;$&apos; ; 是结束符吗？ jne input ; 不是则继续输入; 恢复寄存器 pop si pop di pop dx pop cx pop ax; 子程序返回 retgetstr endpdisplay proc near; 保护寄存器 push dx push ax; DOS光标换行，处理用$结束输入后没有换行的问题 mov ah,2 mov dl,0ah int 21h; 显示最终串 lea dx,string+1 ; 串地址存入dx mov ah, 9 ; dos调用9号功能，显示串 int 21h ; 调用DOS; 恢复寄存器 pop ax pop dx retdisplay endpcode endsend main 结果分析前两题略 题目三遇到的问题及解决方法如下： 获取用户输入的字符串时，按下Enter之后，光标回车，由于题目是多个输入（用户只输入一个字符串时，也要用$作为一次输入，所以也算多个输入），所以要增加换行操作。 输出结果时string后边的`并没有起到作用，只能自己在更新string之后手动存储`。 出现吞字问题：除了第一次输入，之后的输入第一个字符都会被当做判断输入结束的字符而不是字符串的内容…所以会吞字。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-实验（二）]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[实验目的 掌握程序设计中的3种基本结构(顺序结构、选择程序、循环程序)。 熟练使用汇编语言的指令：数据传送类指令、数据运算类指令、逻辑判断类指令与转移指令、循环指令等。 初步了解系统功能调用的使用方法，尝试使用01H号功能调用进行字符输入的方法及使用02H号功能调用进行字符输出（显示）的方法。 程序说明 计算1+2+3+…+10，将结果显示在屏幕上。 利用01H号功能调用输入10个一位数字，并将其由ASCII码转换为二进制数，依此保存到变量BUF的10个字节中，变量BUF的形式为BUF DB 10 DUP（？）。编程求出这10个数中的最大数和最小数，将最大数存入MAX单元、最小数存入MIN单元，并将其在屏幕上显示出来。 设计思想题目一如下图所示，首先通过循环求出1+2+…+10，然后调用子程序display显示sum。 题目二如下图所示，首先调用子程序getinput获取用户输入，同时存储进数组，并更新max和min，最后调用两次子程序display显示max和min。 程序代码题目一12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788;*********************************************************************data segment ; 定义数据段 sum dw 0 ; 存储和data ends;*********************************************************************code segment ; 定义代码段 assume cs:code,ds:data ;--------------------------------------------------------------------- main proc far ; 程序的主部分start:; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- data push ax ; ax压栈; ds设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax) mov cx,10 ; 从10加到1 next: add sum,cx ; sum &lt;- sum+(cx) loop next ; (cx) &lt;- (cx)-1 mov ax,sum ; (ax) &lt;- sum call display ; 调用子程序以十进制显示(ax); 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------display proc near ; 将(ax)以十进制形式输出; 保存寄存器 push ax push bx push cx push dx push si ; 初始化 mov si,0 ; 数字的位数 mov bl,10 ; 数字之后除以bx,即10 ; 数字每位倒序压栈prepare: div bl ; 被除数默认为(ax)，除以10。 add ah,30h ; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h push ax ; 存储最后一位 and ax,00ffh; (ah)&lt;-0 mov cx,ax ; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环 inc si ; 更新数字位数 inc cx ; 如果为0，加一之后为1。loop判断前会将cx减一。 loop prepare; ; 弹栈，并用十进制显示 mov cx,si ; si为数字位数，即循环运行次数show: pop ax ; 获取要显示的数据 mov dl,ah ; 要显示的数据放在dl里 mov ah,2 ; 2号功能 int 21h ; 调用DOS loop show; 恢复寄存器 pop si pop dx pop cx pop bx pop ax ; 返回 ret display endp ; display子程序结束code ends;********************************************************************* end start 题目二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143;*********************************************************************data segment ; 定义数据段 buf db 10 dup(-1) ; 存储10个输进来的数字 max db 0 ; 最大值，输入的数字一定大于等于0 min db 9 ; 最小值，输入的数字一定小于等于9data ends;*********************************************************************code segment ; 定义代码段 assume cs:code,ds:data;--------------------------------------------------------------------- main proc far ; 程序的主部分start:; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- data push ax ; ax压栈; ds设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax) ; 获取用户输入并进行存储，记录最大值最小值 call getinput ; 数字存入al，显示一下; 显示最大值 mov al,max ; 显示最大值 and ax,00ffh ; (ah)&lt;-0 call display ; 调用子程序以十进制显示(ax); 显示最小值 mov al,min ; 显示最小值 and ax,00ffh ; (ah)&lt;-0 call display ; 调用子程序 ; 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------getinput proc near ; 获取用户输入并进行存储，记录最大值最小值; 保存寄存器 push ax push bx push cx; 初始化 mov cx,10 ; 10个输入 lea bx,buf ; 存储数组地址，用来遍历数组; 获取用户输入savetoarray: mov ah,1 ; 1号功能，获取用户输入，保存至al int 21h ; 调用DOS; 存入数组 sub al,30h ; (al)减去30h由ASCII码转为十进制数，在计算机内自动用二进制表示 mov [bx],al ; 存入数组，相对寻址方式 inc bx ; 数组地址加一 ; 判断是否更新最大值updatemax: cmp al,max ; (ax)&lt;-max jl updatemin ; (ax)&lt;max，则不用更新 mov max,al ; 更新最大值 ; 判断是否更新最小值updatemin: cmp al,min ; (ax)&lt;-min jg loopp ; (ax)&gt;min，则不用更新 mov min,al ; 更新最小值 ; 循环savetoarrayloopp: loop savetoarray ; cx减一，循环至cx为0 ; 恢复寄存器 pop cx pop bx pop ax ; 返回 ret getinput endp ; getinput子程序结束;---------------------------------------------------------------------display proc near ; 将(ax)以十进制形式输出; 保存寄存器 push ax push bx push cx push dx push si ; 初始化 mov si,0 ; 数字的位数 mov bl,10 ; 数字之后除以bx,即10 ; 数字每位倒序压栈prepare: div bl ; 被除数默认为(ax)，除以10。 add ah,30h ; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h push ax ; 存储最后一位 and ax,00ffh; (ah)&lt;-0 mov cx,ax ; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环 inc si ; 更新数字位数 inc cx ; 如果为0，加一之后为1。loop判断前会将cx减一。 loop prepare; ; 弹栈，并用十进制显示 mov cx,si ; si为数字位数，即循环运行次数show: pop ax ; 获取要显示的数据 mov dl,ah ; 要显示的数据放在dl里 mov ah,2 ; 2号功能 int 21h ; 调用DOS loop show; 恢复寄存器 pop si pop dx pop cx pop bx pop ax ; 返回 ret display endp ; display子程序结束code ends;********************************************************************* end start 问题回答设计的程序包含了几个段题目一和题目二的程序各设计了两个段：数据段和代码段。 你的代码经过编译和链接之后，总共占用多少个字节题目一和题目二程序编译链接后大小均为1KB。 调用DEBUG进行反汇编，查看程序的第一条指令的地址码是多少？最后一条指令的地址码是多少？ 题目一第一条指令的地址码为076B:0000，最后一条指令的地址码为076B:0018。因为使用了一个子程序，所以主程序较短。 题目二第一条指令的地址码为076B:0000，最后一条指令的地址码为076B:001E。因为使用了两个子程序，所以主程序较短。 对于第2题，怎样修改程序可以同时实现将10个数字的累加功能 首先在数据段中定义变量，代码如：sum db 0； 然后在getinput子程序中savetoarray中sub al,30h后添加代码add sum,al。 对于第2题，若要求输入的是两位数，又该怎么办？ 首先(cx)改为20； 然后每两个数字一组：其中先得到的数字转换为十进制数字A暂存，后得到的数字转换成十进制数字B暂存； 可知我们要操作的数字为A*10+B（可以通过乘法和加法实现）； 其他程序不变。 结果分析题目一运行程序，可见输出了1+2+…+10=55。 题目二运行程序，输入9876543210共10个数字，可见输出了最大值9和最小值0。 查看数据段dds:0，结果如下，可知数字均已存入buf数组。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理课程介绍]]></title>
    <url>%2F2019%2F05%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[之前看哈工大计组视频时的笔记。 课程名称解释计算机：数字电子计算机组成：计算机硬件系统的逻辑实现organization：组成 用数字电路知识实现计算机硬件系统。 原理：一般原理数字电子计算机硬件系统逻辑实现的。 特色 不以具体机型为依托 自顶向下、层层细化 课程讲授内容基本部件的结构和组织方式用数电知识对计算机基本部件进行逻辑实现。 基本运算的操作原理如何用数电知识实现计算机的基本功能：加减乘除等运算的硬件电路。 基本部件和单元的设计思想基本部件和基本单元的设计思想以及如何将部件连接起来。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机系统概论]]></title>
    <url>%2F2019%2F05%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[之前看哈工大计组视频时的笔记。 计算机系统概论现代计算机由哪两部分组成？硬件计算机的实体，如主机、外设等。 软件由具有各类特殊功能的信息（程序）组成。 硬件通过每条指令的有序执行发挥作用。 系统软件管理整个计算机系统。 语言处理程序编译环境 操作系统管理软硬件资源、提供人机交互等。 服务性程序比如数学库。 数据库管理系统网络软件应用软件按照某个任务的需要编制成的各种程序。 硬件和软件逻辑关系硬件进行了相对的封装，为软件提供接口，比如指令集。 应用软件使用系统软件提供的接口，系统软件使用硬件提供的接口。 计算机系统的层次结构https://www.bilibili.com/video/av15123338/?p=3 11分55秒 物理抽象 程序员角度抽象 机器语言-实际机器M1- 操作系统-虚拟机器M2- 汇编语言-虚拟机器M3- 高级语言-虚拟机器M4-用编译程序翻译成汇编语言程序 微指令系统-微程序机器M0- 一条机器语言指令也是很复杂的，将机器指令进行细化。 计算机组成和计算机系统结构的区别从研究内容上来说 计算机系统结构计算机系统结构定义了计算机系统软硬件的交界面，定义了哪些功能由软件来实现吗，哪些功能由硬件来实现，提供上层软件进行编写的时候和硬件进行交互的接口。 计算机系统结构指程序员（机器语言程序员）所见到的计算机系统的属性、概念性结构和功能特性。 计算机系统属性：编写成能在计算机硬件系统上正确执行的程序他所必须了解的计算机系统的属性，比如指令集、寄存器文件的组织等等。 计算机组成计算机组成设计人员的任务是实现计算机系统结构所体现的属性，即具体指令的实现。 计算机的基本组成冯诺依曼计算机的特点冯诺依曼计算机是存储程序型的计算机。 问题是运算器是瓶颈和各部分的组成不具有层次化特征。 由五大部分组成运算器算数运算和逻辑运算。 计算机的功能主要是运算，比如加减乘除。 控制器指挥程序的运行。 控制器控制做什么运算。 存储器存放数据和程序。 指令和数据放在存储器中。（存储程序型的计算机） 输入设备将信息转换成机器能识别的形式。 程序和数据输入到计算机中。 输出设备将结果转换成人们熟悉的形式。 计算结果的输出。 指令和数据以同等地位存于存储器，可按地址访问指令和数据用二进制表示指令由操作码和地址码组成操作码：做什么操作，指出寻址方式、指出操作数类型等等 地址码：操作数在哪里 存储程序这是核心特征。程序存储在存储器中，具有存储程序的计算机都称为冯诺依曼计算机。 以运算器为中心运算器非常地繁忙，成为计算机系统的瓶颈。 改进：以存储器为中心现代计算机硬件框图计算机的解题过程存储器的基本组成存储体存储体由若干个存储单元组成。 存储单元存储单元由多个存储元件（0/1）组成。 指令存储在存储单元中。 每个存储单元有个地址，存储单元按地址寻访。 存储字：一个存储单元中二进制代码的组合。 MAR存储器地址寄存器：反映存储单元的个数，保存存储单元的地址（编号）。 MDR存储器数据寄存器：反映存储字长。 存储字长存储单元中二进制代码的位数。 运算器的基本组成及操作过程视频P8。 计算机硬件的主要技术指标作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之继承（二）]]></title>
    <url>%2F2019%2F05%2F01%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%BB%A7%E6%89%BF%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[构造函数与析构函数 派生类只能在构造函数初始化列表中为基类或对象成员进行初始化。 当基类没有默认构造函数的情况下，派生类必须定义构造函数，并通过它为基类构造函数提供初始化值。（编译器合成的构造函数也算默认构造函数） 子类构造函数只负责直接基类的初始化。 当存在虚基类时，所有虚基类都由最后的派生类负责初始化。如果没有，则报错。 子类继承基类的构造函数C++11允许子类继承基类的构造函数，带来的方便是： 当基类构造函数有较多参数，而派生类没有数据成员需要初始化，但它必须提供构造函数，且唯一目的是为基类构造函数提供初始化值。在这种情况下，它只需要继承直接基类的构造函数就可以了。 12345class Derived:public Base&#123; ... using Base::Base; //继承基类构造函数 ...&#125;; 这个using不受访问权限的控制，放在public、private和protected区域中没有区别。 但这个using与另外两种用法（见继承第一讲）有不同之处：这个会使编译器在子类中生成代码，而用using声明基类成员时，并不生成代码。 构造函数和析构函数的调用次序基类构造函数$\rightarrow$对象成员构造函数$\rightarrow$子类构造函数（体） 多继承时，基类构造函数调用次序为继承方式中声明次序。 有多个对象成员时，按它们在子类中的声明次序调用其构造函数。 析构函数与构造函数次序相反。 这个次序要和之后出现虚拟继承后构造函数的次序进行结合，例题可看课本P173。 基类与继承类的使用根据继承的定义，我们可知任何一个派生类对象的内部都包含一个基类子对象，所以可以通过截取的方法从派生类对象中复制其基类子对象并将之赋值给基类对象。 子类对象对基类对象的赋值和初始化有两种情况：赋值和初始化。如下： 赋值123Derived d1;Base b1;b1=d1; 在把子类对象赋值给基类对象时调用基类的赋值运算符函数。 初始化12Derived d1;Base b1(d1); 1234void func(Base b);//main中Derived d1;func(d1); 以上两种情况，在用子类对象初始化基类对象时，会调用基类的拷贝构造函数。 子类指针和基类指针在这里，在逻辑上引用与指针等价。 基类指针可以指向子类对象12Derived d1;Base* pb=&amp;d1; 子类指针不能指向基类对象12Base b1;Derived* pd=&amp;b1; //错误的 若想实现类似子类指针指向基类对象的功能，需要用强制类型转换，但也只能在逻辑上正确时才能使用，否则后续使用中绝对会出错的。如下： 123Derived d1;Base* pb=&amp;d1;Derived* pd=static_cast&lt;Derived*&gt;(pb); //这里是个模板函数 多继承定义多继承即一个类继承了多个类。 123class D:public A, B,protected C&#123; ... &#125;; 成员二义性多继承情况下，当多个（1个以上）基类拥有同名成员时，会产生成员二义性。 可以通过类域限定符解决该问题，明确指出成员所属的基类。 虚拟继承虚拟继承引入的原因解决多继承引出的二义性问题。 如Student、Employee继承Person，StuEmployee继承了Student、Employee，这样StuEmployee的对象中就有两份不同的Person的数据成员。 123class Student: public Person&#123;...&#125;class Employee: public Person&#123;...&#125;class StuEmployee: public Student,public Employee,&#123;...&#125; 语法123class Student:virtual public Person&#123;...&#125;class Employee:virtual public Person&#123;...&#125;class StuEmployee: public Student,public Employee,&#123;...&#125; 构造函数调用次序 先调用虚基类的构造函数，再调用非虚基类的构造函数。 同一继承层次中有多个虚基类时，就按照它们声明次序进行构造。 若某个虚基类的构造函数已被调用，就不再调用。 若虚基类有非虚基类派生而来，则先调用该虚基类的构造函数，再调用该非虚基类的构造函数。 成员函数优先级继承层次中越靠下优先级越高。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙江理工大学2019数学建模校赛B题记录]]></title>
    <url>%2F2019%2F04%2F29%2F%E6%B5%99%E6%B1%9F%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A0%A1%E8%B5%9BB%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[第一题数据1234567891011121314w=[... 0, 80, 150, 90, 140, 100, 120; 120, 0, 180, 100, 60, 70, 110; 100, 160, 0, 80, 90, 50, 70; inf, inf, inf, 0, 40, 70, 180; inf, inf, inf, 30, 0, 80, 150; inf, inf, inf, 80, 90, 0, 50; inf, inf, inf, 130, 140, 60, 0; ];% 设甲、乙、丙三个矿区为顶点v1，v2，v3，% A、B、C、D 三个冶炼厂为v4、v5、v6、v7。% 该矩阵表示7个顶点间的距离% 由于不是对称矩阵，第一行第二行的元素表示甲到乙还是乙到甲是有区别的。题目不严谨，而老师PPT里是前者。有待区分(TODO)% TODO:graphallshortestpaths函数中的图参数 inf用0表示也可以？% 该矩阵与题给数据是否完全一样，有待比较(TODO) 建立模型构造有向图，G=(V,E, W)，顶点、边、权重。甲、乙、丙三个矿区为顶点v1，v2，v3，% A、B、C、D 三个冶炼厂为v4、v5、v6、v7。TODO:这部分可以参考骆桦PPT或者相关书籍与论文。 xij&gt;0，肯定大于0。即负数用表示同样含义的正数表示（TODO：怎么说呢） 由于可以转运： IMPORTANT：为什么不是用该矩阵中的值作为顶点之间的距离，而是根据此矩阵计算最短路径？（因为题中说可以转运，而最短路径即包括了转运的含义） 问题中最优的定义： 矿区的矿物产量刚好达到（即等于）冶炼厂矿物需求量（TODO：矿物产量和矿物需求量这两个词是否合适，应参照题目或统一规定用词），这是两个约束条件。 IMPORTANT：因为题目是求矿区到各冶炼厂间矿石的最优调运方案，所以从最短路径中提取出两个矿区（甲乙）到四个冶炼厂（ABCD）的最短距离 分别用i =1, 2表示甲乙两个矿区，j =1，2，3，4表示A、B、C、D三个电厂， cij表示第i个矿区到第j个冶炼厂的最短距离，xij表示第i个矿区到第j个冶炼厂的调运量，ai表示第i个矿区的产量，bj表示第j个冶炼厂的需求量。 这里是产量和需求平衡的运输问题 一些假设 花费与路径长度和运送量相关，所以假设花费=路径长度*运送量。在这一点可以尝试讨论，优化？ 假设调运方案中从矿区到各冶炼厂间调运吨数为整数，试试改成小数？ matlab程序计算出的最短路径矩阵，前三行后四列是我们的结果，如下。 12390 130 100 12090 60 70 11080 90 50 70 1234567891011121314151617181920212223242526272829clc;clear;w=[... 0, 80, 150, 90, 140, 100, 120; 120, 0, 180, 100, 60, 70, 110; 100, 160, 0, 80, 90, 50, 70; 0, 0, 0, 0, 40, 70, 180; 0, 0, 0, 30, 0, 80, 150; 0, 0, 0, 80, 90, 0, 50; 0, 0, 0, 130, 140, 60, 0; ];W = sparse(w);d = graphallshortestpaths(W)NodeIDs = &#123;'甲', '乙','丙', 'A', 'B', 'C', 'D'&#125;; % 节点标签，也就是h.Nodes(i).ID属性值h = view(biograph(w, NodeIDs, 'ShowWeights', 'on'))set(h.Nodes, 'shape', 'circle'); % 顶点画成圆形h.EdgeType = 'segmented'; % 边的连接为线段h.LayoutType = 'radial';trydolayout(h) % 刷新图形 会报错，故放在try块中，不影响结果，待深究catch exceptionendh2 = view(biograph(d, NodeIDs, 'ShowWeights', 'on'));h2.EdgeType = 'segmented'; % 边的连接为线段h2.LayoutType = 'equilibrium';trydolayout(h2) % 刷新图形 会报错，故放在try块中，不影响结果，待深究catch exceptionend TODO:matlab的图不怎么样。修改matlab参数、图论工具箱、网络分析工具箱、NetworkX lingo程序矩阵x和Objective Value是我们的最终结果：各矿区到各冶炼厂最优调度方案。 1234567891011121314151617model:sets:kuang/1..3 /:a; !甲乙丙矿区的产量;chang/1..4 /:b; !ABCD四个冶炼厂的矿石用量;link(kuang,chang):c,x;endsetsdata:a = 700 500 500;b = 400 300 400 600;c = 90 130 100 120 90 60 70 110 80 90 50 70;enddatamin = @sum(link: c * x);@for(kuang(i):@sum(chang(j):x(i, j)) = a(i));@for(chang(j):@sum(kuang(i):x(i, j)) = b(j));end TODO：检验答案正确性 135000.0 1234结果：三个矿区到四个冶炼厂的调度方案400 0 200 1000 300 200 00 0 0 500 待解决主要问题图画的不行、论文（建立模型部分、假设部分），可能这只是第一题，不需要花太大精力。 第二题几乎不用假设和建模，而且老师也给了两个lingo程序。但现在问题是老师给的第二个lingo程序看不太懂，不知道怎么把B题里的数据套进去。 我借的matlab书上都有直接给代码，但很长。 最大流 12345678910111213141516171819202122model:sets:nodes/s,1,2,3,t/;arcs(nodes,nodes):c,f;endsetsdata:c=0;@text(&apos;fdata.txt&apos;)=f;enddatacalc:c(1,2)=20;c(1,3)=16;c(2,4)=4;c(2,5)=14;c(3,2)=10;c(3,4)=20;c(4,5)=8;endcalcn=@size(nodes);max=flow;@for(nodes(i)|i #ne# 1 #and# i #ne#n:@sum(nodes(j):f(i,j))=@sum(nodes(j):f(j,i))); @sum(nodes(i):f(1,i))=flow;@sum(nodes(i):f(i,n))=flow;@for(arcs:@bnd(0,f,c));end 最小费用最大流 1234567891011121314151617181920212223model:sets:nodes/s,1,2,3,t/:d;arcs(nodes,nodes):b,c,f;endsetsdata:d=22 0 0 0 -22;b=0;c=0;enddatacalc:b(1,2)=12;b(1,3)=3;b(2,4)=18;b(2,5)=3;b(3,2)=6;b(3,4)=9;b(4,5)=6;c(1,2)=20;c(1,3)=16;c(2,4)=4;c(2,5)=14;c(3,2)=10;c(3,4)=20;c(4,5)=8;endcalcmin=@sum(arcs:b*f);@for(nodes(i):@sum(nodes(j):f(i,j))-@sum(nodes(j):f(j,i))=d(i)); @for(arcs:@bnd(0,f,c));End 第三题可选方法数学实验13-树算法08PPT里的后三种方法： 改进的贪心 模拟退火 修改过的prim 英文论文阅读s commentary the outstanding Steiner tree papers准确解 暴力法 直接暴力，890+个可能位置。 Hanan的一个理论，被三个队伍引用，说只需要考虑和一个已知站x坐标相同并且和另外一个已知站y坐标相同的steiner点。可能的steiner点位置减少到63个。 在此基础上可以，删除角落里的点，可能的位置减少到31个。 动态规划 虽然它还是要计算已知点的所有子集，但它避免测试所有steiner点的子集。 通过该这样的方法，几个小时可以找到50个可能位置，但似乎没有人这样做。 电脑芯片设计者通常喜欢近似解，因为网络的长度并不总是操作速度的限制条件。 近似解一个近似算法是不用虚设点，直接使用最小生成树，Hwang证明这个长度不超过steiner树的150%，但这当然不满足题目的要求。 某队找到一个最好的steiner点，然后把它加进已知站，之后重复这个策略直到加了7个点或者不可能优化了。这个方法找到了一个可能解，但并不是每次都可以这样。 某队用了多种不同的启发式算法，并且用另外四个样例对他们的方法进行了测试。另外，他们在评估他们的算法时做了一个好的决定。关于最小生成树他们还给了一个优化方案，因为他们通常不能计算准确的steiner树。他们的启发式算法都用了贪心策略。他们想出了一种改进的克鲁斯卡尔算法，模仿克鲁斯卡尔但如果有利的话会使用steiner点。这个启发式算法找到了一种可能解。虽然这个算法在速度上优于上一队，但面对更大规模的问题时它不一定能找到相当好的解。 某队(也就是下边的这个论文)用了模拟退火，模拟退火根据当地重新排列规则随机从某种解移向某种解。移向一个解的概率取决于这两个解的花费和一个叫做温度的控制变量。通过一个合适的冷却速率，这个启发式算法最终停在一个几乎最优解。他们模拟了100次这个程序都得到了最优解。 总结最后简单总结一下，有两种方法： exact solution 求确切的最优解，有两种方法。 暴力枚举法 通过减少steiner点可能的位置来节约时间，仍然是在用这种方法。 动态规划 似乎没有人用这个。 近似解 通过启发式算法，求近似最优解，有几种方法。 单点贪心 每次先找到一个最好的steiner点，将其加入已知站，直至N-2或不可能有更好的解了。 改进克鲁斯卡尔算法 模仿克鲁斯卡尔，但考虑了steiner点。 模拟退火，这是最好的一个方法 还未具体去看那篇论文(1991 B Finding optimal Steiner trees) 1991 B Finding optimal Steiner trees模拟退火过程这是一种更有效的寻找所有可行的虚设点和已知点组合的方式。 我们从一个已给的虚设点和已知点组成的树开始，并且允许模拟退火程序创造一个新的配置。对每一个新配置来说，程序决定了最小生成树并且计算其长度。然后模拟退火程序在冷却计划的基础上决定是使用还是拒绝新配置。修改一个配置和评价这个修改方案都很简单。 这个方法很有普适性：任何初始配置都可能被使用，并且算法并不直接取决于固定的站点设置。 和暴力相反，模拟退火并不一定能产生绝对的最优解。然而，我们可以按照我们的希望控制其停在当前最小值（和绝对的最优解不同），同时与暴力相比，计算时间可得到很大的缩减。 虚设点有31个可能位置作为初始条件。该模拟退火程序的输入是已知点位置、steiner点的可能位置，还有一个初始路径。（我们手动找了一个最优解，并将其作为程序的输入。我们把已知网络按照三点一组的规则进行分组，每组添加一个虚设点使该组最优，然后使各组最优，得到的配置作为模拟退火的最小路径出现了几次。） 现在配置改变的方式随机从下边选择： 随机在可能位置添加一个steiner点 移除一个已加入的虚设点 将一个已加入的steiner点随机移到一个新的位置 （通过这三种方式，我们可以尝试所有可能的网络配置。如果是为了这样做，第三种方式并没有必要；但是为了给模拟退火步骤更大的自由性，我们包含了这种方法。） 使用存储起来的新配置，为了建立最小生成树和评价网络的花费，一个计算程序会被调用。这个花费然后会被程序的模拟退火部分（routine METROP from Press et al.）使用，以决定新的配置是否被保存或拒绝（根据一个意见一致的冷却计划）。 刚开始的前几次表明一个趋势：增加度为2的虚设点是没用的。虽然虚设点并不花费什么，我们决定在程序中排除这个多余，通过引入较小的虚设点花费，这个花费足够小，并不会影响在必要时加入虚设点，反而最终会处理没有必要的虚设点。 我们同时也添加了一个模拟退火中不经常出现的特点，借此这个程序可以存储测试出的最优解。（模拟退火一般只返回最终使用的配置） 结果平均迭代9800次退火，1.5min（在25-MHz 386-based PC） 用不同的种子形成不同的随机数生成器，给了5种不同的最优解，长度为94。 超过100个回合时，模拟退火总是收敛到5种中的1种，证明它适用于更大范围的steiner树的问题（当暴力是不可能的时候）。 扩展如果所有站点是有花费的 如果想用模拟退火，我们可以： 用一些暴力方法 模拟退火数量、位置、虚设点的度（嵌套退火） 修改最小生成树算法，找到花费最小（而不是路径长度最短）的树，并且用前边的模拟退火 似乎前两种方法太费时间而且效率不高，我们选择第三种。 虽然模拟退火不一定能给出最优解，但它在100次试验之后，确实给了最优解（暴力检查过）。 工作记录 2019.4.4 工作 尝试做第一题，写了一些假设，思路和需要注意的点等等。 感想 平常还是要做好充足的准备，不要等着题发下来了才去详细了解某些知识和算法。比如这次校赛，昨天出的题，B题就是课上讲过的东西，如果当时抽时间具体研究了，现在不是就已经会了吗？（虽然现在刚学习建模不久，而且当时好像没时间……当然是选择原谅自己） 2019.4.5 工作 实现第一题matlab程序，发现作的图好丑，不够清晰。寻求解决办法，了解到网络分析工具箱、NetWorkX等。 感想 擒贼先擒王。最终目的是写一篇好的论文。现在应该把整个思路给定下来，大体上进行实现。不是能因为这个图花费太多时间，应该在后期优化。 2019.4.6 工作 实现第一题lingo程序，得到答案。重新回顾第一题，整理思路、材料和之后需要做的相关工作。 看第二题，最小费用最小流，好像得出答案比较简单。了解steiner树，查阅文献。 感想 道阻且长，我应该对lingo、matlab极其熟悉吗？ 2019.4.7 工作 阅读英文论文点评并总结，着手查看比较好的一篇论文。 感想 类似的问题，可以直接去看论文。另一方面，更好的是去看论文点评，能够站在顶层往下学习还是很不错的一种体验。 问题让求steiner树，我们可能是要先证明每个图中steiner树是一定存在的？ 2019.4.8 工作 阅读英文论文模拟退火部分并总结，解决第二题最小费用最大流。 2019.4.9 工作 上完建模课和队友讨论，知道了凸包..…突然发现题目要求很变态的一点，管道必须是平行于x轴或y轴的。这个是求出结果后不证自明，还是过程中就要求判断呢。 2019.4.10 工作 知道凸包是什么了，知道了美赛91为什么用L距离，又了解了几种求近似解的方法。着手模拟退火算法 感想 啊..……不会………..…..…不想说话 2019.4.11 工作 学习模拟退火，学了一半吧 2019.4.12 工作 继续学习模拟退火，学完了，知道是什么，大概知道怎么用。 着手将题目与模拟退火结合，设计代码。 2019.4.13 工作 敲代码，整体结构敲出来了，差一个扰动函数 感想 matlab的基础还是不足，很多东西都需要搜着做 2019.4.14 工作 写扰动函数，尝试调参。难呐..… 2019.4.17 工作 通过暴力，发现这个题和普通的steiner树不一样，按普通的steiner树求解的话，是不符合题目要求的。 核心呐：它要求边水平或竖直，这样目标函数就应该改成合法性了。 设想了目标函数为合法性的算法如何实现。 2019.4.20 工作 实现目标函数为合法性的程序，最终可以求得合法的steiner树。但无用的steiner点太多了，需要优化。 2019.4.21 工作 在合法树的基础上进行长度和steiner点个数的优化。 遗留了一个问题：自己写的一个函数总是出问题，不符预期。 2019.4.22 工作 解决昨天遗留的问题，写函数优化无用的steiner点。（原因是在for循环中数组变小了，然后就越界了，python中也有这样的东西嘛我记得 求得最终答案（不知道强迫症还是什么，总感觉有隐患..…，不过本来的思路就是求近似最优解..） 整理代码，完善注释。 那个无用的steiner点即使写了优化函数之后还是有，原因是去掉无用点之后，调用最小生成树算法，这个算法导致有多余的steiner点的产生。 2019.4.23 工作 讨论结果和论文思路，分工 2019.4.24 工作 中午下课吃完饭回来就写论文，晚上剪头，吃麻辣烫看了两集BigBang，回来继续写，写到现在11点半了，写了2500+字。主体部分已经写了有四分之三了，一些细节写在了注释里。耶 2019.4.25 工作 上下午第四节都在写论文，算法设计与分析课上也在写论文..…整体上是写完了，剩下的工作是补充细节。 2019.4.26 工作 快中午的时候开始补充论文细节，一直到晚上，效率挺低的，可能是分工问题，另外是还有一些讨论的工作。 2019.4.27 工作 流程图、公式、标题、字体、程序代码等等都搞定了，差不多结束了，第一题代码太烂就先算了吧，那个不重要。 2019.4.28 工作 搞细节咯，还修改了个流程图。检查了几遍，结束咯~ 整个过程想来还是挺艰辛的，大多都是在尝试，不断地试错然后改进，可能建模都这样吧。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-第五章作业]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[5.6题目编写程序，将一个包含有20个数据的数组M分成两个数组：正数数组P和负数数组N，并分别把这两个数组中的数据个数显示出来。 流程图123456789101112131415161718flowstart=&gt;start: 开始getNum=&gt;operation: 取数组下个元素whetherNegative=&gt;condition: 是负数？isPositive=&gt;operation: 存入正数数组isNegative=&gt;operation: 存入负数数组whetherEnd=&gt;condition: 数组最后一个元素？showNegative=&gt;operation: 显示偶数个数showPositive=&gt;operation: 显示奇数个数end=&gt;end: 结束start-&gt;getNum-&gt;whetherNegativewhetherNegative(yes)-&gt;isNegativewhetherNegative(no)-&gt;isPositiveisNegative-&gt;whetherEndisPositive-&gt;whetherEndwhetherEnd(no)-&gt;getNumwhetherEnd(yes)-&gt;showPositive-&gt;showNegative-&gt;end 程序初始数组中存放20个数字：1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495data segment separator0 dw &apos;A&apos; ; 间隔符，方便查看内存内容 array dw 1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10 ; 存放数组 separator1 dw &apos;A&apos; ; 间隔符，方便查看内存内容 P dw 20 dup (?) ; 存放正数 separator2 dw &apos;A&apos; ; 间隔符，方便查看内存内容 N dw 20 dup (?) ; 存放负数 separator3 dw &apos;A&apos; ; 间隔符，方便查看内存内容 lenOfArray equ 20 ; 数组长度 lenOfP db 0 ; 存放正数的个数 lenOfN db 0 ; 存放负数的个数 positive db 0dh, 0ah, &apos;the positive number is：&apos;, &apos;$&apos; ; 正数的个数是： negative db 0dh, 0ah, &apos;the negative number is：&apos;, &apos;$&apos; ; 负数的个数是： crlf db 0dh, 0ah, &apos;$&apos; ;回车换行data ends; --------------------------------------------------------------------------code segment main proc far assume cs: code, ds: datastart: ; 为返回DOS做准备 push ds ; ds入栈 sub ax, ax ; ax置0 push ax ; 0入栈 ; ds存储数据段地址 mov ax, data mov ds, ax ; 给ds赋值 begin: mov cx, lenOfArray ; 遍历array，cx置为array的长度 lea bx, array ; 将array存入bx lea si, P ; 将P存入si lea di, N ; 将N存入di begin1: mov ax, [bx] ; ax指向array数组 cmp ax, 0 ; 判断是否为负数 js isnegative ; 结果为负则转移至isnegative mov [si], ax ; 是正数，存入正数数组 inc lenOfP ; 正数个数+1 add si, 2 ; si后移 jmp short next ; 判断array数组的下一个元素 isnegative: mov [di], ax ; 是负数，存入负数数组 inc lenOfN ; 负数个数+1 add di, 2 ; di后移next: add bx, 2 ; bx后移 loop begin1 ; cx为0是跳出循环，运行后边的代码 lea dx, positive ; 显示正数个数 mov al, lenOfP call display ; 调显示子程序 lea dx, negative ; 显示负数个数 mov al, lenOfN call display ; 调显示子程序 ret main endp ; -------------------------------------------------------------------------- display proc near ; 显示子程序 mov ah, 9 ; 调用9号DOS功能，显示一个字符串 int 21h ; DOS系统功能调用 aam ; 将(al)中的二进制数转换为二个非压缩bcd码 add ah, ‘0’ ; 变为 0～9 的 ASCII 码 mov dl, ah mov ah, 2 ; 调用2号DOS功能，显示一个字符 int 21h add al, ‘0’ ; 变为 0～9 的ASCII码 mov dl, al mov ah, 2 ; 调用2号DOS功能，显示一个字符 int 21h lea dx, crlf ; 显示回车换行 mov ah, 9 ; 调用9号DOS功能，显示一个字符串 int 21h ret display endp ; 显示子程序结束code ends ; 以上定义代码段; --------------------------------------------------------------------------end start 结果 5.7题目试编写一个汇编语言程序，求出首地址为array的100D字数组中的最小偶数，并把它存放在AX中。 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253data segment array dw 100 dup(?)data ends; --------------------------------------------------------------------------code segment main proc far assume cs: code, ds: datastart: ; 为返回DOS做准备 push ds ; ds入栈 sub ax, ax ; ax置0 push ax ; 0入栈 ; ds存储数据段地址 mov ax, data mov ds, ax ; 给ds赋值 begin: mov bx, 0 mov cx, 100 compare: mov ax, data[bx]; 取数组的第一个数 add bx, 2 test ax, 01h ; 是偶数吗？ loopnz compare ; 不是，则比较下一个数 jnz stop ; 没有偶数，退出 jcxz stop ; 最后一个数是偶数，即为最小偶数，退出 compare1: mov dx, data[bx]; 取数组的下一个数 add bx, 2 test dx, 01h ; 是偶数吗？ jnz next ; 不是，比较下一个数 cmp ax, dx ; (ax)&lt;(dx)吗？ jle next mov ax, dx ; (ax)&lt;(dx)，则置换(ax)为最小偶数 next: loop compare1stop: retmain endpcode ends ; 以上定义代码段; --------------------------------------------------------------------------end start 5.12题目有一个首地址为MEM的100D字数组，试编制程序删除数组中所有为0的项，并将后续项向前压缩，最后将数组的剩余部分补上0。 程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849data segment mem dw 100 dup (?)data ends; --------------------------------------------------------------------------code segment main proc far assume cs: code, ds: datastart: ; 为返回DOS做准备 push ds ; 设置返回 dos sub ax, ax push ax ; ds指向代码段 mov ax, data mov ds, ax ; 给ds赋值 begin: mov si, (100-1)*2 ; (si)指向 mem 的末元素的首地址 mov bx, -2 ; 地址指针的初值 mov cx, 100 comp: add bx, 2 cmp mem [bx], 0 jz cons loop comp jmp finish ; 比较结束，已无0，则结束 cons: mov di, bx cons1: cmp di, si ; 到了最后单元吗？ jae nomov mov ax, mem [di+2] ; 后面的元素向前移位 mov mem [di], ax add di, 2 jmp cons1 nomov: mov word ptr [si], 0 ; 最后单元补 0 loop comp finish: retmain endpcode ends ; 以上定义代码段; --------------------------------------------------------------------------end start 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火学习]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[与贪心的区别出现较好的解就使用，发现不了就形成解。缺点：跳不出局部最优解 模拟退火：与贪心类似，但可以以一定的概率跳出局部最优解，通过两个式子实现，Metropolis准则。玻尔兹曼分布 模拟退火算法和物理退火过程的对应 模拟退火算法 物理退火过程 解 粒子状态 目标函数 能量 最优解 能量最低态 设定初温 设置加温到几度 扰动 热涨落 metropolis采样过程 热平衡，粒子状态满足玻尔兹曼分布 控制参数的下降 冷却 伪代码缩进代表层级嵌套关系。 构造一个初始解，令当前解为该解。 设置初始温度，初始温度要设得比较高。 主要算法，while循环： 循环条件可以是温度的阈值或者是解不怎么变化了 for循环 平衡过程，在该温度下，使达到平衡（metropolis），恒温下1到$T_L$步 根据当前解随机生成一个邻解，跟当前解非常接近（扰动，for循环就是多次扰动） 计算邻解的目标函数（花费、路程、大小、钱数等等），减去当前解的目标函数，求得目标函数变化量 如果变化量小于0（即优化了），使用该邻近解；如果没有优化，则用metropolis准 则，看是不是要跳出坑，跳出则使用该邻解。 平衡后设置新温度，即降温。 模拟退火算法设计要素初始解的生成如果初始解比较好的话，收敛得就很快。 通常以一个随机解作为初始解，并保证理论上能生成解空间中任意的解。（一般要多做几次模拟退火，即试用不同的初始解，再取最优的） 也可以是一个挑出来的比较好的解。这种情况下，初始温度应当设置得较低。 初始解不宜“太好”，否则很难从这个解的邻域中跳出。 邻解生成函数应尽可能保证产生的候选解能遍布整个解空间。 邻域应尽可能的小，能够在少量循环内充分探测，但每次的改变不应该引起太大的变化。 初始温度如何设定初始应该尽可能的高，以确保最终解不受初始解影响，但过高又会增加计算时间。 均匀抽样一组状态，以各状态目标值的方差为初温。（随机生成一组解） 等等 ※ 正式开始退火算法前，可进行一个升温过程确定初始温度：逐渐增加温度，直到所有尝试运动都被接受，将此时的温度设置为初始温度。 等等 等温步数如何确定等温步数即同一个温度下，跑几个循环。 等温步数也称Metropolis抽样稳定准则，用于决定在各温度下产生候选解的数目，通常取决于解空间和邻域的大小。如果解空间小，步数可以小一点。 等温过程是为了让系统达到平衡，因此可通过检验目标函数的均值是否稳定（或连续若干步的目标值变化较小，这个可以写一个函数来检测）来确定等温步数。等温步数可以长，也就是多平衡一会而已。 等温步数受温度的影响。高温时，等温步数可以较小；温度较小时，等温步数要大。随着温度降低，增加等温步数。（因为高温的时候比较混乱， 温度小的时候就在不停地收敛了），可以将等温步数设置成一个温度的函数。 有时为了考虑方便，也可以直接按一定的步数抽样。不区分高温和低温时的等温步数，大一点就好啦。 如何降温经典模拟退火算法降温方式 快速模拟退火算法降温方式 常用的其他降温方式 后边两种比较常用 花费函数不要太复杂，应该能被快速的计算，花费函数的计算是程序的可能瓶颈。 一般用目标函数构造花费函数即可。目标函数、目标函数的倒数/相反数经常直接作为花费函数 终止条件理论上温度降为0才终止退火算法，因为此时没有概率跳出坑了。但实际温度较低时，尝试的接受概率就几乎为0了。 设置终止温度的阈值，或设置外循环循环迭代次数。 算法搜索到的最优值连续若干步保持不变。 其他有人说这就是遗传算法+梯度下降。老师说这个算法属于一种蒙特卡洛算法，和蒙特卡洛算法类似。国赛和美赛几乎不会考TSP，太简单了，小比赛才有可能让选手练手。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>数学建模</tag>
        <tag>算法</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之继承（一）]]></title>
    <url>%2F2019%2F04%2F16%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[继承的概念继承源于生物界，指后代能够传承前代的特征和行为。 基类和子类继承使我们可以通过一个已有的类创建一个新类，新类自然获得已有类的全部功能。在某个继承关系中，已有的类在这个继承关系中作为基类、超类或父类，新类称为派生类或子类。 具体来讲，子类复制了基类的全体数据成员和成员函数。此外，子类还可以进行扩充、修改和重定义。 同一个类可以作为多个类的基类，一个子类也可以作为另一个类的基类。 基类和子类是继承关系中的概念，并不是本质的概念，而是关系上的概念。 继承与派生A作为基类，B作为子类时，我们称： B继承A A派生B 单继承和多继承只能从一个基类派生的继承称为单继承，即一个类一次最多继承一个基类。 可以从多个基类派生的继承称为多继承。 C++支持单继承和多继承。 Java只支持单继承，需要“多继承”时使用接口实现。（接口是什么，学了Java就知道了） 类成员访问权限C++类成员访问权限默认为private。 public语法正确的条件下，访问不受控制，在哪里都可以访问。 private只能在类内、友元函数访问。 protected只能在类内、子类内、友元函数访问。 继承方式注意：继承方式决定的是子类如何继承基类成员的访问权限。 不同继承方式会不同程度地改变基类成员在派生类中的访问权限。（个人觉得这句话不好，易让人误解） C++中继承方式默认为private。 public基类成员的访问权限在派生类中保持不变。 基类的private成员、public成员、protected成员在子类中保持他们在基类中相同的访问权限。 private基类成员的访问权限在派生类中全部变为private。 protected基类的public成员的访问权限在派生类中变为protected。 private成员和protected成员的访问权限不变。 派生类对基类的扩展派生类可以： 增加新的数据成员和成员函数 重载从基类继承到的成员函数 覆盖（重定义）从基类集成到的成员函数 改变基类成员在派生类中的访问属性（通过继承方式实现） 派生类不能继承基类的以下内容： 析构函数 基类的友元函数 静态成员 静态数据成员 静态成员函数 注意： 静态成员为整个继承体系公有。 C++11之前，派生类不能继承基类的构造函数，C++11之后可以，通过using实现。 成员函数的重定义、重载及隐藏派生类对继承到的基类成员函数的重定义或重载都会影响它们在派生类中的可见性。 派生类对基类函数进行重定义或重载时，由于继承和类作用域的原因，导致了隐藏，解决隐藏有三种方法。 影响可见性： 如果派生类重定义或者重载了基类中某个函数名为func的函数，则基类中的所有名字为func的函数都会被隐藏。（其中隐藏指的是在派生类中不能直接看到这个函数。） 解决： 通过基类名称访问被派生类重定义或重载隐藏的函数， 如基类::函数名(...)。 重载基类的所有同名函数，这些重载函数的代码与基类完全相同。 使用using。 前两种方法都很繁琐。 而C++11提供了using使基类中被隐藏的函数在派生类中可见，具体使用在后边的using部分讲解。 重定义是什么覆盖也称为重定义、重写。 重定义是指派生类定义与基类具有相同参数列表的同名成员函数。 （关于重定义的定义，我个人认为书上P147的说法是错的。） 隐藏及解决代码如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class Base &#123;public: void print() &#123; cout &lt;&lt; "Base::print()" &lt;&lt; endl; &#125; void print(int i) &#123; cout &lt;&lt; "Base::print()......" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived :public Base &#123;public: int print() //重定义Base类的void print() &#123; cout &lt;&lt; "Derived::print()" &lt;&lt; endl; return 0; &#125;&#125;;int main()&#123; Base b1; Derived d1; b1.print(); //Base类调用函数正常 b1.print(1);//Base类调用函数正常 d1.print(); //Base类中的print()被隐藏，调用Derived类的print() d1.print(1);//该行报错，编译不通过。原因是Derived类的int print()重定义了Base类的void print()，导致Base中所有同名函数被隐藏，即print(int)和print()被隐藏。 d1.Base::print(); //调用Base类的print() d1.Base::print(1); //调用Base类的print(int) return 0;&#125; 将第34行注释后，输出结果如下： 12345Base::print()Base::print()......1Derived::print()Base::print()Base::print()......1 重载是什么重载与重定义不同，重载要求成员函数名称相同，但具有不同的参数列表。 （关于重载的定义，我个人认为书上P147的说法是错的） 隐藏及解决123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class Base &#123;public: void print() &#123; cout &lt;&lt; "Base::print()" &lt;&lt; endl; &#125; void print(int i) &#123; cout &lt;&lt; "Base::print()......" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived :public Base &#123;public: void print(char i) //重载Base类的两个print函数，即print()、print(int i) &#123; cout &lt;&lt; "Derived::print()......" &lt;&lt; i &lt;&lt; endl; &#125; //int print(int i);//这个是重定义Base的void print(int i)，而非重载&#125;;int main()&#123; Base b1; Derived d1; b1.print(); //Base类调用函数正常 b1.print(1);//Base类调用函数正常 d1.print(); //该行报错，因为Derived的print(char i)重载了Base类的两个print函数，它们在Derived类中被隐藏了 d1.print('A');//调用Derived类的print(char i) d1.Base::print(); //调用Base类的print() d1.Base::print(1); //调用Base类的print(int) return 0;&#125; 将第33行注释后，输出结果如下： 12345Base::print()Base::print()......1Derived::print()......ABase::print()Base::print()......1 usingusing有三个用途： 使隐藏的函数重现 改变基类成员在派生类中的访问权限 使子类继承基类构造函数（在继承第二讲中讲解如何使用） 使隐藏函数重现方法：在派生类中用using 基类::函数名;声明基类的函数名，不需提供函数参数。 一条using可以把指定函数名的所有版本添加到派生类作用域中，它们的访问权限与using语句所在区域的访问权限相同。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Base &#123;public: void print() &#123; cout &lt;&lt; "Base::print()" &lt;&lt; endl; &#125; void print(int i) &#123; cout &lt;&lt; "Base::print()......" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived :public Base &#123;public: void print(char i) //重载Base类的两个print函数，即print()、print(int i) &#123; cout &lt;&lt; "Derived::print()......" &lt;&lt; i &lt;&lt; endl; &#125; using Base::print;&#125;;int main()&#123; Derived d1; d1.print(); //不加using的话该行报错 d1.print('A');//调用Derived类的print(char i) return 0;&#125; 改变基类成员在派生类中的访问权限在派生类的public、protected或private权限区域内，使用using再次声明基类的非private成员，就可以重新设置它们在派生类中的权限为using语句所在区域的权限。 继承和类作用域在存在继承关系时，派生类的作用域嵌套在基类作用域的内层。 因此，在解析类成员名称时，如果在本类的作用域内没有找到，编译器会接着在外层的基类作用域内继续寻找该成员名称的定义。 在这个寻找的过程中，一旦在某个作用域找到了，就停止查找，即使外层作用域内还有同名成员，也不找了。 形式如下： 12345678Base &#123; int print(int)&#123;&#125; ... Derived &#123; void print() ... &#125;&#125; 代码验证： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class Base &#123;public: void print(int i) &#123; cout &lt;&lt; "Base::print()......" &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived1 :public Base &#123;public: void print() &#123; cout &lt;&lt; "Derived::print()......" &lt;&lt; endl; &#125; &#125;;class Derived2 :public Derived1 &#123;&#125;;int main()&#123; Derived2 d; d.print(1); //该行代码报错，因为在Derived1中找到同名函数void print()，不会再向外层找，又因为参数列表不匹配，所以报错 return 0;&#125; 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目开发记录]]></title>
    <url>%2F2019%2F04%2F12%2F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一段旅程算是结尾了吧，以下为本学期开发记录： 2.26 晚上 整理项目里的代码和注释 2.27 中午至下午 解决先登录问题 2.28 下午 解决先登录问题 3.1 中午至下午 解决先登录后续问题：控制台warning，路由重复 尝试数据持久化，redux-persist 3.2 下午 数据持久化 redux-persist。combineReducer？ persistCombineReducer? 3.3 循环injectedReducers，发现有个root，还有动态的数据持久化配置不好实现，改用localStoreage 3.11 晚上 给后端分任务：规定用户名和密码格式要求，并检测其合法性，新的页面要显示什么内容，前后端交互 3.19 下午 总结项目，明确各自的任务 3.23 下午 和hyk讨论前后端合作。 3.25 下午 开发编辑/显示标准基本信息界面，定义与后端交互的接口内容 3.27 早上、晚上 开发修改密码页面，补充标准基本信息界面提交功能 3.30 上午 前后端交互测试成功。向老师汇报情况 3.31 项目上传至coding]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络-实验（二）常用网络指令]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[实验目的 学会并掌握常用网络命令。 学会分析在不同参数下显示的数据。 实验仪器PC机、局域网 常用命令arp知识点扫盲：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。 功能：显示和修改IP地址与物理地址之间的转换表 -a功能：（Windows下）显示当前的ARP信息，可以指定网络地址。 Linux系统中，使用-g。 代码： 1arp -a # 显示当前所有的ARP信息 结果： Internet Address Physical Address Type 192.168.1.178 00-16-ec-a0-42-fa dynamic ..… ..… ..… 代码： 1arp -a 192.168.1.178 # 显示指定IP(即192.168.1.178)的ARP信息 结果： Internet Address Physical Address Type 192.168.1.178 00-16-ec-a0-42-fa dynamic -s功能：添加主机，并将网络地址跟物理地址相对应，这一项是永久生效的。 代码： 12arp -s 157.55.85.212 00-aa-00-62-c6-09 # 在IP和物理地址转换表中添加一项arp -a 157.55.85.212 # 显示指定IP(即157.55.85.212)的ARP信息 结果： Internet Address Physical Address Type 157.55.85.212 00-aa-00-62-c6-09 static 注意：这里添加的一个Type为static的。 -d功能：删除指定的主机，可以使用* 来删除所有主机。 代码： 12arp -d 157.55.85.212 # 删除指定IP(即157.55.85.212)arp -a 157.55.85.212 # 显示指定IP(即157.55.85.212)的ARP信息 结果： 1NO ARP Entries Found ftp知识点扫盲：文件传输协议，即FTP(File Transfer Protocol)。是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议。 ftp也是一种服务。一旦启动，将创建在其中可以使用ftp命令的子环境，通过键入 quit子命令可以从子环境返回到Windows命令提示符。当 ftp 子环境运行时，它由ftp命令提示符代表。 下边的指令除了ftp是在Windows命令提示符，其他都是在ftp的子环境里。 功能：控制文件的双向传输（老师说的..…）。 ftp功能：启动ftp服务。 在命令提示符下，直接输入ftp即可。 open代码： 1open 192.168.1.171 # 连接指定的ftp服务器（这里是老师的电脑） 结果： 12345678Connected to 192.168.1.171.220-Microsoft FTP Service220 张芳之家User (192.168.1.171:(none)): zf331 Password required for zf.Password:230-欢迎进入“张芳之家”230 User zf logged in. 注意：上边的第6行需要输入密码。我们输的时候，屏幕上并不会显示出来。 dir功能：查看本目录下的内容，目录可以理解成文件夹的意思。 代码： 1dir # 查看当前目录内容 结果： 12345200 PORT command successful. # 请求成功150 Opening ASCII mode data connection for /bin/ls. # ASCII传输方式连接/bin/ls04-26-13 08:22AM &lt;DIR&gt; 654 # 有个文件夹，名字是654226 Transfer complete.ftp: 收到 44 字节，用时 0.00 Seconds 44000.00Kbyte/sec. cd功能：更换远程目录。 12cd 654 # 进入文件夹654dir # 查看当前目录内容 结果： 12345200 PORT command successful. # 请求成功150 Opening ASCII mode data connection for /bin/ls. # ASCII传输方式连接/bin/ls04-26-13 08:22AM 70 qqq.txt # 有个文件，名字是qqq.txt226 Transfer complete.ftp: 收到 48 字节，用时 0.00 Seconds 44000.00Kbyte/sec. lcd功能：更换本地目录，若无参数，将显示当前目录。 代码： 1lcd e:\ 结果： 1Local directory now E:\. get功能：将远程文件复制到本地计算机。 代码： 1get qqq.txt 结果： 1234200 PORT command successful. # 请求成功150 Opening ASCII mode data connection for qqq.txt(70 bytes) # ASCII传输方式连接/bin/ls226 Transfer complete.ftp: 收到 70 字节，用时 0.00 Seconds 70000.00Kbyte/sec. quit功能：退出ftp服务。ftp子环境下输入quit即可。 结果： 1221 再见！欢迎下次“张芳之家” ipconfig功能：显示当前的TCP/IP配置的设置值。 代码： 1ipconfig 结果： 1234567Windows IP ConfigurationEthernet adapter 本地连接: Connection-specific DNS Suffix . : IP Address. . . . . . . . . . . . : 192.168.1.95 # IP地址 Subnet Mask . . . . . . . . . . . : 255.255.255.0 # 子网掩码 Default Gateway . . . . . . . . . : 192.168.1.3 # 缺省网关 telnet知识点扫盲：Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。 功能：远程连接另一台计算机 telnet功能：启动telnet。 在命令提示符下，直接输入telnet即可。 open功能：连接指定计算机。 代码： 1open 192.168.1.94 # 连接我同桌.. 结果： 12345正在连接到192.168.1.94... 您将要发送密码信息到 Internet 区域中的远程计算机。这可能不安全。是否还要发送(y/n): nlogin:ligongpassword: 注意：第四行和第五行输入账号和密码，密码并不会显示出来。 copy功能：复制文件到自己电脑上 代码： 1copy qqq.txt c:\ # 复制其e盘qqq.txt到其c盘，前提是此时已在E盘，使用cd e:\实现 quit退出，直接输入quit即可。 net知识点扫盲：它包含了管理网络环境、服务、用户、登陆等Windows 98/NT/2000 中大部分重要的管理功能。 send功能：将消息发送到网络上的其他用户、计算机或消息名。必须运行信使服务以接收邮件。 代码： 1net send * 123 # 给所有人发123 结果： 1消息已经送到域 2HJF 代码： 1net send s14 hello # 给s14机器发hello 结果： 1消息已经送到 S14 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言-实验（一）]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目一问题在数据段DATA中有两个字数据X和Y, 假设X=1122H, Y=3344H, 编程求两个字的和,结果存放到Z单元中。 代码123456789101112131415161718192021222324252627282930313233;*********************************************************************data segment ; 定义数据段 x dw 1122h ; 字 X y dw 3344h ; 字 Y z dw ? ; 字 Zdata ends;*********************************************************************code segment ; 定义代码段 assume cs:code,ds:data;--------------------------------------------------------------------- main proc far ; 程序的主部分start:; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- data push ax ; ax压栈; ds设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax); z=x+y mov ax,x ; (al) &lt;- x add ax,y ; (al) &lt;- (al)+y mov z,ax ; (z) &lt;- (al) ; 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------code ends;********************************************************************* end start 题目二问题从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串传送到DEST_BUFFER开始的单元中。 代码123456789101112131415161718192021222324252627282930313233343536373839404142;*********************************************************************data segment ; 定义数据段 source_buffer db 20 dup('A'); 串source_buffer，占20个字节，内容是20个字母Adata ends;*********************************************************************extra segment ; 定义附加段 dest_buffer db 20 dup(?) ; 串dest_buffer，占20个字节，内容未确定extra ends;*********************************************************************code segment ; 定义代码段 assume cs:code,ds:data,es:extra;---------------------------------------------------------------------main proc far ; 程序的主部分start: ; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- data push ax ; ax压栈 ; ds设为data mov ax,data ; (ax) &lt;- data mov ds,ax ; (ds) &lt;- (ax) ; es设为extra mov ax,extra ; (ax) &lt;- extra mov es,ax ; (es) &lt;- (ax); 准备工作 lea si,source_buffer ; 存储源串首地址 lea di,dest_buffer ; 存储目的串首地址 cld ; 建立方向标志 mov cx,20 ; 20个字符; 移动串 rep movsb ; 移动串至CX为0，即移动整个串 ; 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------code ends;********************************************************************* end start 题目三问题从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串向下移10个单元。 代码1234567891011121314151617181920212223242526272829303132333435;*********************************************************************extra segment ; 定义附加段 source_buffer db 20 dup('A'); 串source_buffer，占20个字节，内容是20个字母A dest_buffer=source_buffer+10; 串dest_buffer，结果串的首地址extra ends;*********************************************************************code segment ; 定义代码段 assume cs:code,es:extra;---------------------------------------------------------------------main proc far ; 程序的主部分start: ; 为返回DOS做准备 push ds ; ds压栈 xor ax,ax ; (ax) &lt;- 0 push ax ; ax压栈 ; es设为extra mov ax,extra ; (ax) &lt;- extra mov es,ax ; (es) &lt;- (ax) ; 准备工作 lea si,source_buffer+19 ; 存储源串末地址 lea di,dest_buffer+19 ; 存储目的串末地址 std ; 建立方向标志 mov cx,20 ; 20个字符; 移动串 rep movs es:byte ptr[di],es:[di] ; 移动串至CX为0，即移动整个串 ; 返回DOS环境 ret ; 返回DOS环境main endp;---------------------------------------------------------------------code ends;********************************************************************* end start BUG不小心，上边代码写错了,rep movs ds:byte ptr[di],ds:[di]，源地址和目标地址不小心都用了di。 按说这样不能进行后移，但却得到了正确的结果。 经过调试，发现可能是编译环境自行将我的错误代码改成了正确代码，进行了优化。 同时也发现：rep movs ds:byte ptr[si],ds:[di]，这个代码也是错的，但也得到了正确的结果。 正确的代码应该是这样：rep movs ds:byte ptr[di],ds:[si]。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>汇编</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之指针悬挂]]></title>
    <url>%2F2019%2F03%2F28%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E6%8C%87%E9%92%88%E6%82%AC%E6%8C%82%2F</url>
    <content type="text"><![CDATA[什么是指针悬挂指向非法内存的指针，也叫野指针。 非法内存即不能使用的内存。 123int* p = (int*)12345;//int* p; //p未初始化，p的值随机，一般都会指向非法内存cout &lt;&lt; *p; //运行这行代码会出错 随便让p指向一块内存（一般指向非法内存）。 运行时使用非法内存，会报错。 一些指针悬挂的情况课本中有两处提到指针悬挂，分别是：合成拷贝构造函数和合成赋值运算符函数。 如果类中有指针，这两个函数可能造成指针悬挂。（看完之后想想为什么只是可能？） 代码下面给出这两种函数造成指针悬挂的代码及注释： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class MyClass&#123;public: int * p; MyClass()&#123; p = new int;&#125; ~MyClass()&#123; delete p;&#125; void print()&#123; cout &lt;&lt; p &lt;&lt; endl;&#125;&#125;;int main()&#123; MyClass a; MyClass b(a); //调用合成拷贝函数 //MyClass b = a; //调用合成赋值运算符 a.print(); b.print(); //据两行输出可知，两个指针指向同一块内存 return 0;&#125;//最后，B会先析构，然后A析构。//B析构会释放p指向的内存，同时这块内存变为非法内存，//此时A的指针p指向非法内存，造成指针悬挂。//A析构时delete p,使用了非法内存，这时出错 解决如果这两个函数造成指针悬挂，应显式提供这两个函数，并将这两个合成函数的浅拷贝改为深拷贝。 作者：@臭咸鱼 转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值和线性回归]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%8F%92%E5%80%BC%E5%92%8C%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[插值根据现有数据，插的值一定在曲线上。 interpl，一维插值函数。 线性回归regress $Y=b_0+b_1x_1+b_2x_2+\cdots+b_kx_k$ 拟合$x_1\ x_2\ \cdots\ x_k$与$Y$的关系 [B, Bint, R, Rint, Status]=regress(Y, X) B：回归得到的自变量系数 Bint：B的95%的置信区间矩阵 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>插值</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传染病模型]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BC%A0%E6%9F%93%E7%97%85%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[简介该模型在数学建模中可以解决很多问题。 该模型由三个微分方程构成。 建立模型定义变量假设系统中有三种人： 易感染的人 数量用$S$表示，刚开始所有人都是易感染的人 感染的人 数量用$I$表示 康复的人 数量用$R$表示（假设该传染病不致命） 微分方程$\begin{equation} \left\{ \begin{array}{r1} \frac{dS}{dt}=-\beta SI\\ \frac{dI}{dt}=\beta SI-\gamma I\\ \frac{dR}{dt}=\gamma I\\ \end{array} \right.\end{equation}$ 其中$\beta$是接触率，$\gamma$是康复率。 代码函数odesir123456789function dy = odesir(t, y, beta, gamma)% 根据传染病模型者中的y和t求出dy/dt% y=[S; I; R]dy =[ -beta*y(1)*y(2); % dS/dt beta*y(1)*y(2) - gamma*y(2); % dS/dt gamma*y(2); % dR/dt] 计算12345678910N = 100;beta = 0.01;gamma = 0.1;tspan = [0,50];y0 = [99,1,0];[t y] = ode45(@odesir, tspan, y0, [], bata, gamma);plot(t,y);xlabel('time');ylabel('population');legend('S', 'I', 'R'); ode23和ode45的区别：精度不一样，ode45精度高。 结果 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runge-Kutta法解微分方程]]></title>
    <url>%2F2019%2F03%2F28%2FRunge-Kutta%E6%B3%95%E8%A7%A3%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[连续问题，微分方程或偏微分方程一定能表示。比如疾病传染、新闻传播等。 离散问题，可以用差分方程或者类似于差分的算法。 一阶微分方程求解方程$y’=cos\ t$ 代码123456789clear,clc;f = @(t,y) cos(t); % 定义函数 f(t,y) = cos(t) 表示的就是dy/dt=cos(t)tspan = [0,2*pi]; % 时间t范围y0 = 2; % y的初值，用来处理积分得到的C[t,y] = ode23(f,tspan,y0); % 注意调用格式plot(t,y);xlabel('t');ylabel('y'); @表示句柄，当把一个函数作为参数传给另外一个函数，这时候必须要用句柄。这里是把函数f传给函数ode23。 结果 高阶微分方程求解方程$\begin{equation} \left\{ \begin{array}{r1} y’’=-sin\ y+sin\ 5t\\ y(0)=1\\ y’(0)=0\\ \end{array} \right.\end{equation}$ 可以将该高阶微分方程转化为两个一阶的微分方程：$\begin{equation} \left\{ \begin{array}{r1} y_1=y\\ y_2=y’\\ y’_1=y_2\\ y’_2=-sin\ y_1+sin\ 5t\\ y_1(0)=1\\ y_2(0)=0\\ \end{array} \right.\end{equation}$ 代码12345678910clear,clc;f = @(t, y) [ y(2); -sin( y(1) ) + sin( 5*t ) ]; % 两个参数分别是y1和y2的导数tspan = [ 0, 20 ]; % 时间t范围y0 = [ 1; 0 ]; % 初值，分别对应y1，y2的初值[t, y] = ode23(f, tspan, y0); % 注意调用格式plot(t,y);xlabel('t');ylabel('y');legend('y1','y2'); 结果​ 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>微分方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之类和对象]]></title>
    <url>%2F2019%2F03%2F27%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[简介如何理解类和对象？ 类是一种自定义数据类型，用类定义出来的变量就是对象。 格式： 数据类型 数据; int a; A a(); 这一章的主要问题就是如何设计、实现和使用类。 设计和实现分别对应类的抽象和封装；使用即最后一步，用类实现功能。 简单地说：面向对象就是将事物定义（包括抽象和封装）成类并使用。 类的抽象和封装抽象计算机软件开发采用的抽象方法主要有两种： 过程抽象 结果给出了函数的名称、接收的参数和能够提供的功能。 数据抽象 数据抽象是面向对象程序设计方法，以数据为中心。 结果形成某事物的类，其中包括成员变量和成员函数。 简单来说，就是找出一个类有哪些变量和功能，但不用封装。 比如这是一个点餐系统。 封装分为两部分： 接口 使用者看到的东西 实现 实现抽象出的类，写.cpp代码 简单地说，就是写代码。 比如：对老师来说，课代表就是接口，课代表怎么收作业就是实现。 提问12345678910111213141516class Cxy&#123;public: double height; void growTaller() &#123; cout &lt;&lt; "drinkMilk" &lt;&lt; endl; height+=2; &#125;;&#125;;int main()&#123; Cxy cbh; cbh.growtaller(); return 0;&#125; 请找出代码里的类、对象、抽象、封装。 成员函数常量成员函数C++中，为了禁止成员函数修改数据成员的值，可以使用常量成员函数。 语法： 123class X&#123; T f(T1, T1, ...) const;&#125;; 注意： 只有类的成员函数才能定义为常量函数，普通函数不能。 常量成员函数与const参数没有关系 对象 每个对象的数据成员都有自己独立的存储空间。就像int变量一样。 注意：一个类的成员函数只有一份，所有对象共用。 注意：类的static成员只有一份，它并不算对象的数据成员。 构造函数设计默认构造函数定义书上P97下边给的定义是最准确的。 想想之前讲的默认的含义。 简单来说：如果用类定义对象时，我们没有给参数的话，调用的就是默认构造函数。 分类默认构造函数有两种： 不带参数的构造函数 1A(); 可以是我们自己定义的，也可以是编译器合成的。 所有形参都提供了默认值的构造函数 这个当然是我们自己定义的。 构造函数与初始化列表初始化列表次序初始化列表中的成员初始化次序与他们在类中的声明次序相同，与初始化列表中的次序无关。 123456789class A&#123;public: int a; int b; int c; A(int aa,int bb,int cc):b(aa),a(bb),c(cc)&#123; cout &lt;&lt; "I am a handsome constructor yo" &lt;&lt; endl; &#125;&#125;; 提问：初始化次序是什么？ 初始化列表执行时间类内初始值$\rightarrow$构造函数初始化列表$\rightarrow$构造函数体 what必须采用初始化列表？C++11之前一个类的 常量成员 引用成员 类对象成员 子类构造函数对基类构造函数的调用 等等 必须通过初始化列表进行初始化。 C++11之后除了初始化列表，可以用类内初始值yo。 析构函数若有几个对象同时结束生存期，析构函数调用顺序与构造函数顺序相反。 静态成员关键字：static。 静态成员可以是变量，也可以是函数。 注意：静态成员函数不可以访问非静态成员。think why？ 意义表示这个成员是属于整个类的。 声明和定义示例： 123456class Boy&#123;public: static int boyNum; //男孩的数量&#125;;static int Boy::boyNum； //未初始化//static int Boy::boyNum = 0；//初始化 在类内static int number；，仅仅是声明， 原则上，定义必须写在类外：static int Boy::boyNum;，值默认为0，也可以进行初始化。 访问两种方式： 通过类名访问（非静态成员不能以这种这样访问） 1cout &lt;&lt; Boy::boyNum &lt;&lt; endl; 通过对象访问 12Boy cbh();cout &lt;&lt; cbhboyNum &lt;&lt; endl; 看看下边的this？ this指针含义this用来标识一个对象，是该对象的地址，类型是Boy* const，隐含在非静态成员函数的参数里。 应用静态成员函数没有this指针，所以不可以访问非静态成员。 常量成员函数的this，类型是const Boy *。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美国人口指数增长模型拟合]]></title>
    <url>%2F2019%2F03%2F27%2F%E7%BE%8E%E5%9B%BD%E4%BA%BA%E5%8F%A3%E6%8C%87%E6%95%B0%E5%A2%9E%E9%95%BF%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[假设美国人口数满足指数增长模型$x(t)=x_0e^{rt}$，其中$x(t)$表示第$t$年的人口数，$x_0$表示第0年的人口数，即人口数初值。 思路$ x(t) = x_0e^{rt} \ \Rightarrow \ ln \,x(t)=rt+ln\,x_0 \,\Rightarrow Y=ln \,x(t)a_1t+a_2$ ， 其中$Y=ln\,x(t)$，$a_1=r$，$a_2=ln\,x_0$。 如上，将指数函数转化为线性函数，利用线性函数进行拟合，再将线性函数转化为指数函数。 代码123456789101112131415t = 1790 : 10 : 1900; % 时间p = [3.9 5.3 7.2 9.6 ... 12.9 17.1 23.2 31.4 ... 38.6 50.2 62.9 76.0]; % 人口数 Y = log(p); % 转换为线性 X = t; % 不用X直接用t也可以 a = polyfit(X, Y, 1); % X,Y线性拟合 x0 = exp(a(2)); % r = a(1); ti = 1790:1900; % 曲线的横坐标 pti = x0*exp(r*ti); % 曲线纵坐标，即拟合结果 plot(t, p, 'o', ti, pti, 'm'); % 原数据与拟合结果对比 xlabel('Year'); ylabel('Population'); 结果 可以看到，前期拟合结果较好，但是1890年到1900年曲线与原数据相比偏高。 原因是人口数并不完全符合指数增长模型，人口并不能完全地按照“J”型曲线增长，而应该是“S”型曲线。物种竞争嘛，所以刚开始的假设是不合理的，可以再进行优化。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性方程组求解]]></title>
    <url>%2F2019%2F03%2F26%2F%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[定解方程组有一组解。 $\begin{equation} \left\{ \begin{array}{r1} 2x+3y+1z = 4\\ 4x+2y+3z=17\\ 7x+1y-1z=1\\ \end{array} \right.\end{equation}$ 1234% A*X=BA = [2 3 1; 4 2 3; 7 1 -1];B = [4 17 1]';X= A\B % 求得X 不定方程组有无数组解。 $\begin{equation} \left\{ \begin{array}{r1} 4x+5y+1z=3\\ 1x+2y+4z=15\\ \end{array} \right.\end{equation}$ 1234% A*X=BA = [4 5 1; 1 2 4];B = [3 15]';X= A\B % 得无数解中的一种 超定方程组无解。 $\begin{equation} \left\{ \begin{array}{r1} 4x+5y = 3\\ 1x+2y = 15\\ 3x+1y = 12\\ \end{array} \right.\end{equation}$ 1234% A*X=BA = [4 5; 1 2; 3 1];B = [3 15 12]';X= A\B % 本来是无解的，按最小二乘法得到最接近的解 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>线性方程组求解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性和非线性拟合]]></title>
    <url>%2F2019%2F03%2F25%2F%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88%2F</url>
    <content type="text"><![CDATA[线性拟合一阶拟合：$y=a_1x+a_2$，这就是线性拟合了。 二阶拟合：$y=a_1x^2+a_2x+a_3​$，这就不是线性拟合了。 polyfita=polyfit(x,y,n) 最小二乘法计算拟合多项式系数 x,y为拟合数据向量 n为拟合多项式次数 通过a保存多项式系数，从最高次向最低次排列 polyvaly=polyval(a,x) 计算多项式的函数值 返回在x处多项式的值 a为多项式系数，元素按多项式降幂排序 代码12345678% 求拟合多项式系数，即ax = [1.0 1.5 2.0 2.5 3.0]';y = [0.9 1.7 2.2 2.6 3.0]';a = polyfit(x,y,1) % 1指一阶拟合，也就是指多项式次数% 求拟合结果xi = 1 : 0.1 : 3;yi = polyval(a, xi); % 求多项式的函数值plot(x,y,'o',xi,yi); % 作图对比原数据和拟合结果 结果 图中点是原始数据，线是拟合结果，线有点点弯。 指定形式拟合fittype定义拟合形式 fit根据数据向量，按照某种拟合形式拟合。 代码12345x = [1.0 1.5 2.0 2.5 3.0]';y = [0.9 1.7 2.2 2.6 3.0]';p = fittype('a*x+b*sin(x)+c'); % 定义拟合形式f = fit(x,y,p) % 向量x,y按照p的形式拟合plot(f,x,y); % 作图对比拟合结果 结果 图中代码没有定义x,y也可以运行，是因为工作区中已经有这两个变量了。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab作图]]></title>
    <url>%2F2019%2F03%2F24%2FMatlab%E4%BD%9C%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[二维作图plot 简单控制语句 sin(x) &amp; cos(x)12345678910x = -2 * pi : 0.1 : 2*pi; % 切片y1 = sin(x);y2 = cos(x);plot(x, y1,'-b'); % - 实线 b 蓝色hold on % 保持当前画的图形不被覆盖掉plot(x, y2, '-r'); % - 实线 r 红色xlabel('x'); % x轴上加标签ylabel('y'); % y轴上加标签text(0, 0, '(0,0)'); % 在(0,0)加文本legend('sin x', 'cos x'); % 图例 two hearts12345678910t = 0 : pi/180 : 4*pi; % 切片x = 16*sin(t).^3; % x,y用参数为t的方程表示y = 13*cos(t) - 5*cos(2*t)... % 本行未结束 -2*cos(3*t) - cos(4*t);plot(x-3, y, '-r', x+3, y, '-b');xlabel('x'); % x轴上加标签ylabel('y'); % y轴上加标签axis([-20, 20, -20, 15]); % 坐标范围：x [-20,20] y [-20,15]title('Two Hearts'); % 标题legend('U', 'I'); % 图例 对数坐标loglog，双对数坐标。 semilogx，只有x是对数。 12345678x = 10*2.^[0:6];y = [100 150 225 340 ... 510 765 1150];loglog(x, y, '.-r'); % 点实线 红色xlim([0.5e1, 0.8e3]); % x坐标范围ylim([0.8e2, 1.4e3]); % y坐标范围xlabel('x'); ylabel('y'); 极坐标polar 123theta = 0 : pi/180 : 4*pi; % 角度r = 1- sin(theta); % 长度polar(theta, r, '-r'); % 实线 红色 三维作图plot312345678910t = 0 : pi/50 : 10*pi; % 2pi是一圈 10pi转5圈 x = sin(t);y = cos(t);z = t;plot3(x, y, z); % 3维title('Helix');xlabel('sin t');ylabel('cos t');zlabel('t');grid on % 打开网格 三维曲面meshgrid，生成绘制3D图形所需的网格数据。 [x, y]=meshgrid(1:3, 1:3) mesh，surf 12345678[x, y] = meshgrid(-pi:0.1:pi); % 生成数据z = sin(x) .* cos(y);mesh(x, y, z); % 作图surf(x, y, z); % 使有颜色xlabel('x'); ylabel('y');zlabel('z');title('sin x sin y'); 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>可视化</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab基础]]></title>
    <url>%2F2019%2F03%2F24%2FMatlab%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本命令和语句clear clear y 删除y变量 clear 删除所有变量 clc清空屏幕输出 文件命名规则matlab文件命名规则和C语言变量命名规则类似。 help帮助文档，help functionname。 lookfor寻找含关键字的函数，lookfor keyword。 向量一行中的元素可以用逗号或者空格隔开。 分号表示一行向量的结束。 切片起点：步长：终点，步长可以省略，默认为1 转置A&#39; linespace类似切片，均匀生成几个数字，得到行向量。 常用矩阵zeros零矩阵，参数是行数和列数或者方阵行数。 ones1矩阵，参数同zeros。 eye单位矩阵 固定变量piπ i虚数，$\sqrt{-1}​$。 Inf无穷大 NaN不是一个数字，not a number。 矩阵运算矩阵指2维向量，向量指1维向量。 矩阵加法同型矩阵同位置元素相加。 若矩阵+向量，每行/列都会加该向量。 矩阵减法类似于矩阵加法。 矩阵乘法/除法点乘点除A.*B，对应位相乘。 次方A^2 点次方A.^2，每一位都次方。 矩阵取值双索引A(1,3)`，第一行第三列元素。 单索引matlab是竖着数的。 若A是三行三列的矩阵，则A(1,2)==A(4)。 取行/列向量A(2,:)，取A的第二行所有列，即第二行。 比较和逻辑运算同位置元素进行比较，&gt;、&lt;、&amp;、|、==、异或xor(x&gt;5,y&lt;7)。比如A==B。 x(x&lt;0)=0，将x中小于0的赋值为0 y(y(:,1)&lt;0,:)=0，如果某行第一列小于0，整行赋值为0 矩阵操作函数设A是矩阵，B是行向量，C是列向量。 flipud上下旋转 fliplr左右旋转 rot90沿副对角线旋转，与转置不同。 sum求和。 sum(B) 求该行的和 sum(A) 每列求和，得到一个行向量 sum(A，1) 等价于sum(A)，1代表维度，列是第一个维度。 sum(A，2) 每行求和，得到一个列向量。 sum(A(:)) 整个矩阵求和。A(:)将矩阵A拉成一个列向量。 max max(B) 求一行的最大值。 max(B,2) 每个元素与2比较，得最大值；若小于2，则结果为2；若大于2，则结果为该元素。 max(A) 与sum类似，每列求最大值，等价于max(A,[],1)。 max(A,[],2) 每行求最大值。 常用数学函数ceil向上取整 fix靠近0取整 floor向下取整 round四舍五入取整 modmod(i,2)，取i/2的余数。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之引用]]></title>
    <url>%2F2019%2F03%2F24%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于引用，讲一个同学问的题目。 代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using std::endl; //域限定符using std::cout; //域限定符int &amp;f(int&amp; a, int b = 20)//定义函数，为了规范，应该在main前边写函数声明，main后定义函数&#123; //a是main函数中j的引用 a = a * b; //j = j * b return a;&#125;int main()&#123; int j = 10; int &amp;m = f(j); //函数f返回引用a，即j的引用，所以m是j的引用 int *p = &amp;m; //p指向j cout &lt;&lt; j &lt;&lt; endl; //200 m = 20; //m是j的引用，j = 20 cout &lt;&lt; j &lt;&lt; endl; //20 f(j, 5); cout &lt;&lt; j &lt;&lt; endl; //100 *p = 300; cout &lt;&lt; j &lt;&lt; endl; //300&#125; 知识点引用引用分为左值引用和右值引用。 左值引用是某个变量的别名，作用类似于指针，提高效率。 右值引用是绑定到右值上的引用，只能绑定到即将销毁的对象上。 域限定符命名空间是为了解决全局命名空间污染问题。 通过限定符可以使用对应命名空间内的对象（变量、函数、类型、类等）。 函数默认参数默认参数又叫做缺省参数。如何理解？ 默认 小明：小红，你在干嘛? 小明：小红，你刚才在干嘛？ 缺省 可以缺少、省略。 所有默认参数都必须出现在无默认参数的最右边。 也就是说实参从左向右给形参赋值，默认参数从右向左给形参赋值。 函数位置函数应该写在代码的哪里？ 如果使用C语言，比较好的方式是将函数声明和函数定义分开放，即在main函数前声明函数，在main函数后定义函数。 如果使用C++，最好面向对象，使用头文件和源文件。 栈相关名词谈到这个，相关的名词有两个： 堆 new出来的内存就在堆里 （堆）栈 如果在main函数中定义一个int，它就存储在栈里。 在学数据结构时，会学到栈和堆，它们是两种数据结构。 栈和函数栈有一个应用就是处理函数的嵌套，比较典型的就是递归。 比如上边代码中的main运行到f函数时，先要保存现在main函数的状态（变量、代码执行到的位置等），将其压栈（PUSH）；然后再进入f函数，栈顶即为f函数的内容，f函数执行完后，出栈（POP）；然后继续执行main函数。 在调试时就可以看到函数调用栈。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之课程介绍]]></title>
    <url>%2F2019%2F03%2F24%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[应要求，周六晚上开了一个课，教C/C++，把课件放在这里。 课程简介 关于我 班级，性别，年龄。 第一次教课，希望大家及时对课堂给予一定建议与反馈。 上课时间 周六晚上六点半，时长根据上课内容的多少和难度确定。 需求 大家的需求是什么？C/C++?（我需要讲得广一点吗？） 具体希望了解哪个方面呢？ 这可能跟你的年级、所上课程有关，也有可能你们也不知道。 课程定位 该课程主要起辅助作用 学习的主要战场应在个人课下的学习和学院老师的课堂上，这个课并不是冲刺课。 由于能力和精力有限，我不能保证谁上了这个课就一定可以考高分或者不挂科。 如果合作愉快，大家一定会有收获。 我的作用是帮助大家 毕竟大二了，与大部分大一的同学相比，写代码的经验和知识面会足一些，我会尽可能把我的知识、思路和方法讲给大家。 课程要求 课堂纪律 合乎公共礼仪即可，好好听课，该请假的要跟我请假。每次课要点名的。 希望大家能做到不懂就问。 每周作业：每人提一个问题给我 这个是为了更好地了解大家的学习上遇到的困难，大家给出问题后，我可以在课堂上有针对性地进行讲解。大家的问题可能会是课堂的主要内容。 课程目标 大家解决编程中遇到的问题的能力有一定提升，能够多思考为什么 更了解C/C++，扩展知识面 课堂之外给大家帮助 课余也可以 课程内容 C/C++课程重难点 面向正在上C++、C语言课程的同学，讲解一些重点。 大家的作业：提出的问题 可以是找到的题，可以是写作业遇到的问题，都可以。 这是使这门课最大程度地为大家服务的一个方式，可以提高这门课的效用。 我遇到的有意思的问题 大概想想有数组名，指针（包括指针赋值），面向对象，抽象，C++类的互相引用等等吧。 大家有什么问题吗？ 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++小课之数组名]]></title>
    <url>%2F2019%2F03%2F24%2FC-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E6%95%B0%E7%BB%84%E5%90%8D%2F</url>
    <content type="text"><![CDATA[我们今天讨论数组名是什么东西，理解它有助于我们进一步理解和使用指针。 因为它涉及到了内存地址。 问题数组名是什么？含义是什么？ 思路前提一个值+1之后的变化可以反映出它的意义/含义。 前提的证明其实不证自明，计算机中就是这样的。 生活中 一个苹果+1，结果是两个，增加了一个苹果。 一箱苹果+1，结果是两箱，个数是2*每箱苹果数，增加了一箱苹果。 计算机中 int型变量的地址+1，增加了一个int的大小。 double型变量的地址+1，增加了一个double的大小。 思路根据前提，通过将数组名或数组名相关的值+1来判断它的含义。 验证编程中要了解一个东西，大多时候我们可以通过输出它来了解它。 代码123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; //注释指出array代表什么 int array[5] = &#123; 1,2,3,4,5 &#125;; printf(" &amp;array[0] = %p\n", &amp;array[0]); //首元素 printf(" array = %p\n", array); //数组 printf(" array+1 = %p\n", array + 1); //数组 printf(" &amp;array[0]+1 = %p\n", &amp;array[0] + 1); //首元素 printf(" &amp;array = %p\n", &amp;array); //数组 printf(" &amp;array+1 = %p\n", &amp;array + 1); //数组 printf("sizeof(array) = %zd\n", sizeof(array));//数组&#125; 为什么用printf不是cout？用cout其实也行，printf更方便。 结果1234567 &amp;array[0] = 0000002A433FF628 array = 0000002A433FF628 array+1 = 0000002A433FF62C &amp;array[0]+1 = 0000002A433FF62C &amp;array = 0000002A433FF628 &amp;array+1 = 0000002A433FF63Csizeof(array) = 20 结论数组名是什么，有什么含义数组名是一个常量（所以不能被赋值），是一个地址。（&amp;array中array并不是地址，因为地址是一个值，我们并不能取一个值的地址吧） 在不同情况下，有着不同的含义。 代表整个数组 碰到&amp;、sizeof时，数组名代表整个数组，作用像是一个变量。 代表数组首元素 数组名单独出现或碰到[]、*时，数组名代表数组第一个元素，是一个地址。（这个下次会讲） 知识点IDE、编译器、编辑器 编辑器 文本编辑器，比如notepad++，sublime。 编译器 处理我们写的代码。 C/C++的比如有：gcc，mingw。 计算机语言可以分为两种：编译语言和解释语言。 IDE Integrated Development Environment，集成开发环境。 集合了编辑器和编译器的功能，还有一些辅助开发的功能。 Visual Studio 解决方案 项目 调试 查看源码 比如看sizeof、iostream，Ctrl+左键 查看类图 右击(项目)-查看-查看类图 十六进制https://tool.lu/hexconvert/ 地址+1核心在于单位。==见下篇== sizeof占用的字节数。基本数据类型、结构体（会字节对齐）。 不同环境下（32位、64位等）某种类型的变量占用字节数可能是不同的 比如指针，32位下是4个字节，64位下是8个字节， 正好是对应计算机的字长。（后边有讲计算机字长是什么） %zd、size_t ==后边还有一篇== %p %x两者有细微差别。 重视warningVS的warning还是比较全的，其他IDE的waring不一定全。 如果写代码出了问题却找不到原因，有可能是warning给出的潜在问题没有处理。 写代码时遇到waring一定要处理，不然很容易出问题。 混合编程C和C++还是不一样的。特别是函数的使用，如果要动态申请一个类对象的内存，可别用malloc，它和new还是不一样的。 一些重要名词值生活、编程中出现的数字、字符串、字符等等，都是值。 比如1,2,3，我爱你等等。 变量变量算是对值的一个替代（或者说抽象）吧，提高复用性。 地址地址是个值。 计算机有存储空间。我们将其一个个地编号，也就是给了它一个地址。 指针指针是个变量。 跟普通变量其实没什么本质区别，只不过它被用来存储地址而已。 运算符优先级* [] &amp;的优先级？ 计算机字长字长：字的长度（位数）。 计算机中有字节这个单位。1个字节等于8位。 多个字节组成字。 我们平常说的电脑32位，64位指的就是字长。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python批量下载邮件附件]]></title>
    <url>%2F2019%2F03%2F23%2Fpython%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E9%82%AE%E4%BB%B6%E9%99%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[背景由于同学每周要通过邮箱收数学建模作业，100多人给她发附件，她要一个个地点着下载。 太麻烦了，所以想用程序实现下载附件的功能。 在网上查资料后，最终实现了稍为简单的下载附件功能，代码有些细节还不是很了解。 2019.4.16更新： 过几天我也要用邮箱收文件，有了这份代码刚好能用！这再次印证知识不会没用处的，不学才会觉得知识没用呢。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import poplibimport emailimport timefrom email.parser import Parserfrom email.header import decode_headerdef decode_str(s):#字符编码转换 value, charset = decode_header(s)[0] if charset: value = value.decode(charset) return valuedef get_att(msg): attachment_files = [] for part in msg.walk(): file_name = part.get_filename() # 获取附件名称类型 contType = part.get_content_type() if file_name: h = email.header.Header(file_name) dh = email.header.decode_header(h) # 对附件名称进行解码 filename = dh[0][0] if dh[0][1]: filename = decode_str(str(filename, dh[0][1])) # 将附件名称可读化 print(filename) # filename = filename.encode("utf-8") data = part.get_payload(decode=True) # 下载附件 att_file = open('D:\\数模作业\\' + filename, 'wb') # 在指定目录下创建文件，注意二进制文件需要用wb模式打开 attachment_files.append(filename) att_file.write(data) # 保存附件 att_file.close() return attachment_fileswith open('D:\\config.txt', 'r') as f1: config = f1.readlines()for i in range(0, len(config)): config[i] = config[i].rstrip('\n')# print(config)# POP3服务器、用户名、密码host = config[0] # pop.163.comusername = config[1] # 用户名 password = config[2] # 密码# 连接到POP3服务器server = poplib.POP3(host)# 身份验证server.user(username)server.pass_(password)# stat()返回邮件数量和占用空间:# print('Messages: %s. Size: %s' % server.stat())# 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]resp, mails, octets = server.list()# print(mails)# 倒序遍历邮件index = len(mails)for i in range(index, 0, -1): # lines存储了邮件的原始文本的每一行 resp, lines, octets = server.retr(i) # 邮件的原始文本: msg_content = b'\r\n'.join(lines).decode('utf-8') # 解析邮件: msg = Parser().parsestr(msg_content) # 获取附件 f_list = get_att(msg)print("文件已下载完成，10秒后关闭程序！")time.sleep(10) 打包使用pyinstaller，将该.py文件打包成.exe文件。 1pyinstaller -F xuer.py 这样她就不需要安装python，方便她使用。 为了保护她的密码隐私，程序通过她自己的文件获得她的用户名和密码，之后文件会自动下载到D盘中数学建模文件夹下。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>python</tag>
        <tag>下载邮件附件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageRank]]></title>
    <url>%2F2019%2F02%2F18%2FPageRank%2F</url>
    <content type="text"><![CDATA[用Matlab实现一个PageRank算法。 介绍PageRank是一种对网页进行排名的算法，通过引用来判断网页的排名。 具体介绍自寻，可以看一下https://baike.baidu.com/item/google%20pagerank#2 题目图中有六个明星，他们之间的箭头表示关注，比如Kim和Ryan互相关注，图片中间的数字是最终计算出的他们的PageRank。 Matlab实现12345678910111213141516171819202122232425262728293031323334353637383940% Find PageRank of network by finding dominant evec%% _ _ _ _% | (1-d)/N | | l11, ..., l1n |% R = | ... | + d | ..., ..., ... | R % |_(1-d)/N_| |_ln1, ..., lnn_| %% R = c + d * L*D * R% R = (I - d * L*D )\c% clc; %清屏d = 0.85; % damping factorname = &#123;'bill', 'ellen', 'jimmy', 'kim', 'paula', 'ryan'&#125;; % celebrities'name[bil, ell, jim, kim, pau, rya] = deal(1,2,3,4,5,6); % celebrities'id，bil=1,ell=2...n = length(name); % number of celebrities,n=6L = zeros(n); % 明星关注关系矩阵,一行是一个人，元素值表示他是否关注他人;一列也是一个人，元素值表示是否被他人关注% if user j follows user i, then L(i,j) = 1L(bil, [rya, ell]) = 1; % bil关注rya ell，下五行同理L(ell, [jim, rya]) = 1; L(jim, [rya, pau, ell]) = 1;L(kim, [jim, rya, ell]) = 1;L(pau, [rya, ell])=1;L(rya, [bil, jim, kim, pau, ell]) = 1;% ot = out-degree, in = in-degreeot = sum(L,1); % 对每1列求和，得行向量，每一列是一个人，元素值为被关注次数in = sum(L,2); % 对每1行求和，得列向量，每一行是一个人，元素值为他关注了多少人k = find(ot~=0); % 找到ot中不等于0的元素的下标,在此都不为0，返回行向量[1,2,3,..,6]D = full(sparse(k,k,1./ot(k),n,n)); %对角矩阵，对角元素表示每个人对其他人的关注的分成% L*D 是 6*6矩阵，一行、一列都是一个人，一行表示得到每个人的关注的分成，列表示对其他人关注的分成c = (1-d)/n*ones(n,1); % 值为(1-d)/n 的 n行列向量I = eye(n); % n*n单位矩阵R = (I - d*L*D)\c % 注意是左除,得到6个人的PageRank 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论和交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
        <tag>PageRank</tag>
        <tag>算法</tag>
        <tag>线性方程组求解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多体问题]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%A4%9A%E4%BD%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题及分析 Matlab代码给出了核心逻辑的注释，作图暂时还不太了解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function SunEarthMoon % M函数文件load planets; % 将planets.mat中的变量mass、position、velocity加载过来[sun, earth, moon] = deal(18, 3, 25); % sun、earth、moon分别是18、3、25行list = [sun, earth, moon]; % 1行3列矩阵G = 6.67e-11; % gravitational constantdt = 24*3600; % 作图的时间间隔为一天，每天有24*3600秒N = length(list); % N=3，三个天体mass = mass(list); % N行1列矩阵，N个天体的质量position = position(list,:); % N行3列矩阵，N个天体的坐标，坐标是1行3列的行向量，三个方向的分量velocity = velocity(list,:); % N行3列矩阵，N个天体的速度，速度是1行3列的行向量，三个方向的分量h = plotplanets(position); %作图函数for t = 1:365 % 图中总时间为一年，一年365天 plotplanets(position,h); % force = zeros(N,3); % N行3列零矩阵，一行表示某个天体在三个方向上的受力 for i = 1 : N % 遍历计算各天体间的万有引力。组合数C（3，2） Pi = position(i,:); % 某天体坐标 Mi = mass(i); % 某天体质量 for j = (i+1):N %the i+1 is to create diagonal Mj = mass(j); % 另一天体质量 Pj = position(j,:); % 另一天体坐标 dr = Pj - Pi; % 两天体的相对，1行3列矩阵 forceij = G*Mi*Mj./(norm(dr).^3).*dr; % 两天体之间的力，1行3列的向量 force(i,:) = force(i,:) + forceij; % 规定正方向，将力计算进矩阵 force(j,:) = force(j,:) - forceij; % 反作用力与作用力方向相反，将力计算进矩阵 % 上两行可替换为force([i,j],:) = force([i,j],:)+[forceij; -forceij]; end end velocity = velocity + force ./ repmat(mass,1,3)*dt; % v=v+a*dt a=F/m position = position + velocity*dt; % r=r+v*dtend % -------------------------------------------------------------------------function h = plotplanets(pos,h) % scale = 50;total_planets = size(pos,1);[sun, earth, moon] = deal(1, 2, 3);radius = [50, 30, 20];marker = &#123;'.r', 'b.','m.'&#125;;pos(moon,:) = pos(earth,:) + scale*(pos(moon,:)-pos(earth,:));if nargin==1 hold on; axis image axis( [-2 2 -2 2]*1e11 ); for i = 1:total_planets if any(i == [sun, earth, moon]) h(i) = plot(pos(i,1),pos(i,2),marker&#123;i&#125;,'markersize',radius(i)); plot(pos(i,1), pos(i,2), marker&#123;i&#125;, 'markersize',5); else h(i) = plot(pos(i,1), pos(i,2), 'k.', 'markersize', 20); plot(pos(i,1), pos(i,2), 'k.', 'markersize',5); end endelse for i = 1:total_planets set(h(i), 'Xdata', pos(i,1) , 'Ydata', pos(i,2) ) if any(i == [sun, earth, moon]) plot(pos(i,1), pos(i,2), marker&#123;i&#125;, 'markersize',5); else plot(pos(i,1), pos(i,2), 'k.', 'markersize',5); end end drawnowend 结果 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎讨论交流!]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[椅子能在不平的地面上放稳吗]]></title>
    <url>%2F2019%2F02%2F16%2F%E6%A4%85%E5%AD%90%E8%83%BD%E5%9C%A8%E4%B8%8D%E5%B9%B3%E7%9A%84%E5%9C%B0%E9%9D%A2%E4%B8%8A%E6%94%BE%E7%A8%B3%E5%90%97%2F</url>
    <content type="text"><![CDATA[问题把椅子放在不平的地面上，通常只有三只脚着地，放不稳，然而只需稍挪动几次，就可以使四只脚同时着地而放稳。这个看来似乎与数学无关的现象能用数学语言表述，并用数学工具来证实吗？让我们来试试看！ 再次读题把椅子 放在 不平的地面上，通常只有三只脚着地，放不稳，然而只需稍挪动几次，就可以使四只脚同时着地而放稳。这个看来似乎与数学无关的现象能用数学语言表述，并用数学工具来证实吗？让我们来试试看！ 对象分析 椅子$\Longrightarrow$四个椅脚$\Longrightarrow$与地面有四个接触点$\Longrightarrow​$正方形（本质应该是长方形） 不平的地面$\Longrightarrow​$光滑曲面（光滑是根据讨论范围确定的，不连续的很陡的地面不在讨论范围之内） 条件分析 通常只有三只脚着地，放不稳$\Longrightarrow$假设至少三只脚着地$\Longrightarrow$$F(\theta)*G(\theta)=0$ 稍挪动几次$\Longrightarrow$位置的变化$\Longrightarrow$角度$\theta$的变化 结论分析 能不能$\Longrightarrow​$存在问题，0和1 放稳$\Longrightarrow$四个脚到地面距离都为0$\Longrightarrow$两对 对角椅脚 离地面的高度之和$F(\theta)=G(\theta)=0$ 2019.3.27补充： 昨天上课学得，在某些问题中，结果为离散的0或1的问题可以转化为结果为连续值的问题。 比如目标是得到最大产值，问题是A、B、C哪里需要建厂，这涉及到原料的生产、加工、运输，成品的销售等等。 如果直接根据问题进行离散的计算，会有$2^3=8\,$种情况。 如果进行连续的计算，将某地是否建厂转化为某地的原料产量。如果产量是0，则表示该地不建厂；如果产量大于0，则表示该地建厂。 数学模型已知F($\theta​$)、G($\theta​$)是$\theta​$的连续函数，对任意$\theta​$，$F(\theta){\times}G(\theta)=0​$，且$G(0)=F(\frac{\pi}{2})=0​$，$F(0)=G(\frac{\pi}{2})&gt;0​$，证明存在$\theta_0​$，使$F(\theta_0)=G(\theta_0)=0​$。 方法总结好好读题，根据题中所给信息，找到研究对象、条件、结论等现实元素转化为一个个数学元素。 讨论关于旋转的变量除了$\theta$，转轴也可以算一个，另外还可以把正方形改为长方形进行讨论。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎交流讨论!]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（十一）之兄弟组件间传值]]></title>
    <url>%2F2019%2F01%2F22%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E4%B9%8B%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[原理React传递数据是单向数据流，两个组件必须有关系才可以传值。 而兄弟组件间并无直接关系，所以需要借助父组件。 兄弟组件传值原理： 简单的逻辑是这样：子组件1传值给父组件，父组件再传给子组件2。 子组件1通过函数参数传值给父组件。 父组件利用子组件1传来的值改变自身state中的某个值。 由于父组件将自身state的那个值传给子组件2，而现在state发生改变 ，子组件2会重新渲染，实现子组件1传值到 这里用到了state和更新dom的知识，不知道的可以看看。前边的文章或百度。 代码实现现有三个组件，父组件App,子组件1Header，子组件2Home，Home比Header小2岁。 实现功能：改变Header的年龄，且同步更新Home的年龄。 App.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from 'react'; //固定写法import Header from './components/Header';import Home from './components/Home';class App extends Component &#123; //ES6写法 constructor()&#123; super(); this.state=&#123; homeAge:10 &#125; &#125; onGreet(headerAge)&#123; //父组件定义回调函数 alert("App:Header is"+headerAge+"years old!"); this.setState(&#123; homeAge: headerAge-2 &#125;) &#125; render() &#123; const user=&#123; //定义一个对象，传给子组件Header name: "Anna", hobbies: ["Sports", "Reading"] &#125; return ( &lt;div&gt; &lt;div&gt; &lt;Header greet=&#123;this.onGreet.bind(this)&#125; name=&#123;"Max"&#125; age=&#123;12&#125; user=&#123;user&#125;&gt; &lt;p&gt;I am Header's children&lt;/p&gt; &lt;/Header&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;I am App&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;Home homeAge=&#123;this.state.homeAge&#125;/&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; Header.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import React, &#123; Component &#125; from 'react'; //固定写法import PropTypes from 'prop-types';class Header extends Component &#123; //ES6写法 constructor(props)&#123; super(props); //执行父类构造方法 this.state=&#123; age:props.age &#125; //this.age=this.props.age; &#125; onMakeOrder()&#123; this.setState(&#123; age:this.state.age+3 &#125;) //this.age+=3; console.log(this); //显示当前Header类的对象 &#125; handleGreet()&#123; this.props.greet(this.state.age); &#125; render() &#123; //console.log(this.props); //显示父组件传来的参数 return ( &lt;div&gt; &lt;h1&gt;I am Header&lt;/h1&gt; &lt;div&gt; props'name is &#123;this.props.name&#125;,my age is &#123;this.state.age&#125; &lt;/div&gt; &#123;/*&lt;button onClick=&#123;() =&gt; this.onMakeOrder()&#125; className="btn btn-primary"&gt;make me older&lt;/button&gt;*/&#125; &lt;button onClick=&#123;this.onMakeOrder.bind(this)&#125; className="btn btn-primary"&gt; make me older &lt;/button&gt; &lt;br /&gt; &lt;button onClick=&#123;this.handleGreet.bind(this)&#125; className="btn btn-primary"&gt; 告诉App我几岁 &lt;/button&gt; &lt;div&gt; &lt;h4&gt;props'hobbies如下：&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt;props's children如下：&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Header.propTypes=&#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, greet: PropTypes.function, children: PropTypes.element.isRequired&#125;export default Header; Home.js123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react'; //固定写法class Home extends Component &#123; //ES6写法 render() &#123; let content=""; let flag=false; if(flag)&#123; content="cbh"; &#125; else&#123; content="cxy"; &#125; return ( &lt;div&gt; &lt;h1&gt;I am Home&lt;/h1&gt; 动态数据：&#123;content&#125; &lt;h1&gt;I am &#123;this.props.homeAge&#125; year's old&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default Home; 具体过程两个子组件本来就是12岁和10岁，无法查看传值效果。 所以先点击makeolder按钮，可以看到Header年龄变为15。 再点击告诉App我几岁按钮。 子组件1Header通过一个回调函数将自己的年龄传给父组件App，父组件再用Header传来的年龄更新自己的state； 由于父组件App给子组件2Home传的参数是state中的一个值，所以子组件2变化的部分会重新渲染，实现子组件1传值给子组件2。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阮一峰React入门教程学习笔记]]></title>
    <url>%2F2019%2F01%2F22%2F%E9%98%AE%E4%B8%80%E5%B3%B0React%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[虽然已经看视频学了一些React基础，看完阮一峰的教程还是对React有了更多的理解。 他的教程感觉还是很简洁明了的，误区、重点都有讲到。 以下为阮一峰React入门教程学习笔记，记录了一些新的、重要的知识点。 本文标题为教程中对应章节的标题。 安装React 可以在浏览器运行，也可以在服务器运行。 HTML模板模板1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src="../build/react.js"&gt;&lt;/script&gt; //react核心库 &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt; //提供dom相关功能 &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt; //将JSX转为JS，很耗时间，应用上线时应将这一步放在服务器完成 &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意JSX语法为React独有，与JS并不兼容，因此使用JSX语法的时候要加上type=&quot;text/babel&quot;。 ReactDOM.render()12345ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') //h1可看作一个组件，插入id为example的DOM结点。); ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点，即挂载组件。 JSX语法介绍可以看React官网。 JSX是JS的语法扩展，它为React提供了元素。 为何使用JSXReact认为页面的渲染逻辑和UI设计的逻辑是耦合的：事件如何处理，状态如何随时间变化，以及数据如何准备显示。 React通过包含标记和逻辑的组件实现 separation of concerns。 React不是必须使用JSX，但JSX使包含UI的JS代码更加容易处理，同时也可以暴露出更多有用的报错和警告信息。 基本语法遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 它允许HTML和JavaScript的混写。 JSX 允许直接在模板插入 JavaScript 变量，JSX中的大括号内可以放置任何有效的JavaScript表达式。 组件render所有组件类都必须有自己的 render 方法，用于输出组件。 组件名组件类的第一个字母必须大写，否则会报错。 一个顶层标签组件类只能包含一个顶层标签，否则也会报错。 传参组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;John&quot;&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 John。组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 保留字问题添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 PropTypes组件类的PropTypes属性，用来验证组件实例的属性是否符合要求。 getDefaultProps 方法可以用来设置组件属性的默认值。 获取真实DOM结点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。 有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 this.stateReact 的一大创新，就是将组件看成是一个状态机。 每次修改this.setState以后，自动调用 this.render 方法，再次渲染组件。 表单要获取用户输入，需要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。 组件的生命周期组件的三种状态组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 状态的处理函数will 函数在进入状态之前调用，did函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 特殊状态的处理函数 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 React 组件样式是一个对象。 Ajax==还没学== 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（十）之子组件向父组件传值]]></title>
    <url>%2F2019%2F01%2F20%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%EF%BC%89%E4%B9%8B%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[子组件向父组件传值，一般要通过回调函数的参数。这也是 父组件定义一个回调函数，并将其传递给子组件，然后子组件调用该函数，并将值通过回调函数的参数传给父组件。 这说明了React数据传递的单向性，虽然实现了子组件传值给父组件，但本质还是父组件传给了子组件一个函数。 父组件定义回调函数App.js中定义回调函数： 123onGreet(age)&#123; //父组件定义回调函数 alert("Son is"+age+"years old!");&#125; 父组件传回调函数给子组件App.js中将定义的回调函数传给子组件： 1234&lt;Header greet=&#123;this.onGreet&#125; name=&#123;"Max"&#125; age=&#123;12&#125; user=&#123;user&#125;&gt; &lt;p&gt;I am header's children&lt;/p&gt; &lt;p&gt;I am header's children&lt;/p&gt;&lt;/Header&gt; 子组件调用回调函数子组件定义处理回函的函数Header.js中定义： 123handleGreet()&#123; this.props.greet(this.state.age);&#125; 子组件调用处理回函的函数Header.js中定义： 123&lt;button onClick=&#123;this.handleGreet.bind(this)&#125; className="btn btn-primary"&gt; Greet&lt;/button&gt; 效果展示 点击Greet按钮 点击Older按钮 点击Greet按钮 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（九）之React如何更新DOM]]></title>
    <url>%2F2019%2F01%2F19%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8BReact%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0DOM%2F</url>
    <content type="text"><![CDATA[React只重新渲染HTML页面中改变的部分。 基本原理React有一个概念：虚拟DOM。 每次操作都会生成一个虚拟DOM，然后通过diff算法和上一次的虚拟DOM进行比较，通过比较可以找到需要重新渲染的组件，然后只重新渲染这些组件，其他不变。 验证使用chrome浏览器，检查元素，按下图操作 然后页面渲染的地方会被高亮（我这里是绿色）。 每次点击按钮，会发现your name is Max,your age is XX被高亮，而其他不变。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（八）之组件的state属性]]></title>
    <url>%2F2019%2F01%2F19%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84state%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[上次讲到state更新，DOM树才会更新，原理是React会监听组件的state。 现在来试一下。 Header代码变动修改Header.js,有如下三处变动,其中注释掉的代码是上一节的代码。 1234567constructor(props)&#123; super(props); //执行父类构造方法 this.state=&#123; age:props.age &#125; //this.age=this.props.age; &#125; 1234567onMakeOrder()&#123; this.setState(&#123; age:this.state.age+3 &#125;) //this.age+=3; console.log(this); //显示当前Header类的对象 &#125; 12&lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.state.age&#125;&lt;/div&gt; //表达式中上次是this.props.age Header.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component &#125; from 'react'; //固定写法import PropTypes from 'prop-types';class Header extends Component &#123; //ES6写法 constructor(props)&#123; super(props); //执行父类构造方法 this.state=&#123; age:props.age &#125; //this.age=this.props.age; &#125; onMakeOrder()&#123; this.setState(&#123; age:this.state.age+3 &#125;) //this.age+=3; console.log(this); //显示当前Header类的对象 &#125; render() &#123; //console.log(this.props); //显示父组件传来的参数 return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.state.age&#125;&lt;/div&gt; &#123;/*&lt;button onClick=&#123;() =&gt; this.onMakeOrder()&#125; className="btn btn-primary"&gt;make me older&lt;/button&gt;*/&#125; &lt;button onClick=&#123;this.onMakeOrder.bind(this)&#125; className="btn btn-primary"&gt;make me older &lt;/button&gt; &lt;div&gt; &lt;h4&gt;hobbies&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Header.propTypes=&#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, children: PropTypes.element.isRequired&#125;export default Header; 效果页面中的age会更改哟。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（七）之事件]]></title>
    <url>%2F2019%2F01%2F19%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[之前组件的功能都是显示字样，现在来加个按钮试试处理事件。 这里用bootstrap写一个好看点的按钮，修改html文件是为了使用bootstrap，如果不使用则不需要修改index.html。 修改html文件百度找到bootstrap的cdn。 1&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"&gt; 将其加入index.html的&lt;head&gt;&lt;/head&gt;里边。 处理事件添加按钮及其响应函数在组件Header中添加按钮，向Header.js中加入以下代码，二选一即可 1&lt;button onClick=&#123;this.onMakeOrder.bind(this)&#125; className="btn btn-primary"&gt;make me older&lt;/button&gt; 1&lt;button onClick=&#123;() =&gt; this.onMakeOrder()&#125; className="btn btn-primary"&gt;make me older&lt;/button&gt; Header.js代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; Component &#125; from 'react'; //固定写法import PropTypes from 'prop-types';class Header extends Component &#123; //ES6写法 constructor(props)&#123; super(props); //执行父类构造方法 this.age=this.props.age; &#125; onMakeOrder()&#123; this.age+=3; console.log(this); //显示当前Header类的对象 &#125; render() &#123; //console.log(this.props); //显示父组件传来的参数 return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.props.age&#125;&lt;/div&gt; &#123;/* &lt;button onClick=&#123;() =&gt; this.onMakeOrder()&#125; className="btn btn- primary"&gt; make me older &lt;/button&gt; */&#125; &lt;button onClick=&#123;this.onMakeOrder.bind(this)&#125; className="btn btn-primary"&gt; make me older &lt;/button&gt; &lt;div&gt; &lt;h4&gt;hobbies&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Header.propTypes=&#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, children: PropTypes.element.isRequired&#125;export default Header; 效果 从图中可以看到age在不断变大，但网页上的age没有更新，这涉及到react的一个机制。 react并不是对象的属性改变的时候，DOM会改变。而是对象的state变化的时候，DOM树才会更新。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（六）之父组件向子组件传值]]></title>
    <url>%2F2019%2F01%2F19%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[组件间的关系继续参考之前的代码App.js。 父子关系App是父，Header和Home相对于App是子。 兄弟关系Header和Home是兄弟关系。 父向子传值父传值父组件向子组件传值是父组件在调用子组件时，进行传值，以下两种方法都可以，App向Header传值，下边的代码是写在App.js里的。 1&lt;Header name=&#123;"Max"&#125; age=&#123;"12"&#125; user=&#123;user&#125;/&gt; 123&lt;Header name=&#123;"Max"&#125; age=&#123;12&#125; user=&#123;user&#125;&gt; &lt;p&gt;I am child&lt;/p&gt;&lt;/Header&gt; 这里使用第二种方法。 子使用值子组件使用父组件传过来的值通过props使用，例如： 1&lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.props.age&#125;&lt;/div&gt; App.js代码：注意第7行和16行 123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react'; //固定写法import Header from './components/Header';import Home from './components/Home';class App extends Component &#123; //ES6写法 render() &#123; //注意这里 const user=&#123; name: "Anna", hobbies: ["Sports", "Reading"] &#125; return ( &lt;div&gt; &lt;div&gt; &lt;Header name=&#123;"Max"&#125; age=&#123;"12"&#125; user=&#123;user&#125;/&gt; //传值 age=&#123;12&#125;也可以 &lt;/div&gt; &lt;div&gt; &lt;h1&gt;I am App&lt;/h1&gt; &lt;/div&gt; &lt;div&gt; &lt;Home /&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; Header.js代码：注意第6行和return的内容 this.props就是父组件传过来的值 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react'; //固定写法class Header extends Component &#123; //ES6写法 render() &#123; console.log(this.props); return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.props.age&#125;&lt;/div&gt; &lt;div&gt; &lt;h4&gt;hobbies&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default Header; 参数类型检查JS是动态语言。 在这里我们对App传过来的值进行检查，理所当然要在Header中检查。 在Header.js中引入静态检查： 1import PropTypes from 'prop-types'; 现在开始检查，设置Header接收到的参数的类型： 123456Header.propTypes=&#123; name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, children: PropTypes.element.isRequired&#125; 其中children是给Header传参时Header闭合标签里的东西。 最终Header.js代码是这样： 1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react'; //固定写法import PropTypes from 'prop-types';class Header extends Component &#123; //ES6写法 render() &#123; console.log(this.props); return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;div&gt;your name is &#123;this.props.name&#125;,your age is &#123;this.props.age&#125;&lt;/div&gt; &lt;div&gt; &lt;h4&gt;hobbies&lt;/h4&gt; &lt;ul&gt; &#123;this.props.user.hobbies.map((hobby,i) =&gt; &lt;li key=&#123;i&#125;&gt;&#123;hobby&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;Header.propTypes=&#123; //注意p是小写 name: PropTypes.string, age: PropTypes.number, user: PropTypes.object, children: PropTypes.element.isRequired&#125;export default Header; 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（五）之输出动态数据]]></title>
    <url>%2F2019%2F01%2F18%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E8%BE%93%E5%87%BA%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[输出动态数据就是输出表达式。 表达式就是2+2，变量等等。 现在在Home.js中输出动态数据。 代码注意代码中的第19行 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react'; //固定写法export class Home extends Component &#123; //ES6写法 render() &#123; let content=""; let flag=false; if(flag)&#123; content="cbh"; &#125; else&#123; content="cxy"; &#125; return ( &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &#123;content&#125; &lt;/div&gt; ); &#125;&#125;export default Home; 效果 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（四）之多个组件]]></title>
    <url>%2F2019%2F01%2F18%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[新建组件在src目录下新建文件夹components，用来存放定义组件的JS代码。 在components文件夹中定义两个组件：Home.js和Header.js，代码几乎和App.js一样，只改变了类名和return的内容。 提示：由于某些原因，之后的代码中可能会有标签匹配出错的问题….. 文件目录结构注意Header.js、Home.js和App.js在目录中的位置。 Home.js显示Home字样。 12345678910111213import React, &#123; Component &#125; from 'react'; //固定写法export class Home extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default Home; Header.js显示Header字样。 12345678910111213import React, &#123; Component &#125; from 'react'; //固定写法export class Header extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;h1&gt;Header&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;export default Header; 使用组件在App中使用定义的两个组件，先使用Header，接着显示I am App，接着再使用Home。 App.js 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react'; //固定写法import Header from './components/Header';import Home from './components/Home';class App extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;Header /&gt; //注意这里！ &lt;/div&gt; &lt;div&gt; &lt;h1&gt;I am App&lt;/h1&gt; //注意这里！ &lt;/div&gt; &lt;div&gt; &lt;Home /&gt; //注意这里！ &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 效果展示 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（三）之第一个组件]]></title>
    <url>%2F2019%2F01%2F18%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[项目结构之前通过create-react-app创建了一个hello-react项目，不知道的可以看博客里之前的的React文章。 暂时只关注三个文件：src\index.js、src\App.js和public\index.html。 文件说明App.js作用App.js定义页面中的一个组件，也就是定义页面中要放的一个零件。 代码定义了一个显示React的logo的组件。 注意下我加的代码注释 12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react'; //固定写法import logo from './logo.svg'; //图片import './App.css'; //cssclass App extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;header className="App-header"&gt; &lt;img src=&#123;logo&#125; className="App-logo" alt="logo" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className="App-link" href="https://reactjs.org" target="_blank" rel="noopener noreferrer" &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; ); &#125;&#125;export default App; index.html作用index.html进行页面内容的布局，也就是哪里放什么标签。 index.html是显示的页面，用户通过检查元素是可以看到html代码的，所以放在public文件夹下吧。 代码主要看body部分，只放了一个div。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /&gt; &lt;meta name="theme-color" content="#000000" /&gt; &lt;!-- manifest.json provides metadata used when your web app is added to the homescreen on Android. See https://developers.google.com/web/fundamentals/web-app-manifest/ --&gt; &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt; &lt;!-- Notice the use of %PUBLIC_URL% in the tags above. It will be replaced with the URL of the `public` folder during the build. Only files inside the `public` folder can be referenced from the HTML. Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will work correctly both with client-side routing and a non-root public URL. Learn how to configure a non-root public URL by running `npm run build`. --&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the &lt;body&gt; tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --&gt; &lt;/body&gt; &lt;/html&gt; index.js作用index.js连接App.js和index.html，通过将组件放入各个标签中，起到连接上边两个文件的作用。 代码主要内容是第11行那里。 注意下我加的代码注释。 1234567891011121314151617//导入reactimport React from 'react';import ReactDOM from 'react-dom';//导入css，.代表当前目录，..代表上一级目录import './index.css';//导入组件，变成App，其实下一行的'./App'省略了.js后缀，本来应该是'./App.js'import App from './App';import * as serviceWorker from './serviceWorker';//设置挂载点，把组件App挂到root上ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: http://bit.ly/CRA-PWAserviceWorker.unregister(); 自己的第一个组件也就是自己写一个组件嘛，组件是在App.js中定义的，所以修改App.js。 定义组件在这里将组件的默认内容删除，也就是render函数中return的东西，然后自己写。 12345678910111213141516171819import React, &#123; Component &#125; from 'react'; //固定写法import logo from './logo.svg'; //图片import './App.css'; //cssclass App extends Component &#123; //ES6写法 render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default App; 代码里div中用的是className是因为class是JS的保留字，所以要用className。 代码修改之后效果在此就不展示了，显示了一个hello world。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（二）之create-react-app]]></title>
    <url>%2F2019%2F01%2F18%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8Bcreate-react-app%2F</url>
    <content type="text"><![CDATA[安装create-react-app环境配置首先要确保你的电脑上有Nodejs和npm 。 检查方法：打开cmd(也就是命令行、终端)，输入node -v和npm -v。 可分别查看Nodejs和npm的版本，有版本环境肯定就配好啦。似乎现在的Nodejs会带着npm。 开始安装打开cmd，输入npm install -g create-react-app -g表示全局，我们可以在任意地方使用npm。 创建react项目我们可以通过create-react-app指令创建一个react项目。 终端中进入项目创建位置创建的项目的位置取决于在cmd中操作的位置。 最近在用VSCode，在VSCode中可以直接右击工作空间的文件夹，再点击在终端中打开，即可在终端中操作该文件夹。 创建项目 启动项目接着上一步 运行效果 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo不蒜子网站访问量统计失效]]></title>
    <url>%2F2019%2F01%2F17%2Fhexo%E4%B8%8D%E8%92%9C%E5%AD%90%E7%BD%91%E7%AB%99%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[问题hexo博客的不蒜子网站访问量统计最近失效了。 解决原因不蒜子域名更改了，所以需要修改博客的配置文件。 方法进入博客目录下\themes\next\layout\_third-party\analytics，（我用的是next主题，如果用的是别的主题，就进入对应主题文件夹。） 打开文件busuanzi-counter.swig 将&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 修改为&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 不知道为什么空格显示的比较宽，但经验证，复制下来是一个正常的空格，可以复制下来使用。 其他不变。]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash: hexo: command not found]]></title>
    <url>%2F2019%2F01%2F17%2Fbash-hexo-command-not-found%2F</url>
    <content type="text"><![CDATA[问题很久没写博客了，今天用hexo新建文章时git报错： bash: hexo: command not found 解决办法百度之后，将D:\WorkingSoftware\GithubBlog\node_modules\.bin添加进PATH，问题解决。 加的时候发现path里确实没有这个路径……..不知道为什么会没有 路径中的GithubBlog是我的博客文件夹，你用的时候改成你的路径，即XXX你的Blog目录XXX\node_modules\.bin 原因可能是因为我今天更新npm了？ 或者是因为我这两天改了计算机用户名(用户名在其他地方用到了，中文是宽字符，会出错)，造成了很多麻烦，差点edge都坏了。 所以告诫大家用户名尽量一开始就用英文，不要用中文。]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习（一）之Hello React]]></title>
    <url>%2F2019%2F01%2F17%2FReact%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BHello-React%2F</url>
    <content type="text"><![CDATA[代码以下是html代码，复制代码到html文件，可直接运行。 (请关注&lt;body&gt;&lt;/body&gt;里的JS代码和注释)： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;helloReact&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( //代码块①开始 &lt;h1&gt;hello world!&lt;/h1&gt;, //代码块①结束，注意结束有个逗号 document.getElementById("app") //设置挂载点 //上一行代码(结尾没有分号)将代码块①放入上边的 &lt;div id="app"&gt;&lt;/div&gt;，F12检查元素可以看到效果。 ) &lt;/script&gt; //两个和react相关的脚本文件 &lt;script src="https://cdn.bootcss.com/react/16.7.0/umd/react.development.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/react-dom/16.7.0/umd/react-dom.development.js"&gt;&lt;/script&gt; //babel文件，作用是解码，详情请参考ES6 &lt;script src="https://cdn.bootcss.com/babel-standalone/7.0.0-beta.3/babel.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行效果 调试F12检查元素可以看到代码块①被添加进id为app的&lt;div&gt; 转码效果babel官网转码（进入官网后点击Try it out）。关于什么是babel，参看ES6（我还不会hh）。 左边是JSX语法，方便我们写代码。]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util.NoSuchElementException]]></title>
    <url>%2F2018%2F11%2F03%2Fjava.util.NoSuchElementException%2F</url>
    <content type="text"><![CDATA[问题引入Java商店作业不同函数里需要获取用户输入，用Scanner的时候,出现了异常java.util.NoSuchElementException 作业中代码模式如下，func1和func2中都使用Scanner并关闭它。然后在main中依次调用func1和func2，func2产生异常。说func1和func2其实不合适，应该加个括号……..懒得加了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Demo.javaimport java.util.Scanner;class Test&#123; void func1() &#123; Scanner sc=new Scanner(System.in); //输出用户输入，替代作业里的使用Scanner System.out.print("Func1请输入内容："); System.out.println("Func1输出"+sc.next()); //关闭Scanner sc.close(); &#125; void func2() &#123; Scanner sc=new Scanner(System.in); //输出用户输入，替代作业里的使用Scanner System.out.print("Func2请输入内容："); System.out.println("Func2输出"+sc.nextInt()); //关闭Scanner sc.close(); &#125;&#125;public class Demo&#123; public static void main(String[] args) &#123; Test t=new Test(); t.func1(); t.func2(); &#125;&#125;/*Console输出如下：Func1请输入内容：小姐，请问你喜欢吃青椒吗？Func1输出：小姐，请问你喜欢吃青椒吗？Func2请输入内容：Exception in thread "main" java.util.NoSuchElementException at java.base/java.util.Scanner.throwFor(Unknown Source) at java.base/java.util.Scanner.next(Unknown Source) at java.base/java.util.Scanner.nextInt(Unknown Source) at java.base/java.util.Scanner.nextInt(Unknown Source) at Test.func2(Demo.java:21) at Demo.main(Demo.java:31)*/ 异常产生原因func1中sc.close();语句关闭了Scanner，func2中使用Scanner产生异常 因为System.in是System类的静态成员，所以不同Scanner对象内的in是同一个in` func1和func2中都用System.in创建了Scanner func1打开Scanner后将其关闭，这里间接地将System.in也关闭了 func1结束后运行func2，这时再调用nextInt，在System.in已经关闭了的情况下，不能读取到任何数据，就会产生 java.util.NoSuchElementException 解决方法系统资源一旦释放就不能再开启了，所以只有确定不在使用系统的时候，才能将流关闭 所以应该在整个程序结束时释放Scanner等资源，而不是某个函数中每次使用Scanner等资源后都释放一次 问题引入中的代码只是个模式，上边的两句话用在作业实际代码里就好了 代码分析Scanner()创建Scanner对象代码为Scanner sc=new Scanner(System.in);构造函数源码如下 123public Scanner(InputStream source) &#123; this(new InputStreamReader(source), WHITESPACE_PATTERN);&#125; 可看出是调用了另外一个构造函数，继续查看源码 123456789101112private Scanner(Readable source, Pattern pattern) &#123; assert source != null : "source should not be null"; assert pattern != null : "pattern should not be null"; this.source = source; //看这句 delimPattern = pattern; buf = CharBuffer.allocate(BUFFER_SIZE); buf.limit(0); matcher = delimPattern.matcher(buf); matcher.useTransparentBounds(true); matcher.useAnchoringBounds(false); useLocale(Locale.getDefault(Locale.Category.FORMAT)); &#125; 至少知道了Scanner内部还是用到了流，算是对流进行了封装吧，使用起来更方便一些 close()调用语句为sc.close();，查看close()源码，如下 1234567891011121314public void close() &#123; if (closed) //1.通过closed标志校验Scanner是否已关闭； return; if (source instanceof Closeable) &#123; //2.执行source的close()方法， try &#123; //将source关闭（这里为System.in）； ((Closeable)source).close(); &#125; catch (IOException ioe) &#123; lastException = ioe; &#125; &#125; sourceClosed = true; //3.将sourceClosed标志设置为true，表示source已关闭； source = null; //4.将source置为null，不再引用，处于可回收状态； closed = true; //5.将closed标志设置为true，表示Scanner已关闭；&#125; 可以知道关闭Scanner的时候，((Closeable)source).close();把System.in关闭了 关闭后下次想再使用就当然有错了~（除非构造函数里还再把in给打开，但这样也不太合理） 其实如果还可以再仔细看看Scanner的构造方法，和Scanner的next()，能力有限，点到为止 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/11/03/java.util.NoSuchElementException/#more 欢迎转发和评论]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java字节流read函数]]></title>
    <url>%2F2018%2F09%2F22%2FJava%E5%AD%97%E8%8A%82%E6%B5%81read%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[问题引入做Java作业从标准输入流获取用户输入，用到了System.in.read(),然后出现了bug。 1234567891011121314151617181920212223//随机生成一个小写字母，用户猜5次，读取用户输入，并判断是否猜对import java.io.IOException;public class LetterGuessing &#123; public static void main(String[] args) throws IOException &#123; char ch,answer; //随机生成字母 answer=(char)(Math.random()*26+'a'); System.out.print("请输入一个小写字母："); for(int i=1;i&lt;=5;i++) &#123; //获取用户输入，可能抛出异常 ch=(char)System.in.read(); //比较大小 if(ch == answer)&#123; System.out.println("恭喜，正确！用了"+i+"次猜对"); break; &#125; else if(ch &gt; answer) System.out.println("您猜大了，还有"+ (5-i) +"次机会"); else System.out.println("您猜小了，还有"+ (5-i) +"次机会"); &#125; &#125;&#125; 输入字符&#39;a&#39;，按下Enter,却没有等我下次输入，循环就运行了三次。 问题来源System.in.read()按字节读，一次读入一个字节。后边有详细讲解。 经调试，可知三次循环中ch分别为a,\r,\n。 为什么a+Enter,会变成a\r\n呢 Windows下存在两种文件读写方式，一个是二进制方式，另一种是文本方式。 文本方式中写时”换行”会变成”回车-换行”，即\r\n；读时”回车-换行”会变成”换行”。 二进制方式中读写是严格按照一个字节一个字节的方式进行的。 在这里虽然没有用到文件，但道理应该是一样的 用read()函数是按照一个字节一个字节读取的，即二进制方式。 可能可以推导出，我们向输入流中输入数据默认是按照文本方式。 解决方法方法一在代码第10行后，加两行System.in.read(); 目的是读取掉输入流中的/r和/n。 这种方法的局限性就是输入字母前后不能加空格，因为它不会使空格从输入流中删除。 方法二不用read()读取，用以下代码代替 123import java.util.Scanner;Scanner input=new Scanner(System.in);ch=input.next().charAt(0); 这种方法就比较好，读取字符串（忽略空格和换行，空格和换行不会留在输入流里），然后取字符串的第一个字符。 知识点System.in官方文档：https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#in System是个类，in是System的一个成员，官方介绍如下： 1public static final InputStream in The “standard” input stream. This stream is already open and ready to supply input data. Typically this stream corresponds to keyboard input or another input source specified by the host environment or user. in是一个InputStream类型的对象,所以只需要了解InputStream即可。 InputStream官方文档： https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html 123public abstract class InputStream //抽象类extends Object //继承Object类implements Closeable //实现Closeable接口 官方介绍如下： This abstract class is the superclass of all classes representing an input stream of bytes. 翻译为：这个抽象类是所有字节流类的父类。 字节流的含义：读取方式为一个字节一个字节地读取,而字符流是二个字节二个字节的读。 Applications that need to define a subclass of InputStream must always provide a method that returns the next byte of input. 翻译为：需要定义一个InputStream子类的应用必须提供一个返回输入下一字节的方法（函数）。 read()官方文档：https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html#read() 12public abstract int read() throws IOException Reads the next byte of data from the input stream. The value byte is returned as an int in the range 0 to255. 这个是重点，它返回下一字节的ASCII码 If no byte is available because the end of the stream has been reached, the value -1 is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown. A subclass must provide an implementation of this method. Returns: the next byte of data, or -1 if the end of the stream is reached. Throws: IOException - if an I/O error occurs. 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/09/22/Java字节流read函数/#more 欢迎转发和评论]]></content>
      <tags>
        <tag>Bug</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++获取文件夹下所有文件的路径]]></title>
    <url>%2F2018%2F09%2F09%2F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[代码getFiles()函数的作用： path是一个文件夹路径，函数在path文件夹下寻找所有文件（包括子文件夹下的文件），然后将所有文件的路径存入files 12345678910111213141516171819202122232425#include &lt;io.h&gt; //实现功能需要包含头文件io.hvoid getFiles(string path, vector&lt;string&gt;&amp; files)&#123; intptr_t hFile = 0;//文件句柄，过会儿用来查找 struct _finddata_t fileinfo;//文件信息 string p; if ((hFile = _findfirst(p.assign(path).append("\\*").c_str(), &amp;fileinfo)) != -1) //如果查找到第一个文件 &#123; do &#123; if ((fileinfo.attrib &amp; _A_SUBDIR))//如果是文件夹 &#123; if (strcmp(fileinfo.name, ".") != 0 &amp;&amp; strcmp(fileinfo.name, "..") != 0) getFiles(p.assign(path).append("\\").append(fileinfo.name), files); &#125; else//如果是文件 &#123; files.push_back(p.assign(path).append("\\").append(fileinfo.name)); &#125; &#125; while (_findnext(hFile, &amp;fileinfo) == 0); //能寻找到其他文件 _findclose(hFile); //结束查找，关闭句柄 &#125;&#125; 代码解读_finddata_t它是存储一个文件相关信息的结构体,查看其定义： 1234567#ifdef _USE_32BIT_TIME_T #define _finddata_t _finddata32_t #define _finddatai64_t _finddata32i64_t#else #define _finddata_t _finddata64i32_t #define _finddatai64_t __finddata64_t#endif 我这里是_finddata64i32_t，查看其定义 123456789struct _finddata64i32_t&#123; unsigned attrib; __time64_t time_create; // -1 for FAT file systems __time64_t time_access; // -1 for FAT file systems __time64_t time_write; _fsize_t size; char name[260];&#125;; attrib是该结构体的一个成员，是attribute（属性）的缩写。 它代表文件的属性，下边是相应的宏 123456#define _A_NORMAL 0x00 // Normal file - No read/write restrictions#define _A_RDONLY 0x01 // Read only file#define _A_HIDDEN 0x02 // Hidden file#define _A_SYSTEM 0x04 // System file#define _A_SUBDIR 0x10 // Subdirectory#define _A_ARCH 0x20 // Archive file 成员name就是文件名字嘛… _findfirst第一个参数是标明文件的字符串，可支持通配符：*.c代表后缀为.c的文件，*就代表所有文件 第二个参数是_finddata_t类型变量的地址。该变量用来保存文件信息。 这有坑 我跟网上有点不同的是，网上我看到的例子定义的hFile都是long型，我用long型打开文件就出问题了。 其实VS已经警告了warning C4244: “=”: 从“intptr_t”转换到“long”，可能丢失数据。 我没在意它，后来改掉了类型就成功了。（就冲这一点，VS天下第一！） 查看_findfirst定义 1234567891011#ifdef _USE_32BIT_TIME_T #define _findfirst _findfirst32 #define _findnext _findnext32 #define _findfirsti64 _findfirst32i64 #define _findnexti64 _findnext32i64#else #define _findfirst _findfirst64i32 #define _findnext _findnext64i32 #define _findfirsti64 _findfirst64 #define _findnexti64 _findnext64#endif 我这里用的是_findfirst64i32，查看其定义 1234_ACRTIMP intptr_t __cdecl _findfirst64i32( _In_z_ char const* _FileName, _Out_ struct _finddata64i32_t* _FindData ); 说明函数返回intptr_t 继续查看intptr_t定义，得到 12345678#ifdef _WIN64 typedef unsigned __int64 size_t; typedef __int64 ptrdiff_t; typedef __int64 intptr_t;#else typedef unsigned int size_t; typedef int ptrdiff_t; typedef int intptr_t; 所以intptr_t在我电脑上实际是__int64，转换成long可能会丢失数据。 _findnext查看其定义 1234567891011#ifdef _USE_32BIT_TIME_T #define _findfirst _findfirst32 #define _findnext _findnext32 #define _findfirsti64 _findfirst32i64 #define _findnexti64 _findnext32i64#else #define _findfirst _findfirst64i32 #define _findnext _findnext64i32 #define _findfirsti64 _findfirst64 #define _findnexti64 _findnext64#endif 我这里是_findnext64i32，查看其定义 1234_ACRTIMP int __cdecl _findnext64i32( _In_ intptr_t _FindHandle, _Out_ struct _finddata64i32_t* _FindData ); 没啥讲的，好好看看_findfirst部分就懂这个了。 位运算fileinfo.attrib &amp; _A_SUBDIR，代码中用到了按位与&amp;。在此表示是文件夹（subdirectory）。位运算经常用在表示属性。具体的这次先不讲。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io 欢迎转发和评论!]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针间的互相赋值]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%8C%87%E9%92%88%E9%97%B4%E7%9A%84%E4%BA%92%E7%9B%B8%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[本篇文章分为三个大的部分 大标题1提出权限”概念”，大标题2验证赋值规则 大标题3、4、5是我的个人理解。 大标题6是最直接的结论。 提醒 看懂这篇文章可能需要你知道并理解四种指针的定义，这是基础。当然如果真的不懂，可以直接去文尾记住结论。 四种指针详解戳这https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/#more 指针修改指向内容的权限普通指针=指针常量&gt;常量指针=四号指针 这个权限指的是通过该指针是否可以修改内存，情况只有两种：是和否。是的话就有权限，否的话就没有权限，这个大小是0和1，false和true，是有和没有，不是12345678的大和小。 普通指针很好说，四号指针也是个常量指针嘛，当然不可以修改内存 这个权限大小关系不难理解，前提是你有理解常指和指常这两个名词吧。 前边的普指和指常都可以修改内存中的内容，而常指和四号则不可以。 指针赋值规则指针间的赋值：权限大的可以赋值给权限小的（权限指操作内存即修改内存中的内容的权限） 权限大的可以赋值给权限小的，同级权限也可以，小赋值给大不行。 123456789101112131415161718192021222324252627282930313233const int n = 0; //常量nint m = 0; //变量mint* p1; //普通指针const int* p2; //常量指针 与int const* p2相同//int* const p3=nullptr; //指针常量//int const * const p4; //四号指针 既是常指又是指常，即自身不可修改，也不可通过它修改指向的内存p1 = p2; //error 普指=常指p1 = p3; //correct 普指=指常p1 = p4; //error 普指=四号p1 = &amp;n; //error 普指=常指p1 = &amp;m; //correct 普指=普指p2 = p1; //correct 常指=普指p2 = p3; //correct 常指=指常p2 = p4; //correct 常指=四号p2 = &amp;n; //correct 常指=常指p2 = &amp;m; //correct 常指=普指//p3是指常，是常量 赋值当然不行了，更别说权限了，所以上边不定义p3，//要讨论的是权限，在此定义并初始化以作示例，但定义只能有一个的啊，我在这提醒过了啊int* const p3 = p1; //correct 指常=普指int* const p3 = p2; //error 指常=常指int* const p3 = p4; //error 指常=四号int* const p3 = &amp;n; //error 指常=常指int* const p3 = &amp;m; //correct 指常=普指//p4是四号，是常量，同p3，不赘述int const * const p4 = p1; //correct 四号=普指int const * const p4 = p2; //correct 四号=常指int const * const p4 = p3; //correct 四号=指常int const * const p4 = &amp;n; //correct 四号=常指int const * const p4 = &amp;m; //correct 四号=普指 这个规则是我自己想出来的，可能书上云里雾里的背后就是这么个规律。我之前好像说过存在即合理..实际表述不太对，应该是存在就有原因。上边的代码应该囊括了所有“品种”指针的互相赋值，验证也都符合预期。如有错误，欢迎指出。 赋值规则的过程赋值得要满足被赋值方的要求，就像你想娶我（捂脸），我就需要你一米八，宠我，其他的都不需要，有的话我也一点不碰。但只要你这两点缺一点，我就不要，你是马云爸爸也不行！ 赋值就是那么个意思，我是指常或者普指，我要求有权限修改内存，所以就只有指常和普指能娶我，能给我赋值，因为常指和四号没有那个权限啊！反过来的话，我是常指和四号，我什么都不要，所以谁赋值都行，上面我们也能看到给常指和四号赋值的时候全都correct了。 赋值规则的必要性赋值规则前提是不同指针的权限不同我想多种指针是为了程序更好吧，不然只有一种指针能实现所有的功能，岂不是很可怕。给了程序员太大的权利，程序员一跑神犯错，程序就极有可能崩溃。给予指针权限之差就像c++里override吧，也是一种对程序员的友好？这是一方面,这应该能说明赋予指针不同权限的必要。 然后才有了赋值规则我们举个例子，如果没有这个规则，不同类型指针自由互相赋值：你定义一个常量n，然后再定义一个int* p，就是普指，普指按说是有修改内存的权利的，然后p=&amp;n，拿到n的地址，是不是就可以通过p改变n了？（在存在不同权限指针的前提下）。如果没有这个规则，我们可以很随意地改变常量了。干嘛自己造了一座木屋，然后又给它浇上油？ 斗胆扯内存不管是指针常量还是常量指针还有普通指针，它们本身和那块内存都是没有本质关系的。 它们（也包括普通类型的指针）只是一个带着镣铐或者没有镣铐的工具，我们可以通过const控制指针的权限以及它本身，同时我们在使用它们时也不能超出它们的权限范围和它们的个人承受力。 结论1234int* p1; //普通指针const int* p2; //常量指针 与int const* p2相同int* const p3=nullptr; //指针常量int const * const p4; //四号指针 既是常指又是指常 p1和p3可以互相赋值； p2和p4可以互相赋值； p1和p3可以给p2和p4赋值，反之不行； p3和p4在程序中只能在定义时被赋值一次，因为它们是const类型的量。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/09/01/指针间的互相赋值/#more 欢迎转发和评论]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物不知其数]]></title>
    <url>%2F2018%2F09%2F01%2F%E7%89%A9%E4%B8%8D%E7%9F%A5%E5%85%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[文章分为三个大的部分： 大标题1是物不知其数问题的引入，大标题2将问题抽象。 大标题3、4、5是物不知其数问题的三种解法及其代码实现。 大标题6是提出的一些问题及不太完善的解释。 提醒： 看文章最好先掌握文章整体结构，电脑会比较方便，可以点击标题跳到自己想看的部分。 看代码发现看不到后边的注释的话，调整网页显示比例（Ctrl+鼠标滚轮） 另外代码里的注释也是有规律的，单独一行的注释是解释下边的几行的功能的，写在代码右边的注释解释这一行代码功能。 问题引入秦王暗点兵和韩信乱点兵都是后人对物不知其数问题的一种故事化，有兴趣可以搜索一下。 物不知其数问题出自《孙子算经》。 原题为：”今有物不知其数，三三数之二，五五数之三，七七数之二，问物几何？” 这道题的意思是：有一批物品，不知道有几件。如果三件三件地数，就会剩下两件；如果五件五件地数，就会剩下三件；如果七件七件地数，也会剩下两件。 问：这批物品共有多少件？ 变成一个纯粹的数学问题就是：有一个数，用3除余2，用5除余3，用7除余2。求这个数。 拿到这个问题，我们可以发现用3和7除余数都是2，自然而然想到3*7=21,21+2=23,23%5=3。所以23就是答案之一，而后边问题中我们求最小值。 这个问题之所以简单，是由于有被3除和被7除余数相同这个特殊性。 问题抽象去除问题数据的特殊性之后，问题可以是像这样： 三人一组余两人，五人一组余三人，七人一组余四人。问：这队士兵至少有多少人？ 就是说我们要找到一个最小的数，使其除以3余2，除以5余3，除以7余4 数据变量化后真正的问题改成：一个数除以x余a，除以y余b，除以z余c，找到符合这三个条件的最小的数。 三个条件按顺序分别称为条件1，条件2，条件3。 暴力方法定义变量n，在范围内从头到尾递增，循环内判断条件为n%3==2&amp;&amp;n%5==3&amp;&amp;n%7==4，符合条件就break 代码实现123456789101112//找到一个最小的数，使其除以x余a，除以y余b，除以z余cint x,y,z; //除数int a,b,c; //余数scanf("%d %d %d %d %d %d",&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);for(int n=1;;n++) //在这里不设范围&#123; if(n%x==a&amp;&amp;n%y==b&amp;&amp;n%z==c) &#123; printf("%d",n); break; &#125;&#125; 合并方法题目中有三个条件，我们可以将前两个条件合并成条件A，再把条件A与第三个条件合并，最后得出结果。 过程条件1和条件2合并成条件A已知n除以3余2，可设n=3i+2(i是正整数)，使i从1变大，判断3i+2除以5是否余3。 我们发现当i=2时，3i+2=8除以5余数为3，即n=8时除以3余2，除以5余3。 然后前两个条件就被我们合并成了条件A：n=15i+8， 本质是：最小的符合前两个条件的数字8加上3和5的最小公倍数15的整数倍 用到的定理：若n除以a余b，n加上a的倍数再除以a余数仍然为b。我们加上的15i即为a的倍数 注意： 是最小公倍数，不要直接看做是两数乘积，因为只有在指出三个除数两两互质的情况下，两数乘积即为最小公倍数，在这里提醒一下，不要理解错误。 如果用的不是最小公倍数，我们下边n增加的单位就变大了，可能会求不到最小值，而题目要求是取得符合要求的最小值。 条件A和条件3合并成结果我们再使条件A和第三个条件合并，n=15i+8(i是正整数)，使i从1变大，判断15i+8除以7的余数是否为4。 我们发现当i=3时，15i+8=53除以7余4，53即为答案 拓展过程中条件合并了两次，让我想到定义一个函数。这个函数要调用两次 写一个比伪代码还伪的代码： 结果 合并(条件，条件) 代码实现最大公约数12345678910111213int Gcd(int a,int b) //Greatest Common divisior&#123; int c; //辗转相除法求最大公约数 Greatest Common Divisor /* 余数不为0，继续相除，直到余数为0 */ while(b!=0) &#123; c=a%b; a=b; b=c; &#125; return a;&#125; 最小公倍数12345int Lcm(int a,int b) //Least Common Multiple &#123; //最小公倍数等于乘积除以最大公约数 return a*b/Gcd(a,b);&#125; 求结果123456789101112131415161718//找到一个最小的数，使其除以x余a，除以y余b，除以z余cint x,y,z; //除数int a,b,c; //余数scanf("%d %d %d %d %d %d",&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);//合并条件1和条件2int i=1;while((x*i+a)%y!=b) //循环跳条件为(x*i+a)%y==b i++;//得到条件Aint d=x*i+a; //得到条件A//合并条件A和条件3int j=1;while((Lcm(x,y)*j+d)%z!=c) //while((Lcm(x,y)*j+d)%z !=c)求得的不一定是最小值 j++;//得到结果int result=Lcm(x,y)*j+d; //int result=x*y*j+d求得的不一定是最小值printf("%d",result); 中国剩余定理方法除数分别是3、5、7，用70(5乘7乘2)乘以用3除的余数，用21(3乘7)乘以用5除的余数，用15(3乘5)乘以用7除的余数，然后把这三个乘积相加。加得的结果如果比105(3乘5乘7)大，就除以105，所得的余数就是满足题目要求的最小正整数解。 过程除数两两结合得到公倍数对所得公倍数的目标(要求)：除以另外一个除数余1 这一步骤中，不用关注三个条件要求余几，条件中的余几会在下一步体现 条件一：用3除 这里是用3除，求另外两个除数的公倍数，并要求用3除余1,5*7=35除以3余2,5乘7乘2=70除以3余1，所以是70 条件二：用5除 3*7=21除以5余1，所以是21 条件三：用7除 3*5=15除以7余1，所以是15 公倍数乘以余数相加70*2+21*3+15*4=263 解读加法：设上式为q+p+r=n。只判断加法会不会影响满足条件1(用3除余2)即可推导出是否满足另外两个条件。 若n除以a余b，n加上a的倍数再除以a余数仍然为b，这里n为140，a为3，b为2，加上的p、r之和是3的倍数，所以余数仍为2，仍满足条件1。（发现百度百科这条定理写错了，嘻。我这数学水平也就能折腾折腾小学数学了吧） 【百度】您于2018-08-31提交的百科词条“秦王暗点兵”版本已通过，查看词条内容：（ http://dwz.cn/s4JsvyGW ）。感谢您参与编写百度百科，亿万网友因您的贡献受益。 9月1日跑步时收到这条短信，这比兴奋剂还兴奋剂，就想来段加速跑。wuhu~ 同理可得，通过加法之后我们得到了一个同时满足三个条件的数字 检验是否最小用上边得到的数字不断减去三个除数的最小公倍数直至数字小于最小公倍数(其实就是得到的数字除以公倍数取余了)，得到最终答案！ 解读：其实就是上边加粗定理的变式，若n除以a余b，n减去a的倍数再除以a余数仍然为b，只是可能说成余数是几不太合理，但要懂那个意思。 拓展个人感觉过程中的前两步完全可以合成一步，在代码实现中很容易就可以看出来，拆开反而更难理解…(差评) 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445//找到一个最小的数，使其除以x余a，除以y余b，除以z余cint x,y,z; //除数int a,b,c; //余数scanf("%d %d %d %d %d %d",&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);//求第二、三个除数的公倍数int i=1;while((Lcm(y,z)*i%x)!=1) i++;//求第一、三个除数的公倍数int j=1;while(((Lcm(x,z)*j%y))!=1) j++;//求第一、二个除数的公倍数int k=1;while((Lcm(x,y)*k%z)!=1) k++;//公倍数乘以对应余数后求和int sum=0;sum+=Lcm(x,z)*j*b;sum+=Lcm(y,z)*i*a;sum+=Lcm(x,y)*k*c;//确认最小值printf("%d\n",sum%Lcm(Lcm(x,y),z));/*拓展对应的代码~~~~~~~~可以替代5到23行int sum = 0;//求第二、三个除数的公倍数同时乘以相应余数求和int i = 1;while ((Lcm(y, z)*i%x) != a) i++;sum += Lcm(y, z)*i;//求第一、三个除数的公倍数同时乘以相应余数求和int j = 1;while (((Lcm(x, z)*j%y)) != b) j++;sum += Lcm(x, z)*j;//求第一、二个除数的公倍数同时乘以相应余数求和int k = 1;while ((Lcm(x, y)*k%z) != c) k++;sum += Lcm(x, y)*k;//确认最小printf("%d\n", sum % Lcm(Lcm(x, y), z));*/ 瑕不掩瑜如果输入 3 3 3 1 1 1(可能这有点刁钻啊) 合并法中，会发现结果是7，但按照我们给出的题目结果应该是1啊！？ 7的来源是： 第一次合并为3*1+1=4，除以3余1，符合条件2，所以得到4； 第二次合并为4*1+1=7，除以3余1，符合条件3，结果为7。 所以答案是7的原因是因为我们默认i是从1开始增长，它代表我们要求的数一定大于三个除数，算经中的问题其实也隐含了这个条件结果要大于三个除数。 如果i从0开始增长，最终答案会是1。 在中国剩余定理中，我们会发现无法跳出循环while ((Lcm(y, z)*i%x) != a) i++;， 原因可能就是定理不适用这种情况吧。我没有深入了解中国剩余定理及其使用。因为我是从韩信点兵的题目了解到这些知识的。搜了一下中国剩余定理，发现它是数论里的一个知识，似乎使用也有一些条件，这里不再过多探索。 emm还是去看了下，中国剩余定理用的时候已经假设了三个除数两两互质。所以输入3 3 3 1 1 1这种就没必要了。但如果能弄懂3 3 3 1 1 1，还是可以让我们对定理有个更好的理解。 (放过我吧，每次写完东西都会发现bug，让我不爽..再多的抽象，也得加点前提条件呐。哪有那么多适用于所有情况的东西，真理也是少之又少。但简单的东西又没那么值得写，最多算个记录罢了) 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/09/01/物不知其数/#more]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常量指针与指针常量]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[常量指针和指针常量是两个经常出现的概念，今天做个小小总结。 文章各部分的内容都是很容易理解的，并且附加代码说明，一切的前提是理解文章2.1和2.2部分，所以搞好基础再往后看呐。干货在嫌长的直接跳到结论去。 废话最近在看VC++，看到书里有提这两个概念，学C的时候也有这两个概念，学C++的时候也有顶层const和底层const（这个我懂是懂，但从理解层次上不是那么懂为什么叫做顶层和底层）。所以就是这个知识点很常见啦，但似乎很多人很迷惑，或者说理解着不舒服。于是我的“神逻辑”就来了。 我对它们的理解主要是翻译问题常量指针、指针常量这种名词是英文翻译过来的，所以中文会有点拗口。常量的、指针的，我们生活中是没有这样的词的。 英文里是这样的两个东西:pointer to const, const pointer。 pointer是指针的意思；const是constant的缩写，作名词是常量的意思，作形容词是不变的的意思。 这两个词：pointer to const, const pointer。中文有两种翻译方法： 翻译方法 pointer to const const pointer 第一种 指向常量的指针（常量指针） 不变的指针（指针常量） 第二种 指向常量的指针（指针常量） 不变的指针（常量指针） 说来说去都是翻译的问题。英文里很容易能看懂的意思，换成中文就有两种换法。 我赞成第一种翻译方法，因为它更符合中文习惯。 第二种方法确实不该有指针常量这个说法，太不合中文习惯。 所以要讨论中文版的话，如果出现指针常量，也应该是第一种方法。 下面是一篇讲常量指针和指针常量的文章： https://www.thegeekstuff.com/2012/06/c-constant-pointers换成英文就不用玩文字游戏了 所以呢，本质上应该用英语去讲。但本篇是讲中文版的一种方法。（去百度也会发现有两种说法，原因是翻译不同）。 基础本文用第一种说法，常指是pointer to const，指常是 const pointer。 常指、指常就是两个词而已，都是四个字。把前边的两个字当做形容词（是用来修饰后边的名词的），后边的名词才是重点。 指针就是地址嘛，常量就是不可以修改的量（初始化不算做赋值，不算做修改）。 注意区分指针本身（的内容）和指向的内存的内容。 修改指针即改变指针本身的内容，修改内存或者说修改内存内容就是修改指针指向的内存中的内容。这样讲的很清楚了吧…….. 常量指针常量指针中的常量呢，指的是这个指针的作用是常量性的、无权修改的，即不可以通过该指针修改内存中的内容，并不代表指向的内存不修改，注意前边有通过二字。 这个词也有指向常量的指针的叫法，我认为这个中文叫法是不准确的甚至是错误的。如果说常量指针是指向常量的指针，我认为这句话最直接的意思是说指针指向的内存是常量，这个意思是错误的，会误导他人，所以我不提倡这样叫它。证明参见文章3.3部分 在讨论问题的时候，互相知道对方说的是什么东西非常重要~，比如c++里的默认构造，没有构造函数这样的句子，不同人的理解方式不同，这些概念理解也是讨论进行的一个前提。 指针常量这里的指针呢，指的是这个常量是一个地址。 如何根据定义判断类型1234//代码1const char * p; //常量指针char const * p; //常量指针 跟上一句等效char * const p; //指针常量 根据const和*的相对位置const 在*左边=》常量指针；反之，指针常量。 根据谁离变量名近const近=》指针常量；反之，常量指针。（const就是不变嘛，就是指针，所以理解是很重要的，也就是*2.1） 代码验证常量指针123456789//代码2//char ch[] = "HelloWorld!";const char* pStr1=ch; //定义常量指针//1.常量指针本身的值可以修改pStr1 = nullptr; //correct//2.不能通过常量指针修改它所指向的内存中的内容（注意通过二字，不要误会常量指针）*pStr1 = 'h'; //error*(pStr1 + 1) = 'E'; //errorpStr1[2] = 'L'; //error 指针常量123456//代码3//char ch[] = "HelloWorld!";//指针常量（顶层const）char * const pStr2 = ch; //定义并初始化//1.是常量，不可以被赋值（不把初始化叫做赋值）pStr2 = nullptr; //error 常量指针容易被误解的地方1234567//代码4int n = 0; //定义变量nconst int * p1 = &amp;n; //常量指针p1int * const p2 = &amp;n; //指针常量p2*p1 = 3; //error 因为不能通过常量指针修改内存中的内容，划重点！：但这不是说指向内存中的内容不可修改n = 3; //correct 这是对的，因为n是变量啊*p2 = 3; //correct 指针常量部分的代码就有体现，不多说 123456//代码5const int n = 0; //定义变量nconst int * p1 = &amp;n; //常量指针p1int * const p2 = &amp;n; //error 错误的 原因见下-指针间的赋值*p1 = 3; //error 原因是常指不可修改内存n = 3; //error 原因是n是变量 代码4和代码5中的常量指针p1都不能改变内存中内容，但内存中内容是否可修改是不一定的。（代码4的第5第6行要好好看） 原因是：常量指针不可以修改内存是因为不可以通过常量指针修改内存所致（你不通过常量指针的话，变量是否可以修改就不一定了） 结论常量指针在这里指pointer to const。指针作用是常量性的，不可以通过它修改指向内存（容易被误会成内存一定不可修改）。 指针常量英文里指const pointer。指针是一个常量，指针本身不可以被修改。 作者：@臭咸鱼 本文为作者原创，转载请注明出处：https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/#more 欢迎转发和评论]]></content>
      <tags>
        <tag>C/C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAI丢包掉帧处理]]></title>
    <url>%2F2018%2F08%2F22%2FJAI%E4%B8%A2%E5%8C%85%E6%8E%89%E5%B8%A7%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[问题时间戳停止变化/图像停止更新 描述本小白刚刚接触JAI，有很多不懂的地方。这次遇到问题是请教了YZ大哥（不知道年龄，暂时这么称呼），很感谢YZ大哥的耐心指导。因为我不仅不知道怎么调，连在哪里调也不知道╭(╯^╰)╮。以下是此次问题解决步骤，是YZ大哥跟我说怎么做，然后我照做，过程中又遇到问题，下边也给出了碰到的问题以及相应的解决方法。（8.21更） 刚刚又看了下JAI SDK Getting Started Guide，发现YZ讲的方法就是文档里那部分我觉得可以先跳过的内容，出现问题应该也是因为我没有按照文档进行配置…..可能我写的这个会有错误、遗漏、表述模糊，具体操作还可参加文档说明（8.22更） 4.4=》设置接收缓冲区 4.5=》设置中断调整 4.6=》打开巨型帧 4.7=》计算和设置包延迟 出现问题原因图像传输时丢包（掉帧） 解决方法使用 JAI Control Tool 采集图像 防止丢包如何使用JAI Control Tool 采集图像 如何查看是否丢包？ 除了通过搜索，也可以找到GigE Image Acquisition-Total missing packets其实观察刚开始采集图像时图片是否有撕裂的情况（出现水平黑线） 如果丢包 设置相机据包为8000左右（我是8196）如何设置相机数据包 设置相机数据包后用JAI Control Tool采图时黑屏，查看黑屏是是否有帧率如何查看帧率 有帧率则调整网卡巨型帧等如何找到相机连接的网卡网络和共享中心-以太网（就是相机那条网线）-属性-由勾选EBUS设置为不勾选EBUS 同时可以看到连接时使用的网卡 找到网卡右击-属性-高级-巨型帧（由关闭设为9KB MTU）接收缓冲区设为最大（我的最大只有512，只能这样了） 提醒：文档中指出当巨型帧打开的时候，相机数据包大小就可以大于1500bytes，但相机数据包必须小于巨型帧大小。 提醒：文档中指出典型的接收缓冲区最大值为2048，标准默认值为256，请结合自己的实际情况 是不是我的网卡太菜了，众筹给我买个好的可以吗？？？ 如果仍丢包则根据文档设置延时直至成功如何设置延时？参照文档设置延时（主要是帧率）我的Max Fps是2.00 ，Band Width是90% 修改最大帧率，调整带宽，点击calculate，点击ok。（文档指出当数据包大小或者像素格式改变时，数据包延迟都需要重新计算） 最后查看是否丢包 如有丢包可以再次调整数据包大小和延迟。另外有一点是，图像的传输是和你整个电脑的运行都有关系的，而不只是网卡和相机设置。]]></content>
      <tags>
        <tag>JAI</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstWriting]]></title>
    <url>%2F2018%2F08%2F16%2FFirstWriting%2F</url>
    <content type="text"><![CDATA[在很久很久以前，你拥有我我拥有你 《外面的世界》在很久很久以前我就有搞一个类似博客的东西的想法，不过一直都没有尝试着搞……某天（10号左右吧）刷知乎看到github和hexo可以搭建博客，于是我就来了hhh不过搞的时候也遇到了好多bug，跳了好多坑…博客一是分享，二是记录，三四五还没想起来。 这是第一次写博客，学习内容是一点点markdown语法，文末有这次学习的链接，之后应该会再好好学学markdown语法。 字体设置斜体1：文字两侧各一个星号_斜体2：文字两侧各一个下划线_粗体：文字两侧各两个星号粗斜体：文字两侧各三个星号删除线：文字两侧各两个波浪号 那就有个疑问了，如果星号、波浪号、下划线出现在文字中怎么处理…或者说这种情况很少吧，并且对内容没什么影响 标题怎么用二级标题三级标题四级标题五级标题六级标题超链接行内形式：我的博客参考形式：我的博客,github 自动链接：我的博客地址https://chouxianyu.github.io/ 列表无序列表 无序列表项1 无序列表项2 无序列表项3 有序列表1.有序列表项12.有序列表项23.有序列表项3 插入图片 表格 表头1 表头2 表头3 表头4 默认左对齐 显式左对齐 居中对齐 右对齐 默认左对齐 显式左对齐 居中对齐 右对齐 默认左对齐 显式左对齐 居中对齐 右对齐 默认左对齐 显式左对齐 居中对齐 右对齐 转载自https://www.jianshu.com/p/56d99a3049a5]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
