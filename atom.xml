<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2019-08-03T14:53:50.141Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT乙级1006</title>
    <link href="https://chouxianyu.github.io/2019/08/03/PAT%E4%B9%99%E7%BA%A71006/"/>
    <id>https://chouxianyu.github.io/2019/08/03/PAT乙级1006/</id>
    <published>2019-08-03T14:52:32.000Z</published>
    <updated>2019-08-03T14:53:50.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805318855278592" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/994805318855278592</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题其实很简单，获取用户输入后，判断数字的位数，根据位数的不同，再获取百位、十位、个位的数字，然后据其进行字符串拼接，最后输出。</p><p>啧，太久没有写C++代码了，下面代码里的<code>numArr</code>可以用string类型的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PAT BasicLevel 1006</span></span><br><span class="line"><span class="comment">// https://pintia.cn/problem-sets/994805260223102976/problems/994805318855278592</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbitnum</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取用户输入的数字</span></span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数字位数</span></span><br><span class="line">    <span class="keyword">int</span> numOfBits=getbitnum(num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储输出内容</span></span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 十个数字，C++的字符串不能直接加数字进行拼接</span></span><br><span class="line">    <span class="keyword">char</span> numArr[<span class="number">9</span>] = &#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成输出内容所用的中间变量</span></span><br><span class="line">    <span class="keyword">switch</span> (numOfBits)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">        <span class="keyword">int</span> bai = num / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bai; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str += <span class="string">"B"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num %= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">        <span class="keyword">int</span> shi = num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shi; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str += <span class="string">"S"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            str +=numArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数字的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getbitnum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 默认一位数</span></span><br><span class="line">    <span class="keyword">int</span> numOfBits=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">99</span>)&#123; <span class="comment">// 三位数</span></span><br><span class="line">        numOfBits=<span class="number">3</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;<span class="number">9</span>)&#123;    <span class="comment">//两位数</span></span><br><span class="line">        numOfBits=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfBits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/pro
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级1004</title>
    <link href="https://chouxianyu.github.io/2019/07/22/PAT%E4%B9%99%E7%BA%A71004/"/>
    <id>https://chouxianyu.github.io/2019/07/22/PAT乙级1004/</id>
    <published>2019-07-22T10:22:39.000Z</published>
    <updated>2019-07-22T10:22:54.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805321640296448" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/994805321640296448</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ol><li>获取用户输入</li><li>排序</li><li>输出</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PAT BasicLevel T1004</span></span><br><span class="line"><span class="comment">// https://pintia.cn/problem-sets/994805260223102976/problems/994805321640296448</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment">// 学号</span></span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="comment">// 分数</span></span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个学生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student &amp;s1, Student &amp;s2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 学生个数</span></span><br><span class="line">    <span class="keyword">int</span> numOfStu = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; numOfStu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 学生数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Student&gt; students;</span><br><span class="line">    students.resize(numOfStu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取学生信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfStu; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; students[i].name;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; students[i].id;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; students[i].score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把学生排序</span></span><br><span class="line">    sort(students.begin(), students.end(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出成绩最好和成绩最差的学生的名字和学号</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; students.back().name &lt;&lt; <span class="string">" "</span> &lt;&lt; students.back().id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; students.front().name &lt;&lt; <span class="string">" "</span> &lt;&lt; students.front().id &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较两个学生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Student &amp;s1, Student &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.score &lt; s2.score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/pro
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mingw控制台中文乱码</title>
    <link href="https://chouxianyu.github.io/2019/07/22/mingw%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>https://chouxianyu.github.io/2019/07/22/mingw控制台中文乱码/</id>
    <published>2019-07-22T06:15:16.000Z</published>
    <updated>2019-07-22T06:34:50.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="乱码原因"><a href="#乱码原因" class="headerlink" title="乱码原因"></a>乱码原因</h1><p>直接先用一段话讲乱码原因，看不懂老老实实就往下看吧</p><p>其实我用Sublime或者VSCode等编辑器写代码出现的控制台中文乱码问题是<strong>编译器mingw输出的数据使用的是UTF-8编码，而控制台用了GBK编码来解析它</strong>。</p><p><strong>其实编码只要统一用UTF8或者GBK都行，但用了错误的编码去解析文件就会出错。</strong></p><h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p>如果我们写轻量代码（比如写算法题）也用VS之类的IDE，就太不划算了；虽然也有Codeblocks、Dev C++这样的小一点的IDE，但用起来还是可以发现让人很不爽的缺点。</p><p>之前尝试用VS Code写C++代码，挺不错的，好看方便。但问题就是难配置，最大的问题是<strong>控制台中文乱码</strong>，我搞了好久都没搞好，今天终于解决了。</p><p>在网上找到一段话是这么讲的：</p><blockquote><p>Windows(中文)默认的字符集是Windows-936(GBK)，mingw的内部是GCC，而GCC编译器默认编译的时候是按照UTF-8解析和输出的，当未指定字符集时一律当作UTF-8进行处理，于是造成乱码。</p></blockquote><p>根据上边这段话，我有点灵感，但还是有疑问，见下。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>我电脑的CMD编码设置的是UTF-8，代码文件的编码也是UTF-8，如果mingw默认按UTF-8处理的话，可以看到这里用的编码全都是UTF-8，那应该不会出现乱码的。</p><p>但我们确实看到了乱码啊！？</p><p>当我去看我的注册表（见下图），发现代码链接、编译后生成的可执行文件有一个单独的注册表，这似乎说明我们运行的可执行文件并不是我们口中的那个CMD（按<code>Win+R、cmd</code>打开的那个CMD）。所以<a href="https://www.cnblogs.com/roadwide/p/10533594.html" target="_blank" rel="noopener">@roadwide</a>整理的网上的改CMD编码啊什么的，可能搞错了问题的方向，不过也算一个方法吧，但似乎对我不适用。我之前也是搞错了方向。<br><a href="https://i.loli.net/2019/07/22/5d35565386a8018626.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/22/5d35565386a8018626.png" alt="Console注册表.png"></a></p><p>如下图所示，我们运行的可执行文件，<strong>也就是那个弹出来的控制台，它的编码是GBK</strong>。现在我们应该知道乱码的原因了。</p><p><a href="https://i.loli.net/2019/07/22/5d35565353d3465690.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/07/22/5d35565353d3465690.png" alt="可执行文件编码.png"></a></p><p>整个过程是这样的：</p><ol><li>我们代码的编码是UTF-8</li><li>把UTF-8编码的代码交给mingw，它也默认当做UTF-8处理（目前为止这是正确的）</li><li>mingw处理后生成的数据还是UTF-8编码（目前为止还是正确的）</li><li>把mingw处理后的数据（UTF-8编码）给cmd（目前为止也是正确的）</li><li>cmd按GBK编码处理它（UTF-8），这时出现错误，所以<strong>出现乱码</strong></li></ol><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><strong>我们可以修改mingw的输出，让它在编译时使用GBK编码输出，然后再让CMD去显示。</strong></p><hr><p><strong>处理中文乱码只需要设置两个（核心只有一个）编译参数</strong>，即在<code>tasks.json</code>中<code>tasks</code>中的<code>args</code>中添加<code>-fexec-charset=GBK</code>和<code>-finput-charset=UTF-8</code>，下边<code>tasks.json</code>中的第14、15行。</p><hr><p>这个解决方案中代码文件的编码是UTF-8，控制台编码是GBK，令mingw实现编码转换。</p><p>下面的<code>.vscode</code>配置是我在网上找到的比较新的VS Code配置，可以作为参考，具体不做解释，想了解可以去看文章末的参考网址。</p><h2 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 用来编译</span><br><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    "version": "2.0.0",</span><br><span class="line">    "tasks": [&#123;</span><br><span class="line">        "label": "Build",   // 任务的名字叫Build（编译），注意是大小写区分的，等会在launch中调用这个名字</span><br><span class="line">        "type": "shell",    // 任务执行的是shell命令</span><br><span class="line">        "command": "g++",   // 命令是g++</span><br><span class="line">        "args": [           //参数</span><br><span class="line">            "-g",           // 调试</span><br><span class="line">            </span><br><span class="line">            //</span><br><span class="line">            "-fexec-charset=GBK",   // 处理mingw中文编码问题</span><br><span class="line">            "-finput-charset=UTF-8",// 处理mingw中文编码问题</span><br><span class="line">            //</span><br><span class="line">            </span><br><span class="line">            "$&#123;file&#125;", //当前文件路径，包括所在目录绝对路径和文件名</span><br><span class="line">            "-o",      //对象名，不进行编译优化</span><br><span class="line">            "$&#123;fileDirname&#125;/exes/$&#123;fileBasenameNoExtension&#125;.exe", //当前目录下exes文件夹下的exe文件，exe文件名为 当前文件名（去掉扩展名）.exe</span><br><span class="line">        ],</span><br><span class="line">        // 所以以上部分，就是在shell中执行下面这行语句（以我E盘中一个main.cpp为例）</span><br><span class="line">        // g++ -g  -fexec-charset=GBK -finput-charset=UTF-8 e:\Study\Programming\Code\Algo\PTABasicLevelCPP\main.cpp -o e:\Study\Programming\Code\Algo\PTABasicLevelCPP/exes/main.exe</span><br><span class="line">        "group": &#123;</span><br><span class="line">            "kind": "build",</span><br><span class="line">            "isDefault": true</span><br><span class="line">            // 任务分组，tasks是个数组，意味着可以执行多个task</span><br><span class="line">            // 在build组的任务们，可以通过在Command Palette(F1) 输入run build task来运行</span><br><span class="line">            // 当然，如果任务分组是test，你就可以用run test task来运行 </span><br><span class="line">        &#125;,</span><br><span class="line">        "problemMatcher": [</span><br><span class="line">            "$gcc" // 使用gcc捕获错误</span><br><span class="line">        ],</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-fexec-charset=GBK</code>是令mingw按GBK编码生成exe文件。</p><p><code>-finput-charset=UTF-8</code>是令mingw按UTF-8编码处理。（经测试这个参数可以不设置）</p><h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">        "name": "C++ Launch (GDB)", // 调试时程序员看到的名字</span><br><span class="line">        "preLaunchTask": "Build",   // launch之前会运行的任务，这个名字一定要跟tasks.json中的任务名一致</span><br><span class="line">        "type": "cppdbg",           // 经测试，不可删除</span><br><span class="line">        "request": "launch",        // 经测试，不可删除</span><br><span class="line">        "program": "$&#123;fileDirname&#125;/exes/$&#123;fileBasenameNoExtension&#125;.exe", //运行当前打开文件的目录下exes文件夹中名字和当前文件相同，但扩展名为exe的程序</span><br><span class="line">        "args": [],                 // 运行程序是默认是没有参数的</span><br><span class="line">        "stopAtEntry": false,       // 选为true则会在打开控制台后停滞，暂时不执行程序</span><br><span class="line">        "cwd": "$&#123;workspaceFolder&#125;",// 当前工作路径：当前文件所在的工作空间</span><br><span class="line">        "environment": [],</span><br><span class="line">        "externalConsole": true,    // 是否使用外部控制台，</span><br><span class="line">        "MIMode": "gdb",</span><br><span class="line">        "miDebuggerPath": "D:\\WorkingSoftware\\MinGW\\bin\\gdb.exe",   //调试器路径</span><br><span class="line">        "setupCommands": [&#123;</span><br><span class="line">            "description": "Enable pretty-printing for gdb",</span><br><span class="line">            "text": "-enable-pretty-printing",</span><br><span class="line">            "ignoreFailures": true</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">// https://code.visualstudio.com/Docs/editor/debugging#_launch-configurations</span><br><span class="line">// author: huihut</span><br><span class="line">// Available variables which can be used inside of strings.</span><br><span class="line">// $&#123;workspaceRoot&#125;: the root folder of the team        </span><br><span class="line">// $&#123;file&#125;: the current opened file                     </span><br><span class="line">// $&#123;fileBasename&#125;: the current opened file's basename </span><br><span class="line">// $&#123;fileDirname&#125;: the current opened file's dirname    </span><br><span class="line">// $&#123;fileExtname&#125;: the current opened file's extension  </span><br><span class="line">// $&#123;cwd&#125;: the current working directory of the spawned process</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/Krone_/article/details/81537239" target="_blank" rel="noopener">中文乱码参考1</a></p><p><a href="https://blog.csdn.net/Timekeeperl/article/details/68266218" target="_blank" rel="noopener">中文乱码参考2</a></p><p><a href="https://www.jianshu.com/p/776a5fb57fbb" target="_blank" rel="noopener">VS Code配置参考</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;乱码原因&quot;&gt;&lt;a href=&quot;#乱码原因&quot; class=&quot;headerlink&quot; title=&quot;乱码原因&quot;&gt;&lt;/a&gt;乱码原因&lt;/h1&gt;&lt;p&gt;直接先用一段话讲乱码原因，看不懂老老实实就往下看吧&lt;/p&gt;
&lt;p&gt;其实我用Sublime或者VSCode等编辑器写代码出现的
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://chouxianyu.github.io/tags/Bug/"/>
    
      <category term="mingw" scheme="https://chouxianyu.github.io/tags/mingw/"/>
    
      <category term="VSCode" scheme="https://chouxianyu.github.io/tags/VSCode/"/>
    
      <category term="中文乱码" scheme="https://chouxianyu.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级1003</title>
    <link href="https://chouxianyu.github.io/2019/07/22/PAT%E4%B9%99%E7%BA%A71003/"/>
    <id>https://chouxianyu.github.io/2019/07/22/PAT乙级1003/</id>
    <published>2019-07-22T01:40:08.000Z</published>
    <updated>2019-08-03T14:48:28.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805323154440192" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/994805323154440192</a></p><h1 id="题解1"><a href="#题解1" class="headerlink" title="题解1"></a>题解1</h1><p>这个是我自己的方法，..…刚开始做题，还啥都不会啊。</p><p>只能过4个Case，Case5过不了，得19分，还不知道哪里错了（让强迫症很难受啊）。</p><p>第1个条件很简单，判断无非法字符即可。</p><p>第2个条件，是<code>xPATx</code>，易得：当字符串中有<code>PAT</code>时，<code>PAT</code>左右两边字符串应相等。</p><p>第3个条件，它依赖于前两个条件，特别是第2个，所以可以采取递归的形式。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PTABasicLevel 1003</span></span><br><span class="line"><span class="comment"> * https://pintia.cn/problem-sets/994805260223102976/problems/994805323154440192</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开scanner</span></span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户输入的字符串</span></span><br><span class="line">        String str=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取测试组数</span></span><br><span class="line">        <span class="keyword">int</span> T=scanner.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// T组测试</span></span><br><span class="line">        <span class="keyword">while</span>( T-- &gt; <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取用户输入的字符串</span></span><br><span class="line">            str=scanner.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            System.out.println(isValid(str)?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户输入的字符串</span></span><br><span class="line">        str=scanner.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.print(isValid(str)?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭scanner</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个字符串是否有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 一个字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> strLength=str.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串中P和T首次出现的位置</span></span><br><span class="line">        <span class="keyword">int</span> indexOfP=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexOfT=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串中P和T的数量</span></span><br><span class="line">        <span class="keyword">int</span> numOfP=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numOfT=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串应仅由P、A、T组成，且P和T各有一个，判断过程中记录P和T的位置和个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strLength;i++)&#123;</span><br><span class="line">            <span class="comment">// 存在PAT以外的字母，字符串就是错误的</span></span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">'P'</span>)&#123;</span><br><span class="line">                indexOfP=i;</span><br><span class="line">                numOfP++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i)==<span class="string">'T'</span>)&#123;</span><br><span class="line">                indexOfT=i;</span><br><span class="line">                numOfT++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i)!=<span class="string">'A'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// P或T不是1个，或者是P和T的位置有问题（应该是PxT，x是正整数个A拼成的字符串）</span></span><br><span class="line">        <span class="keyword">if</span>(numOfP!=<span class="number">1</span>||numOfT!=<span class="number">1</span>||indexOfT-indexOfP&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这一行已可以确定字符串只由1个P和一个T和一些A组成，且P和T位置正确</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 条件2</span></span><br><span class="line">        <span class="comment">// P和T中间只有1个A</span></span><br><span class="line">        <span class="keyword">if</span>(indexOfT-indexOfP==<span class="number">2</span>)&#123;</span><br><span class="line">            String x=str.substring(<span class="number">0</span>,indexOfP);</span><br><span class="line">            <span class="comment">// PAT左右是相等的x</span></span><br><span class="line">            <span class="keyword">if</span>(indexOfT+<span class="number">1</span>==str.lastIndexOf(x))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// PAT左右不相等</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 条件3</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            String a=str.substring(<span class="number">0</span>,indexOfP);</span><br><span class="line">            <span class="keyword">int</span> indexOfRightA=str.lastIndexOf(a);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剥掉Pb和T中间的A，以及Tc后的a</span></span><br><span class="line">            String newStr=str.substring(<span class="number">0</span>,indexOfT-<span class="number">1</span>)+str.substring(indexOfT,indexOfRightA);</span><br><span class="line">            <span class="keyword">return</span> isValid(newStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解2"><a href="#题解2" class="headerlink" title="题解2"></a>题解2</h1><p>在网上找到的，其实和我的一样，都是找规律嘛，不过找到的规律不同。</p><p><code>aPbTc</code>中<code>a</code>和<code>b</code>只能是若干个<code>A</code>或空字符串，且应满足<code>length(a)*length(b)==length(c)&amp;&amp;length(b)&gt;1</code>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PTABasicLevel 1003</span></span><br><span class="line"><span class="comment"> * https://pintia.cn/problem-sets/994805260223102976/problems/994805323154440192</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1003</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开scanner</span></span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用户输入的字符串</span></span><br><span class="line">        String str=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取测试组数</span></span><br><span class="line">        <span class="keyword">int</span> T=scanner.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// T组测试</span></span><br><span class="line">        <span class="keyword">while</span>( T-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取用户输入的字符串</span></span><br><span class="line">            str=scanner.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            System.out.println(isValid(str)?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭scanner</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断一个字符串是否有效</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 一个字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串长度</span></span><br><span class="line">        <span class="keyword">int</span> strLength=str.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串中P和T首次出现的位置</span></span><br><span class="line">        <span class="keyword">int</span> indexOfP=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexOfT=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串中P和T的数量</span></span><br><span class="line">        <span class="keyword">int</span> numOfP=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numOfT=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字符串应仅由P、A、T组成，且P和T各有一个，判断过程中记录P和T的位置和个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strLength;i++)&#123;</span><br><span class="line">            <span class="comment">// 存在PAT以外的字母，字符串就是错误的</span></span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">'P'</span>)&#123;</span><br><span class="line">                indexOfP=i;</span><br><span class="line">                numOfP++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i)==<span class="string">'T'</span>)&#123;</span><br><span class="line">                indexOfT=i;</span><br><span class="line">                numOfT++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i)!=<span class="string">'A'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这一行，已知字符串仅由P、A、T组成</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numOfP==<span class="number">1</span>&amp;&amp;numOfT==<span class="number">1</span>&amp;&amp;indexOfT-indexOfP&gt;<span class="number">1</span>&amp;&amp;indexOfP*(indexOfT-indexOfP-<span class="number">1</span>)==strLength-indexOfT-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/pro
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级1002</title>
    <link href="https://chouxianyu.github.io/2019/07/22/PAT%E4%B9%99%E7%BA%A71002/"/>
    <id>https://chouxianyu.github.io/2019/07/22/PAT乙级1002/</id>
    <published>2019-07-22T01:40:01.000Z</published>
    <updated>2019-07-22T01:44:42.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805324509200384" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/994805324509200384</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先以字符串形式读取用户输入的数字，然后计算各位之和，再把这个和的每一位以拼音形式输出。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PTABasicLevel 1002</span></span><br><span class="line"><span class="comment"> * https://pintia.cn/problem-sets/994805260223102976/problems/994805324509200384</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T1002</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存自然数</span></span><br><span class="line">        String numStr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用字符串保存用户输入的数字</span></span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        numStr=scanner.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算每位之和并输出对应汉语</span></span><br><span class="line">        printSum(calcSum(numStr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭scanner</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算字符串形式的数字的各位之和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 用户输入的数字的字符串形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int类型，用户输入的数字各位之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcSum</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存各位数字之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算各位数字之和</span></span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            sum += str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回各位数字之和</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出一个数字对应的汉语</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum 用户输入的各位数字之和</span></span><br><span class="line"><span class="comment">     * 输出这个和对应的汉语</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSum</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拼音</span></span><br><span class="line">        String[] chineseArr = &#123;<span class="string">"ling"</span>, <span class="string">"yi"</span>, <span class="string">"er"</span>, <span class="string">"san"</span>, <span class="string">"si"</span>, <span class="string">"wu"</span>, <span class="string">"liu"</span>, <span class="string">"qi"</span>, <span class="string">"ba"</span>, <span class="string">"jiu"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int类型的sum转成字符串</span></span><br><span class="line">        String sumStr=Integer.toString(sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        System.out.print(chineseArr[sumStr.charAt(<span class="number">0</span>)-<span class="string">'0'</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length=sumStr.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            System.out.print(<span class="string">" "</span>+chineseArr[sumStr.charAt(i)-<span class="string">'0'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/pro
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级1001</title>
    <link href="https://chouxianyu.github.io/2019/07/22/PAT%E4%B9%99%E7%BA%A71001/"/>
    <id>https://chouxianyu.github.io/2019/07/22/PAT乙级1001/</id>
    <published>2019-07-22T01:39:56.000Z</published>
    <updated>2019-07-22T01:42:25.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>emm就很简单了，考简单的循环和分支。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PTABasicLevel 1001</span></span><br><span class="line"><span class="comment">//https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//存储正整数n</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储步数</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取输入</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算步数</span></span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//n是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            n=(<span class="number">3</span>*n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//n是偶数</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            n=n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步数加一</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出步数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"你好"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805260223102976/pro
      
    
    </summary>
    
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我的大学（上）</title>
    <link href="https://chouxianyu.github.io/2019/07/21/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2019/07/21/我的大学（上）/</id>
    <published>2019-07-21T02:32:42.000Z</published>
    <updated>2019-07-24T05:57:44.243Z</updated>
    
    <content type="html"><![CDATA[<p>现在已是大二暑假，大学的前两年也快要结束了，在这里稍作总结。</p><h1 id="大一上"><a href="#大一上" class="headerlink" title="大一上"></a>大一上</h1><h2 id="事情"><a href="#事情" class="headerlink" title="事情"></a>事情</h2><p>印象里是这样的：</p><p>工作上，从开学开始，做班长前3个月特别忙，之后好像就没什么事情了吧，已经忘了具体情况，但我还记得个团展。刚去学校的前3天，白天跑路多，水喝得少，上火还是怎么着，一天晚上走着走着就流了鼻血。</p><p>学习上，感觉心理还是挺不错的，完全无欲无求，觉得正常地学习就行了，该干嘛干嘛，没想到结果还不错。有种想夸夸自己的感觉，你还不赖嘛你。虽然现在看看也就一般吧。</p><p>刚来大学啥都不懂，也没什么坚定的目标，想学就学，想玩就玩，闲了还打打游戏、打打球、练个字、还早起读了几天英语单词，这样的生活其实挺开心的。</p><p>大一的日记和我的印象也大概是一致的。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>当时大一嘛，带着那种对大学的美好憧憬，心理状态还是很年轻的。</p><p>现在看我当时的一些想法和写的日记，就觉得自己完全是个小孩儿，喜怒哀乐都挺小孩儿的。</p><p>在工作上，自己经常觉得很奇怪，自己怎么和大多人不一样呢？或者说大多人怎么是这样的呢？不过后来在慢慢接受人与人之间的不同了，会觉得每个人都是独立的，成长经历等等会有多么的不同，所以没必要强求。</p><h1 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h1><p>好像就每天学点PPT、学点摄影、学点C++，现在PPT和摄影全忘光光了哈哈。</p><h1 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h1><h2 id="事情-1"><a href="#事情-1" class="headerlink" title="事情"></a>事情</h2><p>印象里，这个学期挺闲的，也是没什么目标，然后就快快乐乐地学习和锻炼。虽也做了点错事，但感觉还好，错就错嘛，影响不大。</p><p>学习上，挺快乐的。还能预习预习，感觉真有意思，最后成绩也还不错。也从老师那里接触了项目，课外会忙一些这个项目。</p><p>学生工作上，没啥事儿吧，都忘了，反正不算忙。</p><p>挺好的是，当时闲，希望自己大学能坚持点东西，然后就想着跑步。它不仅对身体好，还减肥。本来想的是按时间跑，跑个四五十分钟。可能当时身体好吧，跑着跑着就变成十公里竞速了。</p><h2 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h2><p>现在回头看的话，我觉得这个学期是我自我内心塑造比较重要的一个阶段，但不知道是怎么塑造起来的。</p><p>因为我感觉不是在大二上学期塑造的，那个学期一直忙得要死；更不可能是大一上，那时候只是有内心的碰撞和后来的尝试适应，但还并没有形成最终的答案；也不是现在的大二下学期，因为觉得现在是另外一个心理状态了。</p><h1 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h1><p>主基调也是学习，另外还烫了个头。</p><p>印象里是15天java，15天python，这是大二上的课程，预习一下。</p><p>后来班助在班群里说李老师找人做VC，我想着学东西总有好处，就又学了12天左右的MFC，然后回了杭州，开始做项目。</p><h1 id="大二上"><a href="#大二上" class="headerlink" title="大二上"></a>大二上</h1><h2 id="事情-2"><a href="#事情-2" class="headerlink" title="事情"></a>事情</h2><p>因为大一下“作死”提了两门课，导致这学期有37还是38学分的课，想想大一两个学期都是20+学分的课。</p><p>因为当时想好好学习，就不做班长了，这样自己大二上学期就没什么事情。课程虽多，但还有课下的时间，感觉还是没问题的。</p><p>然而，没料到学院突然通知有个导师制！学生必须参加，莫得办法，只能和李老师商量，他的项目先推掉。后来选了沈老师的导师制项目，感觉这个项目的各种比赛穿插了整个学期吧，忙得要炸。好像也是第一次旷课吧，旷了一节物理课，emmmm……</p><p>最后期末搞得一点复习时间都没有，真是死扛着天天只睡四五个小时，把期末给扛过去了。就这样的情况下，那天考完模电，中午没吃饭就看线代，只记得几个小公式就去考线代了。这学期成绩血亏！可能不只是复习时间短的原因吧，平常也没什么精力好好学，最后复习也不知道怎么安排时间。</p><p>因为这个学期我开始对绩点有要求了，不像大一那样佛了。所以没办法，熬也就是这几天，不熬的话这考试可真就炸了。这种情况其实就是自己有了点目标，但又有其它事情和外力让你无法全力甚至无力去做……</p><h2 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h2><p>大一上的那种矛盾感觉又来了，这学期太忙，很炸，心里两种想法就又开始搏斗了。</p><h1 id="寒假-1"><a href="#寒假-1" class="headerlink" title="寒假"></a>寒假</h1><p>留校做沈老师的项目了，学了点React基础，回家后就是做项目，简单地预习一下课程。</p><h1 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h1><h2 id="事情-3"><a href="#事情-3" class="headerlink" title="事情"></a>事情</h2><p>整体来讲，这个学期大概共4个月、4件事，每月1件。</p><ul><li><p>3月</p><p>  主要是在做沈老师项目</p></li><li><p>4月</p><p>  主要是建模校赛</p></li><li><p>5月</p><p>  主要是准备互联网+比赛</p></li><li><p>6月</p><p>  主要是复习，其实还搞了几天互联网+</p></li></ul><p>从头至尾还贯穿着课程知识的学习，其他事情还有建模学习、C++小课、党校培训和党日活动、五四合唱、发展性项目、认知实习等等等等的事情，回头一看感觉真的好多事，怪不得当时整天睡不饱、烦躁。</p><h2 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h2><p>描述不出来。</p><p>拜拜，祝你天天开心！</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在已是大二暑假，大学的前两年也快要结束了，在这里稍作总结。&lt;/p&gt;
&lt;h1 id=&quot;大一上&quot;&gt;&lt;a href=&quot;#大一上&quot; class=&quot;headerlink&quot; title=&quot;大一上&quot;&gt;&lt;/a&gt;大一上&lt;/h1&gt;&lt;h2 id=&quot;事情&quot;&gt;&lt;a href=&quot;#事情&quot; class
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://chouxianyu.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>算法时间复杂度</title>
    <link href="https://chouxianyu.github.io/2019/07/19/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://chouxianyu.github.io/2019/07/19/算法时间复杂度/</id>
    <published>2019-07-19T14:05:37.000Z</published>
    <updated>2019-07-21T10:42:21.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数的渐近的界"><a href="#函数的渐近的界" class="headerlink" title="函数的渐近的界"></a>函数的渐近的界</h1><h2 id="O"><a href="#O" class="headerlink" title="$O$"></a>$O$</h2><p>定义如下：</p><p>设$f$和$g$是定义域为自然数集$N$上的函数，若<strong>存在</strong>正数$c$和$n_0$，使得对<strong>一切</strong>$n\geq n_0$有</p><script type="math/tex; mode=display">0 \leq f(n)\leq c\,g(n)</script><p>成立，则称$f(n)$的<strong>渐进上界</strong>是$g(n)$，记作</p><script type="math/tex; mode=display">f(n)=O(g(n))</script><ul><li>$f(n)$的阶不高于$g(n)$的阶</li><li>可能存在多个正数$c$，只要指出一个即可</li><li>对前面有限个$n$值可以不满足不等式</li><li>常函数的渐进上界可以写作$O(1)$</li></ul><h2 id="Omega"><a href="#Omega" class="headerlink" title="$\Omega$"></a>$\Omega$</h2><p>定义如下：</p><p>设$f$和$g$是定义域为自然数集$N$上的函数，若<strong>存在</strong>正数$c$和$n_0$，使得对<strong>一切</strong>$n\geq n_0$有</p><script type="math/tex; mode=display">0 \leq c\,g(n)\leq f(n)</script><p>成立，则称$f(n)$的<strong>渐进下界</strong>是$g(n)$，记作</p><script type="math/tex; mode=display">f(n)=\Omega (g(n))</script><ul><li>$f(n)$的阶不低于$g(n)$的阶</li><li>可能存在多个正数$c$，只要指出一个即可</li><li>对前面有限个$n$值可以不满足不等式</li></ul><h2 id="o"><a href="#o" class="headerlink" title="$o$"></a>$o$</h2><p>定义如下：</p><p>设$f$和$g$是定义域为自然数集$N$上的函数，若对于<strong>任意</strong>正数$c$都存在$n_0$，使得对<strong>一切</strong>$n\geq n_0$有</p><script type="math/tex; mode=display">0 \leq f(n)< c\,g(n)</script><p>成立，则记作</p><script type="math/tex; mode=display">f(n)=o(g(n))</script><ul><li>$f(n)$的阶低于$g(n)$的阶</li><li>对不同正数$c$，$c$越小$n_0$越大</li><li>对前面有限个$n$值可以不满足不等式</li></ul><h2 id="omega"><a href="#omega" class="headerlink" title="$\omega$"></a>$\omega$</h2><p>定义如下：</p><p>设$f$和$g$是定义域为自然数集$N$上的函数，若对于<strong>任意</strong>正数$c$都存在$n_0$，使得对<strong>一切</strong>$n\geq n_0$有</p><script type="math/tex; mode=display">0\leq c\,g(n)<f(n)</script><p>成立，则记作</p><script type="math/tex; mode=display">f(n)=\omega(g(n))</script><ul><li>$f(n)$的阶高于$g(n)$的阶</li><li>对不同正数$c$，$c$越小​$n_0$越小</li><li>对前面有限个$n$值可以不满足不等式</li></ul><h2 id="theta"><a href="#theta" class="headerlink" title="$\theta$"></a>$\theta$</h2><p>定义如下：</p><p>若$f(n)=O(g(n))=\Omega(g(n))$，则记作</p><script type="math/tex; mode=display">f(n)=\theta(g(n))</script><ul><li>$f(n)$与$g(n)$的阶相等</li><li>对前面有限个$n$值可以不满足条件</li></ul><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><h2 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h2><p>设$f$和$g$是定义域为自然数集合的函数</p><ul><li>如果$lim_{n\rightarrow\infty}\frac{f(n)}{g(n)}$存在，且等于某个常数$c&gt;0$，那么$f(n)=\theta(g(n))$</li><li>如果$lim_{n\rightarrow\infty}\frac{f(n)}{g(n)}=0$，那么$f(n)=o(g(n))$</li><li>如果$lim_{n\rightarrow\infty}\frac{f(n)}{g(n)}=+\infty$，那么$f(n)=\omega(g(n))$</li></ul><p>一些重要结果：</p><ul><li><p><strong>多项式函数的阶低于指数函数的阶</strong></p><p>  $n^d=o(r^n)，r&gt;1，d&gt;0$</p></li><li><p><strong>对数函数的阶低于幂函数的阶</strong></p><p>  $ln\ n=o(n^d)，d&gt;0$</p></li></ul><h2 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h2><p><strong>函数的阶之间的关系具有传递性</strong>，具体如下：</p><p>设函数$f、g、h$的定义域为自然数集合</p><ul><li>如果$f=O(g)$且$g=O(h)$，那么$f=O(h)$</li><li>如果$f=\Omega(g)$且$g=\Omega(h)$，那么$f=\Omega(h)$</li><li>如果$f=\theta(g)$且$g=\theta(h)$，那么$f=\theta(h)$</li></ul><h2 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h2><p>设函数$f、g、h$的定义域为自然数集合，若对某个其它函数$h$，有$f=O(h)$和$g=O(h)$，那么$f+g=O(h)$。</p><p>该性质可以推广到有限个函数。</p><p>因为算法有有限步骤组成，根据每一步的时间复杂度函数上界，可以确定整个算法的时间复杂度函数上界。</p><h1 id="几类重要函数"><a href="#几类重要函数" class="headerlink" title="几类重要函数"></a>几类重要函数</h1><h2 id="基本函数的分类"><a href="#基本函数的分类" class="headerlink" title="基本函数的分类"></a>基本函数的分类</h2><p>按照阶的高低分</p><ul><li><p>至少指数级别</p><p>  $2^n、3^n、n!$</p></li><li><p>多项式级</p><p>  $n、n^2、n\,log\,n、\sqrt n$</p></li><li><p>对数多项式级</p><p>  $log\,n、log^2n、log\,log\,n$</p></li></ul><h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h2><p>一些符号如下：</p><ul><li>$log\,n=log_2n$</li><li>$log^kn=(log\,n)^k$</li><li>$log\,log\,n=log(log\,n)$</li></ul><p>性质：</p><ul><li>$log_2n=\theta(log_ln)$</li><li>$log_bn=o(n^\alpha)，\alpha&gt;0$</li><li>$a^{log_bn}=n^{log_ba}$</li></ul><h2 id="指数函数与阶乘"><a href="#指数函数与阶乘" class="headerlink" title="指数函数与阶乘"></a>指数函数与阶乘</h2><ul><li><p>斯特林（Stirling）公式：</p><p>  $n!=\sqrt{2\pi n}\ (\frac{n}{e})^n(1+\theta(\frac{1}{n}))$</p></li><li><p>$n!=o(n^n)$</p></li><li><p>$n!=\omega(2^n)$</p></li><li><p>$log(n!)=\theta(n\ log\ n)$</p></li></ul><h2 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h2><ul><li>$x-1&lt;\lfloor x\rfloor\leq x\leq\lceil x\rceil&lt;x+1$</li><li>$\lfloor x+n\rfloor=\lfloor x\rfloor+n，\lceil x+n\rceil=\lceil x\rceil+n，n为整数$</li><li>$\lceil\frac{n}{2}\rceil+\lfloor\frac{n}{2}\rfloor=n$</li><li>$\lceil\frac{\lceil\frac{n}{a}\rceil}{b}\rceil=\lceil\frac{n}{ab}\rceil，\lfloor\frac{\lfloor\frac{n}{a}\rfloor}{b}\rfloor=\lfloor\frac{n}{ab}\rfloor$</li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数的渐近的界&quot;&gt;&lt;a href=&quot;#函数的渐近的界&quot; class=&quot;headerlink&quot; title=&quot;函数的渐近的界&quot;&gt;&lt;/a&gt;函数的渐近的界&lt;/h1&gt;&lt;h2 id=&quot;O&quot;&gt;&lt;a href=&quot;#O&quot; class=&quot;headerlink&quot; title=&quot;$O$
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析基础</title>
    <link href="https://chouxianyu.github.io/2019/07/17/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <id>https://chouxianyu.github.io/2019/07/17/算法设计与分析基础/</id>
    <published>2019-07-17T14:11:55.000Z</published>
    <updated>2019-07-21T10:42:51.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h1><ol><li><p>问题建模</p><p> 对输入参数和解给出形式化或半形式化的描述</p></li><li><p>设计算法</p><p> 选择什么算法？如何描述这个方法？</p><p> 这个方法是否对所有实例都得到最优解？如何证明？</p><p> 如果不是，能否找到反例？</p></li><li><p>分析算法</p><p> 分析算法的效率</p></li></ol><h1 id="NP难问题"><a href="#NP难问题" class="headerlink" title="NP难问题"></a>NP难问题</h1><ul><li>NP-hard问题有数千个，大量存在于各个应用领域。NP-hard问题举例：TSP问题、0-1背包、双机调度</li><li>目前还没有找到有效算法，有效算法指的是运行时间是输入规模$n$的指数或更高阶函数，即输入规模$n$的多项式时间。</li><li>至今没有人能证明这类问题不存在多项式时间的算法。</li><li>从是否存在多项式时间算法的角度来看，这些问题是彼此等价的（如果其中一个问题存在多项式时间的算法，则其它问题也都存在；如果其中一个不存在，则其它问题也不存在多项式时间算法）。这些问题的难度处于可有效计算的边界。</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>需要回答的一般性提问，通常含若干参数</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>定义问题参数（可以是集合、变量、函数、序列等等）</li><li>说明每个参数的取值范围和参数间的关系</li><li>定义问题的解</li><li>说明解满足的条件（优化目标或约束条件）</li></ul><h2 id="问题实例"><a href="#问题实例" class="headerlink" title="问题实例"></a>问题实例</h2><p>参数的一组赋值可得到问题的一个实例</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>有限条指令的序列，这个指令序列确定了解决某个问题的一系列运算或操作。</p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>若算法A解问题P，则应满足：</p><ul><li>把问题P的任何实例作为算法A的输入，都可输出该实例的正确解</li><li>每步计算是确定性的</li><li>A能够在有限步停机</li></ul><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>可以是比较、加法、乘法、置指针、交换等等操作。</p><p>基本运算的确定往往和输入规模相关，算法基本运算的次数可表示为输入规模的函数。</p><ul><li><p>排序</p><p>  元素之间的比较</p></li><li><p>检索</p><p>  被检索元素$x$与数组元素的比较</p></li><li><p>整数乘法</p><p>  每位数字相乘（位乘）1次，$m$位和$n$位整数相乘要做$mn$次位乘</p></li><li><p>矩阵相乘</p><p>  每对元素乘1次</p><p>  $i\times j$矩阵与$j\times k$矩阵相乘要做$ijk$次乘法</p></li><li><p>图的遍历</p><p>  置指针</p></li></ul><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>针对指定的基本运算，算法所做基本运算的次数。</p><p>对于相同输入规模的不同实例，算法的基本运算次数也不一样，我们可定义以下两种时间复杂度。</p><ul><li><p>最坏情况下的时间复杂度$W(n)$</p><p>  算法求解输入规模为$n$的实例所需要的最长时间</p></li><li><p>平均情况下的时间复杂度$A(n)$</p><p>  在给定同样规模为$n$的输入实例的概率分布下，算法求解这些实例所需要的平均时间</p><p>  设$S$是规模为$n$的实例集，实例$I\in S$的概率是$P_I$，算法对实例$I$执行的基本运算次数是$t_I$，则$A(n)=\sum_{I\in S}P_It_I$</p></li></ul><h2 id="输入规模"><a href="#输入规模" class="headerlink" title="输入规模"></a>输入规模</h2><p>通常用数组元素多少、调度问题的任务个数、图的顶点数和边数等表示</p><ul><li><p>排序</p><p>  数组中元素个数$n$</p></li><li><p>检索</p><p>  被检索数组的元素个数$n$</p></li><li><p>整数乘法</p><p>  两个整数的位数$m$和$n$</p></li><li><p>矩阵相乘</p><p>  矩阵的行列数$i,j,k$</p></li><li><p>图的遍历</p><p>  图的顶点数$n$，边数$m$</p></li><li><p>给定问题和基本运算就决定了一个算法类</p><p>  比如排序问题，以元素间的比较为基本运算，就确定了一个算法类。</p></li></ul><h2 id="伪码描述"><a href="#伪码描述" class="headerlink" title="伪码描述"></a>伪码描述</h2><ul><li><p>赋值语句</p><p>  $\leftarrow$</p></li><li><p>分支语句</p><p>  if…then..…[else..…]</p></li><li><p>循环语句</p><p>  while，for，repeat，until</p></li><li><p>转向语句</p><p>  goto</p></li><li><p>输出语句</p><p>  return</p></li><li><p>调用</p><p>  直接写过程的名字</p></li><li><p>注释</p><p>  //..…</p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法设计与分析&quot;&gt;&lt;a href=&quot;#算法设计与分析&quot; class=&quot;headerlink&quot; title=&quot;算法设计与分析&quot;&gt;&lt;/a&gt;算法设计与分析&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;问题建模&lt;/p&gt;
&lt;p&gt; 对输入参数和解给出形式化或半形式化的描述&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>优化模型概论</title>
    <link href="https://chouxianyu.github.io/2019/07/17/%E4%BC%98%E5%8C%96%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%AE%BA/"/>
    <id>https://chouxianyu.github.io/2019/07/17/优化模型概论/</id>
    <published>2019-07-17T14:11:41.000Z</published>
    <updated>2019-07-21T10:50:22.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h1><p>在一系列主观或客观限制条件下，寻求使所关注的某个或多个指标达到最大（或最小）的决策，这种决策问题通常称为<strong>最优化问题</strong>或<strong>优化问题</strong>，研究处理这类问题的数学方法称为<strong>最优化方法</strong>。</p><p>用最优化方法解决决策问题包括两个基本步骤：</p><ol><li><p>优化建模</p><p> 建立决策问题的<strong>优化模型</strong></p></li><li><p>模型求解</p><p> 选择、利用优化方法和工具求解模型</p></li></ol><h1 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h1><h2 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h2><p>优化模型是一种特殊的数学模型，优化建模方法是一种特殊的数学建模方法。优化模型一般由以下三个要素：</p><ul><li><p>决策变量</p><p>  通常是该问题<strong>要求解的那些未知量</strong>，可用一个$n$行的列向量$x=(x_1,x_2,\ldots,x_n)^T$表示。当对$x$赋值后它通常称为该问题的一个<strong>解</strong>或一个点。</p></li><li><p>目标函数</p><p>  通常是该问题要优化（最小或最大）的那个目标的数学的表达式，<strong>它是决策变量的函数</strong>，可抽象地记做$f(x)$。</p></li><li><p>约束条件</p><p>  由该问题对决策变量的限制条件给出，即$x$允许取值的范围为$x \in \Omega$，$\Omega$称为<strong>可行域</strong>，常用一组关于$x$的等式和不等式来界定，分别称为<strong>等式约束</strong>和<strong>不等式约束</strong>。</p><p>  优化模型中约束一般没有严格小于、严格大于关系。</p></li></ul><p>一般数学形式如下：</p><script type="math/tex; mode=display">opt \ \ \ z=f(x)\\s.t. \ h_i(x)=0 \ (i=1,2,\ldots,m_e),\\\quad \ \ \ g_i(x)\leq0\ (j=m_e+1,m_e+2,\ldots,m_e+m)</script><p>其中，$opt$是最优化（optimize）的意思，可以是$min$或$max$；</p><p>$s.t.$是“受约束于”（subject to或such that）。</p><h2 id="可行解与最优解"><a href="#可行解与最优解" class="headerlink" title="可行解与最优解"></a>可行解与最优解</h2><p>满足约束条件的解$x$（即$x\in\Omega$）称为<strong>可行解</strong>，否则称为不可行解。</p><p>满足目标函数的可行解$x’$称为<strong>最优解</strong>。</p><p>如果在某个可行解$x^<em>$的附近（$x^</em>$的某个邻域），$x^<em>$使目标函数达到最优，即$x^</em>$是$x^<em>$某个邻域中的最优解，但它不一定是整个可行域上的最优解，则$x^</em>$称为一个<strong>局部最优解</strong>或相对最优解，它实际上只是极值点。</p><p>相对于局部最优解，我们把整个可行域上的最优解称为<strong>全局最优解</strong>或整体最优解。对于大多数优化问题，求全局最优解是很困难的，所以很多优化软件往往只能求到局部最优解。</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>若按模型中决策变量的取值范围以及目标函数和约束函数的特性进行分类，常见类型如下：</p><ul><li><p><strong>连续优化</strong></p><p>  当所有决策变量$x_i(i=1,2,\ldots,n)$取值均为连续数值（即实数）时，优化模型称为连续优化（continuous optimization），也就是通常所说的<strong>数学规划</strong>。</p><ul><li><p><strong>线性规划</strong></p><p>  此时，如果目标函数$f$和约束函数$h_i、g_j$都是线性函数，则优化模型称为线性规划（linear programming，LP）。</p></li><li><p><strong>非线性规划</strong></p><p>  此时，如果目标函数$f$和约束函数$h_i、g_j$中至少有一个是非线性函数，则称为非线性规划（nonlinear programming，NLP）。</p><p>  特别地，如果目标函数$f$是一个二次函数，而约束函数$h_i、g_j$都是线性函数，则称为<strong>二次规划</strong>（quadratic programming,QP），它是一种相对比较简单的非线性规划。</p></li></ul></li><li><p><strong>离散优化</strong></p><p>  若$x_i$至少有一个只取离散数值，则优化模型称为离散优化（discrete optimization），或称为<strong>组合优化</strong>（combinatorial optimization）。</p><p>  这时通常$x$的一个或多个分量只取整数数值，则称为<strong>整数规划</strong>（integer programming，IP），并可以进一步明确地分为<strong>纯整数规划</strong>（pure integer programming，PIP，此时$x$的所有分量都只取整数数值）和<strong>混合整数规划</strong>（mixed integer programming，MIP，此时x的部分分量只取整数数值）。</p><p>  特别地，若$x$的分量中取整数数值的范围还限定为只取0或1，则称为<strong>0-1规划</strong>（zero-one programming，ZOP）。</p><p>  此外，与连续优化分成线性规划和非线性规划类似，整数规划也可以分成<strong>整数线性规划</strong>（ILP）和<strong>整数非线性规划</strong>（INLP）。</p></li></ul><p>根据其他标准，优化问题还可以分为<strong>无约束优化</strong>（unconstrained optimization）和<strong>约束优化</strong>（constrained optimization）、<strong>确定性规划</strong>和<strong>不确定性规划</strong>（如随机规划、模糊规划等）、<strong>光滑优化</strong>和<strong>非光滑优化</strong>、<strong>单目标规划</strong>和<strong>多目标规划</strong>，此外还有<strong>目标规划</strong>、<strong>动态规划</strong>、<strong>多层规划</strong>等等。</p><p>一般来说，离散优化问题比连续优化问题难以求解，非线性规划问题比线性规划问题难以求解，非光滑优化比光滑优化难以求解。</p><h1 id="敏感性分析"><a href="#敏感性分析" class="headerlink" title="敏感性分析"></a>敏感性分析</h1><p>考虑当模型中的参数发生变化时最优解是否变化、变化多少的问题，这种分析称为<strong>敏感性分析</strong>。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最优化问题&quot;&gt;&lt;a href=&quot;#最优化问题&quot; class=&quot;headerlink&quot; title=&quot;最优化问题&quot;&gt;&lt;/a&gt;最优化问题&lt;/h1&gt;&lt;p&gt;在一系列主观或客观限制条件下，寻求使所关注的某个或多个指标达到最大（或最小）的决策，这种决策问题通常称为&lt;stron
      
    
    </summary>
    
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="https://chouxianyu.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>和数据库的初次相遇</title>
    <link href="https://chouxianyu.github.io/2019/07/04/%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%9D%E6%AC%A1%E7%9B%B8%E9%81%87/"/>
    <id>https://chouxianyu.github.io/2019/07/04/和数据库的初次相遇/</id>
    <published>2019-07-04T10:45:31.000Z</published>
    <updated>2019-07-04T10:54:26.492Z</updated>
    
    <content type="html"><![CDATA[<p>以下为一些SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-- 所有sql语句以分号结尾,sql不区分大小写</span><br><span class="line"></span><br><span class="line">-- 建库语句</span><br><span class="line">create database 库名;</span><br><span class="line"></span><br><span class="line">-- 查询已有库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">-- 删除库</span><br><span class="line">drop database 库名;</span><br><span class="line"></span><br><span class="line">-- 使用库</span><br><span class="line">use 库名;</span><br><span class="line"></span><br><span class="line">-- 创建表</span><br><span class="line">create table 表名(</span><br><span class="line">id int,</span><br><span class="line">name varchar(50),</span><br><span class="line">age int</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 查询表结构</span><br><span class="line">desc 表名; -- describe</span><br><span class="line"></span><br><span class="line">-- 查询建表语句</span><br><span class="line">show create table user;</span><br><span class="line"></span><br><span class="line">-- 查询当前库中有哪些表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">-- 删除表</span><br><span class="line">drop table 表名;</span><br><span class="line"></span><br><span class="line">-- 显示表</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">-- 向表中插入数据</span><br><span class="line">insert into 表名 (字段名1,字段名2) values(值1,值2);-- 字段与值一一对应，企业要求</span><br><span class="line">insert into 表名 values(值1,值2,值3);-- 要求是值的顺序和个数必须和表中字段的顺序和个数一致</span><br><span class="line"></span><br><span class="line">insert into user(name.age) values(&apos;Tom&apos;,18);</span><br><span class="line">insert into user values(&apos;Jerry&apos;,20);</span><br><span class="line"></span><br><span class="line">-- 从表中查询数据</span><br><span class="line">select 字段名-- from 表名 where 查询限定条件</span><br><span class="line">select * from user;-- 查询全部数据</span><br><span class="line">select name,age from user;--仅显示表user中name和age字段的值</span><br><span class="line">select * from user where age=19;-- 查询表中age字段为19的表项</span><br><span class="line"></span><br><span class="line">-- 修改表中数据</span><br><span class="line">update 表名 set 字段名=值 where 限定条件;-- 如果不加where，就是对表中指定字段所有数据进行修改</span><br><span class="line">update user set age=22 where name=&apos;tom&apos;;-- 将name字段为&apos;tom&apos;的表项年龄字段改为22</span><br><span class="line"></span><br><span class="line">-- 删除表中数据</span><br><span class="line">delete from 表名 where 限定条件;-- 如果不加where，则删除所有</span><br><span class="line"></span><br><span class="line">-- 总结</span><br><span class="line">-- 库和表的CRUD，关键字分别是create,show,alter,drop</span><br><span class="line">-- 表中数据的CRUD，关键字分别是insert,select,update,delete</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下为一些SQL语句&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-课程设计</title>
    <link href="https://chouxianyu.github.io/2019/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>https://chouxianyu.github.io/2019/06/29/计算机组成原理-课程设计/</id>
    <published>2019-06-29T11:58:10.000Z</published>
    <updated>2019-07-17T14:15:28.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的与要求"><a href="#目的与要求" class="headerlink" title="目的与要求"></a>目的与要求</h1><p>​    深入了解计算机各种指令的执行过程，以及控制器的组成，指令系统微程序设计的具体知识，进一步理解和掌握动态微程序设计的概念；完成微程序控制的特定功能计算机的指令系统设计和调试。</p><p>​    要进行这项大型实验，必须清楚地懂得：</p><ol><li>TEC-2机的功能部件及其连接关系；</li><li>TEC-2机每个功能部件的功能与具体组成；</li><li>TEC-2机支持的指令格式；</li><li>TEC-2机的微指令格式，AM2910芯片的用法；</li><li>已实现的典型指令的执行实例，即相应的微指令与其执行次序的安排与衔接；</li><li>要实现的新指令的格式与功能。</li></ol><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>$TEC-2$模拟机</p><h1 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h1><p>请选定指令格式、操作码，按照要求，设计三条指令。</p><h2 id="指令一"><a href="#指令一" class="headerlink" title="指令一"></a>指令一</h2><ul><li><p><strong>说明</strong></p><p>  把用绝对地址表示的内存单元<code>ADDR1</code>中的内容与内存单元<code>ADDR2</code>中的内容相减，结果存于内存单元<code>ADDR1</code>中。</p><p>  三字指令（控存入口<code>110H</code>）。</p></li><li><p><strong>格式</strong></p><p>  <code>D8××,ADDR1,ADDR2</code></p></li><li><p><strong>功能</strong></p><p>  <code>[ADDR1]=[ADDR1]-[ADDR2]</code></p></li></ul><h3 id="微程序设计与实现"><a href="#微程序设计与实现" class="headerlink" title="微程序设计与实现"></a>微程序设计与实现</h3><div class="table-container"><table><thead><tr><th style="text-align:center">执行顺序</th><th style="text-align:center">微指令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$PC\to AR,PC+1 \to PC$</td><td style="text-align:center">为读取第1个操作数的地址做准备</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$MEM \to R6$</td><td style="text-align:center">读取第1个操作数的地址送入$R_6$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$PC \to AR,PC+1 \to PC$</td><td style="text-align:center">为读取第2个操作数的地址做准备</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$MEM \to AR$</td><td style="text-align:center">读取第2个操作数的地址送入$AR$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$R6 \to AR,MEM \to R6$</td><td style="text-align:center">第1个操作数地址送$AR$，读取第2个操作数送入$R_6$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$MEM-R6\to R6$</td><td style="text-align:center">第1个操作数-第2个操作数送入$R_6$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$R6 \to MEM$</td><td style="text-align:center">$R_6$送第1个操作数所在存储单元</td></tr></tbody></table></div><ol><li>$PC\to AR,PC+1 \to PC$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> A0B5 <span class="number">5402</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbba492b14679.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbba492b14679.png" alt="微指令11.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  不需要读写存储器或输入输出设备，所以为<code>10X</code></p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口，运算器Y输出$A$口</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$B$口和0,（选$A$口和0也可以，因为$A$口和$B$口是同一个寄存器）</p></li><li><p>$A$口</p><p>  选$PC$，即$R_5$</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  选$PC$，即$R_5$</p></li><li><p>$SCI$</p><p>  最低位进位设置为1</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  选微指令中的$A$口、$B$口地址</p></li><li><p>$DC1$</p><p>  因为$AR$只能接收来自运算器的结果输出信号，所以$DC1$可以任意</p></li><li><p>$DC2$</p><p>  运算器输出送$AR$</p></li></ul></li></ul><ol><li>$MEM \to R6$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> <span class="number">30F</span>0 <span class="number">6000</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc13dbd27187.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc13dbd27187.png" alt="微指令12.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口，运算器Y输出运算结果（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和0</p></li><li><p>$A$口</p><p>  任意</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  选$R6$</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  $A$口任意，因为不使用$A$口；选择微指令中的$B$口地址</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><ol><li>$PC \to AR,PC+1 \to PC$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> A0B5 <span class="number">5402</span></span><br></pre></td></tr></table></figure><p>这条微指令和本机器指令的第一条微指令完全一样，不再做解释说明</p><ol><li>$MEM \to AR$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> <span class="number">10F</span>0 <span class="number">0002</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc11e9d48798.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc11e9d48798.png" alt="微指令14.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果不送寄存器，运算器Y输出运算结果送$AR$</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和0</p></li><li><p>$A$口</p><p>  任意</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  任意</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  都任意，因为不使用$A$口和$B$口</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  运算器输出送$AR$</p></li></ul></li></ul><ol><li>$R6 \to AR,MEM \to R6$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> <span class="number">20F</span>6 <span class="number">6002</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc1435171281.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc1435171281.png" alt="微指令15.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口，运算器Y输出$A$口</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和0</p></li><li><p>$A$口</p><p>  $R_6$</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  $R_6$</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$A$口和$B$口</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  运算器输出送$AR$</p></li></ul></li></ul><ol><li>$MEM-R6\to R6$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E01</span> <span class="number">22</span>D6 <span class="number">6000</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc13ed899415.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc13ed899415.png" alt="微指令16.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时是真正的运算，设置标志位</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口；运算器Y输出$A$口（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择减法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和$A$口</p></li><li><p>$A$口</p><p>  $R_6$</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  $R_6$</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$A$口和$B$口</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><ol><li>$R6 \to MEM$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0029</span> <span class="number">0300</span> <span class="number">1046</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc142d818038.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc142d818038.png" alt="微指令17.png"></a></p><ul><li><p>七</p><p>  这是最后一条微指令，下一条微指令是<code>A4H</code>。</p></li><li><p>六</p><p>  $AM2910$命令码为3，即3号指令，条件转移</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  $\bar{CC}$设为0，进行转移</p></li><li><p>$SST$</p><p>  此时并不是运算，所以标志位不变</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  写存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果不送寄存器；运算器Y输出​$A$口</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择0和$A$口</p></li><li><p>$A$口</p><p>  $R_6$</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  任意</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$A$口；$B$口任意</p></li><li><p>$DC1$</p><p>  运算器输出送$IB$</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><h3 id="指令测试"><a href="#指令测试" class="headerlink" title="指令测试"></a>指令测试</h3><p>如下图所示，<code>[A00H]</code>存储单元（$ADDR1$）存储了<code>0045H</code>，<code>[A01H]</code>存储单元（$ADDR2$）存储了<code>0023H</code>，最终指令运行后<code>[A00H]</code>为<code>0022H</code>，实现<code>[ADDR1]=[ADDR1]-[ADDR2]</code>。</p><p><a href="https://i.loli.net/2019/06/22/5d0d96d08694544002.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d08694544002.png" alt="指令测试11.png"></a></p><p><a href="https://i.loli.net/2019/06/22/5d0d96ccdb05229094.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96ccdb05229094.png" alt="指令测试12.png"></a></p><h2 id="指令二"><a href="#指令二" class="headerlink" title="指令二"></a>指令二</h2><ul><li><p><strong>说明</strong></p><p>  将一通用寄存器内容加上某内存单元内容，结果放在另一寄存器中。</p><p>  双字指令（控存入口<code>130H</code>），$SR$和$DR$分别为源、目的寄存器（各4位）。</p></li><li><p><strong>格式</strong></p><p>  <code>E0 DR SR,ADDR</code></p></li><li><p><strong>功能</strong></p><p>  <code>DR=SR+ [ADDR]</code> </p></li></ul><h3 id="微程序设计与实现-1"><a href="#微程序设计与实现-1" class="headerlink" title="微程序设计与实现"></a>微程序设计与实现</h3><div class="table-container"><table><thead><tr><th style="text-align:center">执行顺序</th><th style="text-align:center">微指令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$PC\to AR,PC+1 \to PC$</td><td style="text-align:center">为读取操作数的地址做准备</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$MEM \to AR$</td><td style="text-align:center">操作数的地址送入$AR$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$SR+MEM \to DR$</td><td style="text-align:center">计算$SR$与操作数的和存入$DR$</td></tr></tbody></table></div><ol><li>$PC\to AR,PC+1 \to PC$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> A0B5 <span class="number">5402</span></span><br></pre></td></tr></table></figure><p>这条微指令和第一条机器指令的第一条微指令完全一样，不再做解释说明</p><ol><li>$MEM \to AR$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> <span class="number">10F</span>0 <span class="number">0002</span></span><br></pre></td></tr></table></figure><p>这条微指令和第一条机器指令的第四条微指令完全一样，不再做解释说明</p><ol><li>$SR+MEM \to DR$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0029</span> <span class="number">0301</span> <span class="number">30</span>D0 <span class="number">0088</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbbb584732965.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbbb584732965.png" alt="微指令23.png"></a></p><ul><li><p>七</p><p>  这是最后一条微指令，下一条微指令是<code>A4H</code>。</p></li><li><p>六</p><p>  $AM2910$命令码为3，即3号指令，条件转移</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  $\bar{CC}$设为0，进行转移</p></li><li><p>$SST$</p><p>  此时进行了运算，需要对标志位进行设置</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口；运算器Y输出​运算结果（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和$A$口</p></li><li><p>$A$口</p><p>  使用机器指令中设置的$SR$，微指令中不需要给$A$口地址</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  使用机器指令中设置的$DR$，微指令中不需要给$B$口地址</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用机器指令中的$SR、DR$</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><h3 id="指令测试-1"><a href="#指令测试-1" class="headerlink" title="指令测试"></a>指令测试</h3><p>如图示，$R_0$（$SR$）为<code>0023H</code>，<code>A00H</code>（$ADDR$）存储<code>0023H</code>，程序运行后$R_1$（$DR$）为<code>0046H</code>，实现<code>DR=SR+ [ADDR]</code> 。</p><p><a href="https://i.loli.net/2019/06/22/5d0d96d27564178096.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d27564178096.png" alt="指令测试21.png"></a></p><p><a href="https://i.loli.net/2019/06/22/5d0d96cc0eda569856.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96cc0eda569856.png" alt="指令测试22.png"></a></p><h2 id="指令三"><a href="#指令三" class="headerlink" title="指令三"></a>指令三</h2><ul><li><p><strong>说明</strong></p><ul><li><p>转移指令</p><p>  判断两个通用寄存器内容是否相等，若相等则转移到指定绝对地址，否则顺序执行。</p></li><li><p>双字指令（控存入口<code>140H</code>），<code>SR</code>和<code>DR</code>分别为源、目的寄存器（各4位），<code>ADDR</code>为绝对地址。</p></li><li><p>提示</p><p>  利用指令的<code>CND</code>字段，即$IR_{10-8}$，令$IR_{10-8}=101$，即$\bar{CC}=Z$。</p><p>  当<code>DR==SR​</code>时<code>Z=1</code>，微程序不跳转，接着执行$MEM \to PC$（即$ADDR\to PC$）；</p><p>  而当<code>DR!=SR​</code>时<code>Z=0​</code>，微程序跳转至<code>A4H</code>。</p></li></ul></li><li><p><strong>格式</strong></p><p>  <code>E5 DR SR,ADDR</code></p></li><li><p><strong>功能</strong></p><p>  <code>if DR==SR goto ADDR</code> <code>else　顺序执行</code></p></li></ul><h3 id="微程序设计与实现-2"><a href="#微程序设计与实现-2" class="headerlink" title="微程序设计与实现"></a>微程序设计与实现</h3><div class="table-container"><table><thead><tr><th style="text-align:center">执行顺序</th><th style="text-align:center">微指令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$SR-DR$</td><td style="text-align:center">测试$SR$与$DR$是否相等</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$PC \to AR,PC+1 \to PC，\ $如果$Z=0，$则微程序跳转到$A4H$</td><td style="text-align:center">为读取转移地址做准备</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$MEM \to PC$</td><td style="text-align:center">程序转移到指定地址</td></tr></tbody></table></div><ol><li>$SR-DR$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E01</span> <span class="number">9210</span> <span class="number">0088</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cdeeba4c4559040.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cdeeba4c4559040.png" alt="微指令31.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行，不需要条件测试</p></li><li><p>$SST$</p><p>  此时进行了运算，需要对标志位进行设置，来判断$SR$和$DR$是否相等</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  不进行存储器或IO操作</p></li><li><p>$MI_{8-6}$</p><p>  运算结果不送寄存器；运算器Y输出​运算结果（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择减法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$A$口和$B$口</p></li><li><p>$A$口</p><p>  使用机器指令中设置的$SR$，微指令中不需要给$A$口地址</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  使用机器指令中设置的$DR$，微指令中不需要给$B$口地址</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用机器指令中的$SR、DR$</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><ol><li>$PC \to AR,PC+1 \to PC$，如果$Z=0$，则微程序跳转到$A4H$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0029</span> <span class="number">03E0</span> A045 <span class="number">5412</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cdeebbf81988317.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cdeebbf81988317.png" alt="微指令32.png"></a></p><ul><li><p>七</p><p>  微程序转移，下址字段为<code>A4H</code></p></li><li><p>六</p><p>  $AM2910$命令码为3，即3号指令，条件转移</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  测试条件设置为$IR_{10-8}$，指令中将$IR_{10-8}$设为5，即$\bar{CC}=Z$</p></li><li><p>$SST$</p><p>  此时并不是计算，状态位保持即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  不进行存储器或IO操作</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口；运算器Y输出$A$口</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$A$口和0</p></li><li><p>$A$口</p><p>  $A$口设置为$PC$，即$R_5$。</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  $B$口设置为$PC$，即$R_5$。</p></li><li><p>$SCI$</p><p>  最低位进位设置为1</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$A$口和$B$口地址</p></li><li><p>$DC1$</p><p>  由于是写$AR$，这里把运算器输出送$IB$。经过前两条机器指令的试验，实际上$DC1$可以任意。</p></li><li><p>$DC2$</p><p>  写$AR$</p></li></ul></li></ul><ol><li>$MEM \to PC$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0029</span> <span class="number">0300</span> <span class="number">30F</span>0 <span class="number">5000</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cdeec78a4046521.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cdeec78a4046521.png" alt="微指令33.png"></a></p><ul><li><p>七</p><p>  微程序转移，下址字段为<code>A4H</code></p></li><li><p>六</p><p>  $AM2910$命令码为3，即3号指令，条件转移</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  测试条件设置为0，一定转移</p></li><li><p>$SST$</p><p>  此时并不是计算，状态位保持即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口；运算器Y输出运算结果（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和0</p></li><li><p>$A$口</p><p>  $A$口任意，并不使用。</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  $B$口设置为$PC$，即$R_5$。</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$B$口地址，$A$口任意（因为不使用$A$口）。</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><h3 id="指令测试-2"><a href="#指令测试-2" class="headerlink" title="指令测试"></a>指令测试</h3><p>当$R_1$（$SR$）存储<code>0023H</code>、$R_2$（$DR$）存储<code>0026H</code>时，即$DR \neq SR$时，程序顺序执行，运行了<code>MOV R1,0026</code>，所以程序运行后$R_1$为<code>0026H</code>。</p><p>当$R_1$（$SR$）存储<code>0023H</code>、$R_2$（$DR$）存储<code>0023H</code>时，即$DR = SR$时，程序跳转至<code>828H</code>（$ADDR$），所以未运行<code>MOV R1,0026</code>，所以程序运行后$R_1$仍为<code>0023H</code>。</p><ul><li>$DR \neq SR$时</li></ul><p><a href="https://i.loli.net/2019/06/22/5d0d96d48c64257612.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d48c64257612.png" alt="指令测试31_1.png"></a></p><p><a href="https://i.loli.net/2019/06/22/5d0d96d0d65a585568.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d0d65a585568.png" alt="指令测试31_2.png"></a></p><ul><li>$DR = SR$时</li></ul><p><a href="https://i.loli.net/2019/06/22/5d0d96d491b2e57530.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d491b2e57530.png" alt="指令测试32_1.png"></a></p><p><a href="https://i.loli.net/2019/06/22/5d0d96d07a6d178706.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d07a6d178706.png" alt="指令测试32_2.png"></a></p><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ol><li>磨刀不误砍柴工。在设计微程序前，我把实验书看了一遍，有些地方不是很懂；之后着手去设计微程序，然后再去看书，理解到的更多了；最终微程序设计完之后，我又把书看了一遍，又发现了很多之前理解不到位的地方，正所谓温故而知新。我想这最能说明实践和理论的关系吧，多动手多动脑，才能巩固对知识的理解。</li><li>通过本次对微指令码一位位的设计，我对于计算机的底层实现有了更深的理解，更进一步地了解了计算机的工作原理，特别是运算器、控制器、内存、寄存器等部件之间的协作。本学期也学了汇编语言，它几乎是最靠近计算机硬件的编程语言了，在本次课程设计中，自主设计硬件间的协作，又算是直接接触了硬件，巩固了汇编和计组两门学科的知识与其联系。</li><li>通过本次课程设计，我巩固了微程序设计的方法与思想，比如微指令、微操作、微命令、水平型微指令、微控存等基本概念，了解了微程序层次上程序员所看到的的计算机系统结构，加深了对程序员一词的理解。不同层次的程序员由于工作的“机器”不同，所以面对的问题以及其实现往往也是极为不同的。</li></ol><h1 id="附加材料"><a href="#附加材料" class="headerlink" title="附加材料"></a>附加材料</h1><p><strong>以下为$TEC-2$部分知识点总结。</strong></p><h2 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h2><p>$TEC-2$机字长为16位，运算器、主存、数据与地址总线均为16位。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>$TEC-2$机指令有6位操作码，故支持64条指令，其中53条已实现，用于写出该机的监控程序。</p><p>$IR$：指令寄存器，存储当前正在执行的指令。</p><p>指令最高6位（$IR_{15-10}$）是操作码，之后两位$IR_{9-8}$是条件码，把它用作条件转移指令的判断条件，因此可以认为这两位是指令的扩展操作码。除条件转移指令之外，其余指令不使用这两位。</p><h2 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h2><p>主存支持$64K$字，$4K\times8$的$ROM(2732)$存放监控程序，$2K\times8$的$RAM(2716)$存放用户数据及数据。</p><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><p>运算器主要由4片$AM2901$级联而成，可实现8种运算功能，16个双端口（$A$、$B$）读出、单端口（$B$）写入的通用寄存器（$R_{0-15}$，其中$R_{4-6}$作为$SP$、$PC$、$IP$），另配有1片$AM2902$实现快速进位。</p><ul><li><p>$IP$</p><p>  保存当前正在运行的指令的地址，<strong>用于转移变址的目的</strong>。</p><p>  所以在课设第一条指令中可以使用$R_6$暂存数据，因为此时不需要转移变址，用不到$IP$。</p></li><li><p>$I_{8-6}$</p><p>  进行寄存器结果选择和Y输出选择</p></li><li><p>$I_{5-3}$</p><p>  进行运算功能选择</p></li><li><p>$I_{2-0}$</p><p>  进行数据来源选择</p></li></ul><h3 id="引脚信号"><a href="#引脚信号" class="headerlink" title="引脚信号"></a>引脚信号</h3><ul><li><p>$D_{3-0}$</p><p>  外部送给$AM2901$的数据信号，比如从内存读出来的数据</p></li><li><p>$Y_{3-0}$</p><p>  $AM2901$向外送出的数据，受​$\bar{OE}$控制。但在​$TEC-2$中，​$\bar{OE}$已接地</p></li><li><p>$A、B$</p><p>  选择寄存器组中的源与目的寄存器。</p><p>  当$A$、$B$同值时，被选中的同一个寄存器的内容将被同时送到$A$、$B$两个数据输出端口</p></li></ul><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><ul><li>控制器主要由一片$AM2910$、7片$6116(RAM,2K\times8)$（微控存）、16位的指令寄存器$IR$和2片$2716$（存储用于实现53条机器指令的微程序，加电后读取送入微控存）等组成。</li><li>程序计数器$PC$用运算器中的通用寄存器$R_5$代替，保存下一条指令的地址。</li><li>指令地址寄存器$IP$由运算器中的$R_6$代替。</li><li>控存字长56位，已实现的53条指令的微程序存放在2片单独的8位$ROM$中，加电的过程自动调入控存（装入微码）。</li><li>地址总线的输入信号仅有一组，即地址寄存器（$AR$），而<strong>AR只能接收来自运算器的结果输出信号</strong>。</li></ul><h3 id="AM2910"><a href="#AM2910" class="headerlink" title="$AM2910$"></a>$AM2910$</h3><p>$AM2910$，微程序定序器，<strong>作用：形成下一条微指令的地址</strong>。</p><h4 id="三个输出使能信号"><a href="#三个输出使能信号" class="headerlink" title="三个输出使能信号"></a>三个输出使能信号</h4><p><strong>作用：决定直接输入D的来源</strong></p><ul><li><p>$\bar{MAP}$</p><p>  当其有效时，$D$来源于$MAPROM$，用于实现从机器指令到相应的微程序段的转移。</p></li><li><p>$\bar{VECT}$</p><p>  当其有效时，原意为$D$来源于中断向量，现用于接收手拨微地址。</p></li><li><p>$\bar{PL}$</p><p>  当其有效时，$D$来源于微指令的下地址字段，用于实现微程序转移。</p></li></ul><h4 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h4><ul><li><p>$\bar{CC}$</p><p>  条件测试，当其为低电平时，测试成功，转移（使用下址字段）；否则，顺序执行。</p></li><li><p>$\bar{OE}$</p><p>  Y输出允许信号，低电平有效，已接地</p></li><li><p>$\bar{CCEN}$</p><p>  $\bar{CC}$允许信号，已接地</p></li></ul><h4 id="16条命令"><a href="#16条命令" class="headerlink" title="16条命令"></a>16条命令</h4><ul><li><p>2号命令</p><p>  指令功能分支，无条件转$MAP$</p></li><li><p>3号命令</p><p>  条件转移，条件测试$\bar{CC}$为1时顺序执行，否则按下地址$D$转移。</p></li><li><p>14号命令</p><p>  顺序执行下一条微指令</p></li></ul><h2 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h2><h3 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h3><p>每位的用处已在EXCEL表格中说明。</p><ul><li><p>$DC1$和$DC2$</p><p>  关于这两个控制位我还有两个问题</p><ul><li><p>$DC2$为​$2$时</p><p>  写$AR$时应把$DC2$设为2，即$AR$接收来自$IB$的数据；但$DC1$课本上都是设为0，即微型开关送$IB$。</p><p>  这样不就是把微型开关送到了$AR$嘛？这不太对啊！？以下是我的猜测：</p><p>  我猜在这里$DC1$应该是任意的。因为$AR$只能接收运算器的输出，所以当$DC2$设置为写$AR$时，就忽略$DC1$的设置，硬件应该可以实现。</p></li><li><p>$DC2$为​$0$时</p><p>  此时代表$NC$，即无寄存器接收$IB$的数据，所以此时$DC1$应该也是任意，书上写的是0。</p></li></ul></li><li><p>$SSH$</p></li></ul><h3 id="常用微指令"><a href="#常用微指令" class="headerlink" title="常用微指令"></a>常用微指令</h3><ul><li><p>19H</p><p>  取指令，$PC$增量。</p><p>  该条微指令公用于所有指令。</p></li><li><p>1AH</p><p>  按新取来的指令的操作码找到该条指令本身的微程序段的入口地址。</p><p>  19H之后一定是1AH。</p></li><li><p>A4H</p><p>  根据有无中断请求，决定是进入中断处理过程，还是顺序执行。</p><p>  任何一条机器指令执行完都要去A4H检测中断</p></li></ul><h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><p>以第一条指令为例</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol><li><p>$S_2S_1S_0$</p><p> 设为<code>100</code></p></li><li><p>$FS_1FS_2FS_3FS_4$</p><p> 设为<code>1010</code></p></li><li><p>$STEP/CONT$</p><p> 设为<code>CONT</code></p></li></ol><h3 id="输入并查看微码"><a href="#输入并查看微码" class="headerlink" title="输入并查看微码"></a>输入并查看微码</h3><ol><li><p><code>E900</code></p><p> 将微码输入到<code>900H</code>开始的内存单元中</p></li><li><p><code>D900</code></p><p> 查看内存</p></li></ol><h3 id="将微码加载到微控存"><a href="#将微码加载到微控存" class="headerlink" title="将微码加载到微控存"></a>将微码加载到微控存</h3><ol><li><p><code>A800</code></p><p>输入加载微码的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0800: MOV R1,900; 900是微码在内存中地址</span><br><span class="line">0802: MOV R2,7; 共7条微指令</span><br><span class="line">0804: MOV R3,110; 微码在微控存中的首地址</span><br><span class="line">0806: LDMC;加载微码</span><br><span class="line">0807: RET</span><br></pre></td></tr></table></figure></li><li><p><code>G800</code></p><p> 运行上边的代码，把微码装入微控存<code>110H</code>开始的单元中</p></li></ol><h3 id="测试指令"><a href="#测试指令" class="headerlink" title="测试指令"></a>测试指令</h3><ol><li><p><code>A820</code></p><p>输入测试指令的程序到<code>820H</code>开始的内存单元中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0820: MOV R0,0045</span><br><span class="line">0822: MOV [A00],R0; [A00]单元存储45H</span><br><span class="line">0824: MOV R1,0023</span><br><span class="line">0826: MOV [A01],R1; [A01]单元存储23H</span><br><span class="line">0828: NOP; 占一个字</span><br><span class="line">0829: NOP</span><br><span class="line">082A: NOP</span><br><span class="line">082B: RET</span><br></pre></td></tr></table></figure></li><li><p><code>E826</code></p><p>把新指令写到<code>826H</code>开始的内存单元</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0828    0000:D800  0000:0A00  0000:0A01</span><br></pre></td></tr></table></figure></li><li><p><code>U820</code></p><p>反汇编，查看我们输入的测试指令的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0820: 2C00 0045  MOV    R0,     0045</span><br><span class="line">0822: 3400 0A00  MOV    [0A00], R0</span><br><span class="line">0824: 2C10 0023  MOV    R1,     0023</span><br><span class="line">0826: 3401 0A01  MOV    [0A01], R1</span><br><span class="line">0828: D800       DW     D800</span><br><span class="line">0829: 0A00       ADC    R0,     R0; 高8位为000010XX，对应指令为ADC，实际上是我们自己设计的指令</span><br><span class="line">082A: 0A01       ADC    R0,     R1</span><br><span class="line">082B: AC00       RET</span><br></pre></td></tr></table></figure></li><li><p><code>G820</code></p><p> 运行从<code>820H</code>开始的程序</p></li></ol><h3 id="观察运算结果"><a href="#观察运算结果" class="headerlink" title="观察运算结果"></a>观察运算结果</h3><p><code>DA00</code></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目的与要求&quot;&gt;&lt;a href=&quot;#目的与要求&quot; class=&quot;headerlink&quot; title=&quot;目的与要求&quot;&gt;&lt;/a&gt;目的与要求&lt;/h1&gt;&lt;p&gt;​    深入了解计算机各种指令的执行过程，以及控制器的组成，指令系统微程序设计的具体知识，进一步理解和掌握动态微程
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第七章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第七章复习/</id>
    <published>2019-06-28T13:38:07.000Z</published>
    <updated>2019-06-28T13:39:39.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三层次存储系统"><a href="#三层次存储系统" class="headerlink" title="三层次存储系统"></a>三层次存储系统</h1><p>三层次存储系统指<strong>CACHE-主存-辅存</strong>存储系统。</p><p>目的：解决<strong>高速度、大容量和低成本</strong>间的矛盾。</p><h2 id="主存-辅存层次"><a href="#主存-辅存层次" class="headerlink" title="主存-辅存层次"></a>主存-辅存层次</h2><p>解决<strong>容量和成本</strong>间的矛盾。</p><h2 id="CACHE-主存层次"><a href="#CACHE-主存层次" class="headerlink" title="CACHE-主存层次"></a>CACHE-主存层次</h2><p>解决<strong>速度和成本</strong>间的矛盾。</p><h1 id="CACHE工作原理"><a href="#CACHE工作原理" class="headerlink" title="CACHE工作原理"></a>CACHE工作原理</h1><p>工作原理也就是层次存储系统能发挥效用的原因，如下：</p><p>根据程序访问的局部性，如果当前正在执行的程序和数据存放在CACHE中，当程序运行时，不必从主存储器取指令和数据，访问CACHE即可。</p><p><strong>程序访问的局部性</strong>：</p><p>在一个较短的时间间隔内，程序访问的地址（程序、指令的地址和数据的地址）往往集中制存储器逻辑地址空间的很小范围内。</p><h1 id="三种地址映像方式"><a href="#三种地址映像方式" class="headerlink" title="三种地址映像方式"></a>三种地址映像方式</h1><p>地址映像：主存地址映像到Cache</p><h2 id="直接映像"><a href="#直接映像" class="headerlink" title="直接映像"></a>直接映像</h2><ul><li><p><strong>优点</strong></p><p>  实现简单，只需利用主存地址按某些字段直接判断，即可确定所需字块是否已在cache中</p></li><li><p><strong>缺点</strong></p><p>  不够灵活，不能用替换算法</p></li></ul><h2 id="全相联映像"><a href="#全相联映像" class="headerlink" title="全相联映像"></a>全相联映像</h2><ul><li><p><strong>优点</strong></p><p>  最灵活，可以使用任何替换算法，理论上命中率高</p></li><li><p><strong>缺点</strong></p><p>  成本最高，每个Cache块都要用一个运算器</p></li></ul><h2 id="组相联映像"><a href="#组相联映像" class="headerlink" title="组相联映像"></a>组相联映像</h2><p><strong>组间直接映像，组内全相联映像</strong>。</p><ul><li><p><strong>优缺点</strong></p><p>  是直接映像和全相联映像的折衷方案，性能处于前两种之间。</p></li></ul><h1 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h1><h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>把最先调入cache的字块替换出去</p><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>把近期最少使用的字块替换出去。</p><p>这需要一张表来记录cache中各字块的使用情况，把最近使用的字块放到表的最上边，其他的向下顺移。</p><h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>虚拟存储器拥有辅存的容量，接近主存的速度和辅存的单位成本。</p><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><p>利用程序的模块化形状，把主存按段分配</p><ul><li>优点<ul><li>段的分界和程序的自然分界相对应</li><li>段的逻辑独立性使它易于编译、管理、修改和保护，也易于重复调用。</li></ul></li><li>缺点<ul><li>容易在段间留下许多零碎的存储空间，造成空间浪费。</li></ul></li></ul><h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>主存物理空间被划分为<strong>等长</strong>的页</p><ul><li><p>优点</p><p>  与段式管理相比，空间浪费要小得多</p></li><li><p>缺点</p><p>  处理、保护和共享都不如段式来得方便</p></li></ul><h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><p>程序按模块分段，<strong>段内再分页</strong>，<strong>出入内存仍以页为单位</strong>，用段表和页表进行两级管理（每段一个页表）</p><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><p>虚地址高位字段为虚页号，低位字段为页内字地址。</p><p>假设页表保存在内存中，那么访问存储器时首先要查页表（需要访问主存），得到实地址后，再次访问主存才能完成读写操作，这样相当于<strong>主存速度降低了一半</strong>。</p><p><strong>解决办法</strong>：使用快慢表，快表是慢表（主存中的页表）的小小的副本。</p><p>查表时，用虚页号同时去查快表和慢表，如果在快表中找到，就将对应的实页号送入实主存地址寄存器，并使慢表的查找作废；找不到时，就要花费一个访问主存时间查慢表，从中查到实页号送入实存地址寄存器，并将此虚页号和对应的实页号送入快表，替换快表中某一行内容（这也使用替换算法）。</p><h2 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h2><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三层次存储系统&quot;&gt;&lt;a href=&quot;#三层次存储系统&quot; class=&quot;headerlink&quot; title=&quot;三层次存储系统&quot;&gt;&lt;/a&gt;三层次存储系统&lt;/h1&gt;&lt;p&gt;三层次存储系统指&lt;strong&gt;CACHE-主存-辅存&lt;/strong&gt;存储系统。&lt;/p&gt;
&lt;p&gt;目
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第六章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第六章复习/</id>
    <published>2019-06-28T13:38:01.000Z</published>
    <updated>2019-06-28T13:39:31.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="控制器作用"><a href="#控制器作用" class="headerlink" title="控制器作用"></a>控制器作用</h1><ul><li><p>控制程序的执行</p><p>  即协调并控制计算机各部件执行程序的指令序列。</p></li></ul><h1 id="控制器功能"><a href="#控制器功能" class="headerlink" title="控制器功能"></a>控制器功能</h1><ul><li><p><strong>取指令</strong></p></li><li><p><strong>分析指令</strong></p><p>  又叫指令译码。</p></li><li><p><strong>执行指令</strong></p></li><li><p>控制程序和数据的输入与结果输出</p></li><li><p>对异常情况和某些请求的处理</p></li></ul><h1 id="控制器组成"><a href="#控制器组成" class="headerlink" title="控制器组成"></a>控制器组成</h1><h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><p>程序计数器/指令地址寄存器，存放当前指令或下一条指令的地址（TEC-2中PC存储下一条指令的地址）。</p><ul><li><p>在一条无条件跳转指令的指令周期内，PC的值被修改<strong>2</strong>次。</p><p>  取指令周期结束后，PC值自动加1；执行周期中，PC值修改为要跳转到的地址，故在这个指令周期内，PC值被修改两次。</p></li><li><p>程序计数器（PC）的位数取决于<strong>主存的容量</strong>。</p><p>  程序计数器的内容为指令在主存中的地址，所以程序计数器的位数与主存地址的位数相等，而主存地址位数取决于主存的容量。</p></li><li><p>指令周期、间址周期</p></li></ul><h2 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h2><p>指令寄存器，存放当前正在执行的指令</p><ul><li><p>指令寄存器（IR）的位数取决于指令字长</p><p>  指令寄存器的内容为正在执行的指令，所以位数取决于指令字长。</p></li><li><p>CPU中的通用寄存器不能替代指令寄存器（IR）</p><p>  指令寄存器是专门用于存放指令的专用寄存器，不能由通用寄存器替代。</p></li></ul><h2 id="指令译码器"><a href="#指令译码器" class="headerlink" title="指令译码器"></a>指令译码器</h2><p>又叫操作码译码器，对指令寄存器中的操作码进行分析解释。</p><h2 id="脉冲源及启停电路"><a href="#脉冲源及启停电路" class="headerlink" title="脉冲源及启停电路"></a>脉冲源及启停电路</h2><ul><li><p>脉冲源</p><p>  产生一定频率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号；</p><p>  另外在开机时产生<code>reset</code>信号</p></li><li><p>启停电路</p><p>  保证可靠地送出或封锁完整的时钟脉冲，控制时序信号的发生和停止</p></li></ul><h2 id="时序控制信号形成部件"><a href="#时序控制信号形成部件" class="headerlink" title="时序控制信号形成部件"></a>时序控制信号形成部件</h2><p>形成并调整时序。</p><p>产生控制信号一般有两种方法：</p><h3 id="微程序控制方式"><a href="#微程序控制方式" class="headerlink" title="微程序控制方式"></a>微程序控制方式</h3><h3 id="硬布线控制方式"><a href="#硬布线控制方式" class="headerlink" title="硬布线控制方式"></a>硬布线控制方式</h3><h1 id="几个周期"><a href="#几个周期" class="headerlink" title="几个周期"></a>几个周期</h1><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p><strong>从取指令开始到其执行完成所经过的时间</strong>。</p><p>一个指令周期包含若干个时钟周期。</p><h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>通常称为节拍脉冲或T周期。</p><p><strong>时钟周期</strong>是计算机中最基本的、<strong>最小的时间单位</strong>。</p><h1 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h1><p>结合课后习题6.1食用。</p><ul><li><p>MAR主存地址寄存器；MDR主存数据寄存器；AC累加寄存器，简称累加器。</p></li><li><p>主存与CPU之间的连线有地址总线和数据总线。</p></li><li><p>地址总线的信息仅从CPU传送到主存MAR，数据总线则允许双向传送（CPU和MDR）。</p></li><li><p>指令从主存取出到产生控制信号的数据通路</p><p>  指令地址从PC经地址总线送到MAR，数据从主存经数据总线送到IR。</p></li><li><p>数据在运算器和主存直接进行读/写的数据通路</p><p>  读写地址由IR中指令的地址字段经地址总线送主存MAR；读时数据从主存经数据总线送到MDR，然后送ALU，然后送AC；写时数据从AC送MDR，再送主存。</p></li></ul><h1 id="微程序控制的基本概念"><a href="#微程序控制的基本概念" class="headerlink" title="微程序控制的基本概念"></a>微程序控制的基本概念</h1><p>把机器指令拆分成微指令，再把微指令拆分成微操作。</p><h2 id="微指令"><a href="#微指令" class="headerlink" title="微指令"></a>微指令</h2><p>把机器指令拆分成微指令。</p><p>机器指令与微指令的关系：用微指令解释机器指令</p><p>微指令长度一般要比机器指令长得多。</p><h2 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h2><p><strong>一个微指令中</strong>，由<strong>同时发出的控制信号</strong>所执行的各个操作称为<strong>微操作</strong>。</p><h2 id="微命令"><a href="#微命令" class="headerlink" title="微命令"></a>微命令</h2><p>微命令和微操作一一对应。</p><p>微命令是微操作的控制信号，微操作是微命令的执行过程。</p><h2 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h2><p>微指令序列。</p><h2 id="控制存储器"><a href="#控制存储器" class="headerlink" title="控制存储器"></a>控制存储器</h2><p>用来存放微程序，其<strong>容量取决于实现指令系统所需的微程序长度</strong>（或者说<strong>其容量取决于微指令的条数</strong>）。</p><h1 id="AM2910"><a href="#AM2910" class="headerlink" title="$AM2910$"></a>$AM2910$</h1><p>微程序定序器</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>形成下一条微指令的地址</strong></p><h2 id="三个输出使能信号"><a href="#三个输出使能信号" class="headerlink" title="三个输出使能信号"></a>三个输出使能信号</h2><p><strong>作用：决定直接输入D的来源</strong></p><ul><li><p>$\bar{MAP}$</p><p>  当其有效时，$D$来源于$MAPROM$，用于实现从机器指令到相应的微程序段的转移。</p></li><li><p>$\bar{VECT}$</p><p>  当其有效时，原意为$D$来源于中断向量，现用于接收手拨微地址。</p></li><li><p>$\bar{PL}$</p><p>  当其有效时，$D$来源于微指令的下地址字段，用于实现微程序转移。</p></li></ul><h4 id="16条命令"><a href="#16条命令" class="headerlink" title="16条命令"></a>16条命令</h4><ul><li><p>2号命令</p><p>  指令功能分支，无条件转$MAP$，此时$\bar{MAP}为0$，根据指令的操作码形成用来解释执行该机器指令的微程序的入口地址</p></li><li><p>3号命令</p><p>  条件转移，条件测试$\bar{CC}$为1时顺序执行，否则按下地址$D$转移。</p></li><li><p>14号命令</p><p>  顺序执行下一条微指令</p></li></ul><h1 id="CPU如何区分指令和数据"><a href="#CPU如何区分指令和数据" class="headerlink" title="CPU如何区分指令和数据"></a>CPU如何区分指令和数据</h1><p>可以从时间和空间上来区分</p><p>取指令周期中从内存中读出的信息流是指令流，它流向控制器；</p><p>执行指令周期中从内存读出或送入内存的信息流是数据流，它由内存流向运算器或由运算器流向内存。</p><h1 id="微程序控制的基本工作原理"><a href="#微程序控制的基本工作原理" class="headerlink" title="微程序控制的基本工作原理"></a>微程序控制的基本工作原理</h1><p>机器指令取入<code>IR</code>后，对操作码进行译码，得到相应指令的第一条微指令的地址。</p><ul><li><p><code>MAPROM</code></p><p>  指令译码器可用只读存储器组成，将操作码作为<code>MAPROM</code>的地址输入，该单元的内容即相应指令第一条微指令的地址，之后由微指令的下址字段指出下一条微指令的地址。</p><p>  根据微指令地址从控制存储器中取出微指令，并将它存放在微指令寄存器中。控制字段各位直接与受控门相连，由此生成控制信号。</p></li></ul><h1 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h1><h2 id="水平型微指令"><a href="#水平型微指令" class="headerlink" title="水平型微指令"></a>水平型微指令</h2><p>在一条微指令中定义并执行多个<strong>并行</strong>微命令，所以速度比垂直型微指令快。</p><p>直接控制法、字段编译法经常应用在同一条水平型微指令中。</p><h2 id="垂直型微指令"><a href="#垂直型微指令" class="headerlink" title="垂直型微指令"></a>垂直型微指令</h2><p>在微指令中设置有微操作码字段，由其规定微指令的功能。</p><p>不强调微指令的并行控制功能</p><h2 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h2><p>从实现原理和性能两个方面比较。</p><ol><li>水平型微指令并行操作能力强，效率高，灵活性强</li><li>水平型微指令实现一条机器指令的执行时间短</li><li>水平型微指令字长较长，但微程序短</li><li>水平型微指令用户难以掌握</li></ol><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;控制器作用&quot;&gt;&lt;a href=&quot;#控制器作用&quot; class=&quot;headerlink&quot; title=&quot;控制器作用&quot;&gt;&lt;/a&gt;控制器作用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;控制程序的执行&lt;/p&gt;
&lt;p&gt;  即协调并控制计算机各部件执行程序的指令序列。&lt;/p&gt;
&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第四章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第四章复习/</id>
    <published>2019-06-28T13:37:54.000Z</published>
    <updated>2019-06-28T13:39:23.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h1><h2 id="按在计算机中的作用（层次）分类"><a href="#按在计算机中的作用（层次）分类" class="headerlink" title="按在计算机中的作用（层次）分类"></a>按在计算机中的作用（层次）分类</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>简称主存，又称内存储器（内存）。</p><p>CPU可直接随机对其进行访问，也可以和Cache交换数据。</p><p>特点：容量较小、存取速度较快、单位价格较高。</p><h3 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h3><p>简称辅存，又称外存储器（外存）。</p><p><strong>不能</strong>与CPU直接交换信息。</p><p>特点：容量极大、存取速度较慢、单位成本低。</p><h3 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h3><p>简称Cache，位于主存和CPU之间。</p><p>特点：存储容量小、价格高。</p><h2 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h2><h3 id="磁表面存储器"><a href="#磁表面存储器" class="headerlink" title="磁表面存储器"></a>磁表面存储器</h3><p>比如磁盘、磁带。</p><h3 id="磁心存储器"><a href="#磁心存储器" class="headerlink" title="磁心存储器"></a>磁心存储器</h3><h3 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h3><h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>集成度低，功耗高，速度快</p><h4 id="MOS"><a href="#MOS" class="headerlink" title="MOS"></a>MOS</h4><p>集成度高，功耗低，速度慢。</p><p>所以现在内存主要用的MOS型存储器。</p><h3 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h3><p>比如光盘。</p><h2 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h2><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>随机读写存储器。存取时间与存储单元物理地址无关。</p><p>优点：读写方便、使用灵活，断电后内容丢失。</p><p>主要用作主存或Cache。</p><h4 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h4><p>以触发器原理寄存信息。</p><h4 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h4><p>以电容充电原理寄存信息。</p><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>只读存储器。（Read Only）</p><p>只能<strong>随机读出</strong>而不能写入，断电后内容不会丢失。</p><p>可与RAM共同作为主存的一部分。</p><h3 id="串行访问存储器"><a href="#串行访问存储器" class="headerlink" title="串行访问存储器"></a>串行访问存储器</h3><p>读写时，需按其物理位置的先后顺序寻址。</p><h4 id="顺序存取存储器"><a href="#顺序存取存储器" class="headerlink" title="顺序存取存储器"></a>顺序存取存储器</h4><p>如磁带。</p><p>特点：只能按某种顺序存取，存取速度慢。</p><h4 id="直接存取存储器"><a href="#直接存取存储器" class="headerlink" title="直接存取存储器"></a>直接存取存储器</h4><p>如磁盘。</p><p>存取方式介于RAM和顺序存取存储器，通常先寻找整个存储器中的某个区域（如磁盘上的磁道），再在小区域内顺序查找。</p><h2 id="按信息可保存性分类"><a href="#按信息可保存性分类" class="headerlink" title="按信息可保存性分类"></a>按信息可保存性分类</h2><h3 id="易失性存储器"><a href="#易失性存储器" class="headerlink" title="易失性存储器"></a>易失性存储器</h3><p>断电内容丢失，如RAM。</p><h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><p>断电内容不丢失，如ROM、磁表面存储器和光存储器。</p><p>又可分为</p><p>E代表可擦写（Erase），P代表可编程（Programming）</p><ul><li>$ROM$</li><li>$PROM$</li><li>$EPROM$</li><li>$E^2PROM$，多出来的这个E代表电（Electric）</li><li>$Flash\ Memory$</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>CD-ROM是只读型<strong>光盘</strong>存储器。</p></li><li><p>磁盘是<strong>直接存取存储器</strong>。</p></li><li><p>相联存储器是按<strong>内容指定方式</strong>和<strong>地址指定方式</strong>相结合进行寻址的寄存器。</p><p>  相联存储器的基本原理：把存储单元的一部分内容作为检索项去检索存储器，并将存储器中与该检索项符合的存储单元内容进行读或写。</p></li><li><p>若OS在硬盘上，则内存储器应用RAM和ROM。</p><p>  需将外存中的OS（部分）引导进内存，而引导程序通常用ROM存放。</p><p>  另外ROM还经常存放操作系统等需要频繁使用，尤其是停电后不允许丢失的程序或数据。</p></li></ul><h1 id="RAM-1"><a href="#RAM-1" class="headerlink" title="RAM"></a>RAM</h1><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><p>6管结构。TTL</p><p>读出时，根据两条位线中哪一条有负脉冲来判断触发器的状态。</p><p>写入时，根据两条位线电平来写入1或0。</p><h2 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h2><p>MOS电容</p><ul><li><p>DRAM采用地址复用策略（地址时分复用）。</p><p>  目的：使DRAM芯片的地址管脚减少一半，从而减小器件尺寸。</p></li></ul><h3 id="刷新（再生）"><a href="#刷新（再生）" class="headerlink" title="刷新（再生）"></a>刷新（再生）</h3><p>DRAM通过读出方式实现再生，读出放大器作为一个再生放大器。</p><p>DRAM刷新的单位是行，每列都有自己的读放。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li><p>破坏性读出：某个存储单元被读出时，原存储信息被破坏。</p><p>  破坏性读出的存储器，每次读出后，必须紧接一个再生的操作，以恢复被破坏的信息。</p></li><li><p>另外由于电容漏电阻的存在，也需要进行再生。</p></li></ul><h4 id="常见方式"><a href="#常见方式" class="headerlink" title="常见方式"></a>常见方式</h4><ul><li><p>集中刷新</p><p>  在一个刷新周期内，利用一段固定时，依次对存储器所有行进行刷新，在此期间停止对存储器的读写操作，成为访存“<strong>死区</strong>”。</p></li><li><p>分散刷新</p><p>  把对每行的刷新分散到各个工作周期内，增加了存储周期，但没有死区。</p></li><li><p>分布式刷新（异步刷新）</p><p>  介于集中刷新和分散刷新。</p></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>六个方面：集成度、速度、功耗、价格、容量、原理、刷新</p><ul><li>DRAM价格便宜（因此一般容量大，用作内存；而SRAM则用作Cache），集成度高，功耗低；但速度慢，还需要时间和电路进行再生（刷新）。</li><li>SRAM利用触发器保存信息，DRAM利用电容存储电荷保存信息。</li><li>DRAM需要刷新，SRAM不用刷新。</li><li>DRAM采用地址复用策略，SRAM不采用。</li></ul><h1 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h1><p>主要有3个性能指标，三者相互制约。</p><p>目标：大容量、低成本和高速度。</p><h2 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h2><p>存储字数$\times$字长，如1M$\times$8位。</p><h2 id="单位成本"><a href="#单位成本" class="headerlink" title="单位成本"></a>单位成本</h2><p>总成本/总容量。</p><h2 id="存储速度"><a href="#存储速度" class="headerlink" title="存储速度"></a>存储速度</h2><h3 id="存取时间"><a href="#存取时间" class="headerlink" title="存取时间"></a>存取时间</h3><p>完成一次存储器操作的时间，分为读取时间和写入时间。</p><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><p>又称读写周期或访问周期。连续两次操作存储器之间的最小时间间隔。</p><p>通常存取周期大于存取时间，因为它多了个复原时间。</p><p>复原时间：</p><ul><li><p>SRAM</p><p>  存取信息的稳定时间。</p></li><li><p>DRAM</p><p>  刷新的又一次存取时间，刷新是通过读出实现的。</p></li></ul><p>对于破坏性读出的存储器，存取周期往往比存取时间大得多。</p><h3 id="主存带宽"><a href="#主存带宽" class="headerlink" title="主存带宽"></a>主存带宽</h3><p>又称数据传输率，每秒从主存进出信息的最大数量。</p><h1 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h1><p>读写控制线可以是一根（$\bar{WE}$），也可以是两根（$\bar{WE}$和$\bar{RD}$）。</p><p>字扩展、位扩展和字位扩展是重点（两种操作，如何画图），看PPT上作业及答案。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><div class="table-container"><table><thead><tr><th style="text-align:center">顺序</th><th style="text-align:center">位扩展</th><th style="text-align:center">字扩展</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">地址线与各芯片并联，CPU$\bar{WE}$与各芯片$\bar{WE}$并联</td><td style="text-align:center">低位地址线与各芯片并联，CPU$\bar{WE}$与各芯片$\bar{WE}$并联</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">各芯片$\bar{CS}$并联接地</td><td style="text-align:center">高位地址经译码器各输出分别连接各芯片$\bar{CS}$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">各芯片数据引到数据线（算是串行）</td><td style="text-align:center">各芯片数据引到数据线（算是并行）</td></tr></tbody></table></div><p>四个要素：$\bar{WE}$、$\bar{CS}$、地址线、数据线</p><h1 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h1><ul><li><p>解决的主要问题是<strong>提高主存储器的数据传输率</strong></p></li><li><p>采用低位交叉编址方式</p><p>  低位地址选择不同的存储模块，高位地址指向相应的模块内部的存储字。因此，连续的地址分部在相邻的不同模块中。</p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储器分类&quot;&gt;&lt;a href=&quot;#存储器分类&quot; class=&quot;headerlink&quot; title=&quot;存储器分类&quot;&gt;&lt;/a&gt;存储器分类&lt;/h1&gt;&lt;h2 id=&quot;按在计算机中的作用（层次）分类&quot;&gt;&lt;a href=&quot;#按在计算机中的作用（层次）分类&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第三章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第三章复习/</id>
    <published>2019-06-28T13:37:48.000Z</published>
    <updated>2019-06-28T13:39:12.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h2 id="2进制转8进制"><a href="#2进制转8进制" class="headerlink" title="2进制转8进制"></a>2进制转8进制</h2><p>从小数点开始向左向右，3个一组换算成8进制，缺位补0。</p><p>如例3.4</p><h2 id="8进制转2进制"><a href="#8进制转2进制" class="headerlink" title="8进制转2进制"></a>8进制转2进制</h2><p>将一位8进制数换算成3位2进制数。</p><p>如例3.6</p><h2 id="2进制转16进制"><a href="#2进制转16进制" class="headerlink" title="2进制转16进制"></a>2进制转16进制</h2><p>从小数点开始向左向右，4个一组换算成16进制，缺位补0。</p><h2 id="16进制转2进制"><a href="#16进制转2进制" class="headerlink" title="16进制转2进制"></a>16进制转2进制</h2><p>将一位16进制数换算成4位2进制数。</p><h2 id="8进制转16进制-拓展"><a href="#8进制转16进制-拓展" class="headerlink" title="8进制转16进制(拓展)"></a>8进制转16进制(拓展)</h2><p>从小数点开始向左向右，<strong>2</strong>个一组换算成16进制，缺位补0。可以先变成2进制，再变成16进制。</p><p>如表3.1</p><h2 id="2进制转10进制"><a href="#2进制转10进制" class="headerlink" title="2进制转10进制"></a>2进制转10进制</h2><p>每位2进制数乘以它的权重，再求和。8421</p><p>如例3.1</p><h2 id="10进制转2进制"><a href="#10进制转2进制" class="headerlink" title="10进制转2进制"></a>10进制转2进制</h2><h3 id="整数部分"><a href="#整数部分" class="headerlink" title="整数部分"></a>整数部分</h3><p><strong>除2取余至商为0</strong>，先求出来的余数靠近小数点（低位）。</p><p>如例3.7</p><h3 id="小数部分"><a href="#小数部分" class="headerlink" title="小数部分"></a>小数部分</h3><p><strong>小数部分</strong> <strong>乘2取整至小数部分为0</strong>或满足精度要求，先求出来的整数靠近小数点（高位）。</p><p>如例3.8</p><h1 id="机器数的表示"><a href="#机器数的表示" class="headerlink" title="机器数的表示"></a>机器数的表示</h1><ul><li>机器数有三种表示方式：原码、反码和补码。</li></ul><p>我们先假设机器数为小数，符号为放在最左边，小数点置于符号位和数值之间。</p><h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><ul><li>即<code>±绝对值</code>，用$X$表示，正号有时可省略。</li></ul><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><ul><li>最高位为符号位，0表示正数，1表示负数，绝对值跟随其后。</li><li>小数点的位置默认在符号位之后，书写时可以将小数点保留或省略。</li></ul><p>0的原码有两种表示形式：</p><ul><li>$[+0]_原=00000=0.0000$</li><li>$[-0]_原=10000=1.0000$</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><ul><li>正数的补码与其原码一样</li><li>补码零的表示形式唯一：$[+0]_补=[-0]_补=00000=0.0000$</li></ul><h3 id="负数原码补码互求"><a href="#负数原码补码互求" class="headerlink" title="负数原码补码互求"></a>负数原码补码互求</h3><ol><li>符号位不变</li><li>数据位按位取反</li><li>末位+1</li></ol><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>若加法运算不超过机器范围时：</p><ul><li><p>加法结果仍为补码</p></li><li><p>$[X+Y]_补=[X]_补+[Y]_补$</p><p>  $[X-Y]_补=[X]_补+[-Y]_补$</p></li><li><p><strong>符号位也参与运算</strong></p></li></ul><h3 id="由-Y-补-求-Y-补"><a href="#由-Y-补-求-Y-补" class="headerlink" title="由$[Y]_补$求$[-Y]_补$"></a>由$[Y]_补$求$[-Y]_补$</h3><ol><li>$[Y]_补$<strong>所有位</strong>取反</li><li>末位+1</li></ol><h3 id="证明-X-Y-补-X-补-Y-补"><a href="#证明-X-Y-补-X-补-Y-补" class="headerlink" title="证明$[X+Y]_补=[X]_补+[Y]_补$"></a>证明$[X+Y]_补=[X]_补+[Y]_补$</h3><p>补码定义：</p><script type="math/tex; mode=display">[X]_补=\begin{cases}         X,0\leq X<1\\2+X,-1\leq X<0\end{cases}</script><ol><li><p>$X&gt;0,Y&gt;0$</p><p>可知$X+Y&gt;0$，所以$[X+Y]_补=X+Y=X_补+Y_补$。</p></li><li><p>$X&gt;0,Y&lt;0$</p><p> $[X]_补=X$</p><p> $[Y]_补=2+Y$</p><p> $[X+Y]_补=X+Y=X_补+Y_补$</p></li><li><p>==待续==</p></li></ol><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><ul><li>正数的反码与其原码一样</li></ul><h3 id="负数原码反码互求"><a href="#负数原码反码互求" class="headerlink" title="负数原码反码互求"></a>负数原码反码互求</h3><ol><li>符号位不变</li><li>数据位按位取反</li></ol><h1 id="加减法运算的溢出判断"><a href="#加减法运算的溢出判断" class="headerlink" title="加减法运算的溢出判断"></a>加减法运算的溢出判断</h1><p>有进位$\neq$溢出</p><p>只有两个同号数相加或两个异号数相减，才有可能溢出。</p><p>定点运算器中，无论双符号位还是单符号位，必须有<strong>溢出判断电路</strong>，它一般由<strong>异或门</strong>来实现。</p><p>以下为三种方法（双符号位法较重要）：</p><ul><li><p>当符号相同的两数相加时，结果的符号与加数或被加数不相同，则为溢出。</p></li><li><p>当任意符号两数相加时，如果$C\neq C_f$，则为溢出，即溢出条件为$C\bigoplus C_f$，其中$C$为数值最高位的进位，$C_f$为符号位的进位。</p></li><li><p>采用<strong>双符号位</strong>$f_{S2}f_{S1}$，正数双符号位为00，负数双符号位为11。</p><p>  两个符号位都参与运算，如果结果$f_{S1}\neq f_{S2}$，则为溢出，即溢出条件为$f_{S1}\bigoplus f_{S2}$。</p><p>  若采用双符号位，运算结果的符号位为高符号位$f_{S2}$。</p></li></ul><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>浮点数指小数点位置可浮动的数据，通常以下式表示：</p><script type="math/tex; mode=display">N=M\times R^E</script><ul><li><p>$N$</p><p>  浮点数</p></li><li><p>$M$</p><p>  尾数，mantissa</p></li><li><p>$E$</p><p>  阶码，exponent（幂）</p></li><li><p>$R$</p><p>  阶的基数，radix（进制、基数），$R$为一常数，在一台计算机中，所有数据的$R$都是相同的，不需要在每个数据中表示出来。</p></li></ul><p>浮点数的机内表示一般采用以下形式</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">$M_S$</th><th style="text-align:center">$E$</th><th style="text-align:center">$M$</th></tr></thead><tbody><tr><td style="text-align:center">位数</td><td style="text-align:center">1</td><td style="text-align:center">$n+1$</td><td style="text-align:center">$m$</td></tr><tr><td style="text-align:center">说明</td><td style="text-align:center">尾数的符号位</td><td style="text-align:center">阶码，<strong>其中最高位为符号位</strong>，表示正阶或负阶</td><td style="text-align:center">尾数</td></tr></tbody></table></div><h2 id="尾数规格化"><a href="#尾数规格化" class="headerlink" title="尾数规格化"></a>尾数规格化</h2><ul><li><p>定义</p><p>  <strong>为了保证（极高）数据精度</strong>，尾数通常用规格化形式表示：当$R=2$，且尾数值不为0时，尾数绝对值应$\geq(0.5)_{10}$。</p></li><li><p>方法</p><p>  对非规格化浮点数，通过将尾数左移或右移，并修改阶码值使之满足规格化要求。</p><p>  尾数左移几位，阶码也减少几；尾数右移几，阶码就增加几。</p></li><li><p>机器零</p><p>  当一个浮点数的尾数为0或阶码的值比在机器中表示的最小值还小时，计算机都把该浮点数看成零值，称为<strong>机器零</strong>。</p></li></ul><p>在多数通用机中，浮点数的<strong>尾数</strong>用<strong>原码或补码</strong>表示，<strong>阶码</strong>用<strong>补码</strong>或<strong>移码</strong>表示。</p><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><ul><li>$[X]_补$符号位取反后即为$[X]_移$。</li><li>计算机中，<strong>移码</strong>（阶码）只进行<strong>加减法运算</strong>，且需要对得到的结果进行修正，即<strong>对结果的符号位求反</strong>。</li><li>数据零有惟一的编码，$[+0]_移=[-0]_移=1000\dots0$。当数据小于计算机能表示的最小值时，称为<strong>机器零</strong>，将阶码（移码）置为$0000\dots0$，且不管尾数值是多少，都按浮点数下溢处理。</li></ul><h2 id="数值范围和精度"><a href="#数值范围和精度" class="headerlink" title="数值范围和精度"></a>数值范围和精度</h2><ul><li><p>定义</p><ul><li><p>数值范围</p><p>  机器所能表示的一个数的最大值和最小值之间的范围</p></li><li><p>数据精度</p><p>  一个数的有效位数</p></li></ul></li><li><p>常用浮点数（IEEE754国际标准）</p><p>  基数$R$为2，阶码采用移码（也称增码），尾数采用原码。因为规格化原码尾数的最高位恒为1，所以不再尾数中表示出来，计算时在尾数前边自动添上1。</p><p>  |        浮点数类型        |   阶码   |         尾数          |<br>  | :———————————: | :———: | :—————————-: |<br>  | 单精度浮点数（<strong>32</strong>位） | <strong>8位</strong>  | 24位（内含1位符号位） |<br>  | 双精度浮点数（<strong>64</strong>位） | <strong>11位</strong> | 53位（内含1位符号位） |</p></li></ul><h1 id="浮点数的加减法运算"><a href="#浮点数的加减法运算" class="headerlink" title="浮点数的加减法运算"></a>浮点数的加减法运算</h1><p>有5步操作，如下：</p><ol><li><p><strong>对阶</strong></p><p>阶码较小的浮点数尾数右移$\Delta E$位，其阶码值加上$\Delta E$。</p><p>若<strong>尾数</strong>是<strong>原码</strong>表示的，是<strong>无符号移位</strong>；</p><p>若<strong>尾数</strong>是<strong>补码</strong>表示的，是<strong>带符号移位</strong>。（上边也讲了补码的符号位参与运算嘛）</p></li><li><p><strong>尾数的加减运算</strong></p><p>两尾数进行加减运算，得到两尾数之和/差。</p></li><li><p><strong>规格化操作</strong></p></li></ol><ul><li><p><strong>左规</strong></p><p>  如果结果两符号位值相同，则尾数加减结果<strong>未溢出</strong>。</p><p>  但若最高数值位与符号位相同，此时尾数连续左移，直至<strong>最高数值位</strong>与<strong>符号位</strong>的值不同为止，同时从阶码中减去移位的位数。</p></li><li><p><strong>右规</strong></p><p>  如果结果两符号位值不同，则尾数加减结果<strong>溢出</strong>。此时将尾数结果右移1位，阶码+1。</p></li></ul><ol><li><p><strong>舍入</strong></p><p>作用：处理尾数右移（右规或对阶）时丢失的低位。</p><p>当<strong>丢失的最高位</strong>为1时，在尾数末位+1，如果加1使尾数溢出，就再进行一次右规。</p></li><li><p><strong>检查阶码是否溢出</strong></p><p>阶码溢出表示浮点数溢出。</p><p>若阶码下溢，则置运算结果为机器零（通常尾数和阶码全部置0）；若上溢，则置溢出标志。</p></li></ol><h1 id="定点原码一位乘法"><a href="#定点原码一位乘法" class="headerlink" title="定点原码一位乘法"></a>定点原码一位乘法</h1><h1 id="定点补码一位乘法"><a href="#定点补码一位乘法" class="headerlink" title="定点补码一位乘法"></a>定点补码一位乘法</h1><h1 id="定点原码一位除法"><a href="#定点原码一位除法" class="headerlink" title="定点原码一位除法"></a>定点原码一位除法</h1><h1 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>码距</strong>：根据任意两个合法码之间至少有几个二进制位确定，若仅有1位不同，则称其码距为1。</p><p>使码距由1增加到2。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>为1个字节（8位）补充1位到高位</strong>，称为<strong>校验位</strong>；低8位为<strong>数据位</strong>。</p><p>添加校验位，使<strong>1的个数</strong>为<strong>奇数</strong>时，这种方法称为<strong>奇校验</strong>；使<strong>1的个数</strong>为<strong>偶数</strong>时，称为<strong>偶校验</strong>。</p><ul><li><p>奇校验</p><p>  若数据位中有奇数个1，校验位为0；若有偶数个1，校验位为1。</p></li><li><p>偶校验</p><p>  若数据位中有奇数个1，校验位为1；若有偶数个1，校验位为0。</p></li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><strong>发现1位或奇数个位错</strong>。</li><li>不能确定哪一位错，也不能发现偶数个位错。</li></ul><p>记住第一句话即可，它的功能只有第一句话，所以第二句可有可无。</p><h1 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>海明校验码基于<strong>偶校验</strong>。</p><p>在数据中加入$r$个校验位，并把数据的每一个二进制位（共$k$个数据位）分配在几个奇偶校验组中，即<strong>一个数据位由多个校验位校验</strong>。</p><script type="math/tex; mode=display">2^r-1-r\geq k</script><ul><li>$2^r$：$r$个校验码可以表示$2^r$个信息。</li><li>$-1$：用1个信息表示没有错误。</li><li>$-r$：错误也可能发生在$r$个校验位。</li></ul><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>$k$为数据位个数，$r$为校验位个数，$m=r+k$，即海明码的位数。</p><p>海明码（Hamming Code）为$H_mH_{m-1}…H_2H_1$。</p><ul><li>$H_i$为第$i$个海明码位。</li><li>$P_i$为第$i$个校验位（Parity Bit）。</li><li>$D_i$为第$i$个数据位（Data Bit）。</li></ul><h3 id="确定校验位的位置"><a href="#确定校验位的位置" class="headerlink" title="确定校验位的位置"></a>确定校验位的位置</h3><p>每位海明码由多个校验位校验，规律如下式：</p><script type="math/tex; mode=display">每位海明码的位号=检验该位海明码的各校验位位号之和</script><p>由上式可知，第$i$个校验位$P_i$的海明码位号为$2^{i-1}$或最高位，海明码的其他位为数据位。</p><h3 id="确定校验位的表达式-P-i"><a href="#确定校验位的表达式-P-i" class="headerlink" title="确定校验位的表达式$P_i$"></a>确定校验位的表达式$P_i$</h3><p>根据偶校验原理可得：</p><script type="math/tex; mode=display">P_i=该校验位校验的各数据位的异或</script><h3 id="确定校验和表达式-S-i"><a href="#确定校验和表达式-S-i" class="headerlink" title="确定校验和表达式$S_i$"></a>确定校验和表达式$S_i$</h3><script type="math/tex; mode=display">校验和的个数=校验位的个数=偶校验组的个数</script><script type="math/tex; mode=display">S_i​=每组偶校验组各位的异或</script><p><strong>若某校验和的值为0，说明该组没有错。若所有校验和值为0，则海明码没有出错</strong>。</p><h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h3><p>根据所有校验和的值及其表达式，是可以判断出哪一位出了错的。</p><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><p><strong>发现一位错并纠正。</strong></p><p>若想发现两位错，则应再增加一个校验位$S’$，即书上例子里的$S_5$，用来判断是奇数还是偶数个出错。</p><p>若$S’$为0，则说明偶数个出错；若为1，则奇数个出错。</p><p>偶数个出错时，若$S_i$都为0，即$S$的值都为0时，则没有出错。</p><h1 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h1><h2 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h2><h3 id="模2加减"><a href="#模2加减" class="headerlink" title="模2加减"></a>模2加减</h3><p>即异或。</p><h3 id="模2乘"><a href="#模2乘" class="headerlink" title="模2乘"></a>模2乘</h3><p>按模2加求部分积之和。</p><h3 id="模2除"><a href="#模2除" class="headerlink" title="模2除"></a>模2除</h3><p>按模2减求部分余数。</p><p>每求一位商应使部分余数减少一位（即不要最高的一位），并在低位补0。</p><p>当部分余数首位为1时，商取1，减数取除数；</p><p>当部分余数首位为0时，商取0，减数取0。</p><h2 id="编码方法"><a href="#编码方法" class="headerlink" title="编码方法"></a>编码方法</h2><h3 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h3><p>$(n,k)码$，其中高$k$位是数据位；<strong>后$r$位是校验位</strong>（与奇偶校验不同）；$n=k+r$为CRC码的长度。</p><p>令$M$为数据位；$G$为生成多项式（Generator Polynomial），它有$r+1$位。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>$M$左移$r$位得$M’$，$M’$模2除以$G$。</p><p>设所得余数（Remainder）为$R$，$r$位；商（Quotient）为$Q$。</p><p>$M’$加上$R$即得CRC码。</p><h2 id="纠错方法"><a href="#纠错方法" class="headerlink" title="纠错方法"></a>纠错方法</h2><h3 id="判断错误"><a href="#判断错误" class="headerlink" title="判断错误"></a>判断错误</h3><p>CRC码模2除以$G$是可以除尽的。</p><p>若余数为0，则无误；</p><p>若余数不为0，则某一位出错，且不同位出错，余数不同。</p><p>余数与出错位对应关系不变，只与码制和生成多项式有关。</p><h3 id="纠错-1"><a href="#纠错-1" class="headerlink" title="纠错"></a>纠错</h3><p>得到一个不为0的余数后：</p><p>在其右侧补0，继续除下去（余数的变化是规律的），每除一次的同时将CRC码循环左移。</p><p>循环该操作至余数为101（$G$为1011时），此时出错位在最高位。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h1&gt;&lt;h2 id=&quot;2进制转8进制&quot;&gt;&lt;a href=&quot;#2进制转8进制&quot; class=&quot;headerlink&quot; title=&quot;2进制
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第二章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第二章复习/</id>
    <published>2019-06-28T13:37:42.000Z</published>
    <updated>2019-06-28T13:39:04.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两种电路"><a href="#两种电路" class="headerlink" title="两种电路"></a>两种电路</h1><h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><p>输出只和当前输入有关</p><h2 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h2><p>输出不仅和当前输入有关，还和原来状态有关。</p><h1 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h1><p>$n$位输入，最多$2^n$个输出。</p><p>给定$n$位输入后，输出中仅有对应的那一个为1（或0），其他都为0（或1）。</p><h1 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h1><p>从多个输入中选择某一个作为输出。</p><h1 id="181和182"><a href="#181和182" class="headerlink" title="181和182"></a>181和182</h1><ul><li>181实现了<strong>位间快速进位</strong>。（4位，AM2901也是）</li><li>182实现了<strong>组间快速进位</strong>。（4组，AM2902也是）</li></ul><p>例题：</p><p>如果实现64位快速运算，需要多少个181和多少个182？</p><ul><li><p>181</p><p>  $\frac{64}{4}=16$</p></li><li><p>182</p><p>  $\frac{16}{4}=4，\frac{4}{4}=1$</p><p>  $4+1=5$</p></li></ul><p>如果是128位呢</p><ul><li><p>181</p><p>  $\frac{128}{4}=32$</p></li><li><p>182</p><p>  $\frac{32}{4}=8，\frac{8}{4}=2，\frac{2}{4}=1$</p><p>  $8+2+1=11$</p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;两种电路&quot;&gt;&lt;a href=&quot;#两种电路&quot; class=&quot;headerlink&quot; title=&quot;两种电路&quot;&gt;&lt;/a&gt;两种电路&lt;/h1&gt;&lt;h2 id=&quot;组合逻辑电路&quot;&gt;&lt;a href=&quot;#组合逻辑电路&quot; class=&quot;headerlink&quot; title=&quot;组合逻辑电
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第一章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第一章复习/</id>
    <published>2019-06-28T13:37:32.000Z</published>
    <updated>2019-06-28T13:38:57.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冯诺依曼型计算机特点"><a href="#冯诺依曼型计算机特点" class="headerlink" title="冯诺依曼型计算机特点"></a>冯诺依曼型计算机特点</h1><h2 id="存储程序-核心特点"><a href="#存储程序-核心特点" class="headerlink" title="存储程序(核心特点)"></a>存储程序(核心特点)</h2><ul><li>采用<strong>存储程序</strong>方式，程序和数据放在同一个存储器中，以二进制表示。</li></ul><h2 id="五部分组成"><a href="#五部分组成" class="headerlink" title="五部分组成"></a>五部分组成</h2><p>各部分通过<strong>数据总线、地址总线、控制总线</strong>传递信息，进行联系。</p><ul><li><p>运算器</p><p>  对数据进行运算</p></li><li><p>控制器</p><p>  实现程序的自动执行</p></li><li><p>存储器</p><p>  存放程序和数据</p></li><li><p>输入设备</p><p>  输入原始数据和处理这些数据的程序</p></li><li><p>输出设备</p><p>  输出计算机的处理结果</p></li></ul><h2 id="指令的组成"><a href="#指令的组成" class="headerlink" title="指令的组成"></a>指令的组成</h2><ul><li>由<strong>操作码</strong>和<strong>地址码</strong>组成</li></ul><h2 id="运算器为中心"><a href="#运算器为中心" class="headerlink" title="运算器为中心"></a>运算器为中心</h2><ul><li>输入输出设备与存储器间的数据传送都通过运算器</li></ul><h2 id="指令的存放和执行"><a href="#指令的存放和执行" class="headerlink" title="指令的存放和执行"></a>指令的存放和执行</h2><ul><li>指令在存储器中<strong>按执行顺序存放</strong></li></ul><h1 id="电子计算机的发展"><a href="#电子计算机的发展" class="headerlink" title="电子计算机的发展"></a>电子计算机的发展</h1><ol><li>电子管计算机</li><li>晶体管计算机</li><li>集成电路计算机</li><li>大规模集成电路计算机</li><li>超大规模集成电路计算机</li></ol><h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h2 id="软件系统"><a href="#软件系统" class="headerlink" title="软件系统"></a>软件系统</h2><h2 id="硬件系统"><a href="#硬件系统" class="headerlink" title="硬件系统"></a>硬件系统</h2><h1 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h1><p>==字长==</p><p>==容量==</p><p>==CIP==</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冯诺依曼型计算机特点&quot;&gt;&lt;a href=&quot;#冯诺依曼型计算机特点&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼型计算机特点&quot;&gt;&lt;/a&gt;冯诺依曼型计算机特点&lt;/h1&gt;&lt;h2 id=&quot;存储程序-核心特点&quot;&gt;&lt;a href=&quot;#存储程序-核心特点&quot; c
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-域名系统DNS</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机网络-域名系统DNS/</id>
    <published>2019-06-28T13:34:24.000Z</published>
    <updated>2019-06-28T13:36:28.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>把互连网上的主机名转换为IP地址</p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>当某一个应用进程需要把主机名解析为IP地址时，该应用进程就调用<strong>解析程序</strong>，并成为DNS的一个<strong>客户</strong>。</p><p>把待解析的域名放在<strong>DNS请求报文</strong>中，以<strong>UDP用户数据报</strong>方式发给<strong>本地域名服务器</strong>。</p><p>本地域名服务器在查找域名后，把对应的IP地址放在<strong>回答报文</strong>中返回，应用进程获得目的主机的IP地址。</p><p>若本地域名服务器不能回答该请求，则此域名服务器暂时成为DNS的另一个<strong>客户</strong>（递归查询），并向其他域名服务器发出查询请求（一般迭代查询），直至找到能够回答该请求的域名服务器。</p><h1 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h1><p>采用<strong>层次树状结构</strong>的命名方法。</p><p><strong>域</strong>：名字空间中一个可被管理的划分，域还可以划分为子域，子域还可以划分为子域，形成顶级域、二级域、三级域等等。</p><p>DNS不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</p><p>域名是从右往左看的，越往右等级越高。</p><h1 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h1><p>DNS服务器的管辖范围是<strong>以区为单位</strong>，区可能等于或小于域，但一定不能大于域，即区是域的子集。</p><p>一个服务器所负责管辖（或有权限的）的范围叫做<strong>区</strong>。</p><p>一个区中的所有节点必须是能够连通的。</p><p><strong>每个区</strong>设置响应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的域名到IP地址的映射。</p><h2 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h2><p>根域名服务器是最高层次的域名服务器。</p><p>所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。</p><h2 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h2><p>负责管理在该顶级域名下注册的所有二级域名。</p><h2 id="权限域名服务器"><a href="#权限域名服务器" class="headerlink" title="权限域名服务器"></a>权限域名服务器</h2><p>负责一个区的域名服务器。</p><h2 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h2><p><strong>当一台主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。</strong></p><p>不管哪一个<strong>本地域名服务器</strong>，若要对一个域名进行解析，<strong>只要自己无法解析，就首先要求助于根域名服务器</strong>。</p><h1 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h1><h2 id="主机向本地域名服务器查询"><a href="#主机向本地域名服务器查询" class="headerlink" title="主机向本地域名服务器查询"></a>主机向本地域名服务器查询</h2><p>一般采用<strong>递归查询</strong>。</p><p>如果本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器会以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即<strong>替主机继续查询</strong>）。</p><p>递归查询的结果：</p><ul><li>查到的IP地址</li><li>报错，表示无法查询到所需的IP地址</li></ul><h2 id="本地域名服务器向根域名服务器查询"><a href="#本地域名服务器向根域名服务器查询" class="headerlink" title="本地域名服务器向根域名服务器查询"></a>本地域名服务器向根域名服务器查询</h2><p>一般采用<strong>迭代查询</strong>。</p><p>根域名服务器收到本地域名服务器发出的迭代查询请求报文时，本地域名服务器收到的查询结果有两种：</p><ul><li>查到的IP地址</li><li>下一步向哪个域名服务器查询</li></ul><p>顶级域名服务器在收到本机域名服务器的查询请求后，收到的结果有两种：</p><ul><li>查到的IP地址</li><li>下一步向哪个权限域名服务器查询</li></ul><p>就这样，本地域名服务器就这样进行迭代查询，最终把得到的结果返回给发起查询的主机。</p><h1 id="高速缓存域名服务器"><a href="#高速缓存域名服务器" class="headerlink" title="高速缓存域名服务器"></a>高速缓存域名服务器</h1><p>功能：用来存放<strong>最近查询过的域名</strong>以及<strong>从何处获得域名映射信息</strong>的记录。</p><p>好处：<strong>提高DNS查询效率</strong>，<strong>减轻根域名服务器的负荷</strong>和<strong>减少互联网上的DNS查询报文数量</strong>。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h1&gt;&lt;p&gt;把互连网上的主机名转换为IP地址&lt;/p&gt;
&lt;h1 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-运输层复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机网络-运输层复习/</id>
    <published>2019-06-28T13:34:11.000Z</published>
    <updated>2019-06-28T13:36:06.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>实现两台主机中<strong>进程之间</strong>的通信。</p><ul><li><p>复用和分用</p><ul><li><p>复用</p><p>  多个应用层进程可使用同一运输层服务</p></li><li><p>分用</p><p>  运输层把收到的信息分别交付上面应用层的相应进程</p></li></ul></li><li><p>提供可靠性</p></li></ul><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul><li>面向连接</li><li><strong>面向字节流</strong></li><li>提供可靠性</li><li>不提供广播或多播服务</li><li>协议数据单元是<strong>TCP报文段</strong></li><li>有拥塞控制</li></ul><p>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p><p><strong>套接字</strong>：IP地址+端口号</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><ul><li>无连接</li><li>面向报文（给什么数据，传什么数据）</li><li>尽最大努力交付</li><li>可以一对多、多对一、多对多</li><li>协议数据单元是<strong>UDP用户数据报</strong></li><li>没有拥塞控制</li></ul><h1 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h1><ul><li><p><strong>无差错情况</strong>：停止等待</p><p>  每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。</p></li><li><p><strong>出现差错</strong>：超时重传</p><p>  每发送完一个分组时设置一个超时计数器。</p><p>  如果超时还未收到确认，就重传分组；在超时前收到确认则撤销该超时计数器。</p><ul><li><p>A发送完一个分组后<strong>必须暂时保留已发送到分组的副本</strong>，在收到响应确认后才能清除这个副本。</p></li><li><p>分组和确认分组必须进行<strong>编号</strong>，这样才能明确发送出去的分组是哪一个收到了确认，哪一个没有收到确认。</p><p>  可以处理确认迟到的情况。</p></li><li><p>超时计数器设置的<strong>重传时间应当比数据在分组传输的平均往返时间长一些</strong>。如果设定得很长，通信效率就会降低；如果设定得太短，会导致不必要的重传，浪费了网络资源。</p></li></ul></li><li><p><strong>确认丢失</strong></p><p>  确认丢失时，发送方进行超时重传，而<strong>接收方丢弃这个重复的分组</strong>，<strong>向发送方发送确认</strong>。</p></li><li><p><strong>确认迟到</strong></p><p>  确认迟到了，发送方进行超时重传，而<strong>接收方丢弃这个重复的分组</strong>，<strong>向发送方发送确认</strong>。</p><p>  发送方收到迟到的确认什么也不做。</p></li></ul><h1 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h1><p>TCP进行拥塞控制的一种算法。</p><p>拥塞是运输层的概念。</p><p>发送方维持一个变量：<strong>拥塞窗口</strong>，让自己的<strong>发送窗口等于拥塞窗口</strong>，<strong>拥塞窗口的大小取决于网络的拥塞程度</strong>。</p><p><strong>判断网络拥塞的依据就是出现了超时</strong>。网络拥塞时就把拥塞窗口减小一些。</p><p>慢开始：<strong>由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值</strong>。</p><p>发送方每收到一个对新报文段的确认就使发送方的拥塞窗口+1。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h1&gt;&lt;p&gt;实现两台主机中&lt;strong&gt;进程之间&lt;/strong&gt;的通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;复用和分用&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
