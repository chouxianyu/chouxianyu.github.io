<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2020-09-05T07:10:09.479Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT甲级1147Heaps</title>
    <link href="https://chouxianyu.github.io/2020/09/05/PAT%E7%94%B2%E7%BA%A71147Heaps/"/>
    <id>https://chouxianyu.github.io/2020/09/05/PAT甲级1147Heaps/</id>
    <published>2020-09-05T07:08:26.000Z</published>
    <updated>2020-09-05T07:10:09.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个完全二叉树，请判断它是不是堆（大顶堆指父结点的值大于等于子结点的值，小顶堆指父结点的值小于等于子结点的值）</p><ul><li>输入<ul><li>M：需要测试的树的数量，不超过100</li><li>N：每颗树中值的数量，大于1，不超过1000</li><li>M颗树：每颗树包含N个互异的值（int范围内），按照层次遍历的顺序给出</li></ul></li><li>输出<ul><li>对于每颗树，输出它是最大堆还是最小堆，或者它不是个堆，然后后序遍历输出这个树，值之间用空格间隔</li></ul></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>完全二叉树性质<ul><li>如果某结点的序号为<code>i</code>，如果它的左右子结点存在，那左子结点序号为<code>2i</code>，右子结点序号为<code>2i+1</code>。</li><li>相应地，如果某子结点的序号为<code>i</code>，那其父结点的序号为<code>i/2</code>，其中<code>i</code>为int类型、只取<code>i/2</code>所得结果的整数部分。</li></ul></li></ul><ol><li>因为是完全二叉树，所以不用建树，将所有结点按层次遍历的顺序存入数组即可</li><li>遍历除了根结点以外的结点，判断是否违反大顶堆或小顶堆的特点，然后输出是否是堆</li><li>递归实现后序遍历</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1147</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648</span></span><br><span class="line"><span class="comment">// Tags: Tree DFS Heap</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nodes[<span class="number">1005</span>]; <span class="comment">// 存储n个结点</span></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTrace</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) <span class="keyword">return</span> ; <span class="comment">// 避免越界</span></span><br><span class="line">    postOrderTrace(<span class="number">2</span> * i);</span><br><span class="line">    postOrderTrace(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nodes[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, nodes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 读取树</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, nodes+i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isMaxHeap = <span class="literal">true</span>, isMinHeap = <span class="literal">true</span>; <span class="comment">// 遍历判断是否是大小顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (nodes[i] &gt; nodes[i/<span class="number">2</span>]) isMaxHeap = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nodes[i] &lt; nodes[i/<span class="number">2</span>]) isMinHeap = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isMaxHeap) <span class="built_in">printf</span>(<span class="string">"Max Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isMinHeap) <span class="built_in">printf</span>(<span class="string">"Min Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line"></span><br><span class="line">        postOrderTrace(<span class="number">1</span>); <span class="comment">// 后序遍历完全二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/chouxianyu/p/13293152.html" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/p/13293152.html</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="堆" scheme="https://chouxianyu.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1150Travelling Salesman Problem</title>
    <link href="https://chouxianyu.github.io/2020/09/05/PAT%E7%94%B2%E7%BA%A71150Travelling-Salesman-Problem/"/>
    <id>https://chouxianyu.github.io/2020/09/05/PAT甲级1150Travelling-Salesman-Problem/</id>
    <published>2020-09-05T05:03:36.000Z</published>
    <updated>2020-09-05T05:04:26.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>现在给你一些环，请你找到其中与旅行商问题答案最接近的那个环（旅行商问题的定义在此不再说明）</li><li>输入<ul><li>N：大于2，不超过200，城市的数量</li><li>M：无向图中边的数量，</li><li>M条边：每条边表示为<code>City1 City2 Dist</code>，其中城市索引为[1,N]，城市间距离为不超过100的正数</li><li>K：正整数，path的数量</li><li>K条path：每条path的格式为：<code>n c1 c2 c3 … cn</code>，其中n是path中城市的数量，ci是城市索引</li></ul></li><li>输出<ul><li>对于每条path，输出<code>Path X: TotalDist (Description)</code>，其中X是[1,K]，TotalDist是总距离（不存在则输出NA），Description是<ul><li>经过每个城市的简单环：<code>TS simple cycle</code></li><li>经过每个城市的环，但不是简单环：<code>TS cycle</code></li><li>不是经过每个城市的环：<code>Not a TS cycle</code></li></ul></li><li>最终输出<code>Shortest Dist(X) = TotalDist</code>，其中X是和旅行商问题解最接近的那个环的索引，TotalDist是其距离总和。（已确保只有一个解）</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>距离用二维数组表示，默认值为0，为0则说明两个城市间不存在边</p></li><li><p>读取每条path时，用一维数组存储某个节点被访问的次数（注意城市索引是1到N）</p><p>  在路径合法的前提下</p><ul><li>TS cycle：即经过每个城市并且是一个环，即每个城市被访问的次数都大于0且首尾城市相同</li><li>TS simple cycle：在TS cycle的基础上，要求没有子环，只有起点城市被访问过2次，其它城市都只被访问过一次</li></ul></li><li><p>将k个path的结果存放在一维数组中</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1150</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384</span></span><br><span class="line"><span class="comment">// Tags: Graph TSP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> distances[<span class="number">205</span>][<span class="number">205</span>]; <span class="comment">// 各个城市之间的距离。如果为0，则说明两个城市间无边、不可直达</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1, c2, dist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 存储各个城市之间的距离</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;c1, &amp;c2, &amp;dist);</span><br><span class="line">        distances[c1][c2] = distances[c2][c1] = dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bestX, bestDist = INT_MAX;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= k; x++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> numOfCities, firstCity, pathTotalDist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> pathIslegal = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;numOfCities, &amp;firstCity);</span><br><span class="line">        visited[firstCity] += <span class="number">1</span>; <span class="comment">// 访问第一个城市</span></span><br><span class="line">        c1 = firstCity; <span class="comment">// 更新上一个城市</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numOfCities - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c2); <span class="comment">// 读取当前城市</span></span><br><span class="line">            <span class="keyword">if</span> (distances[c1][c2] != <span class="number">0</span>)&#123;</span><br><span class="line">                visited[c2] += <span class="number">1</span>;</span><br><span class="line">                pathTotalDist += distances[c1][c2]; <span class="comment">// 计算该路径的总距离</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// path中两个城市不存在边</span></span><br><span class="line">                pathIslegal = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c1 = c2; <span class="comment">// 更新上一个城市</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pathIslegal)&#123; <span class="comment">// 路径非法</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: NA (Not a TS cycle)\n"</span>, x);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstCity != c2)&#123; <span class="comment">// 在路径合法的前提下，第一个城市和最后一个城市不同，则该路径不是环</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (Not a TS cycle)\n"</span>, x, pathTotalDist);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isTS = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                isTS = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTS)&#123; <span class="comment">// 该路径没有经过所有城市</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (Not a TS cycle)\n"</span>, x, pathTotalDist);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isSimple = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123; <span class="comment">// 已确保是环且经过所有城市，判断是否是简单环，并更新最短TS环路</span></span><br><span class="line">            <span class="keyword">if</span> (pathTotalDist &lt; bestDist)&#123;</span><br><span class="line">                bestX = x;</span><br><span class="line">                bestDist = pathTotalDist;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != firstCity &amp;&amp; visited[i] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                isSimple = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSimple)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (TS simple cycle)\n"</span>, x, pathTotalDist);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (TS cycle)\n"</span>, x, pathTotalDist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Shortest Dist(%d) = %d\n"</span>, bestX, bestDist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="TSP" scheme="https://chouxianyu.github.io/tags/TSP/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1149Dangerous Goods Packaging</title>
    <link href="https://chouxianyu.github.io/2020/09/02/PAT%E7%94%B2%E7%BA%A71149Dangerous-Goods-Packaging/"/>
    <id>https://chouxianyu.github.io/2020/09/02/PAT甲级1149Dangerous-Goods-Packaging/</id>
    <published>2020-09-02T08:09:05.000Z</published>
    <updated>2020-09-02T08:10:47.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>当用容器运输货物时，一些货物是不能装在一起的。现在告诉你哪些货物能装在一起，给你一些货物，请判断这些货物是否可以被装在一起</p><ul><li><p>输入</p><ul><li><p>N：不能装在一起的货物对的数量，不超过10000</p></li><li><p>M：要运输的货物的组数，不超过100</p></li><li><p>N组不能装在一起的货物：每组包括两个货物索引</p></li><li><p>M组货物</p><p>  第一个数字K（不超过1000）是货物的数量，然后剩下的是货物索引（5位数字）</p></li></ul></li><li><p>输出</p><p>  对于M组货物中的每组，如果其中没有不可以装在一起的货物则输出Yes，否则输出No</p></li></ul><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>这个思路会超时</strong></p><ol><li>通过map和hash记录两个货物是否可以被装在一起，相当于一个邻接矩阵<ul><li>为什么不定义矩阵？如果要用矩阵，在这里就需要定义一个100000×100000的bool矩阵，大概会占用10GB，而内存限制是64MB。</li></ul></li><li>对于每组货物，两两判断是否不相容，是一个两层循环，时间复杂度是$K^2$，再算上M组查询，时间复杂度就是$MK^2$，最大值为100×1000×1000=1e8，大概会耗时1秒，肯定会超过400ms的时间限制。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1149</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176</span></span><br><span class="line"><span class="comment">// Tags: Graph Map Hash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> good1, good2;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; incompatible; <span class="comment">// 通过map和hash记录两个货物是否可以被装在一起</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n--)&#123; <span class="comment">// 通过map和hash记录两个货物是否可以被装在一起</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;good1, &amp;good2);</span><br><span class="line">        incompatible[good1 * <span class="number">100000</span> + good2] = <span class="literal">true</span>;</span><br><span class="line">        incompatible[good2 * <span class="number">100000</span> + good1] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)&#123; <span class="comment">//判断m组货物</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goods(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="comment">// 记录k个货物</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;goods[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> isYes = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123; <span class="comment">//判断k个货物是否可以放在一起</span></span><br><span class="line">            good1 = goods[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">                good2 = goods[j];</span><br><span class="line">                <span class="keyword">if</span> (incompatible[good1 * <span class="number">100000</span> + good2] || incompatible[good2 * <span class="number">100000</span> + good1])&#123;</span><br><span class="line">                    isYes = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (isYes)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li><p>使用邻接表保存每个货物的不能装在一起的货物</p></li><li><p>对于每组货物，使用一维数组保存每个货物是否在这组货物中</p></li><li><p>查询邻接表，并通过一维数组判断每个货物的不相容货物是否出现在这组货物中</p><p> 这里也是用了两层循环，但这两层循环的时间复杂度是$N$，再算上M组查询，时间复杂度就是$MN$，最大值为100×10000=1e6。</p></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1149</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176</span></span><br><span class="line"><span class="comment">// Tags: Graph Map Hash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; incompatible[<span class="number">100000</span>]; <span class="comment">// 邻接表，货物与哪些货物不能装在一起</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, good1, good2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;  <span class="comment">// 建立邻接表</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;good1, &amp;good2);</span><br><span class="line">        incompatible[good1].push_back(good2);</span><br><span class="line">        incompatible[good2].push_back(good1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)&#123; <span class="comment">// m组货物</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goods(k); <span class="comment">// 该组货物</span></span><br><span class="line">        <span class="keyword">bool</span> contained[<span class="number">100000</span>]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 该组货物中有哪些货物</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123; <span class="comment">// 记录该组货物</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;goods[i]);</span><br><span class="line">            contained[goods[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isYes = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123; <span class="comment">// 查询邻接表，并通过一维数组判断每个货物的不相容货物是否出现在这组货物中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; incompatible[goods[i]].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (contained[incompatible[goods[i]][j]])&#123;</span><br><span class="line">                    isYes = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (isYes)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/82560836" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/82560836</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="哈希" scheme="https://chouxianyu.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1134Vertex Cover</title>
    <link href="https://chouxianyu.github.io/2020/09/01/PAT%E7%94%B2%E7%BA%A71134Vertex-Cover/"/>
    <id>https://chouxianyu.github.io/2020/09/01/PAT甲级1134Vertex-Cover/</id>
    <published>2020-09-01T14:18:12.000Z</published>
    <updated>2020-09-01T14:20:38.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><ul><li><p>vertex cover</p><p>  vertex cover指图中的每条边都和这组顶点中至少一个顶点相关，先给定一个图和几组顶点，请判断这几组顶点是否为vertex cover</p></li><li><p>输入</p><ul><li><p>N：顶点数量，不超过10000</p></li><li><p>M：边的数量，不超过10000</p></li><li><p>M条边：顶点通过[0,N-1]表示/索引</p></li><li><p>K：有几组顶点，不超过100</p></li><li><p>K组顶点</p><p>  一组顶点的第一个数字是顶点数量，剩下的是顶点索引</p></li></ul></li><li><p>输出</p><ul><li>是vertex则输出Yes，不是则输出No</li></ul></li></ul><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>定义Edge结构体，包括两个端点</p></li><li><p>把M条边存入vector</p></li><li><p>将顶点组存入set（vector也可以）</p></li><li><p>遍历每条边判断其两个端点是否在set中</p><p>  只要有一条边的两个端点都不在set中，则不是vertex cover</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1134</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088</span></span><br><span class="line"><span class="comment">// Tags: Graph Hash Set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges(m); <span class="comment">// 存储边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;edges[i].v1, &amp;edges[i].v2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; vertices;</span><br><span class="line">        <span class="keyword">int</span> vertexNum, vertex;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vertexNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++)&#123; <span class="comment">// 将一组顶点存入set</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vertex);</span><br><span class="line">            vertices.insert(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isVertexCover = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = edges.begin(); it != edges.end(); it++)&#123;</span><br><span class="line">            <span class="comment">// 只要有一条边的两个端点都不在set中，则不是vertex cover</span></span><br><span class="line">            <span class="keyword">if</span> (vertices.find(it-&gt;v1) == vertices.end() &amp;&amp; vertices.find(it-&gt;v2) == vertices.end())&#123;</span><br><span class="line">                isVertexCover = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isVertexCover)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><p>比上一个方法快</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>给M条边编号为[0,M-1]</li><li>读取每条边时，保存每个顶点与哪条边相关，将这个信息存入vector</li><li>定义vector表示各条边是否被覆盖，遍历上一步得到的vector标记各条边是否被覆盖，最后遍历这一步定义的vector判断是否符合vertex cover的条件</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>一个顶点可以和多条边相关</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1134</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088</span></span><br><span class="line"><span class="comment">// Tags: Graph Hash Set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cover[n]; <span class="comment">// cover[2].push_back(3) 代表顶点2覆盖了边3</span></span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        cover[v1].push_back(i);</span><br><span class="line">        cover[v2].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isCovered(m, <span class="literal">false</span>); <span class="comment">// m条边是否被覆盖</span></span><br><span class="line">        <span class="keyword">int</span> vertexNum, vertex;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vertexNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++)&#123; <span class="comment">// 遍历顶点，将其覆盖的边标记</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vertex);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cover[vertex].size(); j++)</span><br><span class="line">                isCovered[cover[vertex][j]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isVertexCover = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isCovered[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">                isVertexCover = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isVertexCover)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/78037329" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/78037329</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="set" scheme="https://chouxianyu.github.io/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1139First Contact</title>
    <link href="https://chouxianyu.github.io/2020/09/01/PAT%E7%94%B2%E7%BA%A71139First-Contact/"/>
    <id>https://chouxianyu.github.io/2020/09/01/PAT甲级1139First-Contact/</id>
    <published>2020-09-01T09:16:39.000Z</published>
    <updated>2020-09-01T09:18:59.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>背景</p><p>  男生A喜欢女孩B，A找男生C让女孩D跟B说，其中C是A的朋友，D是B和C的朋友。女生也是这样联系男生</p></li><li><p>输入</p><ul><li>N：人的数量，1到300</li><li>M：朋友关系的数量</li><li>M个朋友关系：用4位数字表示一个人，其中负数代表性别是女生</li><li>K：查询数量，不超过100</li><li>K次查询：每次查询是A和B的ID，假设A喜欢B</li></ul></li><li><p>输出</p><ul><li><p>输出有几对C和D可以帮助A联系B</p></li><li><p>输出这几对C和D</p><ul><li><p>如果A和B是异性，则A和C应该是同性，B和D同性；如果A和B是同性，则这4人性别应该相同</p><p>  即A和C同性，B和D同性</p></li><li><p>先按C的ID非降序输出，再按D的ID增序输出</p></li></ul></li></ul></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>使用邻接矩阵表示两个人是否是朋友，用邻接表存储一个人的同性朋友</li><li>给定A和B以后，枚举A的朋友C，枚举B的朋友D，如果C和D是朋友则保存C和D</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>输出时要以4位数字输出，用<code>printf(&quot;%04d&quot;)</code>，第二和第三个测试点都测试了这个</li><li>如果用int接收一对朋友，-0000和0000对于int来说都是0，将无法得知这个人的性别<ul><li>在这里我对他们的id进行了处理：把女生映射到[0,9999]，男生映射到[10000,19999]</li><li>也可以使用其他的哈希方法</li></ul></li><li>正常回路为A-C-D-B，不可以形成A-B-D-B或A-C-A-B的回路，即AD不相等、BC不相等</li><li><strong>写循环代码时注意一些变量是否会随着循环运行而改变，比如数组大小、外层循环变量是否被内层循环改变</strong></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1139</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312</span></span><br><span class="line"><span class="comment">// Tags: Graph Hash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isFriend[<span class="number">20000</span>][<span class="number">20000</span>]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; friends[<span class="number">20000</span>]; <span class="comment">// 邻接表，同性朋友</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Helper</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transform</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将负数映射到[0,9999]，将正数映射到[10000,19999]</span></span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(stoi(s));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000</span> + stoi(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">restore</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将transform得到的[0,19999]的数字映射到[0,9999]，即原来的[-9999,9999]取绝对值得到[0,9999]，以进行输出</span></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">9999</span>)</span><br><span class="line">        <span class="keyword">return</span> num - <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helperCmp</span><span class="params">(Helper&amp; h1, Helper&amp; h2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h1.c == h2.c ? h1.d &lt; h2.d : h1.c &lt; h2.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, a, b, c ,d;</span><br><span class="line">    <span class="built_in">string</span> s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 将图存入邻接矩阵和邻接表</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        a = transform(s);</span><br><span class="line">        b = transform(t);</span><br><span class="line">        isFriend[a][b] = isFriend[b][a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (a&lt;<span class="number">10000</span> &amp;&amp; b&lt;<span class="number">10000</span>) || (a&gt;<span class="number">9999</span> &amp;&amp; b&gt;<span class="number">9999</span>) )&#123; <span class="comment">// 同性则存储到邻接表</span></span><br><span class="line">            friends[a].push_back(b);</span><br><span class="line">            friends[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        a = transform(s);</span><br><span class="line">        b = transform(t);</span><br><span class="line">        <span class="built_in">vector</span>&lt;Helper&gt; helpers;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = friends[a].begin(); it1 != friends[a].end(); it1++)&#123;</span><br><span class="line">            c = *it1;</span><br><span class="line">            <span class="keyword">if</span> (c == b) <span class="comment">// C和B不能是一个人</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it2 = friends[b].begin(); it2 != friends[b].end(); it2++)&#123;</span><br><span class="line">                d = *it2;</span><br><span class="line">                <span class="keyword">if</span> (d == a) <span class="comment">// D和A不能是一个人</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (isFriend[c][d])</span><br><span class="line">                    helpers.push_back(&#123;restore(c), restore(d)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(helpers.begin(), helpers.end(), helperCmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, helpers.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = helpers.begin(); it != helpers.end(); it++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%04d %04d\n"</span>, it-&gt;c, it-&gt;d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一份超时的代码"><a href="#一份超时的代码" class="headerlink" title="一份超时的代码"></a>一份超时的代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1139</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312</span></span><br><span class="line"><span class="comment">// Tags: Graph Hash Map</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Helper</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helperCmp</span><span class="params">(Helper&amp; h1, Helper&amp; h2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(stoi(h1.c)) == <span class="built_in">abs</span>(stoi(h2.c)) ? <span class="built_in">abs</span>(stoi(h1.d)) &lt; <span class="built_in">abs</span>(stoi(h2.d)) : <span class="built_in">abs</span>(stoi(h1.c)) &lt; <span class="built_in">abs</span>(stoi(h2.c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">string</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; friends; <span class="comment">// 会很耗时</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 存储朋友关系</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            a = <span class="string">'+'</span> + a;</span><br><span class="line">        <span class="keyword">if</span> (b[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            b = <span class="string">'+'</span> + b;</span><br><span class="line">        friends[a].push_back(b);</span><br><span class="line">        friends[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">// a喜欢b</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            a = <span class="string">'+'</span> + a;</span><br><span class="line">        <span class="keyword">if</span> (b[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            b = <span class="string">'+'</span> + b;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Helper&gt; helpers;</span><br><span class="line">        <span class="comment">// 下边这个大的for循环也很耗时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = friends[a].begin(); it1 != friends[a].end(); it1++)&#123;</span><br><span class="line">            c = *it1; <span class="comment">// a的朋友c</span></span><br><span class="line">            <span class="keyword">if</span> (b == c || a[<span class="number">0</span>] != c[<span class="number">0</span>]) <span class="comment">// a和c不可以是同一个人，且应该是同性</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it2 = friends[c].begin(); it2 != friends[c].end(); it2++)&#123;</span><br><span class="line">                d = *it2; <span class="comment">// c的朋友d</span></span><br><span class="line">                <span class="keyword">if</span> (a == d || b[<span class="number">0</span>] != d[<span class="number">0</span>]) <span class="comment">// a和d不可以是同一个人，且应该是同性</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (find(friends[d].begin(), friends[d].end(), b) != friends[d].end())&#123;</span><br><span class="line">                    helpers.push_back(&#123;c, d&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(helpers.begin(), helpers.end(), helperCmp); <span class="comment">// 按id升序存储，达到题目输出要求</span></span><br><span class="line">        <span class="keyword">int</span> num = helpers.size();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%04d %04d\n"</span>, <span class="built_in">abs</span>(stoi(helpers[i].c)), <span class="built_in">abs</span>(stoi(helpers[i].d)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/79065004" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/79065004</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
      <category term="哈希" scheme="https://chouxianyu.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1154Vertex Coloring</title>
    <link href="https://chouxianyu.github.io/2020/08/30/PAT%E7%94%B2%E7%BA%A71154Vertex-Coloring/"/>
    <id>https://chouxianyu.github.io/2020/08/30/PAT甲级1154Vertex-Coloring/</id>
    <published>2020-08-30T09:49:06.000Z</published>
    <updated>2020-09-01T09:19:10.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li>k着色：相邻（有共享边）点的颜色不同</li><li>输入<ul><li>N：点的数量，点的编号为[0,N-1]，不超过10000</li><li>M：边的数量，不超过10000</li><li>M条边</li><li>K：着色方案的数量，不超过100</li><li>K个着色方案：每行有N个数字，第i个数字就是第i个点的颜色，相同数字代表同色</li></ul></li><li>输出<ul><li>对于每个着色方案，如果它是某个k着色，则输出<code>k-coloring</code>，否则输出<code>No</code></li></ul></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>把所有边存起来</li><li>把所有点的颜色存起来，并把颜色放入set中统计颜色个数</li><li>检查每条边两个点的颜色是否相同</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>cin、cout是会比scanf、printf慢的，如果用cin、cout，第三个测试点可能会超时</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1154</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552</span></span><br><span class="line"><span class="comment">// Tags: Graph Map Set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> v1, v2;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; edges(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">// 获取边</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;edges[i].v1, &amp;edges[i].v2);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123; <span class="comment">// k个着色方案</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; vColors;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; colors;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123; <span class="comment">// 获取着色方案</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vColors[i]);</span><br><span class="line">            colors.insert(vColors[i]); <span class="comment">// 存储颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isYes = <span class="literal">true</span>;  <span class="comment">// 判断着色方案是否符合k着色标准</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (vColors[edges[i].v1] == vColors[edges[i].v2])&#123;</span><br><span class="line">                isYes = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (isYes)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d-coloring\n"</span>, colors.size());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="set" scheme="https://chouxianyu.github.io/tags/set/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1137Final Grading</title>
    <link href="https://chouxianyu.github.io/2020/08/28/PAT%E7%94%B2%E7%BA%A71137Final-Grading/"/>
    <id>https://chouxianyu.github.io/2020/08/28/PAT甲级1137Final-Grading/</id>
    <published>2020-08-28T15:16:44.000Z</published>
    <updated>2020-08-28T15:17:37.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>要获得证书，一个学生的在线编程作业至少要拿到200分，最后评分G至少要拿到60分。</p><p>  如果期中分数大于期末分数，则G等于期中成绩乘以40%+期末成绩乘以60%，否则G等于期末成绩</p></li><li><p>输入</p><ul><li><p>第一行</p><p>  三个数字，都不超过10000</p><ul><li>P：完成网上在线作业的学生的数量</li><li>M：参加期中考试的学生的数量</li><li>N：参加期末考试的学生的数量</li></ul></li><li><p>P个学生网上在线作业的成绩</p></li><li><p>M个学生期中考试的成绩</p></li><li><p>N个学生期末考试的成绩</p></li></ul></li><li><p>输出</p><p>  输出获得证书的学生的ID及其3个成绩，按G(四舍五入到整数)降序输出，如果G相等，则按ID升序输出。如果某学生某些成绩不存在，则输出-1</p></li></ul><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li><p>assignment</p><p>  工作、任务</p><p>  分配、指派</p></li><li><p>certificate</p><p>  证明</p></li><li><p>round</p><p>  四舍五入</p></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>先读取在线编程作业分数，如果小于200，就不记录该学生的信息</li><li>在第一步记录的学生范围内，记录其期中分数</li><li>在第一步记录的学生范围内，记录其期末分数，同时计算其最后分数G，如果G大于60，则存入vector</li><li>将vector排序</li><li>输出</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1137</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608</span></span><br><span class="line"><span class="comment">// Tags: unordered_map vector sort</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">int</span> gp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> gm=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> gf=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> g=<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">studentCmp</span><span class="params">(Student&amp; s1, Student&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.g == s2.g ? s1.id &lt; s2.id : s1.g &gt; s2.g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p, m, n;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, Student&gt; students_map;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">200</span>)&#123;  <span class="comment">// 在线编程分数大于200才行（不允许该分数不存在）</span></span><br><span class="line">            students_map[str].id = str;</span><br><span class="line">            students_map[str].gp = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (students_map.find(str) != students_map.end()) <span class="comment">// 避免创建新的学生</span></span><br><span class="line">            students_map[str].gm = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student&gt; students_vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (students_map.find(str) != students_map.end())&#123; <span class="comment">// 避免创建新的学生</span></span><br><span class="line">            students_map[str].gf = score;</span><br><span class="line">            <span class="keyword">if</span> (students_map[str].gm &gt; students_map[str].gf)</span><br><span class="line">                students_map[str].g = round(students_map[str].gm * <span class="number">0.4</span> + students_map[str].gf * <span class="number">0.6</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                students_map[str].g = students_map[str].gf;</span><br><span class="line">            <span class="keyword">if</span> (students_map[str].g &gt;= <span class="number">60</span>)</span><br><span class="line">                students_vec.push_back(students_map[str]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(students_vec.begin(), students_vec.end(), studentCmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = students_vec.begin(); it != students_vec.end(); it++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d %d %d %d\n"</span>, it-&gt;id.c_str(), it-&gt;gp, it-&gt;gm, it-&gt;gf, it-&gt;g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/weixin_44385565/article/details/88669948" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44385565/article/details/88669948</a></p><p><a href="https://blog.csdn.net/liuchuo/article/details/79064895" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/79064895</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>使用Python和OpenCV实现SIFT与ORB</title>
    <link href="https://chouxianyu.github.io/2020/08/16/%E4%BD%BF%E7%94%A8Python%E5%92%8COpenCV%E5%AE%9E%E7%8E%B0SIFT%E4%B8%8EORB/"/>
    <id>https://chouxianyu.github.io/2020/08/16/使用Python和OpenCV实现SIFT与ORB/</id>
    <published>2020-08-16T10:01:09.000Z</published>
    <updated>2020-08-16T10:06:12.652Z</updated>
    
    <content type="html"><![CDATA[<p>目录如下：</p><p>[TOC]</p><h1 id="程序运行环境"><a href="#程序运行环境" class="headerlink" title="程序运行环境"></a>程序运行环境</h1><ul><li>python 3.7.3</li><li>numpy 1.16.6</li><li>opencv-python 4.4.0.40</li></ul><h1 id="SIFT-pratice-py"><a href="#SIFT-pratice-py" class="headerlink" title="SIFT_pratice.py"></a>SIFT_pratice.py</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">该程序使用dataset中的1.jpg和2.jpg，使用SIFT对这2张图片进行特征检测和特征提取，使用暴力匹配法对这2张图片进行特征匹配，最后计算匹配程度较高的特征点的单应性矩阵</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">img1 = cv2.imread(<span class="string">'./dataset/1.jpg'</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">'./dataset/2.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SIFT</span></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测关键点并提取特征</span></span><br><span class="line">kp1, des1 = sift.detectAndCompute(img1, <span class="keyword">None</span>)</span><br><span class="line">kp2, des2 = sift.detectAndCompute(img2, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征匹配：暴力匹配</span></span><br><span class="line">bf = cv2.DescriptorMatcher_create(cv2.DescriptorMatcher_BRUTEFORCE)</span><br><span class="line">matches = bf.match(des1, des2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制特征匹配结果</span></span><br><span class="line">matches = sorted(matches, key=<span class="keyword">lambda</span> x: x.distance)</span><br><span class="line">good_matches = matches[:<span class="number">50</span>]  <span class="comment"># 只取前XX个匹配</span></span><br><span class="line">result = cv2.drawMatches(img1, kp1, img2, kp2, good_matches,</span><br><span class="line">                         <span class="keyword">None</span>, matchColor=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), singlePointColor=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))  <span class="comment"># 只画前XX个匹配</span></span><br><span class="line">cv2.imshow(<span class="string">'result'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算单应性矩阵</span></span><br><span class="line">pts1, pts2 = [], []</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> good_matches:</span><br><span class="line">    pts1.append(kp1[f.queryIdx].pt)</span><br><span class="line">    pts2.append(kp2[f.trainIdx].pt)</span><br><span class="line">H, _ = cv2.findHomography(np.float32(pts1), np.float32(pts2), cv2.RHO)</span><br><span class="line">print(<span class="string">'单应性矩阵：'</span>)</span><br><span class="line">print(H)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h2><p>该程序使用dataset中的<strong>1.jpg和2.jpg</strong>，使用<strong>SIFT</strong>对这2张图片进行<strong>特征检测</strong>和<strong>特征提取</strong>，使用<strong>暴力匹配</strong>法对这2张图片进行<strong>特征匹配</strong>，最后计算匹配程度较高的特征点的<strong>单应性矩阵</strong>。</p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200816071602SIFT_pratice运行结果.png" alt="SIFT_pratice运行结果"></p><h1 id="ORB-pratice-py"><a href="#ORB-pratice-py" class="headerlink" title="ORB_pratice.py"></a>ORB_pratice.py</h1><h2 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">该程序使用dataset中的3.jpg和4.jpg，使用ORB对这2张图片进行特征检测和特征提取，使用暴力匹配法对这2张图片进行特征匹配，，最后计算匹配程度较高的特征点的单应性矩阵</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">img1 = cv2.imread(<span class="string">'./dataset/3.jpg'</span>)</span><br><span class="line">img2 = cv2.imread(<span class="string">'./dataset/4.jpg'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ORB</span></span><br><span class="line">orb = cv2.ORB_create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测关键点并提取特征</span></span><br><span class="line">kp1, des1 = orb.detectAndCompute(img1, <span class="keyword">None</span>)</span><br><span class="line">kp2, des2 = orb.detectAndCompute(img2, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特征匹配：暴力匹配、汉明距离</span></span><br><span class="line">bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=<span class="keyword">True</span>)</span><br><span class="line">matches = bf.match(des1, des2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制特征匹配结果</span></span><br><span class="line">matches = sorted(matches, key=<span class="keyword">lambda</span> x: x.distance)</span><br><span class="line">good_matches = matches[:<span class="number">50</span>]  <span class="comment"># 只取前XX个匹配</span></span><br><span class="line">result = cv2.drawMatches(img1, kp1, img2, kp2, good_matches, <span class="keyword">None</span>)</span><br><span class="line">cv2.imshow(<span class="string">'result'</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算单应性矩阵</span></span><br><span class="line">pts1, pts2 = [], []</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> good_matches:</span><br><span class="line">    pts1.append(kp1[f.queryIdx].pt)</span><br><span class="line">    pts2.append(kp2[f.trainIdx].pt)</span><br><span class="line">H, _ = cv2.findHomography(np.float32(pts1), np.float32(pts2), cv2.RHO)</span><br><span class="line">print(<span class="string">'单应性矩阵：'</span>)</span><br><span class="line">print(H)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="程序功能-1"><a href="#程序功能-1" class="headerlink" title="程序功能"></a>程序功能</h2><p>该程序使用dataset中的<strong>3.jpg和4.jpg</strong>，使用<strong>ORB</strong>对这2张图片进行<strong>特征检测</strong>和<strong>特征提取</strong>，使用<strong>暴力匹配</strong>法对这2张图片进行<strong>特征匹配</strong>，，最后计算匹配程度较高的特征点的<strong>单应性矩阵。</strong></p><h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200816071618ORB_pratice运行结果.png" alt="ORB_pratice运行结果"></p><h1 id="相关理论"><a href="#相关理论" class="headerlink" title="相关理论"></a>相关理论</h1><h2 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h2><ul><li><p>作者</p><p>  David Lowe</p></li><li><p>发表</p><p>  David Lowe于1999年发表于ICCV，经过整理和完善，在2004年发表于IJCV。</p></li><li><p>特点</p><p>  对图片大小和旋转不敏感，而且对光照、噪声等影响的抗击能力也非常优秀。</p></li><li><p>实现</p><p>  可以分为4个步骤</p><ol><li>Scale-space extrema detection<ul><li>使用高斯差分函数（DoG）来计算并搜索所有尺度上的图像位置，用于识别对尺度和方向不变的潜在兴趣点。</li><li>由于平滑区域临近像素之间变化不大，但是在边、角、点这些特征较丰富的地方变化较大，因此通过<strong>DOG</strong>比较临近像素可以检测出候选关键点。</li></ul></li><li>Keypoint localization<ul><li>通过一个拟合精细的模型在每个候选位置上确定位置和尺度，关键点的选择依赖于它们的稳定程度。</li><li>根据关键点的稳定性来选择关键点。在每个候选位置，通过一个模型来确定位置和比例。</li></ul></li><li>Orientation assignment<ul><li>基于局部图像的梯度方向，将一个或多个方向分配给每个关键点位置。</li><li>后续所有对图像数据的操作都是相对于关键点的方向、尺度和位置进行变换，从而为这些变换提供了不变性。</li></ul></li><li>Keypoint descriptor<ul><li>在每个关键点周围的区域内以选定的比例计算局部图像梯度，这些梯度被变换成一种表示。</li><li>这种表示允许比较大的局部形状的变形和光照变化。</li></ul></li></ol></li></ul><h2 id="ORB"><a href="#ORB" class="headerlink" title="ORB"></a>ORB</h2><ul><li><p>作者</p><p>  Ethan Rublee在2011年发表于ICCV</p></li><li><p>提出</p><ul><li><p>SIFT算法</p><p>  不管是特征提取还是特征描述，SIFT都十分复杂，并且特征向量的匹配采用浮点数之间计算欧式距离，较为耗时。</p></li><li><p>FAST特征提取算法</p><p>  于2006年ECCV上提出，作为十分高效的特征点提取算法，其并<strong>没有提取出特征点的主方向</strong>，因而后续无法根据主方向对特征点进行描述。</p></li><li><p>BRIEF特征描述算法</p><p>  于2010年CVPR上提出，其是一种十分简单的特征点描述算法，其输出向量为二进制、进而极大的节省了向量的保存空间和简化了特征向量间的距离计算，但该算法对方向的改变十分敏感，因此<strong>对特征点的描述将不具有旋转不变性</strong>。</p></li><li><p><strong>ORB</strong></p><p>  ORB算法在FAST算法的基础上，提取了特征点的方向。同时根据特征点的方向，采用改进BRIEF算法的Rotated BRIEF算法对特征进行描述。ORB取长补短，<strong>既高效地完成了特征提取和特征描述，又使得特征描述向量具有旋转不变性。</strong></p></li></ul></li><li><p>特点</p></li><li><p>实现</p><p>  可以分为4个步骤</p><ol><li><p>构造图像金字塔</p><p> 在不同降采样大小的图像下进行FAST特征点提取，进而得到特征点的尺度信息</p></li><li><p>FAST算法</p><ol><li>对于图像中一个像素点p，其灰度值为Ip</li><li>以该像素点为中心考虑一个半径为3的离散化的Bresenham圆，圆边界上有16个像素</li><li><p>设定一个合适的阈值t，如果圆上有n个连续像素点的灰度值小于Ip−t或者大于Ip+t，那么这个点即可判断为特征点（角点），n的值可取9、11、12。</p><p>运行完FAST算法，会得到大量特征点，需要用NMS筛选</p></li></ol></li><li><p>计算旋转角度</p><ul><li>利用灰度质心法求一个圆形区域的质心，连接质心和圆心形成一个向量，这个向量的角度就是角点的角度。</li><li>其中圆的半径取为15，因为整个patch一般取的是31×31的。</li><li>这个角度可以用来指导BRIEF描述子的提取，保证每次都在相同的方向上计算描述子，实现角度不变性。</li></ul></li><li><p>计算旋转后的BRIEF描述子</p><ul><li>BRIEF<ul><li>在特征点的描述区域范围（系数*尺度）内，随机生成256个位置对。对于每对位置，如果位置1点的像素值大于位置2点的像素值，则该对位置的输出为1，反之为0。</li><li>一共有256个位置对，所以最终特征描述将用一个256向量组成，向量的每个元素都是二进制数。</li><li>对于随机生成的256个位置对，BRIEF作者尝试了五种方法，最终选择二维高斯函数作为位置对的分布。</li><li>位置对的生成为初始随机生成，但生成后位置对便固定下来，最终匹配的时候所有特征点均采用相同的位置对。</li></ul></li><li>Steered BRIEF<ul><li>BRIEF算法中，位置对是以右方向为x轴。</li><li>在Steered BRIEF算法中，特征点的位置对以特征点的主方向为x轴，因此当主方向为θ时，原BRIEF算法中的位置对的位置也需要根据θ进行坐标转换。<ul><li>具体方法是已选好的256个位置对乘上旋转矩阵，从而得到以特征点的主方向为x轴时坐标系下的位置。</li><li>通过该256个位置对对特征点进行描述，由于位置对的位置已经根据方向发生了相应的改变，因此Steered BRIEF算法具有一定的旋转不变性。</li></ul></li></ul></li><li>Rotated BRIEF<ul><li>在Steered BRIEF算法，其256维度的特征描述向量，每一个位置对的位置与其输出有一定的相关性，进而使得特征描述向量的信息熵减少。由此， Rotated BRIEF 提出<strong>用统计学习的方法选择位置对</strong>代替二维高斯随机分布选择位置对。</li></ul></li></ul></li></ol></li></ul><h2 id="单应性变换"><a href="#单应性变换" class="headerlink" title="单应性变换"></a>单应性变换</h2><ul><li><p>单应性变换是什么</p><ul><li>单应性变换是一个平面内的点映射到另一个平面内的二维投影变换，对应的变换矩阵称为<strong>单应性矩阵</strong>。</li><li>在这里，平面是指图像或者三维中的平面表面。</li></ul></li><li><p>单应性变换的作用</p><p>  单应性变换具有很强的实用性，比如图像配准，图像纠正和纹理扭曲，以及创建全景图像。</p></li><li><p>关于齐次坐标</p><ul><li>对于图像平面内的点，齐次坐标是个非常有用的表示方式。</li><li>点的齐次坐标是依赖于尺度定义的，所以x=[x,y,w]=[αx,αy,αw]=[x/w,y/w,1] 都表示同一个点。因此单应性矩阵H也依赖尺度定义。</li></ul></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目录如下：&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;程序运行环境&quot;&gt;&lt;a href=&quot;#程序运行环境&quot; class=&quot;headerlink&quot; title=&quot;程序运行环境&quot;&gt;&lt;/a&gt;程序运行环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;python 3.7.3&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
      <category term="OpenCV" scheme="https://chouxianyu.github.io/tags/OpenCV/"/>
    
      <category term="SIFT" scheme="https://chouxianyu.github.io/tags/SIFT/"/>
    
      <category term="ORB" scheme="https://chouxianyu.github.io/tags/ORB/"/>
    
      <category term="单应性变换" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%BA%94%E6%80%A7%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>SOLO(SOLO: Segmenting Objects by Locations)论文阅读笔记</title>
    <link href="https://chouxianyu.github.io/2020/08/16/SOLO-SOLO-Segmenting-Objects-by-Locations-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://chouxianyu.github.io/2020/08/16/SOLO-SOLO-Segmenting-Objects-by-Locations-论文阅读笔记/</id>
    <published>2020-08-16T09:51:17.000Z</published>
    <updated>2020-08-16T09:58:01.560Z</updated>
    
    <content type="html"><![CDATA[<p>以下为我总结出的论文各部分的主要内容，某些地方可能夹带着一些自己的理解和思考。</p><p>[TOC]</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul><li><p>本文内容：SOLO</p><p>  提出新的、非常简单的实例分割方法<strong>SOLO</strong></p></li><li><p>与许多其他密集预测任务（比如语义分割）相比，实例分割的难点</p><p>  实例数量的不确定性</p></li><li><p>实例分割的主流方法，把实例分割任务分解为2个分类任务</p><ul><li>先检测后分割，比如Mask R-CNN</li><li>先预测embedding vector，然后通过聚类将像素分组成独立实例</li></ul></li><li><p><strong>本文提出的SOLO的方法</strong></p><p>  <strong>引入“instance categories”的概念：根据实例的位置和大小为实例中的每个像素分配类别，从而很好地将实例分割转换为分类问题</strong></p></li><li><p>SOLO的性能</p><p>  精度与Mask R-CNN持平，比最近的其它single-shot实例分割算法要高。</p></li></ul><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><ul><li><p>实例分割的难点</p><p>  语义分割可以视为给每个像素分类的任务，但由于实例数量的不确定性，导致语义分割等任务的方法不能在实例分割中奏效。</p></li><li><p>实例分割算法分类及其优缺点</p><p>  为克服上面提到的实例分割的难点，最近的实例风格算法（也就是摘要提到的主流方法）可分为两类，缺点是step-wise、indirect</p><ul><li><p>top-down</p><ul><li><p>思路</p><p>  ‘detect-then-segment’，先检测矩形边界框，然后在每个矩形框内做分割</p></li><li><p>缺点</p><p>  严重依赖精准的矩形检测框</p></li></ul></li><li><p>bottom-up</p><ul><li><p>思路</p><p>  通过push属于不同实例的像素并close同一实例中的像素来学习affinity relation（亲和关系），为每个像素分配embedding vector，然后通过分组后处理以分离实例。</p></li><li><p>缺点</p><p>  依赖像素级的embedding learning和分组后处理</p></li></ul></li><li><p>SOLO</p><p>  基于实例分割标注（有监督训练），直接预测实例的掩码</p></li></ul></li><li><p><strong>rethinking</strong></p><ul><li><strong>图片中的物体实例的根本区别是什么？</strong></li><li><strong>以MSCOCO为例，绝大多数情况下，图片中的两个实例要么有不同的中心位置、要么有不同尺寸，数据分析如下：</strong><ul><li><strong>98.3%的object pair（实例对）的中心的距离超过30个像素</strong></li><li><strong>剩下的1.7%，其中40.5%的实例对的大小比例大于1.5</strong></li></ul></li><li><strong>所以可以直接通过中心位置和大小区分实例</strong></li></ul></li><li><p><strong>模仿语义分析主流方法</strong></p><ul><li><p><strong>语义分析主流方法是用FCN（全卷积神经网络）输出N个通道，每个通道负责一个语义类别</strong></p></li><li><p><strong>SOLO模仿语义分析使用FCN的方法，提出“instance categories”的概念，即量化的中心位置center locations和实例大小object sizes</strong></p><p>  <strong>个人思考：这不是和YOLO很像吗？？</strong></p></li></ul></li></ul><h2 id="Locations"><a href="#Locations" class="headerlink" title="Locations"></a>Locations</h2><ul><li>SOLO如何处理Locations，即实例的位置<ul><li>SOLO把一张图片分成a grid of S×S cells（S×S个单元格）即得到<strong>S×S个center location classes</strong>。</li><li>SOLO根据实例的中心坐标为每个实例分配one of the grid cells，作为该实例的center location category</li><li>DeepMask and TensorMask，pack the mask into the channel axis。SOLO将center location category编码为channel axis，类似于语义分割中的语义类别。<strong>输出的每个channel代表一个center location category，预测属于这个center location category的实例的掩码。</strong></li></ul></li><li>SOLO这样处理Location的作用<ul><li>本质上，instance category近似于center location。因此，把每个像素<strong>分类</strong>到instance category其中，等效于使用<strong>回归</strong>从每个像素预测center location。</li><li><strong>将location预测任务转换为分类而不是回归的重要性在于，通过分类，使用固定数量的通道对不同数量的实例进行建模更加简单明了，同时又不依赖于grouping或者learning embeddings等后处理</strong></li><li>个人思考：前文强调了实例分割任务中实例的数量是不确定的，导致实例分割很难，可以猜测是之前的方法是回归，处理实例数量不确定这个情况的方法并不优雅</li></ul></li></ul><h2 id="Sizes"><a href="#Sizes" class="headerlink" title="Sizes"></a>Sizes</h2><ul><li>SOLO如何处理Sizes，即实例的大小<ul><li>使用特征金字塔网络FPN，为大小不同的实例分配对应大小的特征图，作为其<strong>object size classes</strong>。</li><li>注意FPN旨在检测图像中不同大小的实例。在之后，我们根据经验证明FPN是SOLO的核心组成部分，对分割性能（尤其是大小不同的目标）产生深远影响。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>SOLO只需要分割标注，不需要框标注（目前多数方法是需要的），即可完成实例分割</p></li><li><p>在COCO上的性能，摘要里讲过</p></li><li><p>通用性：我们通过实例轮廓检测的任务展示了我们框架的通用性，将实例边缘轮廓视为one-hot的二进制掩码，几乎没有任何修改，SOLO可以生成合理的实例轮廓。</p></li><li><p>SOLO只需解决<strong>两个像素级分类任务</strong></p><p>  和语义分割一样，所以可以再参考语义分割领域的进步，提高SOLO</p></li><li><p>本质上，SOLO通过离散量化将坐标回归转换为分类</p><p>  避免了通常在诸如YOLO之类的检测器中使用的坐标规范化和对数转换</p></li></ul><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h1><p>回顾了一些和SOLO最相近的实例分割工作</p><h2 id="Top-down-Instance-Segmentation"><a href="#Top-down-Instance-Segmentation" class="headerlink" title="Top-down Instance Segmentation"></a>Top-down Instance Segmentation</h2><p>SOLO和下面的方法相比， 不受限于anchor和box</p><ul><li><p>典型方法</p><p>  在边界框里做分割</p></li><li><p>FCIS</p><p>  FCIS：由region proposal network（RPN）生成的ROI中assemble（计算?）position-sensitive score maps，以预测实例掩码。</p></li><li><p>Mask R-CNN</p><p>  扩展Faster R-CNN，具体来讲是在其中添加一个branch（用于在检测到的边界框中分割实例）</p></li><li><p>PANet</p><p>  基于Mask R-CNN，进一步增强了特征表示以提高准确性</p></li><li><p>Mask Scoring R-CNN</p><p>  基于Mask R-CNN，添加了mask-IoU分支（预测所预测的掩码的质量并对掩码进行评分）以提高性能。</p></li><li><p>TensorMask</p><p>  采用dense sliding window方法，通过预定义的windows和scales在每个像素的本地窗口中分割实例</p></li></ul><h2 id="Bottom-up-Instance-Segmentation"><a href="#Bottom-up-Instance-Segmentation" class="headerlink" title="Bottom-up Instance Segmentation"></a>Bottom-up Instance Segmentation</h2><p>这类方法通过将像素分组为图像中的实例（任意数量）来进行实例分割，可通过损失函数实现，这类方法的精度一般比Top-down的要低，特别是有复杂场景和语义类别的图片。</p><ul><li><p>SGN</p><p>  把语义分割分解为一系列分组问题</p></li><li><p>SSAP</p><p>  学习像素对相关性金字塔，即两个像素属于同一实例的概率，并通过级联图分区顺序生成实例掩码。</p></li></ul><h2 id="Direct-Instance-Segmentation"><a href="#Direct-Instance-Segmentation" class="headerlink" title="Direct Instance Segmentation"></a>Direct Instance Segmentation</h2><p>目前没有这种方法，最近提出的一些方法被视为‘semi-direct’（半直接）。</p><p>这两个方法都是分步骤的，或者是折中的（比如粗略表示掩码）</p><ul><li><p>AdaptIS</p><p>  先预测点，然后生成位于这些点中的实例的实例的掩码</p></li><li><p>PolarMask</p><p>  PolarMask提出使用极坐标表示来编码掩码，并将每个像素的掩码预测转换为距离回归。</p></li><li><p>本文SOLO</p><p>  图片作为输入，直接输出掩码和概率；全卷积；不需要box不需要分组也不需要ROI等</p></li></ul><h1 id="3-我们的方法SOLO"><a href="#3-我们的方法SOLO" class="headerlink" title="3. 我们的方法SOLO"></a>3. 我们的方法SOLO</h1><h2 id="3-1-问题表述"><a href="#3-1-问题表述" class="headerlink" title="3.1 问题表述"></a>3.1 问题表述</h2><ul><li><p>实例分割做什么</p><p>  给定一张图片，如果其中存在实例，要求返回实例的掩码</p></li><li><p>SOLO</p><ul><li>将实例分割任务分为两个<strong>同时的</strong>任务：category-aware prediction和instance-aware mask generation</li><li>把图片分成a uniform grids（S×S），如果物体中心在某个grid cell中，那这个grid cell负责预测语义类别和掩码</li></ul></li></ul><h3 id="3-1-1-语义类别"><a href="#3-1-1-语义类别" class="headerlink" title="3.1.1  语义类别"></a>3.1.1  语义类别</h3><ul><li><p>对于每个grid，SOLO都会预测C维输出表示语义类别概率，其中C是类别数，这些概率取决于grid cell。</p></li><li><p>如果将输入图像划分为S×S grids，则输出空间将为S×S×C，如图2（顶部）所示。</p></li><li><p><strong>该设计基于以下假设：each cell of S×S grids必须属于一个单独的实例</strong>，因此仅属于一个语义类别。</p><p>  这个假设很重要</p></li><li><p>在推理期间，C维输出表示每个对象实例的各类概率。</p></li></ul><h3 id="3-1-2-实例掩码"><a href="#3-1-2-实例掩码" class="headerlink" title="3.1.2 实例掩码"></a>3.1.2 实例掩码</h3><ul><li><p>与语义类别预测并行，每个正grid cell还将生成相应的实例掩码。</p></li><li><p>对于输入图像I，如果将其划分为S×S grids，则总共最多会有$S^2$个预测的掩码。我们在3D输出张量的第3维（通道）上显式编码这些掩码。具体而言，实例掩码输出的尺寸为$H_I×W_I×S^2$，第k个通道将负责在grid(i,j)处分割实例，其中k = i·S + j（i和j从零开始）。为此，在语义类别和与类无关的掩码之间建立了一对一的对应关系（图2）。</p></li><li><p>预测实例掩码的直接方法是采用<strong>完全卷积网络</strong>，例如语义分割中的FCN。</p></li><li><p><strong>FCN的缺点</strong>，这一点不是很懂</p><p>  常规的卷积运算在某种程度上在空间上是不变的，空间不变性对于某些任务（例如图像分类）是理想的，因为它会引入鲁棒性。<br>  但是，这里我们需要一个空间变化（spatially variant）的模型，或者更精确地说，是位置敏感的模型，因为我们的分割掩码的条件是网格单元和必须由不同的功能通道分隔。</p></li><li><p>最后还要进行NMS</p></li></ul><h2 id="3-2-网络结构"><a href="#3-2-网络结构" class="headerlink" title="3.2. 网络结构"></a>3.2. 网络结构</h2><ul><li>FPN会为每个级别生成具有不同大小的特征图金字塔，并具有固定数量的通道（通常为256-d）。网格数可能在不同的金字塔上有所不同。</li><li>这些特征图用作每个预测头的输入：语义类别和实例掩码。</li><li>头部的权重在不同级别上共享。</li></ul><h2 id="3-3-SOLO-Learning"><a href="#3-3-SOLO-Learning" class="headerlink" title="3.3 SOLO Learning"></a>3.3 SOLO Learning</h2><h3 id="3-3-1-标签分配"><a href="#3-3-1-标签分配" class="headerlink" title="3.3.1 标签分配"></a>3.3.1 标签分配</h3><ul><li><p>正负样本</p><p>  如果网格（i，j）在任一个实例的中心区域，则视其为正样本；否则，它为负样本。</p></li><li><p>中心区域</p><p>  center (cx, cy)，factor，中心区域为(cx, cy, w×factor, h×factor)，factor=0.2</p></li></ul><h3 id="3-3-2-损失函数"><a href="#3-3-2-损失函数" class="headerlink" title="3.3.2 损失函数"></a>3.3.2 损失函数</h3><ul><li><p>损失函数</p><p>  L = Lcate + λLmask</p></li></ul><h2 id="3-4-推理"><a href="#3-4-推理" class="headerlink" title="3.4. 推理"></a>3.4. 推理</h2><ul><li>给定输入图像，然后通过骨干网络和FPN推理，并获得网格（i，j）处的类别得分pi，j和相应的掩码mk，其中k = i·S + j，因为我们通常保持行优先（有效）。</li><li>使用置信度阈值0.1来过滤低置信度的预测，然后选择得分排名前500位的掩码，并将其输入到NMS操作中，使用阈值0.5将预测的软掩码二进制化，保留前100个实例蒙版进行评估。</li></ul><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h1><ul><li>测试集：COCO</li><li>训练细节<ul><li>synchronized SGD</li><li>8 GPUs with a total of 16 images per mini-batch、</li><li>36 epochs</li><li>initial learning rate of 0.01，which is then divided by 10 at 27th and again at 33th epoch</li><li>All models are initialized from ImageNet pre-trained weights</li><li>比例抖动：较短的图像边从640到800像素中随机采样。</li></ul></li></ul><h2 id="4-1-主要结果"><a href="#4-1-主要结果" class="headerlink" title="4.1. 主要结果"></a>4.1. 主要结果</h2><p>引言和摘要里讲过</p><h2 id="4-2-SOLO如何工作-起效？"><a href="#4-2-SOLO如何工作-起效？" class="headerlink" title="4.2. SOLO如何工作/起效？"></a>4.2. SOLO如何工作/起效？</h2><p>核心在图4，可以看到预测出的掩码。每个网格将仅对应一个实例，多个相邻的掩码通道可以预测同一个实例，最后使用NMS抑制这些冗余掩码。</p><h2 id="4-3-Ablation-Experiments"><a href="#4-3-Ablation-Experiments" class="headerlink" title="4.3. Ablation Experiments"></a>4.3. Ablation Experiments</h2><ul><li><p>Grid number<br>  在MS COCO上，S = 12已经可以达到27.2 AP。<br>  将网格数提高到24时，SOLO获得29.0 AP。此结果表明，我们的<strong>单比例SOLO可适用于对象比例变化不大的某些场景</strong>。</p></li><li><p>Multi-level Prediction</p><p>  <strong>单尺度SOLO在分割多尺度实例方面遇到了困难，使用FPN的多级预测可以很大程度上解决此问题</strong>，获得了35.8 AP，分割效果的所有指标均得到了很大的改善。</p></li><li><p>CoordConv</p><p>  标准卷积可以在某种程度上具有空间变异性，两个或多个CoordConv无法带来明显的改善。<br>  这表明单个CoordConv已经使预测对空间变体/位置敏感。</p></li><li><p>Loss function</p><p>  Focal Loss比BCE要好，因为实例掩码的大多数像素都在背景中，而FL可通过减少分类良好的样本的损失来减轻样本不平衡问题。但DL最好，而无需手动调整损耗超参数。 </p><p>  通过仔细调整平衡超参数并引入其他训练技巧，可以大大改善BCE和FL的结果。<br>  但是，这里的要点是，<strong>DL使训练通常变得更加稳定</strong>，并且在不使用大量启发式方法的情况下更有可能获得良好的效果。</p><ul><li>BCE<ul><li>正样本的掩码损失权重设置为10，将像素权重设置为2</li></ul></li><li>FL<ul><li>掩码损失权重设置为20</li></ul></li><li>DL<br>  Dice Loss可将像素视为一个整体，并可以自动在前景像素和背景像素之间建立适当的平衡。</li></ul></li></ul><h2 id="4-4-SOLO-512"><a href="#4-4-SOLO-512" class="headerlink" title="4.4. SOLO-512"></a>4.4. SOLO-512</h2><p>较小SOLO版本，输入分辨率较小，旨在加快推理速度。SOLO-512和SOLO之间的其他训练和测试参数相同。</p><p><strong>34.2 mask AP</strong>，SOLO-512达到了<strong>22.5 FPS</strong>的模型推断速度</p><h1 id="5-Decoupled-SOLO"><a href="#5-Decoupled-SOLO" class="headerlink" title="5. Decoupled SOLO"></a>5. Decoupled SOLO</h1><ul><li>output space is decreased from H×W×$S^2$ to H×W×2S</li><li>表7所示，Decoupled SOLO的性能与普通SOLO相同,由于输出空间大大减少，因此在训练和测试期间，Decoupled SOLO需要的GPU内存要少得多。</li></ul><h1 id="6-错误分析"><a href="#6-错误分析" class="headerlink" title="6. 错误分析"></a>6. 错误分析</h1><p>表8，对于每个预测的二进制掩码，我们用标注计算IoU，然后用最重叠的标注替换。</p><ul><li>SOLO AP：37.1</li><li>Ground Truth AP：68.1</li></ul><h1 id="7-SOLO-for-实例轮廓检测"><a href="#7-SOLO-for-实例轮廓检测" class="headerlink" title="7. SOLO for 实例轮廓检测"></a>7. SOLO for 实例轮廓检测</h1><ul><li>改变掩码预测分支的优化目标</li><li>使用OpenCV的findContours函数将COCO中的标注转换为实例轮廓，然后使用该轮廓优化掩码分支。<br>  使用Focal Loss来优化轮廓检测，其他设置与实例分割基线相同。</li></ul><h1 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a>8. 结论</h1><ul><li>与Mask R-CNN相比，具有竞争优势。</li><li>端到端可训练，以恒定推理时间将输入图像直接映射到所需的实例掩码。</li><li>首次引入“实例类别”这一新概念，将实例分割变为为简单的分类任务，从而比所有当前方法都更加简单。</li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下为我总结出的论文各部分的主要内容，某些地方可能夹带着一些自己的理解和思考。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本
      
    
    </summary>
    
    
      <category term="SOLO" scheme="https://chouxianyu.github.io/tags/SOLO/"/>
    
      <category term="实例分割" scheme="https://chouxianyu.github.io/tags/%E5%AE%9E%E4%BE%8B%E5%88%86%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>COCO(Microsoft COCO: Common Objects in Context)论文阅读笔记</title>
    <link href="https://chouxianyu.github.io/2020/08/16/COCO-Microsoft-COCO-Common-Objects-in-Context-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://chouxianyu.github.io/2020/08/16/COCO-Microsoft-COCO-Common-Objects-in-Context-论文阅读笔记/</id>
    <published>2020-08-16T09:50:27.000Z</published>
    <updated>2020-08-16T09:59:04.079Z</updated>
    
    <content type="html"><![CDATA[<p>以下为我总结出的论文各部分的主要内容，某些地方可能夹带着一些自己的理解和思考。</p><p>[toc]</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul><li><p>该论文/该数据集的目的</p><p>  推动目标识别领域的技术突破</p></li><li><p>数据集概要</p><ul><li>320k张图片，250万个实例，91种实例类型</li><li>标注类型：实例分割</li><li>该数据集的主要创新：实例是放在natural context中的，并且语境有很多种而非人为定义的背景中，看Fig1就懂这一点创新了</li></ul></li><li><p>本文工作</p><ol><li>制作该数据集</li><li>统计分析该数据集，并与其它3个数据集做比较</li><li>使用DPM，提供该数据集的目标检测和实例分割的baseline，并分析其performance</li></ol></li></ul><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li><p>场景理解包含的任务</p><ol><li>图像分类：识别目标的种类</li><li>定位：定位2D或3D目标</li><li>确定目标和场景的属性</li><li>描述物体间的关系</li><li>提供场景的语义描述</li></ol></li><li><p>该数据集解决场景理解中3个核心研究问题</p><ol><li>检测非图标的目标。图标型目标，比如百度搜到的那种自行车，绝大多数都是背景很空，中间放了个自行车；自然型目标，比如人在骑自行车，停车场中的自行车，背景、语义的差异是极大的。可以看Fig.2</li><li>对象之间的上下文推理，即上面第4个任务</li><li>目标的精确2D定位，即上面第2个任务中的实例分割</li></ol></li><li><p>假设存在的问题并在该数据集上证明</p><p>  现在的视觉识别系统识别图标型目标的能力相当好，但识别自然场景中的目标的能力却不好</p></li><li><p>一个观点</p><p>  理解目标的空间位置关系，将成为场景分析的核心部分</p></li><li><p>数据集里的图片怎么来的？</p><ol><li>搜索两个目标</li><li>搜索场景</li></ol></li><li><p>在标注时，分步进行，由于标注工作的不确定性在每个阶段中做了很多权衡</p></li><li><p>和其它数据集的区别，详见Fig.5</p><ul><li>和ImageNet对比，COCO有更少类别，但每个类别有更多实例，更有利于目标的定位</li><li>和ImageNet、VOC、SUN相比，该数据集每个类别都有更多实例，更关键的是每张图中实例更多，有利于学习目标间的关系</li><li>和ImageNet相比、VOC相比，该数据集每张图里的实例更多；SUN一张图里的实例则比该数据集高，但整体上数据集中的实例更少。</li></ul></li></ul><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>该数据集依次解决3个问题：</p><ol><li>图像分类</li><li>目标检测</li><li>semantic scene labeling</li></ol><h2 id="图像分类"><a href="#图像分类" class="headerlink" title="图像分类"></a>图像分类</h2><ul><li><p>图像分类做什么</p><p>  给出二进制标签，指出图片中是否包含某目标，见Fig1(a)</p></li><li><p>进展</p><ol><li>MNIST、COIL等数量少，甚至只有一种类别</li><li>CIFAR-10 and CIFAR-100，类别多了些，但还很少且是入门级别entry-level，和人类认知相差很多</li><li>ImageNet突然实现数量和类别（both entry-level and fine-grained）的大增长</li></ol></li></ul><h2 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h2><ul><li><p>目标检测做什么</p><p>  识别并定位某物体，典型的定位方式是矩形框，见Fig.1(b)</p></li><li><p>发展</p><ol><li>人脸识别，先是各种临时数据集，后来出现了更复杂的</li><li>行人识别，Caltech Pedestrian Dataset</li><li>基础目标识别，2005到2012年多年努力，VOC数据集</li></ol></li></ul><h2 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h2><ul><li><p>语义分割做什么</p><p>  确定图片里每个像素属于什么类别，即使是“背景”，见Fig.1(c)</p></li><li><p>发展</p><p>  很难标注，比如草、街道；有室内和室外的数据集；有些数据集还有深度信息（什么意思？没懂）</p><ul><li>SUN数据集，长尾现象（类别数量不平衡，比如wall有20213个，但boat只有349个）</li><li>该数据集（COCO）保证每个类别有大量实例</li></ul></li></ul><h2 id="其它视觉数据集"><a href="#其它视觉数据集" class="headerlink" title="其它视觉数据集"></a>其它视觉数据集</h2><ul><li>Middlebury datasets，立体视觉，多视图立体，光流</li><li>Berkeley Segmentation Data Set(BSDS500)，分割，边缘检测</li></ul><h1 id="图片收集"><a href="#图片收集" class="headerlink" title="图片收集"></a>图片收集</h1><p>如何选择目标的类别以及候选图片</p><h2 id="常见目标类别"><a href="#常见目标类别" class="headerlink" title="常见目标类别"></a>常见目标类别</h2><ul><li><p>对类别的要求</p><ol><li>所有类别中有代表性的那些类别</li><li>和现实应用相关</li><li>高频出现以保证数据集数据多</li></ol></li><li><p>其它类别</p><p>  是否要包括stuff、thing，是否要包括细粒度（Fine-grained）、对象部分（object-part）</p><ul><li><p>thing：很容易区分和标注，比如person、chair。该数据集中做了标注</p></li><li><p>stuff：没有明显边界，比如sky、street、grass。</p><p>  该数据集中没有标注，stuff包含了重要的上下文信息，对其标注是有益的，这一点可以改进</p></li></ul></li><li><p>类别细分度</p><ul><li>例：牧羊犬是狗，狗也是哺乳动物</li><li>为使方案可行，并且保证每个类别有大量实例，该数据集的类别选择entry-level，入门级别，即人们普遍使用的类别，dog、chair、person</li></ul></li><li><p>对象部分</p><p>  预计将包含对象部分类别，比如face、hands、wheels，它们有益于现实应用</p></li><li><p>确定类别</p><ol><li>PASCAL VOC+a subset of the 1200 most frequently used words that denote visually identifiable objects</li><li>让4到8岁的小孩说出他们在室内外看到的物体</li><li>合著者投票5级制投票，考虑是否常用、现实应用价值、与其它类别的差异程度</li><li>根据投票结果选择，同时保证每个类别实例数量均匀且充足。为保证向后兼容，VOC的所有类别都被包含了</li><li>最终得到91个类别</li></ol></li></ul><h2 id="非图标图片收集"><a href="#非图标图片收集" class="headerlink" title="非图标图片收集"></a>非图标图片收集</h2><ul><li><p>将图片分为3类</p><ol><li>iconic object images，通过谷歌和必应图片搜索可以很方便地找到</li><li>iconic scene images</li><li>non-iconic images，目标是主要收集这些图片</li></ol></li><li><p>收集non-iconic images，两个策略</p><ol><li><p>像VOC一样，从Flickr中收集，其中的图片有可以搜索的原数据和关键词</p></li><li><p>成对搜索类别，比如dog + car，搜索结果一般都是non-iconic images，甚至图片里不只这两个类别</p><p> 还有scene/object category pairs</p><p> 如果找不到足够的图片，就单独搜索类别然后筛选出non-iconic images</p></li></ol></li></ul><h1 id="图片标注"><a href="#图片标注" class="headerlink" title="图片标注"></a>图片标注</h1><p>如何标注收集到的图片</p><ul><li>标注pipeline，见Fig3<ol><li>类别标注</li><li>实例定位</li><li>实例分割</li></ol></li><li>对于众包任务，标注人员，来自Amazon’s Mechanical Turk (AMT)，用户接口见附录</li><li>提高标注质量<ol><li>类别标注和实例定位这两个阶段的标注人员增加到8个</li><li>增加一个阶段验证实例分割的标注结果</li></ol></li></ul><h2 id="类别标注"><a href="#类别标注" class="headerlink" title="类别标注"></a>类别标注</h2><ul><li><p>类别标注做什么</p><p>  确定图片里有哪些类别，Fig3(a)，大致标出位置</p></li><li><p>类别标注怎么做</p><ul><li><p>分级/分步：把91个类别分为11个父类</p><p>  只需标出图片里有哪些类别，比如有多个dog，标出一个即可。</p><ol><li>给定图像，向标注人员依次显示每组类别，并要求其指示是否存在该父类的实例。</li><li>如果某标注人员负责从父类（比如动物）中确定存在实例，则对于存在的每个下属类别（狗，猫等），工作人员必须将类别的图标拖到该类别的一个实例上的图像上。</li></ol></li><li><p>共8个标注人员负责这项工作，如果有任何标注人员指出该类别，则认为该类别存在（提高recall）；误报将在后续阶段处理。</p></li></ul></li><li><p>类别标注耗时多久</p><p>  这个阶段耗时20000工时</p></li></ul><h2 id="实例定位"><a href="#实例定位" class="headerlink" title="实例定位"></a>实例定位</h2><ul><li><p>实例定位做什么</p><p>  基于上一步类别标注的结果，标注图像中对象类别的所有实例，大致位置，如果有多个dog，都要标注出来。Fig3(b)</p></li><li><p>实例定位怎么做</p><ul><li>标注人员在上一个阶段中找到的特定类别的每个实例的顶部放置一个叉号</li><li>标注人员可以用放大镜去找到小的实例</li><li>每个工作人员被要求为每个图像标记最多10个给定类别的实例。</li></ul></li><li><p>实例定位耗时多久</p><p>  每个图像由8名工人标记，总计约10,000个工时</p></li></ul><h2 id="实例分割"><a href="#实例分割" class="headerlink" title="实例分割"></a>实例分割</h2><ul><li><p>实例分割做什么</p><p>  基于上一步实例定位的结果，</p></li><li><p>实例分割怎么做</p><ul><li>修改了Bell等人开发的用户接口，</li><li>如果在图像中已经对其他实例进行了分割，则将这些分割显示给工作人员。</li><li>工作人员还可能指示图像中没有给定类别的对象实例（这意味着来自上一阶段的假肯定标签），或者所有对象实例都已被分割。</li><li>为最小化成本，每个实例仅有一名标注人员分割</li><li>初步标注出的质量不高，所以训练标注人员，标注人员和标注结果的质量提高了</li><li>要求多个工作人员（3至5名）判断每个标注，并表明其是否与实例完全匹配。质量不高的标注将被丢弃，并将相应的实例添加回未标注的对象池中。</li><li>一些批准的工人总是生成差劲的标注；从这些工人那里获得的所有工作都被丢弃</li><li>如果实例很密集，比如人群、一车香蕉，就会标注为一个“crowds”（出于评估目的，标记为crowds的区域将被忽略，并且不会影响探测器的得分）</li></ul></li><li><p>实例分割耗时多久</p><ul><li>22 worker hours per 1,000 segmentations.</li></ul></li></ul><h2 id="标注性能分析"><a href="#标注性能分析" class="headerlink" title="标注性能分析"></a>标注性能分析</h2><ul><li>10个标注人员和7个专家标注对比（其实是合著者）</li><li>Ground Truth根据专家的标注确定，10个标注人员的recall更高，见Fig4(a)</li><li>测评中recall更关键，因为错误标注可以在之后去掉</li><li>大多数标注人员具有很高的precision；这些标注人员通常会完成更多工作，见Fig4(b)</li></ul><h2 id="Caption-Annotation"><a href="#Caption-Annotation" class="headerlink" title="Caption Annotation"></a>Caption Annotation</h2><ul><li>为每张图片提供5个说明注释，这一版本的数据集不久后发布</li></ul><h1 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h1><p>和ImageNet, PASCAL VOC 2012, and SUN进行对比</p><ul><li>各自特点<ul><li>ImageNet：类别多且很多是细粒度的</li><li>SUN：关注场景类型及其中的常见目标</li><li>VOC：主要应用于自然图片的目标检测</li><li>COCO：自然图片中的目标检测和分割</li></ul></li><li>其它内容就是Fig5，以及前面引言INtroduction里对数据集本身的描述</li><li>Fig5<ul><li>每个类别的实例的数量，比较均匀</li><li>每张图片里的类别的数量，ImageNet和VOC多数只有1或2个类别，而COCO多数有1-6个类别</li><li>每张图片里的实例的数量，SUN最多，ImageNet和VOC多数是1-2个，COCO多数是1-5个</li><li>类别数量VS实例数量，越靠右上角越复杂</li><li>实例在图片中的占比（尺寸维度），几个数据集差不多，50%以上的目标都不超过图片尺寸的10%</li></ul></li></ul><h1 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h1><p>为更快发行数据集，COCO被分成大致等量的两部分</p><ul><li>第一部分，2014公开，82783训练，40504验证，40775测试</li><li>第二部分，2015公开，165,482 train, 81,208 val, and 81,434 test images.</li><li>训练和验证的标注会公开，但测试集的标注不会公开</li></ul><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="目标框检测"><a href="#目标框检测" class="headerlink" title="目标框检测"></a>目标框检测</h2><ul><li>从COCO中选55k张图片，根据分割标注进行tight-fitting得到矩形框</li><li>在COCO和VOC上测试数据集</li><li>测试两个模型：DPMv5-P和DPMv5-C。P指在PascalVOC2012上训练的。C指在COCO（5000正样本，10000负样本）上训练的，使用默认设置训练COCO的模型。</li><li>两个模型在两个数据集上进行测试，在COCO上的性能都比在VOC上的性能低（见Table1），指出COCO包含更多难的图片。</li><li>关于训练集对性能的影响的<strong>结论</strong>：文中指出<strong>在训练过程中包含困难（非图标）图像可能并不总是有帮助，如果该模型不够丰富，无法捕获此类外观可变性，则此类示例可能会充当噪声并污染学习的模型。<br>  我们的数据集允许探索此类问题。</strong></li><li>一个<strong>结论</strong>：<strong>根据实验，模型在MS COCO的总体性能要低得多。这些观察结果支持两个假设：1）MS COCO比PASCAL VOC困难得多，并且2）在有更多训练数据的情况下，在MS COCO上训练的模型可以更好地推广到更容易的数据集，例如PASCAL VOC。</strong></li></ul><h2 id="基于检测框生成分割"><a href="#基于检测框生成分割" class="headerlink" title="基于检测框生成分割"></a>基于检测框生成分割</h2><ul><li>对每个类别，学习其像素级掩码，方式是将训练得到的实例（框）对齐，然后平均，见Fig7</li></ul><h2 id="通过分割评估检测"><a href="#通过分割评估检测" class="headerlink" title="通过分割评估检测"></a>通过分割评估检测</h2><ul><li>现在有分割标注，通过tight-fitting得到矩形框1，以预测（检测）的分割tight-fitting得到的矩形框2和矩形框1的交并比应大于等于0.5为标准，见Fig8</li><li><strong>结论</strong><ul><li>即使预测和标签的真实边界框重叠得很好，预测的分割也可能无法恢复对象细节，见Fig9左</li><li>Fig9中的结论没怎么看懂，大概是说即使标注及其矩形框IOU很大，也还是难以预测</li><li>Fig9右，在COCO上测试，正确预测的平均交并比也都不高，基本不超0.5，这一点也不是很懂</li></ul></li></ul><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>又强调了一些东西</p><ul><li>over 70,000 worker hours</li><li>non-iconic images of objects in natural environments and varied viewpoints.</li><li>rich contextual information</li></ul><p>未来展望/方向：</p><ul><li>现在没有标注stuff，未来可以标注</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul><li>detailed descriptions of the AMT user interfaces </li><li>the full list of OBJECT &amp; SCENE CATEGORIES</li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下为我总结出的论文各部分的主要内容，某些地方可能夹带着一些自己的理解和思考。&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;该
      
    
    </summary>
    
    
      <category term="COCO" scheme="https://chouxianyu.github.io/tags/COCO/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1141PAT Ranking of Institutions</title>
    <link href="https://chouxianyu.github.io/2020/08/11/PAT%E7%94%B2%E7%BA%A71141PAT-Ranking-of-Institutions/"/>
    <id>https://chouxianyu.github.io/2020/08/11/PAT甲级1141PAT-Ranking-of-Institutions/</id>
    <published>2020-08-11T06:14:01.000Z</published>
    <updated>2020-08-11T06:17:01.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>n个考生，每个考生信息为：</p><ul><li><p>ID</p><p>  6个字符的字符串，第一位是考试等级（B、A、T）</p></li><li><p>score</p><p>  分数，[0,100]的整数</p></li><li><p>school</p><p>  不超6位的学校码，由英文字母组成，不区分大小写，但输入中有大小写</p></li></ul><p>请输出：</p><ul><li><p>第一行输出学校的数量</p></li><li><p>然后按rank的非降序输出Rank School TWS Ns</p><ul><li><p>rank是排名，从1开始，根据TWS非升序排序。</p><p>  如果TWS相等，则两校的rank也相等，且应按NS增序输出；如果Ns也相等，则按学校码的字母表顺序输出</p></li><li><p>school是学校码，用小写输出</p></li><li><p>TWS是加权分，等于该校B级考生总分/1.5+该校A级考生总分+该校T级考生总分*1.5，只取计算结果的整数部分</p></li><li><p>Ns是该校的考生数</p></li></ul></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>注意将学校码转换为小写</p></li><li><p>输出顺序有两方面：</p><ul><li>如果TWS相等，则两校的rank也相等，这一点要在最后控制</li><li>其它输出顺序通过sort函数使用的cmp函数控制</li></ul></li><li><p>我这里是使用了一个map，最后存入vector排序；也可以使用两个map（键都为学校码），一个存每个TWS，一个存Ns，最后都存入vector</p><p>  我计算TWS的方法比较麻烦，因为刚开始理解错了TWS的公式</p></li><li><p>用map而不是unorder_map的话，最后一个测试点会超时</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1141</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184</span></span><br><span class="line"><span class="comment">// Tags: map unordered_map sort</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">School</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> code;  <span class="comment">// 小写的学校码</span></span><br><span class="line">    <span class="keyword">double</span> testeeScoreSums[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> TWS;</span><br><span class="line">    <span class="keyword">int</span> Ns = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calcTWS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;TWS = testeeScoreSums[<span class="number">0</span>] / <span class="number">1.5</span> + testeeScoreSums[<span class="number">1</span>] + testeeScoreSums[<span class="number">2</span>] * <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照要求比较两个学校</span></span><br><span class="line"><span class="comment">// 根据TWS非升序排序。如果TWS相等，则按Ns增序输出；如果Ns也相等，则按学校码的字母表顺序输出</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schoolCmp</span><span class="params">(School &amp;s1, School &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.TWS == s2.TWS)</span><br><span class="line">        <span class="keyword">if</span> (s1.Ns == s2.Ns)</span><br><span class="line">            <span class="keyword">return</span> s1.code &lt; s2.code;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> s1.Ns &lt; s2.Ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s1.TWS &gt; s2.TWS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, score; <span class="comment">// the number of testees, the score of a testee</span></span><br><span class="line">    <span class="built_in">string</span> id, schoolCode, testLevels=<span class="string">"BAT"</span>; <span class="comment">// the id of a testee, the school of a testee, three test levels</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, School&gt; schoolsMap;  <span class="comment">// 键为学校码，值为学校</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; score &gt;&gt; schoolCode;</span><br><span class="line">        transform(schoolCode.begin(), schoolCode.end(), schoolCode.begin(), ::<span class="built_in">tolower</span>);  <span class="comment">// 将学校码转为小写</span></span><br><span class="line">        schoolsMap[schoolCode].code = schoolCode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(id[<span class="number">0</span>] == testLevels[j])&#123;</span><br><span class="line">                schoolsMap[schoolCode].testeeScoreSums[j] += score; <span class="comment">// 分别统计该校三个等级考生的总分</span></span><br><span class="line">                schoolsMap[schoolCode].Ns += <span class="number">1</span>;  <span class="comment">// 统计该校考生数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将学校存入vector并排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;School&gt; schools;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, School&gt;::iterator it = schoolsMap.begin(); it != schoolsMap.end(); it++)&#123;</span><br><span class="line">        it-&gt;second.calcTWS();</span><br><span class="line">        schools.push_back(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(schools.begin(), schools.end(), schoolCmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果，如果TWS相等，则两校的rank也相等，其它输出顺序要求已通过schoolCmp控制</span></span><br><span class="line">    <span class="keyword">int</span> schoolNum = schools.size(), rank = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d %s %d %d\n"</span>, schoolNum, rank, schools[<span class="number">0</span>].code.c_str(), schools[<span class="number">0</span>].TWS, schools[<span class="number">0</span>].Ns);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; schoolNum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(schools[i].TWS &lt; schools[i<span class="number">-1</span>].TWS)</span><br><span class="line">            rank = i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %d %d\n"</span>, rank, schools[i].code.c_str(), schools[i].TWS, schools[i].Ns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1153Decode Registration Card of PAT</title>
    <link href="https://chouxianyu.github.io/2020/08/10/PAT%E7%94%B2%E7%BA%A71153Decode-Registration-Card-of-PAT/"/>
    <id>https://chouxianyu.github.io/2020/08/10/PAT甲级1153Decode-Registration-Card-of-PAT/</id>
    <published>2020-08-10T14:11:51.000Z</published>
    <updated>2020-08-10T14:13:42.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785190929788928" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1071785190929788928</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求和思路"><a href="#题目要求和思路" class="headerlink" title="题目要求和思路"></a>题目要求和思路</h2><p>PAT注册号分4个部分：</p><ul><li>第1位字母代表考试等级</li><li>第2到4位数字是考试地点，大小从101到999</li><li>第5到10位数字为考试日期</li><li>第11到13位数字是考生号，大小从000到999</li></ul><ul><li><p>1：给定考试等级，要求输出该考试等级所有考生的注册号和分数（注册号升序，分数非升序）</p><p>  遍历找出指定考试等级的考生，然后排序输出</p></li><li><p>2：给定考试地点，要求输出该考试地点中考生数和考生分数之和</p><p>  遍历找出指定考试地点的考生，然后统计数据</p></li><li><p>3：给定考试时间，要求输出每个考试地点的考生数（考试地点升序，考生数非升序）</p><p>  遍历考生， 统计每个考试地点的考生数到unordered_map里（统计到map里会超时），键是考试地点，值是考生数，然后输出（我这里是先存入vector再输出）</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1153</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785190929788928</span></span><br><span class="line"><span class="comment">// Tags: map unordered_map sort</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存参试者的信息和最终要输出的结果</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nodeCmp</span><span class="params">(Node&amp; t1, Node&amp; t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.val == t2.val ? t1.str &lt; t2.str : t1.val &gt; t2.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取考生信息</span></span><br><span class="line">    <span class="keyword">int</span> n, m;  <span class="comment">// 输入和查询的数量</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; testees(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; testees[i].str &gt;&gt; testees[i].val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要求并求解</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="built_in">string</span> term;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> caseIndex = <span class="number">1</span>; caseIndex &lt;= m; caseIndex++)&#123;</span><br><span class="line">        <span class="comment">// 获取要求</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type &gt;&gt; term;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %s\n"</span>, caseIndex, type, term.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// type为1和3时的结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; results;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : &#123;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                    <span class="keyword">if</span> (testees[i].str[<span class="number">0</span>] == term[<span class="number">0</span>])</span><br><span class="line">                        results.push_back(testees[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : &#123;</span><br><span class="line">                <span class="keyword">int</span> testeeNum = <span class="number">0</span>, testeeScoreSum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                    <span class="keyword">if</span> (testees[i].str.substr(<span class="number">1</span>, <span class="number">3</span>) == term)&#123;</span><br><span class="line">                        testeeNum += <span class="number">1</span>;</span><br><span class="line">                        testeeScoreSum += testees[i].val;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (testeeNum == <span class="number">0</span> &amp;&amp; testeeScoreSum == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, testeeNum, testeeScoreSum);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : &#123;</span><br><span class="line">                <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; statistics;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                    <span class="keyword">if</span> (testees[i].str.substr(<span class="number">4</span>, <span class="number">6</span>) == term)</span><br><span class="line">                        statistics[testees[i].str.substr(<span class="number">1</span>, <span class="number">3</span>)] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it : statistics)</span><br><span class="line">                    results.push_back(&#123;it.first, it.second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span> || type == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (results.empty())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sort(results.begin(), results.end(), nodeCmp);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.size(); i++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, results[i].str.c_str(), results[i].val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>使用Python语言通过PyQt5和socket实现UDP服务器</title>
    <link href="https://chouxianyu.github.io/2020/08/10/%E4%BD%BF%E7%94%A8Python%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87PyQt5%E5%92%8Csocket%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://chouxianyu.github.io/2020/08/10/使用Python语言通过PyQt5和socket实现UDP服务器/</id>
    <published>2020-08-10T07:07:03.000Z</published>
    <updated>2020-08-10T07:12:19.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近做了一个小软件，记录一下相关内容。</p><h2 id="已有条件"><a href="#已有条件" class="headerlink" title="已有条件"></a>已有条件</h2><p>现在已有一个硬件设备作为客户端（暂称其为“电路”）。</p><p>基于SIM卡，电路可以通过UDP协议传输数据（程序已经内置在电路中），只需要修改配置文件（位于SD卡中，主要修改服务器端的IP和端口）即可。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我面向的需求是这样的：我需要开发一个服务器端的程序，接收多个客户端发来的数据并开发可视化界面。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从开发角度和技术角度来看，软件的基础和核心技术是使用<strong>UDP协议</strong>进行数据传输，并使用PyQt5和pyqtgraph做可视化界面（还用到了QThread和自定义的下拉复选框），开发过程中还涉及到了内网穿透和NATAPP。</p><h1 id="理论基础：运输层"><a href="#理论基础：运输层" class="headerlink" title="理论基础：运输层"></a>理论基础：运输层</h1><p>为使用UDP协议进行数据传输，我大致复习了一下计算机网络中的运输层。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>运输层实现两台主机中<strong>进程</strong>之间的通信，一个主机中的多个进程可以和另一台主机中的多个进程通信。</p><p>运输层实现上述功能的方案是端口（port）</p><h2 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h2><p>运输层有两个主要协议：</p><ul><li>传输控制协议TCP（Transmission Control Protocol）</li><li>用户数据报协议UDP（User Datagram Protocol）</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>TCP是<strong>面向连接</strong>的<ul><li>应用进程在传输数据前必须先建立连接，数据传送结束后要释放连接</li></ul></li><li>TCP连接是<strong>点对点</strong>的<ul><li>每一条TCP连接只能有两个端点</li><li>TCP不提供广播或多播服务</li></ul></li><li>TCP提供<strong>可靠交付</strong>的服务<ul><li>通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达</li></ul></li><li>TCP<strong>面向字节流</strong><ul><li>虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成一连串的无结构的字节流。</li><li>TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小</li><li>TCP保证接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样，同时接收方应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul></li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li>UDP是<strong>无连接</strong>的<ul><li>在传输数据前不需要先建立连接，主机在收到UDP报文后不需要给出任何确认</li></ul></li><li>UDP是<strong>面向报文</strong>的<ul><li>发送方：UDP对应用层交下来的报文，不合并也不拆分，添加首部后就交付给IP层</li><li>接收方：UDP对IP层交上来的UDP用户数据包，在去除首部后就直接交付给应用层的进程</li></ul></li><li>UDP<strong>尽最大努力交付</strong><ul><li>不保证可靠交付</li></ul></li><li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信</li></ul><h1 id="Python中的UDP编程"><a href="#Python中的UDP编程" class="headerlink" title="Python中的UDP编程"></a>Python中的UDP编程</h1><p>Python中的UDP编程可以通过<code>socket</code>来实现，下面是一个简单样例</p><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_ip = <span class="string">'127.0.0.1'</span></span><br><span class="line">server_port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="comment"># socket.SOCK_DGRAM代表是UDP通信</span></span><br><span class="line"><span class="comment"># 绑定IP和端口</span></span><br><span class="line">s.bind((server_ip, server_port))</span><br><span class="line">print(<span class="string">'Bind UDP Server on %s:%s'</span> % (server_ip, server_port))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(addr, <span class="string">"\t"</span>, data)</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    s.sendto(<span class="string">b'Received:%s'</span>%data, addr)</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_ip = <span class="string">'127.0.0.1'</span></span><br><span class="line">server_port = <span class="number">59955</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="comment"># socket.SOCK_DGRAM代表是UDP通信</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'Michael'</span>, <span class="string">b'Tracy'</span>, <span class="string">b'Sarah'</span>]:</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    s.sendto(data, (server_ip, server_port))</span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    <span class="comment"># print(s.recv(1024).decode('utf-8'))</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><h2 id="值得注意的问题：缓冲区机制"><a href="#值得注意的问题：缓冲区机制" class="headerlink" title="值得注意的问题：缓冲区机制"></a>值得注意的问题：缓冲区机制</h2><p>UDP通信时，两个主机都要建立一个socket。</p><p>我这里的情况是客户端会一直给服务器端发数据。</p><p>在服务器端我发现socket一旦建立（准确来讲是创建socket对象并绑定至本地端口），就会一直接收数据，而不是调用recvfrom等函数（这类函数用来接收数据）时才会接收。</p><p>估计这是缓冲区机制，UDP应该就是这么设计的。大概就是socket对象创建后，收到的内容就会放入缓冲区，如果调用了recvfrom等数据接收函数就从缓冲区中取出数据。</p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="为什么要用内网穿透"><a href="#为什么要用内网穿透" class="headerlink" title="为什么要用内网穿透"></a>为什么要用内网穿透</h2><p>先不讲内网穿透是什么，有兴趣的可以自己去查查，下面我大概讲讲我浅显的理解。</p><p>在开发服务器端程序的过程中，我用的是自己的电脑，连接的网络是手机热点（因为在宿舍），因此我的电脑是没有公网IP的。</p><p>客户端程序用的是SIM卡，用的是公网（外网）IP，我开发的服务器端程序用的是私网（内网）IP。</p><p>公网IP是无法访问私网IP的（因为NAT），所以<strong>我需要让我的服务器端程序能够被外网访问</strong>。</p><p>问了一下<a href="https://www.cnblogs.com/roadwide/" target="_blank" rel="noopener">@roadwide</a>，他说要用内网穿透，并推荐了<strong>NATAPP</strong>等软件。</p><h2 id="NATAPP的使用"><a href="#NATAPP的使用" class="headerlink" title="NATAPP的使用"></a>NATAPP的使用</h2><p>怎么用呢？看看官方教程就知道了，链接放在文章末尾了。</p><p>讲一个比较关键的点，以理解下NATAPP是干嘛的</p><p><img src="https://cdn.natapp.cn/uploads/ueditor/php/upload/image/20170118/1484723077222282.png" alt="NATAPP截图"></p><p>NATAPP运行起来后，就会将上图红框里的URL映射到本机（127.0.0.1）的80端口。</p><p>NATAPP会给我一个URL（作为我的外网IP），这样客户端程序通过访问NATAPP给我的URL就可以间接访问我在本机运行的服务器端程序。</p><h1 id="PyQt5"><a href="#PyQt5" class="headerlink" title="PyQt5"></a>PyQt5</h1><h2 id="QThread"><a href="#QThread" class="headerlink" title="QThread"></a>QThread</h2><p>服务器端程序的界面上有两个作用分别是开始接收数据和停止接收数据的按钮。</p><p>接收数据是通过一个while循环（循环体中接收一个数据）实现的，如果点击开始接收数据的按钮，那就运行while循环直到停止接收数据的按钮被点击。</p><p>刚开始实现数据接收功能时发现程序界面会崩溃、点击不动，因为直接把while循环写在<strong>软件主界面</strong>的代码中。</p><p>后来使用了PyQt5中的QThread（也有人说QThread并不是一个线程），在一个线程中实现while循环，然后就成功了。</p><p>在实现时我参考了其他网友的代码，参考链接放在文章末尾，注意一点是实现方式不止一种，比如说有些网友说用threading也可以，而且我也发现我的思路和参考的那份代码稍有不一样（我们实现的功能是相似的，但我只用了一个pyqtSignal，而那位网友用了两个）。</p><h2 id="下拉复选框"><a href="#下拉复选框" class="headerlink" title="下拉复选框"></a>下拉复选框</h2><p>这个软件需要有一个下拉复选框，而PyQt5中并没有这个东西，因此需要手动实现，这里我参考了其他网友的实现方式，参考链接见文章末尾。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><h2 id="Python中的UDP编程-1"><a href="#Python中的UDP编程-1" class="headerlink" title="Python中的UDP编程"></a>Python中的UDP编程</h2><p><a href="https://blog.csdn.net/vict_wang/article/details/81587093" target="_blank" rel="noopener">https://blog.csdn.net/vict_wang/article/details/81587093</a></p><p><a href="https://www.jb51.net/article/165933.htm" target="_blank" rel="noopener">https://www.jb51.net/article/165933.htm</a></p><h2 id="理解NAT和内网穿透"><a href="#理解NAT和内网穿透" class="headerlink" title="理解NAT和内网穿透"></a>理解NAT和内网穿透</h2><p><a href="https://baike.baidu.com/item/nat/320024" target="_blank" rel="noopener">https://baike.baidu.com/item/nat/320024</a></p><p><a href="https://baike.baidu.com/item/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F</a></p><h2 id="NATAPP"><a href="#NATAPP" class="headerlink" title="NATAPP"></a>NATAPP</h2><p><a href="https://natapp.cn/#" target="_blank" rel="noopener">https://natapp.cn/#</a></p><p><a href="https://natapp.cn/article/natapp_newbie" target="_blank" rel="noopener">https://natapp.cn/article/natapp_newbie</a></p><h2 id="PyQt5-1"><a href="#PyQt5-1" class="headerlink" title="PyQt5"></a>PyQt5</h2><ul><li><p>PyQt5下拉式复选框QComboCheckBox</p><p>  <a href="https://blog.csdn.net/LJX4ever/article/details/78039318" target="_blank" rel="noopener">https://blog.csdn.net/LJX4ever/article/details/78039318</a></p></li><li><p>QThread实现循环</p><p>  <a href="https://segmentfault.com/a/1190000020746912?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020746912?utm_source=tag-newest</a></p></li><li><p>AttributeError: ‘PyQt5.QtCore.pyqtSignal’ object has no attribute ‘connect’</p></li></ul><h2 id="pyqtgraph"><a href="#pyqtgraph" class="headerlink" title="pyqtgraph"></a>pyqtgraph</h2><ul><li><p>pyqtgraph中绘制多个线条（我实现这个功能时也看了pyqtgraph的example）</p><p>  <a href="https://zmister.com/archives/219.html#plot-2" target="_blank" rel="noopener">https://zmister.com/archives/219.html#plot-2</a></p></li><li><p>pyqtgraph中添加图例（legend）</p><p>  <a href="https://zmister.com/archives/220.html?replytocom=558" target="_blank" rel="noopener">https://zmister.com/archives/220.html?replytocom=558</a></p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近做了一个小软件，记录一下相关内容。&lt;/p&gt;
&lt;h2 id=&quot;已有条件&quot;&gt;&lt;a href=&quot;#已有条件&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="UDP" scheme="https://chouxianyu.github.io/tags/UDP/"/>
    
      <category term="PyQt5" scheme="https://chouxianyu.github.io/tags/PyQt5/"/>
    
      <category term="socket" scheme="https://chouxianyu.github.io/tags/socket/"/>
    
      <category term="pyqtgraph" scheme="https://chouxianyu.github.io/tags/pyqtgraph/"/>
    
      <category term="QThread" scheme="https://chouxianyu.github.io/tags/QThread/"/>
    
      <category term="内网穿透" scheme="https://chouxianyu.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="NATAPP" scheme="https://chouxianyu.github.io/tags/NATAPP/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1145Hashing - Average Search Time</title>
    <link href="https://chouxianyu.github.io/2020/08/07/PAT%E7%94%B2%E7%BA%A71145Hashing-Average-Search-Time/"/>
    <id>https://chouxianyu.github.io/2020/08/07/PAT甲级1145Hashing-Average-Search-Time/</id>
    <published>2020-08-07T15:23:04.000Z</published>
    <updated>2020-08-07T15:23:51.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343236767744" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805343236767744</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="基础知识：哈希"><a href="#基础知识：哈希" class="headerlink" title="基础知识：哈希"></a>基础知识：哈希</h2><p>为做这道题，我简单复习了一下<a href="https://www.cnblogs.com/chouxianyu/p/13455884.html" target="_blank" rel="noopener">哈希（点击查看）</a>。</p><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>往一个哈希表里插入n个正整数，然后从哈希表里查找m个正整数，请输出平均查找次数（即比较次数）</p><p>哈希函数定义为$H(key)= key \% TSize$，其中$TSize$是哈希表的最大容量，它最好是素数，如果输入的不是素数就必须找到大于输入的最小素数。</p><p>用二次探测（仅具有正增量）解决冲突。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li><p>distinct</p><p>  截然不同的, 完全分开的</p></li><li><p>sequence</p><p>  有关联的一组事物, 一连串</p></li><li><p>quadratic</p><p>  二次的，二次方程式</p></li><li><p>probe</p><p>  n. 探针；调查<br>  vi. 调查；探测<br>  vt. 探查；用探针探测</p></li><li><p>collision</p><p>  碰撞, 冲突, 抵触</p></li><li><p>Quadratic probing (with positive increments only) is used to solve the collisions.</p><p>  二次探测（仅具有正增量）用于解决冲突。</p></li><li><p>synonym</p><p>  同义词</p></li><li><p>accurate up to 1 decimal place</p><p>  精确到小数点后1位</p></li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>待查找的元素可能不存在</li><li>题目说了输入的关键字都是<strong>正</strong>整数，所以可以把0作为表中某个位置没有元素的标志</li><li>注意这里的二次探测再散列只有正增量</li><li>查找时间指查找时进行比较的次数，如果没有再探测（即一次就找到了），那比较次数就是1</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1145</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343236767744</span></span><br><span class="line"><span class="comment">// Tags: Hash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++)</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取输入的第一行</span></span><br><span class="line">    <span class="keyword">int</span> mSize, n, m; <span class="comment">// 哈希表最大容量、输入的整数的数量、待查找的整数的数量，都不超过1e4</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mSize &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立哈希表</span></span><br><span class="line">    <span class="keyword">while</span> (!isPrime(mSize)) mSize++;  <span class="comment">// 使哈希表表长为大于等于输入的最小素数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashTable(mSize); <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span> key, pos; <span class="comment">// 关键字、哈希地址</span></span><br><span class="line">    <span class="keyword">bool</span> posFound; <span class="comment">// 某个key的位置是否找到了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; key; <span class="comment">// 获取关键字</span></span><br><span class="line">        posFound = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mSize; j++)&#123; <span class="comment">// 二次探测再散列（只有正增量）</span></span><br><span class="line">            pos = (key + j * j) % mSize;</span><br><span class="line">            <span class="keyword">if</span> (hashTable[pos] == <span class="number">0</span>)&#123;  <span class="comment">// 这要求key不为0</span></span><br><span class="line">                hashTable[pos] = key;</span><br><span class="line">                posFound = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!posFound) <span class="built_in">printf</span>(<span class="string">"%d cannot be inserted.\n"</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素并统计平均查找次数</span></span><br><span class="line">    <span class="keyword">double</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= mSize; j++)&#123; <span class="comment">// 题目似乎有问题，应该是j&lt;mSize的，而不是&lt;=</span></span><br><span class="line">            pos = (key + j * j) % mSize;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (hashTable[pos] == key || hashTable[pos] == <span class="number">0</span>)  <span class="comment">// 注意待查找的元素可能不存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, count / m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="哈希" scheme="https://chouxianyu.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-哈希</title>
    <link href="https://chouxianyu.github.io/2020/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C/"/>
    <id>https://chouxianyu.github.io/2020/08/07/数据结构-哈希/</id>
    <published>2020-08-07T15:22:37.000Z</published>
    <updated>2020-08-07T15:25:05.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希函数、哈希表、哈希地址"><a href="#哈希函数、哈希表、哈希地址" class="headerlink" title="哈希函数、哈希表、哈希地址"></a>哈希函数、哈希表、哈希地址</h1><p>根据设定的<strong>哈希函数</strong>$H(key)$和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集上的“像”作为记录在表中的存储位置，这种表便称为<strong>哈希表</strong>，这一映像过程称为哈希造表或散列，所得存储位置成<strong>哈希地址</strong>或散列地址。</p><h1 id="冲突、同义词"><a href="#冲突、同义词" class="headerlink" title="冲突、同义词"></a>冲突、同义词</h1><p>不同的关键字经哈希函数映像后求得到的哈希地址可能相同，即$key1\neq key2\ and \ H(key1)=H(key2)$，这就是<strong>冲突（collision）</strong>；具有相同哈希地址的关键字对该哈希函数来说就是<strong>同义词（synonym）</strong>。</p><p>哈希函数选得合适可以减少冲突现象。</p><p>一般情况下，哈希函数是一个压缩映像（关键字集合到地址集合的映像，而关键字集合的大小远大于地址集合），因此冲突只能尽可能地少而不能完全避免。</p><h1 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h1><p>常用的构造哈希函数的方法有：</p><ol><li>直接定址法</li><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>除留余数法</li><li>随机数法</li></ol><h1 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h1><p>处理冲突过程中会有一个地址序列$H_i,i=1,2,\dots,k$，即如果发生冲突，就去找下一个地址。</p><p>通常用的处理冲突的方法有下列几种：</p><ol><li>开放定址法</li><li>再哈希法</li><li>链地址法</li><li>建立一个公共溢出区</li></ol><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><script type="math/tex; mode=display">H_i=(H(key)+d_i)\ MOD\ m \ ，\ i=1,2,\dots, k(k\leq m-1)</script><p>其中$H(key)$为哈希函数；$m$是哈希表表长；$d_i$为增量序列，可以有下面3种取法：</p><ol><li>$d_i=1,2,3\dots,m-1$，称为线性探测再散列</li><li>$d_i=1^2,-1^2,2^2,-2^2,3^2,\dots,\pm k^2,(k\leq m/2)$，称为二次探测再散列</li><li>$d_i=伪随机数序列$，称为伪随机探测再散列</li></ol><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希函数、哈希表、哈希地址&quot;&gt;&lt;a href=&quot;#哈希函数、哈希表、哈希地址&quot; class=&quot;headerlink&quot; title=&quot;哈希函数、哈希表、哈希地址&quot;&gt;&lt;/a&gt;哈希函数、哈希表、哈希地址&lt;/h1&gt;&lt;p&gt;根据设定的&lt;strong&gt;哈希函数&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希" scheme="https://chouxianyu.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1133Splitting A Linked List</title>
    <link href="https://chouxianyu.github.io/2020/08/07/PAT%E7%94%B2%E7%BA%A71133Splitting-A-Linked-List/"/>
    <id>https://chouxianyu.github.io/2020/08/07/PAT甲级1133Splitting-A-Linked-List/</id>
    <published>2020-08-07T04:50:59.000Z</published>
    <updated>2020-08-07T04:52:33.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给1个有n（不超过1e5）个结点的单向链表和数字k（不超过1e3），链表的值属于[-1e5,1e5]要求将链表改为（或输出）：负数结点出现在正数结点之前，值属于[0,k]的结点出现在值大于k的结点之前，其余不变##</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>PAT中的这种链表适合用数组形式的链表</li><li>PAT里的链表和LeetCode里的链表（LeetCode里的链表是基于指针的）不太一样，因此操作也要适当调整</li><li>不一定要修改链表结构，能按要求输出就可以</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用数组表示链表，然后遍历将链表里的结点分成3类（小于0的、0到k的、大于k的）并存入3个数组，然后按顺序遍历3个数组并输出</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1133</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320</span></span><br><span class="line"><span class="comment">// Tags: Linked List</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListNode <span class="built_in">list</span>[<span class="keyword">int</span>(<span class="number">1e5</span>) + <span class="number">10</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parts[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    <span class="keyword">int</span> head, n, k; <span class="comment">// 头结点地址、结点数量、k</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; head &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; address;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">list</span>[address].val &gt;&gt; <span class="built_in">list</span>[address].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表将其中的结点分为3个部分</span></span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> partIndex = <span class="number">1</span>;  <span class="comment">// 默认为第2部分，即结点的值属于[0,k]</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>[p].val &lt; <span class="number">0</span>)</span><br><span class="line">            partIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">list</span>[p].val &gt; k)</span><br><span class="line">            partIndex = <span class="number">2</span>;</span><br><span class="line">        parts[partIndex].push_back(p);</span><br><span class="line">        p = <span class="built_in">list</span>[p].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将划分好的3部分结点输出</span></span><br><span class="line">    <span class="keyword">bool</span> isFirstLine = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; parts[i].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isFirstLine)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%05d %d"</span>, parts[i][j], <span class="built_in">list</span>[parts[i][j]].val);</span><br><span class="line">                isFirstLine = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %05d\n%05d %d"</span>, parts[i][j], parts[i][j], <span class="built_in">list</span>[parts[i][j]].val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" -1"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1144The Missing Number</title>
    <link href="https://chouxianyu.github.io/2020/08/06/PAT%E7%94%B2%E7%BA%A71144The-Missing-Number/"/>
    <id>https://chouxianyu.github.io/2020/08/06/PAT甲级1144The-Missing-Number/</id>
    <published>2020-08-06T15:41:28.000Z</published>
    <updated>2020-08-06T15:42:51.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343463260160" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805343463260160</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给n（小于1e5）个int，找到最小的不在这些数字里的正整数</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li><p>map未创建某元素时，如果直接访问，则其value是一个默认值</p></li><li><p>根据输入样例可知n个数字中可以有重复数字</p></li><li><p>map会按照key自动升序排列</p></li><li><p>这道题也可以暴力解，创建一个int数组，因为最后要求<strong>正</strong>整数，所以可以不统计负数</p><p>  如果这么做，要注意一个边界情况：不缺数字，比如输入了5个数字，分别是1 2 3 4 5</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1144</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343463260160</span></span><br><span class="line"><span class="comment">// Tags: map</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numCount;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        numCount[num]++; <span class="comment">// 计数，根据输入样例可知n个数字中可以有重复数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (++num)</span><br><span class="line">        <span class="comment">// map未创建某元素时，如果直接访问，则其value是一个默认值</span></span><br><span class="line">        <span class="keyword">if</span> (numCount[num] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1132Cut Integer</title>
    <link href="https://chouxianyu.github.io/2020/08/06/PAT%E7%94%B2%E7%BA%A71132Cut-Integer/"/>
    <id>https://chouxianyu.github.io/2020/08/06/PAT甲级1132Cut-Integer/</id>
    <published>2020-08-06T10:12:19.000Z</published>
    <updated>2020-08-06T10:13:19.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347145859072" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805347145859072</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>给n个k位（k为偶数）的整数z，将其分成a和b，判断z/(a*b)是不是一个整数即可</p><p>这里要注意a和b是否为0，这是个<strong>边界情况</strong>，如果没有处理这个边界情况，有2个测试点不能过，只能得14分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1132</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347145859072</span></span><br><span class="line"><span class="comment">// Tags: Math</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="built_in">string</span> z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; z;</span><br><span class="line">        <span class="built_in">string</span> a = z.substr(<span class="number">0</span>, z.length() / <span class="number">2</span>), b = z.substr(z.length() / <span class="number">2</span>, z.length() / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> mul = stoi(a) * stoi(b);</span><br><span class="line">        <span class="keyword">if</span> (mul != <span class="number">0</span> &amp;&amp; stoi(z) % mul == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1148Werewolf - Simple Version</title>
    <link href="https://chouxianyu.github.io/2020/08/05/PAT%E7%94%B2%E7%BA%A71148Werewolf-Simple-Version/"/>
    <id>https://chouxianyu.github.io/2020/08/05/PAT甲级1148Werewolf-Simple-Version/</id>
    <published>2020-08-05T15:19:12.000Z</published>
    <updated>2020-08-05T15:20:20.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1038429808099098624" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1038429808099098624</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>N（5到100）个玩家，其中2个狼人，只有1个狼人在撒谎（题目里说至少有1个狼人在撒谎但不是所有狼人都在撒谎……直接讲只有1个狼人在撒谎不行吗……），共有2人撒谎，请找出两个狼人</p><p>描述中+则是人类，-则是狼人</p><p>如果有解，请按增序输出狼人</p><p>如果多个解，则输出最小的</p><p>没有讲解则输出”No Solution” </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>刚看完题时没啥思路……特别是有多个解的情况，让我以为要求出所有解，我似乎还想过枚举是谁在撒谎（得到谁在撒谎并不能很有效地得到答案……）</p><p>可以枚举狼人是谁的情况，如果与题目和输入相符（1个狼人和1个人在撒谎），则直接输出狼人（如果有多个解，从小到大枚举狼人求得的第一个解就是多个解中最小的解）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1148</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429808099098624</span></span><br><span class="line"><span class="comment">// Tags: Math</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; statements(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; statements[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="comment">// 枚举2个狼人是i和j</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; identities(n+<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 玩家身份：1代表人类，-1代表狼人</span></span><br><span class="line">            identities[i] = identities[j] = <span class="number">-1</span>; <span class="comment">// i和j是狼人</span></span><br><span class="line">            <span class="comment">// 寻找撒谎的玩家</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; liars;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; statements.size(); k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (statements[k] * identities[<span class="built_in">abs</span>(statements[k])] &lt; <span class="number">0</span>)</span><br><span class="line">                    liars.push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断当前枚举的狼人i和j是否符合题目要求和输入</span></span><br><span class="line">            <span class="keyword">if</span> (liars.size() == <span class="number">2</span> &amp;&amp; identities[liars[<span class="number">0</span>]] + identities[liars[<span class="number">1</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1136A Delayed Palindrome</title>
    <link href="https://chouxianyu.github.io/2020/08/05/PAT%E7%94%B2%E7%BA%A71136A-Delayed-Palindrome/"/>
    <id>https://chouxianyu.github.io/2020/08/05/PAT甲级1136A-Delayed-Palindrome/</id>
    <published>2020-08-05T07:49:08.000Z</published>
    <updated>2020-08-05T07:52:46.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li><p>notation</p><p>  标记法</p></li><li><p>palindromic</p><p>  回文的</p></li><li><p>palindrome</p><p>  回文</p></li><li><p>be paired with</p><p>  与……配对</p></li></ul><h2 id="思路、注意点和代码"><a href="#思路、注意点和代码" class="headerlink" title="思路、注意点和代码"></a>思路、注意点和代码</h2><ul><li>要实现回文数判断</li><li>要实现字符串逆序</li><li>整体思路就是题目描述的那样：判断是不是回文数，不是的话就逆序后和原数相加，重复这一过程直至得到回文数或者超过10次迭代</li></ul><p>下面是我刚开始时写的代码，结果是Partially Accepted，得了14分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1136</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624</span></span><br><span class="line"><span class="comment">// Tags: String</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[len<span class="number">-1</span>-i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a_str, b_str, c_str;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a_str;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        b_str = <span class="built_in">string</span>(a_str.rbegin(), a_str.rend());</span><br><span class="line">        c_str = to_string(stoi(a_str) + stoi(b_str));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a_str &lt;&lt; <span class="string">" + "</span> &lt;&lt; b_str &lt;&lt; <span class="string">" = "</span> &lt;&lt; c_str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (isPalindromic(c_str))&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c_str &lt;&lt; <span class="string">" is a palindromic number."</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a_str = c_str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found in 10 iterations."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><p>看了下柳婼的代码，和我写的题解一相比，她的代码有以下不同：</p><ul><li><p>她考虑了输入就是回文数的<strong>边界情况</strong>，我没有考虑，这个测试点占4分</p></li><li><p>回文数的判断方法不同，她是判断逆序后是否相等，我是遍历判断</p></li><li><p>她手动实现了字符串数字的加法，而我是将字符串转成数字进而相加，这里我忽略了<strong>数值范围</strong>，这个测试点占2分</p><p>  题目说不超过1000位，就算使用longlong也不行，所以必须手动实现字符串相加</p></li></ul><p>基于我刚开始写的题解一和上面分析的内容，正确代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1136</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624</span></span><br><span class="line"><span class="comment">// Tags: String Palindrome</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[len<span class="number">-1</span>-i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addString</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum = a[i] - <span class="string">'0'</span> + b[i] - <span class="string">'0'</span> + carry;  <span class="comment">// 注意进位和'0'</span></span><br><span class="line">        a[i] = sum % <span class="number">10</span> + <span class="string">'0'</span>;  <span class="comment">// 注意'0'</span></span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">        a = <span class="string">"1"</span> + a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a_str, b_str, c_str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a_str;</span><br><span class="line">    <span class="keyword">if</span> (isPalindromic(a_str))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a_str &lt;&lt; <span class="string">" is a palindromic number."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        b_str = <span class="built_in">string</span>(a_str.rbegin(), a_str.rend());</span><br><span class="line">        c_str = addString(a_str, b_str);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a_str &lt;&lt; <span class="string">" + "</span> &lt;&lt; b_str &lt;&lt; <span class="string">" = "</span> &lt;&lt; c_str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (isPalindromic(c_str))&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c_str &lt;&lt; <span class="string">" is a palindromic number."</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a_str = c_str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found in 10 iterations."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="字符串" scheme="https://chouxianyu.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回文数" scheme="https://chouxianyu.github.io/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
</feed>
