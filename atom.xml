<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2020-07-26T06:38:21.849Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode101对称二叉树</title>
    <link href="https://chouxianyu.github.io/2020/07/26/LeetCode101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://chouxianyu.github.io/2020/07/26/LeetCode101对称二叉树/</id>
    <published>2020-07-26T06:36:56.000Z</published>
    <updated>2020-07-26T06:38:21.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>我写的</li><li>递归解法</li><li>具体方法见代码注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 101</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/symmetric-tree/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion DFS</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 判断两个树s和t是否互相对称</span></span><br><span class="line">    <span class="comment">// 有3个要求：</span></span><br><span class="line">    <span class="comment">// ①根节点值相等</span></span><br><span class="line">    <span class="comment">// ②s的左子树和t的右子树互相对称</span></span><br><span class="line">    <span class="comment">// ③s的右子树和t的左子树互相对称</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* s, TreeNode* t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span> &amp;&amp; t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span> || t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val == t-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isSymmetric(s-&gt;left, t-&gt;right) &amp;&amp; isSymmetric(s-&gt;right, t-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果该树为空，则为对称的</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 左子树和右子树对称</span></span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/symmetric-tree/&quot; tar
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode572另一个树的子树</title>
    <link href="https://chouxianyu.github.io/2020/07/26/LeetCode572%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>https://chouxianyu.github.io/2020/07/26/LeetCode572另一个树的子树/</id>
    <published>2020-07-26T06:05:52.000Z</published>
    <updated>2020-07-26T06:06:55.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subtree-of-another-tree/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>我写的</li><li>两层DFS、双重DFS</li><li>其它题解一般也是这个思路</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 572</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/subtree-of-another-tree/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion DFS</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 判断s和t两个树是否相同（同质）</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSametree</span><span class="params">(TreeNode* s, TreeNode* t)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个树均为空</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span> &amp;&amp; t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 一个树为空</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span> || t==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 两个树都不为空</span></span><br><span class="line">        <span class="keyword">if</span>(s-&gt;val==t-&gt;val)</span><br><span class="line">            <span class="comment">// 如果根节点的val都相同，则递归比较子树</span></span><br><span class="line">            <span class="keyword">return</span> isSametree(s-&gt;left, t-&gt;left) &amp;&amp; isSametree(s-&gt;right, t-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 判断t是否为s的子树</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果s是空树，则t不可能是s的子树</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// t为s的子树有3种可能：s==t、t是s左子树的子树、t是s右子树的子树</span></span><br><span class="line">        <span class="keyword">return</span> isSametree(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/subtree-of-another-t
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode437路径总和III</title>
    <link href="https://chouxianyu.github.io/2020/07/26/LeetCode437%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/"/>
    <id>https://chouxianyu.github.io/2020/07/26/LeetCode437路径总和III/</id>
    <published>2020-07-26T05:40:41.000Z</published>
    <updated>2020-07-26T05:42:27.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum-iii/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li><p>两个DFS，两个DFS作用不一样</p></li><li><p>我写的，其它人的题解大概也是这个思路</p></li><li><p>这道题是<a href="https://www.cnblogs.com/chouxianyu/p/13377753.html" target="_blank" rel="noopener">昨天那道题(点击查看)</a>的扩展，建议先看一下昨天那道题的题解二。</p><ul><li>昨天那道题中的路径是<strong>根节点到叶子节点</strong>之间的路径</li><li>今天这道题中的路径是<strong>任意节点到任意节点</strong>之间的路径，只要求是向下的（即从父节点到子节点）</li></ul></li><li><p>可以按照下面2步修改昨天那道题，即可得到今天这道题并求解</p><ol><li><p><strong>Step1</strong>：求<strong>根节点到任意节点（而非叶子节点）</strong>之间的路径</p><p> 处理这一差异，只需要将昨天那道题判断语句中的叶子结点条件删除即可，即只判断路径长度是否相等，不管是不是叶子结点</p></li><li><p><strong>Step2</strong>：求<strong>任意结点（而非根节点）到任意节点</strong>之间的路径</p><p> 处理这一差异，只需基于昨天那道题的解法，再套一层递归，即不止求根节点，还要递归求解其左右子树并将路径数相加</p></li></ol></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 437</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/path-sum-iii/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion DFS</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Step1：搜索当前子树中节点到根节点之间距离等于sum的路径数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == sum)</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">return</span> count + dfs(root-&gt;left, sum - root-&gt;val) + dfs(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Step2：结果为：以当前节点为根节点时的路径数+以左子节点为根节点时的路径数+以右子节点为根节点时的路径数；</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/path-sum-iii/&quot; targe
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode112路径总和</title>
    <link href="https://chouxianyu.github.io/2020/07/25/LeetCode112%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>https://chouxianyu.github.io/2020/07/25/LeetCode112路径总和/</id>
    <published>2020-07-25T10:31:57.000Z</published>
    <updated>2020-07-25T10:47:13.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-sum/</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><ul><li>我自己写的</li><li>在dfs过程中要记录当前节点与根节点之间的距离，并且回溯时也需要更新该值</li><li>注意要求是<strong>叶子</strong>节点到根节点之间的距离</li><li>详细思路见代码注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 112</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/path-sum/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion DFS 回溯</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> existed = <span class="literal">false</span>;  <span class="comment">// 当前是否存在叶子节点到根节点的路径和等于给定sum</span></span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;  <span class="comment">// 当前节点的路径和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">-1</span>;  <span class="comment">// 给定的sum</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前已找到符合要求的节点，则不用再搜索</span></span><br><span class="line">        <span class="keyword">if</span>(existed==<span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 如果是空节点，则不用搜索</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 遍历当前节点，计算其到根节点之间的距离</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;now += root-&gt;val;</span><br><span class="line">        <span class="comment">// 如果是叶子结点并且其与根节点的距离等于给定sum，则该节点符合条件</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span> &amp;&amp; <span class="keyword">this</span>-&gt;now == <span class="keyword">this</span>-&gt;sum)&#123;</span><br><span class="line">            existed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索左子树和右子树</span></span><br><span class="line">        dfs(root-&gt;left);</span><br><span class="line">        dfs(root-&gt;right);</span><br><span class="line">        <span class="comment">// 该子树已搜索完毕，需要更新当前节点与根节点之间的距离（回溯）</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;now -= root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置目标</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;sum = sum;</span><br><span class="line">        <span class="comment">// 深度搜索</span></span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">// 返回搜索结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;existed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><ul><li>别人的题解，用另外一种方式理解了sum，厉害 thumb up</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 112</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/path-sum/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion DFS 回溯</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span> &amp;&amp; root-&gt;right==<span class="literal">nullptr</span> &amp;&amp; root-&gt;val==sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/path-sum/&quot; target=&quot;_
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="回溯" scheme="https://chouxianyu.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode617合并二叉树</title>
    <link href="https://chouxianyu.github.io/2020/07/25/LeetCode617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://chouxianyu.github.io/2020/07/25/LeetCode617合并二叉树/</id>
    <published>2020-07-25T10:00:27.000Z</published>
    <updated>2020-07-25T10:01:34.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-binary-trees/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>递归解法</li><li>解法见代码注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 617</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/merge-two-binary-trees/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将树t1和t2合并至t1，并返回t1</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">heleper</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 两个空树，返回null</span></span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">nullptr</span> &amp;&amp; t2==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 仅t2为空树，不需合并，直接返回t1即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1!=<span class="literal">nullptr</span> &amp;&amp; t2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仅t1为空树，不需合并，直接返回t2即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1==<span class="literal">nullptr</span> &amp;&amp; t2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// t1和t2均非空</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t1-&gt;val += t2-&gt;val;  <span class="comment">// 合并根节点</span></span><br><span class="line">            t1-&gt;left = heleper(t1-&gt;left, t2-&gt;left);  <span class="comment">// 合并左子树</span></span><br><span class="line">            t1-&gt;right = heleper(t1-&gt;right, t2-&gt;right);  <span class="comment">// 合并右子树</span></span><br><span class="line">            <span class="keyword">delete</span> t2;  <span class="comment">// 释放结点</span></span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heleper(t1,t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-binary-tre
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode226翻转二叉树</title>
    <link href="https://chouxianyu.github.io/2020/07/25/LeetCode226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://chouxianyu.github.io/2020/07/25/LeetCode226翻转二叉树/</id>
    <published>2020-07-25T09:32:55.000Z</published>
    <updated>2020-07-25T10:53:38.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/invert-binary-tree/</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><ul><li>递归解法</li><li>我写的，不够简洁</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 226</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/invert-binary-tree/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口，空结点直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 该结点交换左右子树</span></span><br><span class="line">        TreeNode *temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="comment">// 递归翻转左右子树</span></span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><ul><li>比我写的简洁一些，交换了最后两步的顺序，特别是利用了二叉树翻转后根节点不变的特点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 226</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/invert-binary-tree/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口，空结点直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 递归翻转左右子树</span></span><br><span class="line">        TreeNode* left = invertTree(root-&gt;left);</span><br><span class="line">        TreeNode* right = invertTree(root-&gt;right);</span><br><span class="line">        <span class="comment">// 该结点交换左右子树</span></span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/invert-binary-tree/&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode543二叉树的直径</title>
    <link href="https://chouxianyu.github.io/2020/07/25/LeetCode543%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <id>https://chouxianyu.github.io/2020/07/25/LeetCode543二叉树的直径/</id>
    <published>2020-07-25T05:21:14.000Z</published>
    <updated>2020-07-25T05:21:54.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>一棵二叉树的直径长度是任意两个结点路径长度中的最大值，两结点之间的路径长度是以它们之间边的数目表示</li><li>将一条路径分为左右两半，两个结点之间路径长度等于根节点左右子树的深度之和</li><li>这条路径可能穿过也可能不穿过根结点，所以在DFS过程中记录路径长度的最大值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 543</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/maxDiameter-of-binary-tree/</span></span><br><span class="line"><span class="comment">// Tags: Tree DFS Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">nullptr</span>),right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maxDiameter=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 空节点深度为0</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 左右子树深度</span></span><br><span class="line">        <span class="keyword">int</span> leftDepth = depth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = depth(root-&gt;right);</span><br><span class="line">        <span class="comment">// 更新最大直径</span></span><br><span class="line">        <span class="keyword">if</span> (leftDepth + rightDepth &gt; <span class="keyword">this</span>-&gt;maxDiameter)</span><br><span class="line">            <span class="keyword">this</span>-&gt;maxDiameter = leftDepth + rightDepth;</span><br><span class="line">        <span class="comment">// 返回该树深度</span></span><br><span class="line">        <span class="keyword">return</span> max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/diameter-of-binary-t
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode110平衡二叉树</title>
    <link href="https://chouxianyu.github.io/2020/07/25/LeetCode110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://chouxianyu.github.io/2020/07/25/LeetCode110平衡二叉树/</id>
    <published>2020-07-25T03:14:05.000Z</published>
    <updated>2020-07-25T03:15:26.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>递归解法</li><li>平衡二叉树定义：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1</li><li>递归函数返回值：如果平衡则返回该树的高度，空树则返回0，不平衡（左右子树不平衡或该结点不平衡）则返回-1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 110</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/balanced-binary-tree/description/</span></span><br><span class="line"><span class="comment">// Tags: Tree DFS</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recursion</span><span class="params">(TreeNode* root)</span></span>&#123;<span class="comment">//若该树平衡则返回其高度，不平衡则返回-1</span></span><br><span class="line">        <span class="comment">// 空树深度为0，也算平衡树</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子树和右子树深度</span></span><br><span class="line">        <span class="keyword">int</span> left=recursion(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right=recursion(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若子树不平衡，则父树也不平衡(平衡二叉树定义：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1)</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;<span class="number">0</span>||right&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左右子树平衡，则判断该树是否平衡</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left-right)&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> max(left,right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recursion(root)&gt;=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/balanced-binary-tree
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode104二叉树的最大深度</title>
    <link href="https://chouxianyu.github.io/2020/07/24/LeetCode104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <id>https://chouxianyu.github.io/2020/07/24/LeetCode104二叉树的最大深度/</id>
    <published>2020-07-24T14:56:59.000Z</published>
    <updated>2020-07-24T15:01:33.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>递归</li><li>递归出口是当前结点为空，则返回0</li><li>如果非空，则该结点深度为左子树和右子树深度的最大值+1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 104</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>==root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-depth-of-bin
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode102二叉树层次遍历</title>
    <link href="https://chouxianyu.github.io/2020/07/24/LeetCode102%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://chouxianyu.github.io/2020/07/24/LeetCode102二叉树层次遍历/</id>
    <published>2020-07-24T14:39:14.000Z</published>
    <updated>2020-07-24T14:44:39.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><h1 id="题解一：非递归BFS"><a href="#题解一：非递归BFS" class="headerlink" title="题解一：非递归BFS"></a>题解一：非递归BFS</h1><ul><li>用队列存储每层的节点</li><li>获取到一层节点后，则可以获得该层所有节点的val和下一层的所有节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 102</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></span><br><span class="line"><span class="comment">// Tags: Tree BFS DFS Recursion Queue</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;  <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; parentNodes;  <span class="comment">// 父层节点</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)</span><br><span class="line">            parentNodes.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!parentNodes.empty())&#123;</span><br><span class="line">            <span class="comment">// 找子层节点</span></span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; childNodes; <span class="comment">// 子层节点</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parentVals;  <span class="comment">// 父层节点元素</span></span><br><span class="line">            <span class="keyword">while</span> (!parentNodes.empty())&#123;</span><br><span class="line">                root = parentNodes.front();</span><br><span class="line">                parentNodes.pop();</span><br><span class="line">                parentVals.push_back(root-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">                    childNodes.push(root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">                    childNodes.push(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            parentNodes = childNodes;</span><br><span class="line">            result.push_back(parentVals);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二：DFS递归"><a href="#题解二：DFS递归" class="headerlink" title="题解二：DFS递归"></a>题解二：DFS递归</h1><ul><li>用变量level记录当前处于哪一层</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 102</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></span><br><span class="line"><span class="comment">// Tags: Tree BFS DFS Recursion Queue</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result; <span class="comment">// 最终结果</span></span><br><span class="line">        dfs(result, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, TreeNode* root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 空指针，无动作</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>==root)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果该层第一次被遍历到，则为该层创建空数组</span></span><br><span class="line">        <span class="keyword">if</span>(result.size()&lt;=level)&#123;</span><br><span class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历该结点</span></span><br><span class="line">        result[level].push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        dfs(result, root-&gt;left, level + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        dfs(result, root-&gt;right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-or
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="队列" scheme="https://chouxianyu.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>二叉树前序、中序、后序遍历（非递归统一解法）</title>
    <link href="https://chouxianyu.github.io/2020/07/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E7%BB%9F%E4%B8%80%E8%A7%A3%E6%B3%95%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2020/07/13/二叉树前序、中序、后序遍历（非递归统一解法）/</id>
    <published>2020-07-13T06:52:57.000Z</published>
    <updated>2020-07-13T07:21:08.328Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天和今天复习了二叉树的前序遍历、中序遍历和后序遍历，找到了一种统一的非递归的方法（即使用一个思路非递归实现二叉树的前序、中序和后序遍历）。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>思路本质上还是递归，只不过不通过递归函数显式递归，而是通过栈模拟递归。</p><p>具体思路：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/mo-fang-di-gui-zhi-bian-yi-xing-by-sonp/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/mo-fang-di-gui-zhi-bian-yi-xing-by-sonp/</a></p><p><strong>注意：</strong></p><ul><li><p>非空的树节点指针才能存入栈中</p><p>  因为使用<code>nullptr</code>作为递归函数结束的标志，所以在栈中存储树节点指针时必须要检查是否非空。</p></li><li><p>遍历顺序和入栈顺序相反</p></li></ul><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><p>LeetCode题目：<a href="https://www.cnblogs.com/chouxianyu/p/13290758.html" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/p/13290758.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)</span><br><span class="line">        nodes.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        <span class="comment">// 取出节点</span></span><br><span class="line">        root = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="comment">// 将节点对应的树拆解成前序，模拟递归解法中的函数调用</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(root-&gt;left);</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            nodes.push(<span class="literal">nullptr</span>);  <span class="comment">// 设置nullptr标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nullptr代表栈顶对应的树（根、左子树、右子树）已按照指定顺序遍历，一层递归函数运行结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result.push_back(nodes.top()-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><p>LeetCode题目：<a href="https://www.cnblogs.com/chouxianyu/p/13293153.html" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/p/13293153.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)</span><br><span class="line">        nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        root = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="comment">// 模拟调用递归函数</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(root-&gt;right);</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            nodes.push(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一层递归函数结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result.push_back(nodes.top()-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><p>LeetCode题目：<a href="https://www.cnblogs.com/chouxianyu/p/13293152.html" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/p/13293152.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)</span><br><span class="line">        nodes.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">        root = nodes.top();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="comment">// 模拟调用递归函数</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodes.push(root);</span><br><span class="line">            nodes.push(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                nodes.push(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归函数调用成功</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result.push_back(nodes.top()-&gt;val);</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;昨天和今天复习了二叉树的前序遍历、中序遍历和后序遍历，找到了一种统一的非递归的方法（即使用一个思路非递归实现二叉树的前序、中序和后序遍历）。
      
    
    </summary>
    
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://chouxianyu.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode94二叉树中序遍历</title>
    <link href="https://chouxianyu.github.io/2020/07/13/LeetCode94%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://chouxianyu.github.io/2020/07/13/LeetCode94二叉树中序遍历/</id>
    <published>2020-07-13T06:45:52.000Z</published>
    <updated>2020-07-13T07:03:50.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><h1 id="题解一：递归"><a href="#题解一：递归" class="headerlink" title="题解一：递归"></a>题解一：递归</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 94</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion Stack</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            traversal(root-&gt;left, result);</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">            traversal(root-&gt;right, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二：非递归（通过栈模拟递归）"><a href="#题解二：非递归（通过栈模拟递归）" class="headerlink" title="题解二：非递归（通过栈模拟递归）"></a>题解二：非递归（通过栈模拟递归）</h1><p>思路：<a href="https://www.cnblogs.com/chouxianyu/p/13293284.html" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/p/13293284.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 94</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion Stack</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            root = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="comment">// 模拟调用递归函数</span></span><br><span class="line">            <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.push(root-&gt;right);</span><br><span class="line">                nodes.push(root);</span><br><span class="line">                nodes.push(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.push(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一层递归函数结束</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.push_back(nodes.top()-&gt;val);</span><br><span class="line">                nodes.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-inorder-
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://chouxianyu.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode145二叉树后序遍历</title>
    <link href="https://chouxianyu.github.io/2020/07/13/LeetCode145%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://chouxianyu.github.io/2020/07/13/LeetCode145二叉树后序遍历/</id>
    <published>2020-07-13T06:45:11.000Z</published>
    <updated>2020-07-13T07:04:01.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/</a></p><h1 id="题解一：递归"><a href="#题解一：递归" class="headerlink" title="题解一：递归"></a>题解一：递归</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 145</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/</span></span><br><span class="line"><span class="comment">// Tags: Stack Tree Recursion </span></span><br><span class="line"><span class="comment">// Difficulty: Hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                traversal(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                traversal(root-&gt;right);</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root)&#123;</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二：非递归（通过栈模拟递归）"><a href="#题解二：非递归（通过栈模拟递归）" class="headerlink" title="题解二：非递归（通过栈模拟递归）"></a>题解二：非递归（通过栈模拟递归）</h1><p>思路：<a href="https://www.cnblogs.com/chouxianyu/p/13293284.html" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/p/13293284.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 145</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/</span></span><br><span class="line"><span class="comment">// Tags: Stack Tree Recursion </span></span><br><span class="line"><span class="comment">// Difficulty: Hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            root = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="comment">// 模拟调用递归函数</span></span><br><span class="line">            <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                nodes.push(root);</span><br><span class="line">                nodes.push(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.push(root-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.push(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 递归函数调用成功</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.push_back(nodes.top()-&gt;val);</span><br><span class="line">                nodes.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-postorde
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://chouxianyu.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode144二叉树前序遍历</title>
    <link href="https://chouxianyu.github.io/2020/07/12/LeetCode144%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>https://chouxianyu.github.io/2020/07/12/LeetCode144二叉树前序遍历/</id>
    <published>2020-07-12T15:40:38.000Z</published>
    <updated>2020-07-13T07:03:55.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/</a></p><h1 id="题解一：递归"><a href="#题解一：递归" class="headerlink" title="题解一：递归"></a>题解一：递归</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 144</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion Stack</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            result.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                traversal(root-&gt;left, result);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                traversal(root-&gt;right, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二：非递归"><a href="#题解二：非递归" class="headerlink" title="题解二：非递归"></a>题解二：非递归</h1><ul><li>需要用到栈</li><li>注意循环条件</li><li>注意是先把右子树存入栈中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 144</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion Stack</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            root = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                result.push_back(root-&gt;val);</span><br><span class="line">                nodes.push(root-&gt;right);</span><br><span class="line">                nodes.push(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解三：非递归（通过栈模拟递归）"><a href="#题解三：非递归（通过栈模拟递归）" class="headerlink" title="题解三：非递归（通过栈模拟递归）"></a>题解三：非递归（通过栈模拟递归）</h1><p>思路：<a href="https://www.cnblogs.com/chouxianyu/p/13293284.html" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/p/13293284.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 144</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/</span></span><br><span class="line"><span class="comment">// Tags: Tree Recursion Stack</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)</span><br><span class="line">            nodes.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出节点</span></span><br><span class="line">            root = nodes.top();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="comment">// 将节点对应的树拆解成前序，模拟递归解法中的函数调用</span></span><br><span class="line">            <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.push(root-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">                    nodes.push(root-&gt;left);</span><br><span class="line">                nodes.push(root);</span><br><span class="line">                nodes.push(<span class="literal">nullptr</span>);  <span class="comment">// 设置nullptr标志</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nullptr代表栈顶对应的树（根、左子树、右子树）已按照指定顺序遍历，一层递归函数运行结束</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.push_back(nodes.top()-&gt;val);</span><br><span class="line">                nodes.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-preorder
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://chouxianyu.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode83</title>
    <link href="https://chouxianyu.github.io/2020/07/12/LeetCode83/"/>
    <id>https://chouxianyu.github.io/2020/07/12/LeetCode83/</id>
    <published>2020-07-12T08:43:58.000Z</published>
    <updated>2020-07-13T06:55:29.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/</a></p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><ul><li>链表已排序</li></ul><h1 id="题解一：迭代"><a href="#题解一：迭代" class="headerlink" title="题解一：迭代"></a>题解一：迭代</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历链表，如果发现重复元素就删除。</p><p>注意发现重复时遍历链表用的指针不要后移，不重复时才后移。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 83</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == head)&#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line">        ListNode *next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* ret = head; <span class="comment">// 用于返回</span></span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next !=  <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            <span class="comment">// 元素重复</span></span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val == next-&gt;val)&#123;</span><br><span class="line">                head-&gt;next = next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 元素未重复</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二：递归"><a href="#题解二：递归" class="headerlink" title="题解二：递归"></a>题解二：递归</h1><h2 id="关于递归"><a href="#关于递归" class="headerlink" title="关于递归"></a>关于递归</h2><p>又摸到一个递归函数套路（有可能仅针对这道题）：</p><ol><li>递归出口（包括边界）</li><li>递归调用</li><li>手工拼接？（这一步可能直接融合到第二步）</li></ol><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>递归函数的功能是将一个链表去重</li><li>思路是取出head然后剩下的链表通过递归去重，然后手动去重</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 83</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == head || <span class="literal">nullptr</span> == head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出head然后剩下的链表通过递归去重</span></span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">        <span class="comment">// 手动去重</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class="line">            ListNode* ret = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> head;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-duplicates-from-
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
      <category term="迭代" scheme="https://chouxianyu.github.io/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode21</title>
    <link href="https://chouxianyu.github.io/2020/07/11/LeetCode21/"/>
    <id>https://chouxianyu.github.io/2020/07/11/LeetCode21/</id>
    <published>2020-07-11T09:53:16.000Z</published>
    <updated>2020-07-13T06:55:16.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/description/</a></p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><ul><li>两个链表已排序</li><li>新链表应该是两个链表拼接起来的，而非new出来的</li><li>链表中头结点的val应该是有意义的</li></ul><h1 id="题解一：迭代"><a href="#题解一：迭代" class="headerlink" title="题解一：迭代"></a>题解一：迭代</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>先new一个无意义的头结点，方便建立新链表</li><li>同时遍历两个链表并拼接至新链表，每取一个结点就更新其所在链表的指针和新链表指针，直至两个链表中的某一个遍历结束</li><li>将未遍历完的链表拼接至新链表</li><li>delete无意义的头结点，释放内存，返回其next</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 21</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/merge-two-sorted-lists/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next): val(x), next(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义头结点，方便建立新链表</span></span><br><span class="line">        ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 遍历链表用的指针</span></span><br><span class="line">        ListNode *l3 = head;</span><br><span class="line">        <span class="comment">// 同时遍历两个链表并拼接值较小的结点到新链表中，同步更新链表指针，直至某个链表遍历结束</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                l3-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l3-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            l3 = l3-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将未遍历完的链表拼接至新链表</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            l3-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            l3-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放无意义头结点并返回其next</span></span><br><span class="line">        l3 = head-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> head;</span><br><span class="line">        <span class="keyword">return</span> l3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二：递归"><a href="#题解二：递归" class="headerlink" title="题解二：递归"></a>题解二：递归</h1><h2 id="再思递归"><a href="#再思递归" class="headerlink" title="再思递归"></a>再思递归</h2><p>昨天也做了一个<a href="https://www.cnblogs.com/chouxianyu/p/13284071.html" target="_blank" rel="noopener">递归</a>题，今天这道题也可以用递归，我又有了一些关于递归的想法：</p><ul><li>递归表达式<ul><li>其实就是函数，要求明确几点：输入、输出、功能、拼接公式，有时候还需要知道函数运行对各个变量的影响（比如昨天那道题从代码二修改至代码三）</li></ul></li><li>递归出口（也包括边界）<ul><li>一定要最小化</li><li>要求能够处理递归表达式的已知情况，即输入取特定值（因题目而不同）时的情况</li></ul></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li><p>递归表达式</p><ul><li>输入：两个链表的头指针</li><li>输出：两个链表拼接后的头指针</li><li>功能：将两个链表拼接</li></ul></li><li><p>递归出口</p><p>  链表指针为null时。如果出口是next为null，这个出口并不是最小化的</p></li></ul><p>递归函数实现的功能和思路为：</p><p>递归函数拿到了两个链表A和B，取出两个链表中值较小的那个头结点N，然后通过递归拼接剩下的两个链表返回M，然后手动拼接N和M。</p><p>思路模拟：</p><p>假设是链表A的头结点N的值比较小，那我取出其头结点N后形成一个新的链表A1（不包括头结点），然后通过递归拼接A1和B返回M，然后手工拼接N和M（即<code>N-&gt;next=M;</code>）。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 21</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/merge-two-sorted-lists/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next): val(x), next(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界和递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>==l1)&#123;<span class="keyword">return</span> l2;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>==l2)&#123;<span class="keyword">return</span> l1;&#125;</span><br><span class="line">        <span class="comment">// 递归表达式</span></span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lis
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
      <category term="迭代" scheme="https://chouxianyu.github.io/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode206</title>
    <link href="https://chouxianyu.github.io/2020/07/11/LeetCode206/"/>
    <id>https://chouxianyu.github.io/2020/07/11/LeetCode206/</id>
    <published>2020-07-11T08:13:26.000Z</published>
    <updated>2020-07-13T06:55:56.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/description/</a></p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><ul><li>要求：反转一个单向链表</li><li>代码模板里的<code>ListNode</code>给了3个构造函数，明显是方便我们构造结点用的（如果要new，最好要delete）</li><li>可以迭代实现，也可以递归实现</li></ul><h1 id="题解一：递归"><a href="#题解一：递归" class="headerlink" title="题解一：递归"></a>题解一：递归</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归算法中有两个重要概念：递归表达式和递归出口，这一点似乎主要是在算法设计与分析课程上学得的。</p><ul><li><p>递归出口</p><p>  递归出口越小越好，出口应该考虑到边界条件</p></li><li><p>递归表达式</p><p>  递归表达式是将链表分为两部分A和B，B用递归表达式递归处理，然后再将A和B“拼接”起来</p></li></ul><h2 id="过程经历"><a href="#过程经历" class="headerlink" title="过程经历"></a>过程经历</h2><ol><li>找错递归出口然后修改</li><li>未处理只有0或1个结点的边界情况，修改后得到代码一</li><li>代码一未将递归出口最小化，修改后得到代码二</li><li>代码二未利用一点（链表B反转后，原先的头结点已经是尾结点了，不需要通过遍历寻找尾结点），因此存在多余的遍历，修改后得到代码三</li></ol><h2 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h2><p>这一版不太优美，最后一层没用递归（<strong>递归应该最大化，出口应该最小化</strong>），而是手动实现了就又改了一版，可以再往下看（代码二）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 206</span></span><br><span class="line"><span class="comment">// URL: https://leetcode.com/problems/reverse-linked-list/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next): val(x), next(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 边界：when there is no node or there is only 1 node, then it's no need to reverse,just return the input</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == head || <span class="literal">nullptr</span> == head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归出口（recursive export），when there are only 2 nodes</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == head-&gt;next-&gt;next)&#123;</span><br><span class="line">            ListNode *ptrA = head;</span><br><span class="line">            ListNode *ptrB = head-&gt;next;</span><br><span class="line">            ptrB-&gt;next = ptrA;</span><br><span class="line">            ptrA-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> ptrB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下为递归表达式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// devide the nodes into A(the original head) and B(the nodes except the original head).</span></span><br><span class="line">        ListNode *ptrA = head;  <span class="comment">// A:原先的head</span></span><br><span class="line">        ListNode *ptrB = reverseList(head-&gt;next);  <span class="comment">// B:将原先head以外的结点逆序并返回其head</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// look for the tail of B，寻找B的尾巴</span></span><br><span class="line">        ListNode* tailB = ptrB;  </span><br><span class="line">        <span class="keyword">while</span> (tailB-&gt;next != <span class="literal">nullptr</span>)&#123;tailB = tailB-&gt;next;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A连接到B后面并将A设置为尾结点</span></span><br><span class="line">        tailB-&gt;next = ptrA;</span><br><span class="line">        ptrA-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回链表B</span></span><br><span class="line">        <span class="keyword">return</span> ptrB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 206</span></span><br><span class="line"><span class="comment">// URL: https://leetcode.com/problems/reverse-linked-list/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next): val(x), next(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 边界：when there is no node, then it's no need to reverse,just return the input</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归出口（recursive export），when there is only 1 nodes</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// devide the nodes into A(the original head) and B(the nodes except the original head).</span></span><br><span class="line">        ListNode *ptrA = head; <span class="comment">// A:原先的head</span></span><br><span class="line">        ListNode *ptrB = reverseList(head-&gt;next); <span class="comment">// B:将原先head以外的结点逆序并返回其head</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// look for the tail of B，寻找B的尾巴</span></span><br><span class="line">        ListNode *tailB = ptrB;</span><br><span class="line">        <span class="keyword">while</span> (tailB-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tailB = tailB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A连接到B后面并将A设置为尾结点</span></span><br><span class="line">        tailB-&gt;next = ptrA;</span><br><span class="line">        ptrA-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回链表B</span></span><br><span class="line">        <span class="keyword">return</span> ptrB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a>代码三</h2><p>第二天看了题解之后，发现我自己忽略了一点：</p><p>在<code>ListNode *ptrB = reverseList(head-&gt;next);</code>运行后，链表B反转前的第一个结点（即<code>head-&gt;next</code>）已经是链表B反转后的最后一个结点，所以不需要再寻找B的尾结点了。</p><p>修改后代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 206</span></span><br><span class="line"><span class="comment">// URL: https://leetcode.com/problems/reverse-linked-list/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next): val(x), next(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 边界：when there is no node, then it's no need to reverse,just return the input</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归出口（recursive export），when there is only 1 nodes</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// devide the nodes into A(the original head) and B(the nodes except the original head).</span></span><br><span class="line">        ListNode *ptrA = head; <span class="comment">// A:原先的head</span></span><br><span class="line">        ListNode *ptrB = reverseList(head-&gt;next); <span class="comment">// B:将原先head以外的结点逆序并返回其head，此时head-&gt;next已经为最后一个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将A连接到B后面并将A设置为尾结点</span></span><br><span class="line">        head-&gt;next-&gt;next = ptrA;</span><br><span class="line">        ptrA-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回链表B</span></span><br><span class="line">        <span class="keyword">return</span> ptrB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二：迭代"><a href="#题解二：迭代" class="headerlink" title="题解二：迭代"></a>题解二：迭代</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>其实就是头插法，另外要注意这道题里中链表的头结点的val是有意义的，所以最后要new出来的头结点delete掉，并返回其next。</p><h2 id="代码一-1"><a href="#代码一-1" class="headerlink" title="代码一"></a>代码一</h2><p>这份代码是没有修改原链表的结构的，而是基于原链表new了一个新链表（是原链表的逆序）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 206</span></span><br><span class="line"><span class="comment">// URL: https://leetcode.com/problems/reverse-linked-list/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next): val(x), next(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建新链表</span></span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *tempNodePtr = <span class="keyword">new</span> ListNode(head-&gt;val, head-&gt;next);</span><br><span class="line">            tempNodePtr-&gt;next = newHead-&gt;next;</span><br><span class="line">            newHead-&gt;next = tempNodePtr;</span><br><span class="line">            <span class="comment">// 取下一个结点</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放无用的头结点并返回真正的头结点</span></span><br><span class="line">        ListNode* ret = newHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> newHead;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码二-1"><a href="#代码二-1" class="headerlink" title="代码二"></a>代码二</h2><p>这份代码修改了原链表的结构，直接利用了原链表的结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 206</span></span><br><span class="line"><span class="comment">// URL: https://leetcode.com/problems/reverse-linked-list/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion Iteration</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(): val(<span class="number">0</span>), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode* next): val(x), next(next)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建新链表</span></span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = newHead-&gt;next;</span><br><span class="line">            newHead-&gt;next = head;</span><br><span class="line">            <span class="comment">// 取下一个结点</span></span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放无用的头结点并返回真正的头结点</span></span><br><span class="line">        ListNode* ret = newHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> newHead;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
      <category term="迭代" scheme="https://chouxianyu.github.io/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode160</title>
    <link href="https://chouxianyu.github.io/2020/07/10/LeetCode160/"/>
    <id>https://chouxianyu.github.io/2020/07/10/LeetCode160/</id>
    <published>2020-07-10T13:25:22.000Z</published>
    <updated>2020-07-13T06:55:52.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><h1 id="初次读题"><a href="#初次读题" class="headerlink" title="初次读题"></a>初次读题</h1><p>初次读题可知</p><ul><li>两个指针相同即需要求得的结果</li><li>链表长度可能不同</li><li>两个链表可能没有交叉点，此时返回NULL</li><li>不可修改链表结构</li><li>链表中无循环</li></ul><p>我第一次读题时看的是英文版，并且我刚开始做LeetCode对题目风格也不熟悉，同时这道题的Example也是很神奇，我一下子没有理解题意，看了中文版的题目和题解后才明白这个题是怎么做的。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>根据这道题的代码模板和最终答案可知，最终我们需要找到交叉结点的指针。</p><p>在Example1中，val为1的两个结点虽然内容相同，但不是交叉点，因为交叉点的定义是同时存在于两个链表中。</p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假如两个链表有交叉点（intersection），则可以设两个链表彼此不重复的结点个数分别为d1和d2，重复的结点个数为d。如果一个链表遍历完则使其从另外一个链表的头部重新开始，这样形成一个式子：<code>d1+d+d2=d2+d+d1</code>。</p><p>假如两个链表没有交叉点，这也只是<code>d=0</code>的一个特例，因此只要实现上述思路即可。</p><p>关于思路，可以看看这个题的一个视频题解：</p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/lian-biao-xiang-jiao-shuang-zhi-zhen-onshi-jian-fu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/lian-biao-xiang-jiao-shuang-zhi-zhen-onshi-jian-fu/</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: Leetcode 160</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</span></span><br><span class="line"><span class="comment">// Tags: Linked List</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x):val(x),next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Deal with the border "nullptr"</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span>==headA || <span class="literal">nullptr</span>==headB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *ptrA = headA;</span><br><span class="line">        ListNode *ptrB = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// d1+d+d2=d2+d+d1</span></span><br><span class="line">        <span class="keyword">while</span> (ptrA != ptrB)&#123;</span><br><span class="line">            ptrA = <span class="literal">nullptr</span> == ptrA ? headB : ptrA-&gt;next;</span><br><span class="line">            ptrB = <span class="literal">nullptr</span> == ptrB ? headA : ptrB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptrA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><p>也看到有人讲这个思路：</p><p>遍历链表A并将每个结点的指针存入set，然后遍历链表B并判断每个结点指针是否存在于set中。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>计算某天的下一天：黑盒测试之等价类划分+JUnit参数化测试</title>
    <link href="https://chouxianyu.github.io/2020/04/28/%E8%AE%A1%E7%AE%97%E6%9F%90%E5%A4%A9%E7%9A%84%E4%B8%8B%E4%B8%80%E5%A4%A9%EF%BC%9A%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86-JUnit%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>https://chouxianyu.github.io/2020/04/28/计算某天的下一天：黑盒测试之等价类划分-JUnit参数化测试/</id>
    <published>2020-04-27T19:10:53.000Z</published>
    <updated>2020-04-28T14:10:26.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>测试以下程序：该程序有三个输入变量month、day、year（month、day和year均为整数值，并且满足：1≤month≤12、1≤day≤31和1900≤year≤2050)，分别作为输入日期的月份、日、年份，通过程序可以输出该输入日期在日历上隔一天的日期。例如，输入为2004年11月30日，则该程序的输出为2004年12月1日。</p><ol><li>划分等价类，按照等价类划分法设计测试用例；</li><li>编写getNextDate函数；</li><li>掌握Junit4的用法，使用Junit4测试getNextDate函数。</li></ol><h1 id="等价类表"><a href="#等价类表" class="headerlink" title="等价类表"></a>等价类表</h1><p>假设输入格式为year,month,day，且三个输入变量year、month和day均被输入。</p><p><strong>year要区分闰年和平年，其中闰年还可以分为世纪闰年和普通闰年，且year要属于[1900,2050]。</strong></p><p><strong>month要根据该月有几天来进行区分，并且需要考虑是否向year进位，且month要属于[1,12]。</strong></p><p><strong>day要根据月份来判断天数是否合法，并且需要考虑是否向month进位，且day要属于[1,31]。</strong></p><p>等价类划分如下。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200427190527等价类划分表.jpg" alt="等价类划分表.jpg"></p><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="有效等价类测试用例"><a href="#有效等价类测试用例" class="headerlink" title="有效等价类测试用例"></a>有效等价类测试用例</h2><p>共有5个有效等价类测试用例。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>测试数据</strong></th><th style="text-align:center"><strong>期望结果</strong></th><th style="text-align:center"><strong>覆盖范围</strong></th></tr></thead><tbody><tr><td style="text-align:center">2004/12/25</td><td style="text-align:center">2004/12/26</td><td style="text-align:center">2,10,14</td></tr><tr><td style="text-align:center">2001/2/28</td><td style="text-align:center">2001/3/1</td><td style="text-align:center">3,7,15</td></tr><tr><td style="text-align:center">2000/2/29</td><td style="text-align:center">2000/3/1</td><td style="text-align:center">1,7,16</td></tr><tr><td style="text-align:center">2001/4/30</td><td style="text-align:center">2001/5/1</td><td style="text-align:center">3,8,17</td></tr><tr><td style="text-align:center">2001/5/31</td><td style="text-align:center">2001/6/1</td><td style="text-align:center">3,9,18</td></tr></tbody></table></div><h2 id="无效等价类测试用例"><a href="#无效等价类测试用例" class="headerlink" title="无效等价类测试用例"></a>无效等价类测试用例</h2><p>共有12个有效等价类测试用例。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>测试数据</strong></th><th style="text-align:center"><strong>期望结果</strong></th><th style="text-align:center"><strong>覆盖范围</strong></th></tr></thead><tbody><tr><td style="text-align:center">1899/6/1</td><td style="text-align:center">year非法</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2051/6/1</td><td style="text-align:center">year非法</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">a/6/1</td><td style="text-align:center">year非法</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">1999/0/1</td><td style="text-align:center">month非法</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">1999/13/1</td><td style="text-align:center">month非法</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">1999/a/1</td><td style="text-align:center">month非法</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">1999/1/0</td><td style="text-align:center">day非法</td><td style="text-align:center">19</td></tr><tr><td style="text-align:center">1999/1/32</td><td style="text-align:center">day非法</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">1999/1/a</td><td style="text-align:center">day非法</td><td style="text-align:center">21</td></tr><tr><td style="text-align:center">2001/2/29</td><td style="text-align:center">day非法</td><td style="text-align:center">22</td></tr><tr><td style="text-align:center">2000/2/30</td><td style="text-align:center">day非法</td><td style="text-align:center">23</td></tr><tr><td style="text-align:center">2001/4/31</td><td style="text-align:center">day非法</td><td style="text-align:center">24</td></tr></tbody></table></div><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>项目结构如下图所示</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200427190552%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg" alt="项目结构.jpg"></p><h2 id="DateUtil-java"><a href="#DateUtil-java" class="headerlink" title="DateUtil.java"></a>DateUtil.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有31天的月份</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] monthOfThirtyOne = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="comment">// 有30天的月份</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] monthOfThirty = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="comment">// 年月日</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终实现的功能，输入是一个“年/月/日”格式的字符串；</span></span><br><span class="line">    <span class="comment">// 如果函数运行成功，输出则是相同格式的下一天，否则是错误信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNextDate</span><span class="params">(String dateStr)</span></span>&#123;</span><br><span class="line">        String updateResult = <span class="keyword">this</span>.updateDate(dateStr);</span><br><span class="line">        <span class="comment">// 如果输入合法</span></span><br><span class="line">        <span class="keyword">if</span> (updateResult.equals(<span class="string">"success"</span>))&#123;</span><br><span class="line">            String checkResult = <span class="keyword">this</span>.checkDate();</span><br><span class="line">            <span class="comment">// 如果输入合法</span></span><br><span class="line">            <span class="keyword">if</span> (checkResult.equals(<span class="string">"valid"</span>))&#123;</span><br><span class="line">                <span class="comment">// 计算明天的日期</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.calcNextDate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> checkResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updateResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据输入字符串转换并更新年月日</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">updateDate</span><span class="params">(String dateStr)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取年月日</span></span><br><span class="line">        String[] numbers = dateStr.split(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.year = Integer.parseInt(numbers[<span class="number">0</span>]);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"year非法"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.month = Integer.parseInt(numbers[<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"month非法"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.day = Integer.parseInt(numbers[<span class="number">2</span>]);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"day非法"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查日期是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">checkDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String valid = <span class="string">"valid"</span>;</span><br><span class="line">        String yearInvalid = <span class="string">"year非法"</span>;</span><br><span class="line">        String monthInvalid = <span class="string">"month非法"</span>;</span><br><span class="line">        String dayInvalid = <span class="string">"day非法"</span>;</span><br><span class="line">        <span class="comment">// year合法</span></span><br><span class="line">        <span class="keyword">if</span> (year&gt;=<span class="number">1900</span>&amp;&amp;year&lt;=<span class="number">2050</span>)&#123;</span><br><span class="line">            <span class="comment">// month合法</span></span><br><span class="line">            <span class="keyword">if</span> (month&gt;=<span class="number">1</span>&amp;&amp;month&lt;=<span class="number">12</span>)&#123;</span><br><span class="line">                <span class="comment">// day小于1</span></span><br><span class="line">                <span class="keyword">if</span> (day&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> dayInvalid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 至此能保证day大于0</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 是2月</span></span><br><span class="line">                <span class="keyword">if</span> (month==<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="comment">// 闰年</span></span><br><span class="line">                    <span class="keyword">if</span> (yearIsLeap(year))&#123;</span><br><span class="line">                        <span class="comment">// 1-29</span></span><br><span class="line">                        <span class="keyword">if</span> (day&lt;=<span class="number">29</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> valid;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> dayInvalid;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 平年2月</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 1-28</span></span><br><span class="line">                        <span class="keyword">if</span> (day&lt;=<span class="number">28</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> valid;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> dayInvalid;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 至此能保证不是2月</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 是否为31天的月</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (month==monthOfThirtyOne[i])&#123;</span><br><span class="line">                        <span class="comment">// 1-31</span></span><br><span class="line">                        <span class="keyword">if</span> (day&lt;=<span class="number">31</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> valid;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> dayInvalid;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 至此能保证不是2月和31天的月</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 是否为30天的月</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (month==monthOfThirty[i])&#123;</span><br><span class="line">                        <span class="comment">// 1-30</span></span><br><span class="line">                        <span class="keyword">if</span> (day&lt;=<span class="number">30</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> valid;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> dayInvalid;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// month非法</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> monthInvalid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// year非法</span></span><br><span class="line">        <span class="keyword">return</span> yearInvalid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算下一天</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">calcNextDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> yearNext;</span><br><span class="line">        <span class="keyword">int</span> monthNext;</span><br><span class="line">        <span class="keyword">int</span> dayNext=day+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dayCarry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> monthCarry=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理day</span></span><br><span class="line">        <span class="comment">// 是2月</span></span><br><span class="line">        <span class="keyword">if</span> (month==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// 闰年</span></span><br><span class="line">            <span class="keyword">if</span> (yearIsLeap(year))&#123;</span><br><span class="line">                <span class="comment">// 1-29</span></span><br><span class="line">                <span class="keyword">if</span> (day==<span class="number">29</span>)&#123;</span><br><span class="line">                    dayNext = <span class="number">1</span>;</span><br><span class="line">                    dayCarry = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 平年2月</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 1-28</span></span><br><span class="line">                <span class="keyword">if</span> (day==<span class="number">28</span>)&#123;</span><br><span class="line">                    dayNext = <span class="number">1</span>;</span><br><span class="line">                    dayCarry = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是2月</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> isThirtyOne= <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 是否为31天的月</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span> (month==monthOfThirtyOne[i])&#123;</span><br><span class="line">                    isThirtyOne = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 1-31</span></span><br><span class="line">                    <span class="keyword">if</span> (day==<span class="number">31</span>)&#123;</span><br><span class="line">                        dayNext = <span class="number">1</span>;</span><br><span class="line">                        dayCarry = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 至此能保证是30天的月</span></span><br><span class="line">            <span class="keyword">if</span> (!isThirtyOne)&#123;</span><br><span class="line">                <span class="comment">// 1-30</span></span><br><span class="line">                <span class="keyword">if</span> (day==<span class="number">30</span>)&#123;</span><br><span class="line">                    dayNext = <span class="number">1</span>;</span><br><span class="line">                    dayCarry = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理月</span></span><br><span class="line">        <span class="keyword">if</span> (month+dayCarry&gt;<span class="number">12</span>)&#123;</span><br><span class="line">            monthNext = <span class="number">1</span>;</span><br><span class="line">            monthCarry = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            monthNext = month+dayCarry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  处理年</span></span><br><span class="line">        yearNext = year+monthCarry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> yearNext +<span class="string">"/"</span>+ monthNext +<span class="string">"/"</span>+ dayNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断某一年是否为闰年</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">yearIsLeap</span><span class="params">(<span class="keyword">int</span> year)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 普通闰年和世纪闰年</span></span><br><span class="line">        <span class="keyword">if</span> ((year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)||(year%<span class="number">400</span>==<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平年</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DateUtilTest-java"><a href="#DateUtilTest-java" class="headerlink" title="DateUtilTest.java"></a>DateUtilTest.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.company.DateUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、参数化测试：引入相关的包和类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Parameterized;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Parameterized.Parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(Parameterized.class) <span class="comment">//2、参数化测试：更改测试运行器为RunWith(Parameterized.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//3、参数化测试：声明变量用来存放预期值与结果值</span></span><br><span class="line">    <span class="keyword">private</span> DateUtil util = <span class="keyword">new</span> DateUtil();</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String except;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、参数化测试：声明一个返回值为 Collection 的公共静态方法，并使用@Parameters 进行修饰</span></span><br><span class="line">    <span class="meta">@Parameters</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">data</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;</span><br><span class="line">                &#123;<span class="string">"2004/12/25"</span>, <span class="string">"2004/12/26"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"2001/2/28"</span>, <span class="string">"2001/3/1"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"2000/2/29"</span>, <span class="string">"2000/3/1"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"2001/4/30"</span>, <span class="string">"2001/5/1"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"2001/5/31"</span>, <span class="string">"2001/6/1"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"1899/6/1"</span>, <span class="string">"year非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"2051/6/1"</span>, <span class="string">"year非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"a/6/1"</span>, <span class="string">"year非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"1999/0/1"</span>, <span class="string">"month非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"1999/13/1"</span>, <span class="string">"month非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"1999/a/1"</span>, <span class="string">"month非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"1999/1/0"</span>, <span class="string">"day非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"1999/1/32"</span>, <span class="string">"day非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"1999/1/a"</span>, <span class="string">"day非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"2001/2/29"</span>, <span class="string">"day非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"2000/2/30"</span>, <span class="string">"day非法"</span>&#125;,</span><br><span class="line">                &#123;<span class="string">"2001/4/31"</span>, <span class="string">"day非法"</span>&#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、参数化测试：为测试类声明一个带有参数的公共构造方法，并在其中为声明变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateUtilTest</span><span class="params">(String date, String except)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">        <span class="keyword">this</span>.except = except;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetNextDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertEquals(except, util.getNextDate(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>如下图所示，17个测试用例均测试成功，程序实际输出与期望值相同。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200427190603测试结果.jpg" alt="测试结果.jpg"></p><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>本次实验的主要目的是巩固黑盒测试方法中的等价类划分法的知识，练习JUnit的参数化测试。在本次实验中，我认为我的getNextDate函数的实现并不是很优雅，比较过程化。写这个函数花了我很多时间，主要问题在于我没有抓住一些关键的、抽象的逻辑和子函数，比如天向月份进位和月份向年份完全可以参照加法器的循环、可以写一个函数根据年份和月份判断出天数的最大值等等。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h1&gt;&lt;p&gt;测试以下程序：该程序有三个输入变量month、day、year（month、day和year均为整数值，并且满足：1≤mon
      
    
    </summary>
    
    
      <category term="Java" scheme="https://chouxianyu.github.io/tags/Java/"/>
    
      <category term="黑盒测试" scheme="https://chouxianyu.github.io/tags/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    
      <category term="软件测试，JUnit" scheme="https://chouxianyu.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%8CJUnit/"/>
    
  </entry>
  
  <entry>
    <title>黑盒测试之因果图法</title>
    <link href="https://chouxianyu.github.io/2020/04/20/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95/"/>
    <id>https://chouxianyu.github.io/2020/04/20/黑盒测试之因果图法/</id>
    <published>2020-04-20T09:28:07.000Z</published>
    <updated>2020-04-20T09:37:30.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>设要对一个自动饮料售货机软件进行黑盒测试。该软件的规格说明如下：“有一个处理单价为1元5角的盒装饮料的自动售货机软件，若投入1元5角硬币，按下“可乐”、“雪碧”或“红茶”按钮，相应的饮料就送出来。若投入的是2元硬币，在送出饮料的同时退还5角硬币。“</p><ol><li>试利用因果图法，建立该软件的因果图；</li><li>设计测试该软件的全部测试用例。</li></ol><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="原因和结果"><a href="#原因和结果" class="headerlink" title="原因和结果"></a>原因和结果</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>原因</strong></th><th style="text-align:center"><strong>中间原因</strong></th><th style="text-align:center"><strong>结果</strong></th></tr></thead><tbody><tr><td style="text-align:center">c1：投入1元5角硬币</td><td style="text-align:center">m1：已投币</td><td style="text-align:center">e1：退还5角硬币</td></tr><tr><td style="text-align:center">c2：投入2元硬币</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">c3：按下“可乐”按钮</td><td style="text-align:center"></td><td style="text-align:center">e2：送出可乐</td></tr><tr><td style="text-align:center">c4：按下“雪碧”按钮</td><td style="text-align:center">m2：已按下按钮</td><td style="text-align:center">e3：送出雪碧</td></tr><tr><td style="text-align:center">c5：按下“红茶”按钮</td><td style="text-align:center"></td><td style="text-align:center">e4：送出红茶</td></tr></tbody></table></div><h2 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h2><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200420092644因果图.png" alt="因果图"></p><h2 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h2><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>1</strong></th><th style="text-align:center"><strong>2</strong></th><th style="text-align:center"><strong>3</strong></th><th style="text-align:center"><strong>4</strong></th><th style="text-align:center"><strong>5</strong></th><th style="text-align:center"><strong>6</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>c1</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>c2</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c3</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>c4</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c5</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>m1</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>m2</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>e1</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>e2</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td style="text-align:center"><strong>e3</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>e4</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>10</strong></td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center"><strong>12</strong></td></tr><tr><td style="text-align:center"><strong>c1</strong></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c2</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>c3</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c4</strong></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c5</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>m1</strong></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>m2</strong></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>e1</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center"><strong>e2</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>e3</strong></td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>e4</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr></tbody></table></div><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>测试用例编号</strong></th><th style="text-align:center"><strong>输入</strong></th><th style="text-align:center"><strong>预期输出</strong></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">不投币，不按按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">不投币，按下“可乐”按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">不投币，按下“雪碧”按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">不投币，按下“红茶”按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">投1元5角硬币，不按按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">投1元5角硬币，按下“可乐”按钮</td><td style="text-align:center">送出可乐</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">投1元5角硬币，按下“雪碧”按钮</td><td style="text-align:center">送出雪碧</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">投1元5角硬币，按下“红茶”按钮</td><td style="text-align:center">送出红茶</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">投2元硬币，不按按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">投2元硬币，按下“可乐”按钮</td><td style="text-align:center">送出可乐并退还5角硬币</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">投2元硬币，按下“雪碧”按钮</td><td style="text-align:center">送出雪碧并退还5角硬币</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">投2元硬币，按下“红茶”按钮</td><td style="text-align:center">送出红茶并退还5角硬币</td></tr></tbody></table></div><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h1&gt;&lt;p&gt;设要对一个自动饮料售货机软件进行黑盒测试。该软件的规格说明如下：“有一个处理单价为1元5角的盒装饮料的自动售货机软件，若投入
      
    
    </summary>
    
    
      <category term="软件测试" scheme="https://chouxianyu.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="黑盒测试" scheme="https://chouxianyu.github.io/tags/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
