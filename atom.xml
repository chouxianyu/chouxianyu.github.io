<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2020-10-19T09:33:46.071Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT甲级1118Birds in Forest</title>
    <link href="https://chouxianyu.github.io/2020/10/19/PAT%E7%94%B2%E7%BA%A71118Birds-in-Forest/"/>
    <id>https://chouxianyu.github.io/2020/10/19/PAT甲级1118Birds-in-Forest/</id>
    <published>2020-10-19T09:32:57.000Z</published>
    <updated>2020-10-19T09:33:46.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>输入<ul><li>N：正整数，不超过1000，照片的数量</li><li>N张照片：每张照片中有K只鸟，鸟的索引从1开始，不超过10000。假设一张图片中出现的所有鸟属于同一棵树</li><li>Q：正整数，不超过10000，查询的数量</li><li>Q个查询</li></ul></li><li>输出<ul><li>有多少颗树、多少只鸟</li><li>判断Q对鸟是否属于同一颗树</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>用并查集做就行，这道题和<a href="https://www.cnblogs.com/chouxianyu/p/13839712.html" target="_blank" rel="noopener">PAT甲级1114Family Property</a>很相似，但简单很多。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1118</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712</span></span><br><span class="line"><span class="comment">// Tags: 并查集 路径压缩</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> tree[MAXN];</span><br><span class="line"><span class="keyword">int</span> birdNum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTree</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="number">-1</span> || x == tree[x]) ? x : tree[x] = findTree(tree[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UNION</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ta = findTree(a), tb = findTree(b);</span><br><span class="line">    <span class="keyword">if</span> (ta != tb)</span><br><span class="line">        tree[tb] = ta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(tree, tree + MAXN, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> n, q, k, bird1, bird2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bird1);</span><br><span class="line">        <span class="keyword">if</span> (tree[bird1] == <span class="number">-1</span>)</span><br><span class="line">            tree[bird1] = bird1; <span class="comment">// 记录该鸟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bird2);</span><br><span class="line">            <span class="keyword">if</span> (tree[bird2] == <span class="number">-1</span>)</span><br><span class="line">                tree[bird2] = bird2; <span class="comment">// 记录该鸟</span></span><br><span class="line">            UNION(bird1, bird2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tempTree;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        tempTree = findTree(i);</span><br><span class="line">        <span class="keyword">if</span> (tempTree != <span class="number">-1</span>)&#123;</span><br><span class="line">            birdNum[tempTree] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> treeCount = <span class="number">0</span>, birdCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (birdNum[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            treeCount += <span class="number">1</span>;</span><br><span class="line">            birdCount += birdNum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, treeCount, birdCount);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">int</span> tree1, tree2;</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;bird1, &amp;bird2);</span><br><span class="line">        tree1 = findTree(bird1);</span><br><span class="line">        tree2 = findTree(bird2);</span><br><span class="line">        <span class="keyword">if</span> (tree1 != <span class="number">-1</span> &amp;&amp; tree2 != <span class="number">-1</span> &amp;&amp; tree1 == tree2)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="并查集" scheme="https://chouxianyu.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="路径压缩" scheme="https://chouxianyu.github.io/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1114Family Property</title>
    <link href="https://chouxianyu.github.io/2020/10/19/PAT%E7%94%B2%E7%BA%A71114Family-Property/"/>
    <id>https://chouxianyu.github.io/2020/10/19/PAT甲级1114Family-Property/</id>
    <published>2020-10-19T05:13:41.000Z</published>
    <updated>2020-10-19T05:15:20.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>给出每个人的家庭成员和属于他的房产信息，请计算每个家庭的成员数、房产平均面积、房产数</li><li>输入<ul><li>N：不超过1000，人的数量</li><li>N个有房产的人的信息：id、父亲、母亲、孩子、房产数、房产面积</li></ul></li><li>输出<ul><li>输出家庭数量</li><li>输出每个家庭的最小id、人数、平均房产数、平均房产面积（按平均房产面积降序，然后按最小id升序）</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>题目只给了N个有房产的人的信息，但人并不一定是N个，也不一定是10000个，因此需要标记一个id是否有效（即这个人是否存在）</p><p>  如果一个人的代表人是-1，则这个人不存在</p></li><li><p>题目要求输出每个家庭的最小id，这个最小id可以在建立家族关系时保存，即合并两个家族时取较小的id</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1114</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288</span></span><br><span class="line"><span class="comment">// Tags: 并查集 路径压缩</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Family</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, memberNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> estateNum = <span class="number">0</span>, estateArea = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> representative[MAXN];</span><br><span class="line"><span class="keyword">int</span> estateArea[MAXN];</span><br><span class="line"><span class="keyword">int</span> estateNum[MAXN];</span><br><span class="line">Family families[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepresentative</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="number">-1</span> || x == representative[x]) ? x : representative[x] = findRepresentative(representative[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UNION</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ra = findRepresentative(a), rb = findRepresentative(b);</span><br><span class="line">    <span class="comment">// 取家族中的最小id作为representative</span></span><br><span class="line">    <span class="keyword">if</span> (rb &lt; ra)</span><br><span class="line">        representative[ra] = rb;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ra &lt; rb)</span><br><span class="line">        representative[rb] = ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">familyCmp</span><span class="params">(Family&amp; f1, Family&amp; f2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f1.estateArea == f2.estateArea ? f1.id &lt; f2.id : f1.estateArea &gt; f2.estateArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化家族关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        representative[i] = <span class="number">-1</span>; <span class="comment">// representative为-1代表该人不存在</span></span><br><span class="line">        families[i].id = i; <span class="comment">// 该人作为代表者时，对应一个家族。该id是为了排序用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立家族关系</span></span><br><span class="line">    <span class="keyword">int</span> n, id, fatherID, motherID, k, childID, num, area;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;id, &amp;fatherID, &amp;motherID, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (representative[id] == <span class="number">-1</span>)</span><br><span class="line">            representative[id] = id; <span class="comment">// 记录：该人存在</span></span><br><span class="line">        <span class="keyword">if</span> (fatherID != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (representative[fatherID] == <span class="number">-1</span>)</span><br><span class="line">                representative[fatherID] = fatherID; <span class="comment">// 记录：该人存在</span></span><br><span class="line">            UNION(id, fatherID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (motherID != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (representative[motherID] == <span class="number">-1</span>)</span><br><span class="line">                representative[motherID] = motherID; <span class="comment">// 记录：该人存在</span></span><br><span class="line">            UNION(id, motherID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;childID);</span><br><span class="line">            <span class="keyword">if</span> (representative[childID] == <span class="number">-1</span>)</span><br><span class="line">                representative[childID] = childID; <span class="comment">// 记录：该人存在</span></span><br><span class="line">            UNION(id, childID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;estateNum[id], &amp;estateArea[id]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计家族数据</span></span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        tmp = findRepresentative(i);</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="number">-1</span>)&#123; <span class="comment">// 如果这个人存在</span></span><br><span class="line">            families[tmp].memberNum += <span class="number">1</span>;</span><br><span class="line">            families[tmp].estateNum += estateNum[i];</span><br><span class="line">            families[tmp].estateArea += estateArea[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Family&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (families[i].memberNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            families[i].estateArea = families[i].estateArea / families[i].memberNum;</span><br><span class="line">            families[i].estateNum = families[i].estateNum / families[i].memberNum;</span><br><span class="line">            v.push_back(families[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v.size());</span><br><span class="line">    sort(v.begin(), v.end(), familyCmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04d %d %.3f %.3f\n"</span>, v[i].id, v[i].memberNum, v[i].estateNum, v[i].estateArea);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="并查集" scheme="https://chouxianyu.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="路径压缩" scheme="https://chouxianyu.github.io/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1107Social Clusters</title>
    <link href="https://chouxianyu.github.io/2020/10/18/PAT%E7%94%B2%E7%BA%A71107Social-Clusters/"/>
    <id>https://chouxianyu.github.io/2020/10/18/PAT甲级1107Social-Clusters/</id>
    <published>2020-10-18T13:54:41.000Z</published>
    <updated>2020-10-18T13:56:21.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>输入<ul><li>N：正整数，不超过1000，人的数量，索引为[1,N]</li><li>N个人的爱好：爱好的索引为[1,1000]</li></ul></li><li>输出<ul><li>有几个类（如果两人有共同爱好，则他们属于同一类）</li><li>每类的人数</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1107</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744</span></span><br><span class="line"><span class="comment">// Tags: 并查集 路径压缩</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, clusterSize;</span><br><span class="line"><span class="keyword">int</span> likeHobby[<span class="number">1001</span>]; <span class="comment">// 保存这一爱好的代表人（任意）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> father[x] == x ? x : father[x] = findFather(father[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="comment">// return father[x] == x ? x : findFather(father[x]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UNION</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = findFather(a), fb = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (fa != fb)</span><br><span class="line">        father[fa] = fb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, hobby;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    father.resize(n+<span class="number">1</span>);</span><br><span class="line">    clusterSize.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; father.size(); i++) <span class="comment">// 初始化，每人都是一个cluster</span></span><br><span class="line">        father[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;hobby);</span><br><span class="line">            <span class="keyword">if</span> (likeHobby[hobby] == <span class="number">0</span>)</span><br><span class="line">                likeHobby[hobby] = i;</span><br><span class="line">            UNION(i, likeHobby[hobby]); <span class="comment">// 将i和他的爱好的代表人合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个cluster的人数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        clusterSize[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(clusterSize.begin(), clusterSize.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (clusterSize[cnt] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, clusterSize[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, clusterSize[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/93647900" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93647900</a></p><p><a href="https://blog.csdn.net/liuchuo/article/details/52191082" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52191082</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="并查集" scheme="https://chouxianyu.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="路径压缩" scheme="https://chouxianyu.github.io/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1098Insertion or Heap Sort</title>
    <link href="https://chouxianyu.github.io/2020/10/18/PAT%E7%94%B2%E7%BA%A71098Insertion-or-Heap-Sort/"/>
    <id>https://chouxianyu.github.io/2020/10/18/PAT甲级1098Insertion-or-Heap-Sort/</id>
    <published>2020-10-18T12:00:10.000Z</published>
    <updated>2020-10-18T12:00:57.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805368847187968" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805368847187968</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>给定一个序列，及用某种排序方法经过几次迭代后的结果，请指出用了什么排序方法。（升序）</li><li>输入<ul><li>N：正整数，不超过100，给定序列中元素的个数</li><li>给定序列：N个整数</li><li>未完全排序的序列</li></ul></li><li>输出<ul><li>输出是堆排序还是插入排序</li><li>输出该排序算法下一步迭代的结果</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>插入排序特征：序列分成左右两部分，左半部分是从小到大，右半部分是原序列。据此可以检测是否是插入排序，否则是堆排序。</p></li><li><p>堆排序特征：序列分成左右两部分，左半部分是大顶堆，右半部分是从小到大。</p><p>  步骤如下：</p><ol><li>将序列[1,N]构建成大顶堆（最终得到升序序列）</li><li>将堆顶元素(值最大)与末尾元素交换</li><li>将序列[1,N-1]构建/调整为大顶堆（重复步骤1、2）</li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1098</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805368847187968</span></span><br><span class="line"><span class="comment">// Tags: 堆 排序 堆排序 插入排序 完全二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> father = start, child = father * <span class="number">2</span>; <span class="comment">// 结点从1开始编号</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= end &amp;&amp; b[child] &lt; b[child + <span class="number">1</span>]) <span class="comment">// 取值较大的子结点</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span> (b[father] &gt;= b[child]) <span class="comment">//如果父结点大于子结点，则不需调整，函数结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(b[father], b[child]);</span><br><span class="line">        father = child;</span><br><span class="line">        child = father * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n+<span class="number">1</span>), b(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n &amp;&amp; b[p] &gt;= b[p - <span class="number">1</span>])</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">int</span> index = p;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n &amp;&amp; a[p] == b[p])</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">if</span> (p == n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> key = b[index];</span><br><span class="line">        p = index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">0</span> &amp;&amp; b[p] &gt;= b[index])</span><br><span class="line">            p--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt; p + <span class="number">1</span>; i--)</span><br><span class="line">            b[i] = b[i<span class="number">-1</span>];</span><br><span class="line">        b[p+<span class="number">1</span>] = key;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Heap Sort\n"</span>);</span><br><span class="line">        p = n;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">2</span> &amp;&amp; b[p] &gt;= b[<span class="number">1</span>])</span><br><span class="line">            p--;</span><br><span class="line">        swap(b[<span class="number">1</span>], b[p]);</span><br><span class="line">        max_heapify(b, <span class="number">1</span>, p - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52252172" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52252172</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p><a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="排序" scheme="https://chouxianyu.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆" scheme="https://chouxianyu.github.io/tags/%E5%A0%86/"/>
    
      <category term="堆排序" scheme="https://chouxianyu.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="https://chouxianyu.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="完全二叉树" scheme="https://chouxianyu.github.io/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1051Pop Sequence</title>
    <link href="https://chouxianyu.github.io/2020/10/17/PAT%E7%94%B2%E7%BA%A71051Pop-Sequence/"/>
    <id>https://chouxianyu.github.io/2020/10/17/PAT甲级1051Pop-Sequence/</id>
    <published>2020-10-17T05:55:26.000Z</published>
    <updated>2020-10-17T05:56:02.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>背景</p><p>  给定一个最大容量为M的栈，随机压入和弹出N个数(从1到N)。请判断一个序列是否有可能是该栈弹出的序列</p></li><li><p>输入</p><ul><li>M：不超过1000，栈的最大容量</li><li>N：不超过1000，输入序列的长度</li><li>K：不超过1000，待检查的序列的数量</li><li>K个序列</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>模拟入栈和出栈的过程，参考了柳婼的题解。</p><p>从1到N入栈：每入栈一个数字，便判断是否出栈，如果可以出栈则出栈（重复此步骤）。如果入栈后，栈大小超过M，则跳出循环停止入栈，结果为NO；如果正确模拟了入栈和出栈，则结果为YES。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1051</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944</span></span><br><span class="line"><span class="comment">// Tags: 栈</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            s.push(i);</span><br><span class="line">            <span class="keyword">if</span> (s.size() &gt; m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() == v[current])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current == n + <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52215337" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52215337</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://chouxianyu.github.io/tags/%E6%A0%88/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1091Acute Stroke</title>
    <link href="https://chouxianyu.github.io/2020/10/16/PAT%E7%94%B2%E7%BA%A71091Acute-Stroke/"/>
    <id>https://chouxianyu.github.io/2020/10/16/PAT甲级1091Acute-Stroke/</id>
    <published>2020-10-16T05:56:13.000Z</published>
    <updated>2020-10-19T11:14:01.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><ul><li>输入<ul><li>M：正整数</li><li>N：正整数</li><li>L：正整数，不超过60，一个大脑中slice的数量</li><li>T：正整数，阈值，如果一个connected core的体积小于T，则这个core不能被计数</li><li>L个slice：每个slice是一个M×N的二值矩阵（1代表stroke，0代表正常），</li></ul></li><li>输出<ul><li>输出所有core的体积之和</li></ul></li></ul><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>三维的图，一个结点和周围六个结点是相邻的，本质上还是求连通分量。</p><p>DFS，会段错误（Segmentation Fault），因为递归层数太多，堆栈溢出了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1091</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072</span></span><br><span class="line"><span class="comment">// Tags: BFS 图 连通分量 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, l, t, volume;</span><br><span class="line"><span class="keyword">int</span> brain[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line"><span class="keyword">int</span> bias[<span class="number">6</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    visit[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">    volume++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> biasIndex = <span class="number">0</span>, ii, jj, kk; biasIndex &lt; <span class="number">6</span>; biasIndex++)&#123;</span><br><span class="line">        ii = i + bias[biasIndex][<span class="number">0</span>];</span><br><span class="line">        jj = j + bias[biasIndex][<span class="number">1</span>];</span><br><span class="line">        kk = k + bias[biasIndex][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (!visit[ii][jj][kk] &amp;&amp; brain[ii][jj][kk] == <span class="number">1</span>)&#123;</span><br><span class="line">            dfs(ii, jj, kk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;m, &amp;n, &amp;l, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;brain[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> volumeSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visit[i][j][k] &amp;&amp; brain[i][j][k] == <span class="number">1</span>)&#123;</span><br><span class="line">                    volume = <span class="number">0</span>;</span><br><span class="line">                    dfs(i, j, k);</span><br><span class="line">                    <span class="keyword">if</span> (volume &gt;= t)&#123;</span><br><span class="line">                        volumeSum += volume;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, volumeSum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>用BFS方法遍历求连通分量</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1091</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072</span></span><br><span class="line"><span class="comment">// Tags: BFS 图 连通分量 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, l, t, volume;</span><br><span class="line"><span class="keyword">int</span> brain[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line">Node bias[<span class="number">6</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; nodes;</span><br><span class="line">    nodes.push(node);</span><br><span class="line">    visit[node.i][node.j][node.k] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!nodes.empty())&#123;</span><br><span class="line">        node = nodes.front();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        volume++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> biasIndex = <span class="number">0</span>, ii, jj, kk; biasIndex &lt; <span class="number">6</span>; biasIndex++)&#123;</span><br><span class="line">            ii = node.i + bias[biasIndex].i;</span><br><span class="line">            jj = node.j + bias[biasIndex].j;</span><br><span class="line">            kk = node.k + bias[biasIndex].k;</span><br><span class="line">            <span class="keyword">if</span> (!visit[ii][jj][kk] &amp;&amp; brain[ii][jj][kk])&#123;</span><br><span class="line">                nodes.push(&#123;ii, jj, kk&#125;);</span><br><span class="line">                visit[ii][jj][kk] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;m, &amp;n, &amp;l, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;brain[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visit[i][j][k] &amp;&amp; brain[i][j][k])&#123;</span><br><span class="line">                    volume = <span class="number">0</span>;</span><br><span class="line">                    bfs(&#123;i, j, k&#125;);</span><br><span class="line">                    <span class="keyword">if</span> (volume &gt;= t)&#123;</span><br><span class="line">                        result += volume;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="连通分量" scheme="https://chouxianyu.github.io/tags/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1076Forwards on Weibo</title>
    <link href="https://chouxianyu.github.io/2020/10/10/PAT%E7%94%B2%E7%BA%A71076Forwards-on-Weibo/"/>
    <id>https://chouxianyu.github.io/2020/10/10/PAT甲级1076Forwards-on-Weibo/</id>
    <published>2020-10-10T02:03:14.000Z</published>
    <updated>2020-10-10T02:05:15.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>给定一个社交网络，请计算某用户的最大转发量（只计算L层间接关注者，假设一条微博，每个人只能转发一次）。</li><li>输入<ul><li>N：正整数，不超过1000，用户的数量，索引为[1,N]</li><li>L：正整数，不超过6，需要计算的间接关注者的层数</li><li>N个用户分别关注了哪些用户：每个用户关注的用户列表</li><li>K：正整数，要查询的用户的数量</li><li>K个要查询的用户：</li></ul></li><li>输出</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>需要判断层次的BFS：通过类来保存每个结点的层次即可</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1076</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736</span></span><br><span class="line"><span class="comment">// Tags: 图 BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> n, l;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; followers[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,layer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> tempID)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;User&gt; users;</span><br><span class="line">    users.push(&#123;tempID, <span class="number">0</span>&#125;);</span><br><span class="line">    visit[tempID] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!users.empty())&#123;</span><br><span class="line">        User u = users.front();</span><br><span class="line">        users.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = followers[u.id].begin(); it != followers[u.id].end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[*it] &amp;&amp; u.layer &lt; l)&#123;</span><br><span class="line">                visit[*it] = <span class="literal">true</span>;</span><br><span class="line">                users.push(&#123;*it, u.layer + <span class="number">1</span>&#125;);</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;l);</span><br><span class="line">    <span class="keyword">int</span> tempUser, m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tempUser);</span><br><span class="line">            followers[tempUser].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tempUser);</span><br><span class="line">        fill(visit, visit + MAXN, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(tempUser));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1131Subway Map</title>
    <link href="https://chouxianyu.github.io/2020/10/05/PAT%E7%94%B2%E7%BA%A71131Subway-Map/"/>
    <id>https://chouxianyu.github.io/2020/10/05/PAT甲级1131Subway-Map/</id>
    <published>2020-10-05T15:04:38.000Z</published>
    <updated>2020-10-05T15:05:18.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>给定起点和目标地，找到最快的路</p></li><li><p>输入</p><ul><li>N：正整数，不超过100，地铁线路的数量，索引为[1,n]</li><li>N条地铁线路：M个站点，站点索引为[0000,9999]<ul><li>两条地铁线路不会经过同一条边（站到站）</li><li>可能存在环，但没有自环</li><li>每个站点最多有5条线路经过</li></ul></li><li>K：正整数，不超过10，查询的数量</li><li>K对起点和终点</li></ul></li><li><p>输出</p><p>  对于每个查询，输出最少经过的站数。如果有多个解，输出换线最少的解。</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>因为存在环，所以在DFS时需要用visit数组表示某个车站是否已经DFS过。其实只要存在可以从多个结点到达某个结点V的情况，就应该设置visit数组标记是否已访问过结点V，如果访问过则不用再访问。</li><li><strong>注意输出要按四位输出</strong></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1131</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432</span></span><br><span class="line"><span class="comment">// Tags: 图 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> line[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextStop[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempPath, ansPath;</span><br><span class="line"><span class="keyword">int</span> tempTransfer, ansTransfer;</span><br><span class="line"><span class="keyword">int</span> n, m, k, start, destination;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> stop,<span class="keyword">int</span> preLine)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[stop])</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    tempPath.push_back(stop);</span><br><span class="line">    visited[stop] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop == destination)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempPath.size() &lt; ansPath.size())&#123;</span><br><span class="line">            ansPath = tempPath;</span><br><span class="line">            ansTransfer = tempTransfer;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempPath.size() == ansPath.size() &amp;&amp; tempTransfer &lt; ansTransfer)&#123;</span><br><span class="line">            ansPath = tempPath;</span><br><span class="line">            ansTransfer = tempTransfer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nextStop[stop].begin(); it != nextStop[stop].end(); it++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> transferFlag = (line[stop][*it] != preLine);</span><br><span class="line">            <span class="keyword">if</span> (transferFlag)</span><br><span class="line">                tempTransfer++;</span><br><span class="line">            dfs(*it, line[stop][*it]);</span><br><span class="line">            <span class="keyword">if</span> (transferFlag)</span><br><span class="line">                tempTransfer--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">    visited[stop] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">            line[u][v] = i;</span><br><span class="line">            line[v][u] = i;</span><br><span class="line">            nextStop[u].push_back(v);</span><br><span class="line">            nextStop[v].push_back(u);</span><br><span class="line">            u = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;start, &amp;destination);</span><br><span class="line">        tempTransfer = <span class="number">-1</span>;</span><br><span class="line">        ansTransfer = MAXN;</span><br><span class="line">        tempPath.clear();</span><br><span class="line">        ansPath.resize(MAXN);</span><br><span class="line">        dfs(start, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ansPath.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> tempStart = start, preLine = line[ansPath[<span class="number">0</span>]][ansPath[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansPath.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (preLine != line[ansPath[i]][ansPath[i + <span class="number">1</span>]])&#123; <span class="comment">// 要换线</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Take Line#%d from %04d to %04d.\n"</span>, preLine, tempStart, ansPath[i]);</span><br><span class="line">                tempStart = ansPath[i];</span><br><span class="line">                preLine = line[ansPath[i]][ansPath[i + <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Take Line#%d from %04d to %04d.\n"</span>, preLine, tempStart, ansPath.back());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1130Infix Expression</title>
    <link href="https://chouxianyu.github.io/2020/09/29/PAT%E7%94%B2%E7%BA%A71130Infix-Expression/"/>
    <id>https://chouxianyu.github.io/2020/09/29/PAT甲级1130Infix-Expression/</id>
    <published>2020-09-29T05:14:35.000Z</published>
    <updated>2020-09-29T05:19:45.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>给定语法树，请输出其中缀表达式，用圆括号表示优先级，最后一层不要圆括号。</li><li>输入<ul><li>N：正整数，不超过20，语法树中结点的个数</li><li>N个结点：结点索引为[1,N]，-1代表空</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是二叉树的中序遍历而已，DFS就行。</p><p>最外层不需要括号，这时手动遍历根结点即可。</p><p>妙的是：<strong>所有结点中没有作为子结点的结点就是根结点</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1130</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312</span></span><br><span class="line"><span class="comment">// Tags: 二叉树 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> data;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; <span class="number">1</span> || root &gt; n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].left != <span class="number">-1</span> || nodes[root].right != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    dfs(nodes[root].left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nodes[root].data;</span><br><span class="line">    dfs(nodes[root].right);</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].left != <span class="number">-1</span> || nodes[root].right != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    nodes.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nodes[i].data;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].left, &amp;nodes[i].right);</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].left != <span class="number">-1</span>)</span><br><span class="line">            visited[nodes[i].left] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].right != <span class="number">-1</span>)</span><br><span class="line">            visited[nodes[i].right] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(visited[root])</span><br><span class="line">        root++;</span><br><span class="line"></span><br><span class="line">    dfs(nodes[root].left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nodes[root].data;</span><br><span class="line">    dfs(nodes[root].right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1103Integer Factorization</title>
    <link href="https://chouxianyu.github.io/2020/09/29/PAT%E7%94%B2%E7%BA%A71103Integer-Factorization/"/>
    <id>https://chouxianyu.github.io/2020/09/29/PAT甲级1103Integer-Factorization/</id>
    <published>2020-09-29T03:27:54.000Z</published>
    <updated>2020-09-29T03:30:36.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>正整数N的K-P因数分解就是把N写成K个整数的P次幂之和。</p></li><li><p>输入</p><ul><li>N：不超过400，</li><li>K：不超过N</li><li>P：大于1，不超过7</li></ul></li><li><p>输出</p><p>  按格式输出K个整数</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>DFS+剪枝</p><p>思路是按照柳神题解来的，我可真是个菜鸡┭┮﹏┭┮。</p><p>题目样例一的输出似乎是错的诶。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1103</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805364711604224</span></span><br><span class="line"><span class="comment">// Tags: DFS 剪枝</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, p, maxFacSum = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, ans, tempAns;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>, index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp &lt;= n) &#123;</span><br><span class="line">        v.push_back(temp);</span><br><span class="line">        temp = <span class="built_in">pow</span>(index, p);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> tempSum,<span class="keyword">int</span> tempK, <span class="keyword">int</span> facSum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tempK == k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempSum == n &amp;&amp; facSum &gt; maxFacSum)&#123;</span><br><span class="line">            ans = tempAns;</span><br><span class="line">            maxFacSum = facSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempSum + v[index] &lt;= n)&#123;</span><br><span class="line">            tempAns[tempK] = index;</span><br><span class="line">            dfs(index, tempSum + v[index], tempK + <span class="number">1</span>, facSum + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;k, &amp;p);</span><br><span class="line">    init();</span><br><span class="line">    tempAns.resize(k);</span><br><span class="line">    dfs(v.size() - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (maxFacSum == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d = %d^%d"</span>, n, ans[<span class="number">0</span>], p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" + %d^%d"</span>, ans[i], p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52493390" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52493390</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="剪枝" scheme="https://chouxianyu.github.io/tags/%E5%89%AA%E6%9E%9D/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1034Head of a Gang</title>
    <link href="https://chouxianyu.github.io/2020/09/26/PAT%E7%94%B2%E7%BA%A71034Head-of-a-Gang/"/>
    <id>https://chouxianyu.github.io/2020/09/26/PAT甲级1034Head-of-a-Gang/</id>
    <published>2020-09-26T09:30:35.000Z</published>
    <updated>2020-09-26T09:31:40.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805456881434624" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805456881434624</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>背景</p><p>  A和B打电话，则A和B有关系，A和B关系的权重为他们间通话的总时长。</p><p>  一个帮派由2个人以上组成，他们关系的总权重超过K。</p><p>  帮派中和别人关系的总权重最大的人就是头目。现给出多个通话，请找出头目。</p></li><li><p>输入</p><ul><li>N：正整数，不超过1000，通话的数量</li><li>K：正整数，不超过1000，权重阈值</li><li>N个通话</li></ul></li><li><p>输出</p><ul><li>帮派的数量</li><li>每个帮派的头目和成员数量（按头目名称的字典序输出）</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>通过map保存名字和索引的关系。</p></li><li><p>一个帮派就是一个连通分量</p></li><li><p>通过DFS求有多少个连通分量，通过成员数量和总权重进行筛选，最终输出其结点数和头目</p></li><li><p>题目有个地方很奇怪？要把题目理解对了</p><p>  <code>In each gang, the one with maximum total weight is the head.</code>这句话指出在每个帮派中，总权重最大的人就是头目。</p><p>  我起初理解为应在这个帮派之内求每个人的权重（如果A属于某帮派而B不属于这个帮派，那计算A的总权重时，则不应该将A和B的权重包含在内）。但题目的意思是在所有人范围内计算总权重，即使帮派里不包含B，计算A的总权重时也要将A和B的权重计入。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1034</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805456881434624</span></span><br><span class="line"><span class="comment">// Tags: 图 连通分量 map DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sti;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; its;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2001</span>; <span class="comment">// 最多1000个通话，最多就有2000个人</span></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> e[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> weight[MAXN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span>&amp; head, <span class="keyword">int</span>&amp; totalWeight, <span class="keyword">int</span>&amp; memberCount)</span></span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    memberCount += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (weight[u] &gt; weight[head])&#123;</span><br><span class="line">        head = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; id; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[u][v] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            totalWeight += e[u][v]; <span class="comment">// 在所有人范围内计算总权重</span></span><br><span class="line">            e[u][v] = e[v][u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v])</span><br><span class="line">                dfs(v, head, totalWeight, memberCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">        <span class="keyword">if</span> (sti[s1] == <span class="number">0</span>)&#123;</span><br><span class="line">            sti[s1] = id;</span><br><span class="line">            its[id] = s1;</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sti[s2] == <span class="number">0</span>)&#123;</span><br><span class="line">            sti[s2] = id;</span><br><span class="line">            its[id] = s2;</span><br><span class="line">            id++;</span><br><span class="line">        &#125;</span><br><span class="line">        e[sti[s1]][sti[s2]] += t;</span><br><span class="line">        e[sti[s2]][sti[s1]] += t;</span><br><span class="line">        weight[sti[s1]] += t;</span><br><span class="line">        weight[sti[s2]] += t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; id; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> head = i, totalWeight = <span class="number">0</span>, memberCount = <span class="number">0</span>;</span><br><span class="line">            dfs(i, head, totalWeight, memberCount);</span><br><span class="line">            <span class="keyword">if</span> (memberCount &gt; <span class="number">2</span> &amp;&amp; totalWeight &gt; k)</span><br><span class="line">                ans[its[head]] = memberCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = ans.begin(); it != ans.end(); it++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, it-&gt;first.c_str(), it-&gt;second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="连通分量" scheme="https://chouxianyu.github.io/tags/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1021Deepest Root</title>
    <link href="https://chouxianyu.github.io/2020/09/25/PAT%E7%94%B2%E7%BA%A71021Deepest-Root/"/>
    <id>https://chouxianyu.github.io/2020/09/25/PAT甲级1021Deepest-Root/</id>
    <published>2020-09-25T08:16:06.000Z</published>
    <updated>2020-09-25T08:19:59.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>输入<ul><li>N：正整数，不超过10000，结点的数量，索引为[1,N]</li><li>N-1条边</li></ul></li><li>输出<ul><li>输出深度最大的根结点，如果不唯一，则按升序输出。如果这个图不是树，则输出图中连通分量的数量</li></ul></li></ul><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>没有回路的无向图是连通的当且仅当它是树</li></ul><ol><li>求该图的连通分量数，如果连通分量数大于1，则输出连通分量数，程序终止；</li><li>对于每一个结点，将其作为根结点，通过dfs求其高度depth，将depth与全局最大高度maxDepth比较，并更新全局最大高度及其对应根结点；</li><li>输出根结点</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>如果用邻接矩阵，则第3个点会超时，用邻接表则不超时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1021</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856</span></span><br><span class="line"><span class="comment">// Tags: 树 图 连通分量 连通图 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> n, tempDepth = <span class="number">0</span>, depth = <span class="number">0</span>, maxDepth = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; deepestRoot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    tempDepth += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; tempDepth)&#123;</span><br><span class="line">        depth = tempDepth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[u].size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v[u][i]])&#123;</span><br><span class="line">            dfs(v[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tempDepth -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    v.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        v[v1].push_back(v2);</span><br><span class="line">        v[v2].push_back(v1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components"</span>, num);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> root = <span class="number">1</span>; root &lt;= n; root++)&#123;</span><br><span class="line">            fill(visited + <span class="number">1</span>, visited + <span class="number">1</span> + n, <span class="literal">false</span>);</span><br><span class="line">            depth = <span class="number">0</span>;</span><br><span class="line">            dfs(root);</span><br><span class="line">            <span class="keyword">if</span> (maxDepth &lt; depth)&#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                deepestRoot.clear();</span><br><span class="line">                deepestRoot.push_back(root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (maxDepth == depth)&#123;</span><br><span class="line">                deepestRoot.push_back(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deepestRoot.size(); i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, deepestRoot[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>第一次DFS：判断连通分量数量，如果超过1，则直接输出，程序结束</p><p> 同时保存深度最大的那些结点到数组s中</p></li><li><p>第二次DFS：从s中的任一个结点出发进行DFS，此时深度最大的结点与s的并集就是结果</p></li></ol><p>这个思路很妙，并且速度很快：这是无向图，是双向的，所以正序倒序各求一遍合起来就是结果。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1021</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805482919673856</span></span><br><span class="line"><span class="comment">// Tags: 树 图 连通分量 连通图 DFS set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> n, depth = <span class="number">0</span>, maxDepth = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    depth += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxDepth &lt; depth)&#123;</span><br><span class="line">        maxDepth = depth;</span><br><span class="line">        temp.clear();</span><br><span class="line">        temp.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (maxDepth == depth)&#123;</span><br><span class="line">        temp.push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[u].size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v[u][i]])&#123;</span><br><span class="line">            dfs(v[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depth -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    v.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        v[v1].push_back(v2);</span><br><span class="line">        v[v2].push_back(v1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %d components"</span>, num);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++)</span><br><span class="line">            result.insert(temp[i]);</span><br><span class="line">        </span><br><span class="line">        fill(visited + <span class="number">1</span>, visited + <span class="number">1</span> + n, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">int</span> u = temp[<span class="number">0</span>];</span><br><span class="line">        temp.clear();</span><br><span class="line">        dfs(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); i++)</span><br><span class="line">            result.insert(temp[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = result.begin(); it != result.end(); it++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52294178" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52294178</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="连通图" scheme="https://chouxianyu.github.io/tags/%E8%BF%9E%E9%80%9A%E5%9B%BE/"/>
    
      <category term="连通分量" scheme="https://chouxianyu.github.io/tags/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
      <category term="树" scheme="https://chouxianyu.github.io/tags/%E6%A0%91/"/>
    
      <category term="set" scheme="https://chouxianyu.github.io/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1013Battle Over Cities</title>
    <link href="https://chouxianyu.github.io/2020/09/25/PAT%E7%94%B2%E7%BA%A71013Battle-Over-Cities/"/>
    <id>https://chouxianyu.github.io/2020/09/25/PAT甲级1013Battle-Over-Cities/</id>
    <published>2020-09-25T03:49:36.000Z</published>
    <updated>2020-09-25T03:51:52.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>在战争中，如果一个城市被敌方占领，那通向该城市或者从该城市出发的高速公路都会被关闭，需要修复其它公路保证所有的城市互相连通。（一个图去掉一个顶点，请补充边使该图变为连通图，即所有顶点都被经过）</li><li>输入<ul><li>N：小于1000，城市总数，索引为[1,N]</li><li>M：剩余高速公路的数量</li><li>K：需要被检查的城市的数量</li><li>M条高速公路</li><li>K个需要被检查的城市</li></ul></li><li>输出<ul><li>对于每个需要检查的城市，如果它被敌方占领，请输出需要修复几条高速公路。</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="知识概念"><a href="#知识概念" class="headerlink" title="知识概念"></a>知识概念</h3><ul><li><p>连通/通路</p><p>  如果从顶点x出发，可以到达y，那x和y<strong>连通</strong>，这条路径就是一个<strong>通路</strong>。</p></li><li><p>连通图</p><p>  如果图<em>G</em>中每两点间皆连通，则<em>G</em>是<strong>连通图</strong>。</p></li><li><p>最大连通子图</p><p>  如果在这个子图中在添加一个顶点则该子图不再是连通图，则该子图就是最大连通子图。</p></li><li><p>连通分量</p><p>  无向图G的一个最大连通子图称为G的一个<strong>连通分量</strong>或<strong>连通分支</strong>。</p></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>这道题就是求去除某个结点后图中的连通分量数</p><p>  添加路线的最小数量，就是去除该顶点后图中的连通分量数-1。</p><p>  因为当a个互相分立的连通分量需要变为连通图的时候，只需要添加a-1个路线，就能让他们相连。</p></li><li><p>一个城市被占领，不用删除和其关联的所有边，只要将该顶点设置为已标记即可，这样DFS时就会忽略该顶点。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1013</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805500414115840</span></span><br><span class="line"><span class="comment">// Tags: DFS 图 连通图 连通分量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">bool</span> e[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v] &amp;&amp; e[u][v])&#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        e[v1][v2] = e[v2][v1] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> occupied;</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        fill(visited + <span class="number">1</span>, visited + <span class="number">1</span> + n, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;occupied);</span><br><span class="line">        visited[occupied] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                num += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52293756" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52293756</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="连通图" scheme="https://chouxianyu.github.io/tags/%E8%BF%9E%E9%80%9A%E5%9B%BE/"/>
    
      <category term="连通分量" scheme="https://chouxianyu.github.io/tags/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1111Online Map</title>
    <link href="https://chouxianyu.github.io/2020/09/24/PAT%E7%94%B2%E7%BA%A71111Online-Map/"/>
    <id>https://chouxianyu.github.io/2020/09/24/PAT甲级1111Online-Map/</id>
    <published>2020-09-24T07:58:16.000Z</published>
    <updated>2020-09-24T08:01:05.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>输入</p><ul><li>N：取值范围是[2,500]，结点数量，索引为[0,N-1]</li><li>M：正整数，边的数量</li><li>M条边</li><li>起点和终点</li></ul></li><li><p>输出</p><ul><li><p>最短路径</p><p>  如果最短路径不唯一，输出其中最快的那条路径</p></li><li><p>最快路径</p><p>  如果最快路径不唯一，输出其中经过结点最少的那条路径</p></li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题是先后做两次dijkstra+DFS，即可求解。</p><p>解法是dijkstra+DFS的题目还有：</p><ol><li><a href="https://www.cnblogs.com/chouxianyu/p/13709220.html" target="_blank" rel="noopener">PAT甲级1087All Roads Lead to Rome</a></li><li><a href="https://www.cnblogs.com/chouxianyu/p/13692483.html" target="_blank" rel="noopener">PAT甲级1030Travel Plan</a></li><li><a href="https://www.cnblogs.com/chouxianyu/p/13690906.html" target="_blank" rel="noopener">PAT甲级1018Public Bike Management</a></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1111</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805358663417856</span></span><br><span class="line"><span class="comment">// Tags: 图 最短路 单源最短路 dijkstra BFS DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, start, destination;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">99999999</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> timee[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> minDis[MAXN];</span><br><span class="line"><span class="keyword">int</span> minTime[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; disPath, timePath, tempPath, disPre[MAXN], timePre[MAXN];</span><br><span class="line"><span class="keyword">int</span> disPathMinTime = INF, timePathMinNodeCount = INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calcPathTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vec.size() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        sum += timee[vec[i]][vec[i - <span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disDFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    <span class="keyword">if</span> (v == start)&#123;</span><br><span class="line">        <span class="keyword">int</span> pathTime = calcPathTime(tempPath);</span><br><span class="line">        <span class="keyword">if</span> (disPathMinTime &gt; pathTime)&#123;</span><br><span class="line">            disPath = tempPath;</span><br><span class="line">            disPathMinTime = pathTime;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disPre[v].size(); i++)</span><br><span class="line">        disDFS(disPre[v][i]);</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeDFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    <span class="keyword">if</span> (v == start)&#123;</span><br><span class="line">        <span class="keyword">if</span> (timePathMinNodeCount &gt; tempPath.size())&#123;</span><br><span class="line">            timePath = tempPath;</span><br><span class="line">            timePathMinNodeCount = tempPath.size();</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; timePre[v].size(); i++)</span><br><span class="line">        timeDFS(timePre[v][i]);</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(timee[<span class="number">0</span>], timee[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(minDis, minDis + MAXN, INF);</span><br><span class="line">    fill(minTime, minTime + MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> v1, v2, oneWay, l, t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d"</span>, &amp;v1, &amp;v2, &amp;oneWay, &amp;l, &amp;t);</span><br><span class="line">        <span class="keyword">if</span> (oneWay == <span class="number">1</span>)&#123;</span><br><span class="line">            dis[v1][v2] = l;</span><br><span class="line">            timee[v1][v2] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oneWay == <span class="number">0</span>)&#123;</span><br><span class="line">            dis[v1][v2] = dis[v2][v1] = l;</span><br><span class="line">            timee[v1][v2] = timee[v2][v1] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;start, &amp;destination);</span><br><span class="line"></span><br><span class="line">    minDis[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, tempMin = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; tempMin &gt; minDis[j])&#123;</span><br><span class="line">                tempMin = minDis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dis[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (minDis[v] &gt; minDis[u] + dis[u][v])&#123;</span><br><span class="line">                    minDis[v] = minDis[u] + dis[u][v];</span><br><span class="line">                    disPre[v].clear();</span><br><span class="line">                    disPre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (minDis[v] == minDis[u] + dis[u][v])&#123;</span><br><span class="line">                    disPre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    disDFS(destination);</span><br><span class="line"></span><br><span class="line">    fill(visited, visited + MAXN, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    minTime[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, tempMin = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; tempMin &gt; minTime[j])&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                tempMin = minTime[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; timee[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (minTime[v] &gt; minTime[u] + timee[u][v])&#123;</span><br><span class="line">                    minTime[v] = minTime[u] + timee[u][v];</span><br><span class="line">                    timePre[v].clear();</span><br><span class="line">                    timePre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (minTime[v] == minTime[u] + timee[u][v])&#123;</span><br><span class="line">                    timePre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.clear();</span><br><span class="line">    timeDFS(destination);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isIdentical = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (disPath.size() == timePath.size())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disPath.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (disPath[i] != timePath[i])&#123;</span><br><span class="line">                isIdentical = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        isIdentical = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isIdentical)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d; Time = %d: %d"</span>, minDis[destination], minTime[destination], start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = disPath.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" -&gt; %d"</span>, disPath[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d: %d"</span>, minDis[destination], start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = disPath.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" -&gt; %d"</span>, disPath[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nTime = %d: %d"</span>, minTime[destination], start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = timePath.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" -&gt; %d"</span>, timePath[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1087All Roads Lead to Rome</title>
    <link href="https://chouxianyu.github.io/2020/09/21/PAT%E7%94%B2%E7%BA%A71087All-Roads-Lead-to-Rome/"/>
    <id>https://chouxianyu.github.io/2020/09/21/PAT甲级1087All-Roads-Lead-to-Rome/</id>
    <published>2020-09-21T14:34:33.000Z</published>
    <updated>2020-09-21T14:37:15.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>找到成本最低、快乐值总和最高的路径。<strong>优先找成本最低的，然后再找快乐值最高的，然后再找平均快乐值最高的。</strong></p><ul><li>输入<ul><li>N：正整数，[2,200]，城市的数量</li><li>K：正整数，路径的数量</li><li>起始城市的名称</li><li>N-1个城市的名字及其快乐值</li><li>K条路径</li></ul></li><li>输出<ul><li>成本最低的路径的数量</li><li>成本</li><li>快乐值总和</li><li>平均快乐值（只输出整数部分）</li><li>路径</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是一道dijkstra+DFS的题，和<a href="https://www.cnblogs.com/chouxianyu/p/13690906.html" target="_blank" rel="noopener">PAT甲级1018Public Bike Management</a>很类似，所以详细思路不再说明。</p><ul><li>用两个map将城市的名字和索引相互对应</li><li>用dijkstra算法求出起始城市到所有城市的最短距离，并记录每个城市的前驱城市</li><li>使用DFS求出路径（并计算、比较快乐值总和与平均值）</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1087</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984</span></span><br><span class="line"><span class="comment">// Tags: 图 最短路 单源最短路 dijkstra BFS DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">string</span> startCity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sti;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; its;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">9999999</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">201</span>;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> minDis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"><span class="keyword">int</span> happiness[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempPath;</span><br><span class="line"><span class="keyword">int</span> ansHappinessSum = -INF, ansPathNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> ansHappinessAve = -INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">1</span>)&#123; <span class="comment">// 到达起点</span></span><br><span class="line">        <span class="keyword">int</span> happinessSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = tempPath.begin(); iter != tempPath.end(); iter++)</span><br><span class="line">            happinessSum += happiness[*iter];</span><br><span class="line">        <span class="keyword">double</span> happinessAve = happinessSum * <span class="number">1.0</span> / (tempPath.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ansHappinessSum &lt; happinessSum)&#123;</span><br><span class="line">            path = tempPath;</span><br><span class="line">            ansHappinessSum = happinessSum;</span><br><span class="line">            ansHappinessAve = happinessAve;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ansHappinessSum == happinessSum &amp;&amp; ansHappinessAve &lt; happinessAve)&#123;</span><br><span class="line">            path = tempPath;</span><br><span class="line">            ansHappinessAve = happinessAve;</span><br><span class="line">        &#125;</span><br><span class="line">        ansPathNum++;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].size(); i++)</span><br><span class="line">        dfs(pre[v][i]);</span><br><span class="line"></span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(minDis, minDis + MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; startCity;</span><br><span class="line">    sti[startCity] = <span class="number">1</span>;</span><br><span class="line">    its[<span class="number">1</span>] = startCity;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        sti[s] = i;</span><br><span class="line">        its[i] = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h);</span><br><span class="line">        happiness[i] = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;dis[sti[s]][sti[t]]);</span><br><span class="line">        dis[sti[t]][sti[s]] = dis[sti[s]][sti[t]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempMin = INF, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; tempMin &gt; minDis[j])&#123;</span><br><span class="line">                tempMin = minDis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dis[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (minDis[v] &gt; minDis[u] + dis[u][v])&#123;</span><br><span class="line">                    minDis[v] = minDis[u] + dis[u][v];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (minDis[v] == minDis[u] + dis[u][v])&#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(sti[<span class="string">"ROM"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n%s"</span>, ansPathNum, minDis[sti[<span class="string">"ROM"</span>]], ansHappinessSum, <span class="keyword">int</span>(ansHappinessAve), startCity.c_str());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%s"</span>, its[path[i]].c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1072Gas Station</title>
    <link href="https://chouxianyu.github.io/2020/09/20/PAT%E7%94%B2%E7%BA%A71072Gas-Station/"/>
    <id>https://chouxianyu.github.io/2020/09/20/PAT甲级1072Gas-Station/</id>
    <published>2020-09-20T10:41:01.000Z</published>
    <updated>2020-09-20T10:41:50.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>加油站要离各个住宅的最小距离应该尽可能地大，但也要保证住宅在加油区的服务距离内。</p><p>现在给出几个加油站的候选位置，请你找出最好的一个（<strong>距离各住宅的最小距离最大）。如果有多个解，则选择离住宅平均距离最短的那个。如果还是有多个解，则选择索引较小的那个。</strong></p><ul><li><p>输入</p><ul><li>N：正整数，不超过1000，住宅的数量，住宅索引为[1,N]</li><li>M：正整数，不超过10，加油站候选位置的数量，索引为[G1,GM]</li><li>K：正整数，不超过10000，边的数量</li><li>Ds：正整数，加油站的最大服务距离</li><li>K条边</li></ul></li><li><p>输出</p><ul><li><p>加油站候选位置的索引</p></li><li><p>加油站与住宅的最短距离和平均距离</p><p>  数字必须精确到小数点后一位。</p></li><li><p>解不存在则输出<code>No Solution</code></p></li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>除了输入输出需要懂点心思，这道题就是一道简单的单源最短路题目了。</p><ul><li>这里有两类结点：住宅和加油站，可以对输入进行处理，规定索引[1,n]是住宅，索引[n+1,n+m]是加油站</li><li>然后对每个加油站运行dijkstra算法，在不超过加油站服务距离的前提下求解</li><li>注意是优先求距离各住宅的最小距离最大的解</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1072</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072</span></span><br><span class="line"><span class="comment">// Tags: 图 最短路 单源最短路 dijkstra BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1011</span>; <span class="comment">// [1,n]是住宅，[n+1,n+m]是加油站</span></span><br><span class="line"><span class="keyword">int</span> n, m, k, ds;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN]; </span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> minDis[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;k, &amp;ds);</span><br><span class="line">    <span class="built_in">string</span> aStr, bStr;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; aStr &gt;&gt; bStr;</span><br><span class="line">        a = (aStr[<span class="number">0</span>] == <span class="string">'G'</span>) ? stoi(aStr.substr(<span class="number">1</span>)) + n : stoi(aStr);</span><br><span class="line">        b = (bStr[<span class="number">0</span>] == <span class="string">'G'</span>) ? stoi(bStr.substr(<span class="number">1</span>)) + n : stoi(bStr);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; dis[a][b]) <span class="comment">// 处理输入的特殊情况</span></span><br><span class="line">            dis[a][b] = dis[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个加油站运行dijkstra算法</span></span><br><span class="line">    <span class="keyword">int</span> ansStation = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> ansDis = -INF, ansAverDis = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> station = n + <span class="number">1</span>; station &lt;= n + m; station++)&#123;</span><br><span class="line">        <span class="keyword">double</span> tempMin = INF, averDis = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        fill(minDis, minDis + MAXN, INF);</span><br><span class="line">        fill(visited, visited + MAXN, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行dijkstra算法，求该加油站到其它加油站和住宅的最短路径</span></span><br><span class="line">        minDis[station] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tempMin = INF, u = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; minDis[j] &lt; tempMin)&#123;</span><br><span class="line">                    u = j;</span><br><span class="line">                    tempMin = minDis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            visited[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n + m; v++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; dis[u][v] != INF)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (minDis[v] &gt; minDis[u] + dis[u][v])&#123;</span><br><span class="line">                        minDis[v] = minDis[u] + dis[u][v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最终结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (minDis[i] &gt; ds)&#123;</span><br><span class="line">                tempMin = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minDis[i] &lt; tempMin)&#123;</span><br><span class="line">                tempMin = minDis[i];</span><br><span class="line">            &#125;</span><br><span class="line">            averDis += minDis[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tempMin == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        averDis /= n;</span><br><span class="line">        <span class="keyword">if</span> (tempMin &gt; ansDis)&#123;</span><br><span class="line">            ansDis = tempMin;</span><br><span class="line">            ansStation = station;</span><br><span class="line">            ansAverDis = averDis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tempMin == ansDis &amp;&amp; averDis &lt; ansAverDis)&#123;</span><br><span class="line">            ansStation = station;</span><br><span class="line">            ansAverDis = averDis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ansStation == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"G%d\n%.1f %.1f"</span>, ansStation - n, ansDis, ansAverDis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1030Travel Plan</title>
    <link href="https://chouxianyu.github.io/2020/09/18/PAT%E7%94%B2%E7%BA%A71030Travel-Plan/"/>
    <id>https://chouxianyu.github.io/2020/09/18/PAT甲级1030Travel-Plan/</id>
    <published>2020-09-18T09:31:06.000Z</published>
    <updated>2020-09-18T09:33:06.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>输入<ul><li>N：正整数，不超过500，结点的数量，索引为[0,N-1]</li><li>M：正整数，边的数量</li><li>S：起点索引</li><li>D：终点索引</li><li>M条边</li></ul></li><li>输出<ul><li>最短路径经过的结点</li><li>总距离</li><li>总成本</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题在普通最短路径题目基础上补充了2点</p><p>我是先做了<a href="https://www.cnblogs.com/chouxianyu/p/13690906.html" target="_blank" rel="noopener">PAT甲级1018Public Bike Management</a>，这两题很相似，1018更难，这题更简单。</p><ol><li><p>输出最短路径经过的结点</p><p> 因为最终的最短路径只有一条，所以保存最短路径中每个结点的前一个结点，最终从D往回遍历即可</p></li><li><p>优先考虑距离，再考虑成本</p><p> 通过if语句实现</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后生成path时我是递归存入vector，其实也可以直接迭代生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1030</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392</span></span><br><span class="line"><span class="comment">// Tags: 最短路 图 dijkstra 单源最短路 BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">9999999</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s, d;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"><span class="keyword">int</span> minDis[MAXN];</span><br><span class="line"><span class="keyword">int</span> minCost[MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    path.push_back(v);</span><br><span class="line">    <span class="keyword">if</span> (v != s)&#123;</span><br><span class="line">        getPath(pre[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(minDis, minDis + MAXN, INF);</span><br><span class="line">    fill(minCost, minCost + MAXN, INF);</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(cost[<span class="number">0</span>], cost[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;s, &amp;d);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;dis[a][b], &amp;cost[a][b]);</span><br><span class="line">        dis[b][a] = dis[a][b];</span><br><span class="line">        cost[b][a] = cost[a][b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDis[s] = <span class="number">0</span>;</span><br><span class="line">    minCost[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minD = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; minDis[j] &lt; minD)&#123;</span><br><span class="line">                    minD = minDis[j];</span><br><span class="line">                    u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dis[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (minDis[u] + dis[u][v] &lt; minDis[v])&#123;</span><br><span class="line">                    minDis[v] = minDis[u] + dis[u][v];</span><br><span class="line">                    minCost[v] = minCost[u] + cost[u][v];</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (minDis[u] + dis[u][v] == minDis[v] &amp;&amp; minCost[u] + cost[u][v] &lt; minCost[v])&#123;</span><br><span class="line">                    minCost[v] = minCost[u] + cost[u][v];</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getPath(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = path.rbegin(); iter != path.rend(); iter++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *iter);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, minDis[d], minCost[d]);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1018Public Bike Management</title>
    <link href="https://chouxianyu.github.io/2020/09/18/PAT%E7%94%B2%E7%BA%A71018Public-Bike-Management/"/>
    <id>https://chouxianyu.github.io/2020/09/18/PAT甲级1018Public-Bike-Management/</id>
    <published>2020-09-18T05:53:15.000Z</published>
    <updated>2020-09-18T09:35:37.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>如果有多个最短路径，则选择PBMC送出自行车的数量最少的路径</p><p>  如果还是有多条最短路径，那么就选择从车站带回的自行车数目最少的（带回的时候是不调整路过的车站的）</p></li><li><p>PBMC携带或者从经过的车站收集一定数量的自行车前往某车站，并使路过的车站都达到半满。</p></li><li><p>输入</p><ul><li>Cmax：不超过100，偶数，每个站点中最多有多少辆自行车</li><li>N：不超过500，站点的数量，站点索引为[1,N]，PBMC索引为0</li><li>Sp：有问题的站点</li><li>M：边的数量</li><li>N个站点中自行车的数量</li><li>M条边</li></ul></li><li><p>输出</p><ul><li>PBMC要送多少辆自行车</li><li>路径</li><li>要送多少辆自行车到PBMC</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="https://www.cnblogs.com/chouxianyu/p/13692483.html" target="_blank" rel="noopener">PAT甲级1030Travel Plan</a>和这题很类似，但比这题简单，大概是比这题少了一个DFS。</p><ul><li><p>dijkstra</p><p>  除了要求出PBMC到所有结点的最短路径长度，还要在算法过程中记录所有最短路径上每个结点的前一个结点，进而进行下一步的DFS。</p></li><li><p>DFS</p><p>  运行dijkstra算法后，已经记录了所有最短路径上每个结点的前一个结点（可以有多个），然后从结点sp开始DFS，相当于从sp走到PBMC。</p><p>  DFS过程中要记录当前路径</p></li><li><p>求路径上多余或缺少的自行车的数量</p><p>  DFS过程中，如果当前结点是PBMC，则从PBMC走到sp，求多余或缺少的自行车的数量，再和全局最小值比较、更新</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1018</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024</span></span><br><span class="line"><span class="comment">// Tags: 最短路 dijkstra BFS DFS 单源最短路 图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> cmax, n, sp, m;</span><br><span class="line"><span class="keyword">int</span> minStationNeed = INF, minStationExtra = INF; <span class="comment">// PBMC最少需要送出多少辆车，最少要送多少辆车到PBMC</span></span><br><span class="line"><span class="keyword">int</span> e[MAXN][MAXN]; <span class="comment">// 车站间的距离</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN]; <span class="comment">// PBMC到各车站的最短路径的长度</span></span><br><span class="line"><span class="keyword">int</span> extraBikeNum[MAXN]; <span class="comment">// 各车站中有多少辆自行车是多余的</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXN]; <span class="comment">// 是否已求出PBMC到各车站的最短路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXN]; <span class="comment">// 在保证路径最短的前提下，最短路径中每个车站的前一个车站</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempPath;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历当前结点</span></span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>)&#123; <span class="comment">// 此时已形成一条最短路径的逆序，存储在tempPath中</span></span><br><span class="line">        <span class="keyword">int</span> stationNeed = <span class="number">0</span>, stationExtra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tempPath.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = tempPath[i];</span><br><span class="line">            <span class="keyword">if</span> (extraBikeNum[u] &gt; <span class="number">0</span>)&#123; <span class="comment">// 当前站点中自行车数量超过容量的一半，则可以送给后面的车站或者送回PBMC</span></span><br><span class="line">                stationExtra += extraBikeNum[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (extraBikeNum[u] &lt; <span class="number">0</span>)&#123; <span class="comment">// 当前站点中自行车数量少于容量的一半</span></span><br><span class="line">                <span class="keyword">if</span> (stationExtra + extraBikeNum[u] &gt;= <span class="number">0</span>)&#123; <span class="comment">// 前边车站多出来的自行车足够使当前车站半满</span></span><br><span class="line">                    stationExtra += extraBikeNum[u];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    stationNeed -= (stationExtra + extraBikeNum[u]);</span><br><span class="line">                    stationExtra = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stationNeed &lt; minStationNeed)&#123;</span><br><span class="line">            path = tempPath;</span><br><span class="line">            minStationNeed = stationNeed;</span><br><span class="line">            minStationExtra = stationExtra;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stationNeed == minStationNeed &amp;&amp; stationExtra &lt; minStationExtra)&#123;</span><br><span class="line">            path = tempPath;</span><br><span class="line">            minStationExtra = stationExtra;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; pre[v].size(); i++)</span><br><span class="line">        dfs(pre[v][i]);</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    fill(e[<span class="number">0</span>], e[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(dis, dis + MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;cmax, &amp;n, &amp;sp, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;extraBikeNum[i]);</span><br><span class="line">        extraBikeNum[i] = extraBikeNum[i] - cmax / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        e[a][b] = e[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// PBMC为起点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minDis = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; minDis)&#123;</span><br><span class="line">                minDis = dis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; e[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[u] + e[u][v] &lt; dis[v])&#123;</span><br><span class="line">                    dis[v] = dis[u] + e[u][v];</span><br><span class="line">                    pre[v].clear(); <span class="comment">// 新的最短路径，所以要clear</span></span><br><span class="line">                    pre[v].push_back(u); <span class="comment">// u是v的最短路径中v的前一个车站</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dis[u] + e[u][v] == dis[v])&#123;</span><br><span class="line">                    pre[v].push_back(u); <span class="comment">// u是v的最短路径中v的前一个车站</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(sp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d 0"</span>, minStationNeed);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%d"</span>, path[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, minStationExtra);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52316405" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52316405</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1003Emergency</title>
    <link href="https://chouxianyu.github.io/2020/09/17/PAT%E7%94%B2%E7%BA%A71003Emergency/"/>
    <id>https://chouxianyu.github.io/2020/09/17/PAT甲级1003Emergency/</id>
    <published>2020-09-17T09:36:18.000Z</published>
    <updated>2020-09-20T10:27:05.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>有几个城市，每个城市中有多个救援队，城市间由公路相连，公路的长度不一</p></li><li><p>输入</p><ul><li><p>N：正整数，不超过500，城市的数量，城市索引为[0,N-1]</p></li><li><p>M：公路的数量</p></li><li><p>c1：你现在所在的城市</p></li><li><p>c2：你需要去的城市</p></li><li><p>各城市中救援队数量：N个整数</p></li><li><p>各条公路连接的两个城市其该公路的长度：M行</p><p>  保证c1到c2至少有一条路径</p></li></ul></li><li><p>输出</p><ul><li>c1到c2的最短路径的数量</li><li>在保证路径最短的前提下，最多可以聚集多少只救援队</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>dijkstra算法</p><ul><li><p>特点</p><ul><li>适用于边权为正的情况</li><li>单源最短路（Single-Source Shortest Paths，SSSP），求单个源点到所有结点的最短路</li><li>同时适用于有向图和无向图</li></ul></li><li><p>伪代码</p><p>  n个结点</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[n];  <span class="comment">// 标记：是否找到源点s到某点的最短路径</span></span><br><span class="line"><span class="keyword">int</span> dis[n]; <span class="comment">// 记录源点s到某点的最短路径的长度</span></span><br><span class="line"><span class="keyword">int</span> w[n][n]; <span class="comment">// 结点间的距离</span></span><br><span class="line"></span><br><span class="line">visited数组置<span class="literal">false</span>;</span><br><span class="line">dis数组置无穷大，dis[s]置<span class="number">0</span>;</span><br><span class="line">循环n次&#123;</span><br><span class="line">    寻找未被标记的、距离结点s最近的结点u;</span><br><span class="line">    如果找到u则将其标记(visited[u] = <span class="literal">true</span>),否则结束循环;</span><br><span class="line">    如果存在边&lt;u,v&gt;,则更新dis[v] = min(dis[v], dis[u] + w[u][v]); <span class="comment">// 贪心</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其它</p><ul><li><p>c1到c2的最短路径的数量<code>pathNum</code></p><ul><li><p>如果<code>dis[v] &lt; dis[u] + w[u][v]</code>，则<code>pathNum[v] = path[u]</code></p><p>  u到v只有一条边，所以源点到u和v的路径的数量相等</p></li><li><p>如果<code>dis[v] == dis[u] + w[u][v]</code>，则<code>pathNum[v] = path[u] + path[v]</code></p><p>  在距离相等的情况下，除了经过u，还可以从其他结点到达v</p></li></ul></li><li><p>在保证路径最短的前提下，<strong>最多</strong>可以聚集多少只救援队</p><ul><li><p>如果<code>dis[v] &lt; dis[u] + w[u][v]</code>，则<code>teamGatherNum[v] = teamGatherNum[u] + teamNum[v]</code></p></li><li><p>如果<code>dis[v] == dis[u] + w[u][v]</code>，则<code>teamGatherNum[v] = min(teamGatherNum[v], teamGatherNum[u] + teamNum[v])</code></p><p>  此时最短路径不止一条，所以要判断哪条路径聚集的救援队更多</p></li></ul></li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1003</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376</span></span><br><span class="line"><span class="comment">// Tags: 最短路 djikstra DFS 单源最短路 贪心</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN =  <span class="number">500</span>; <span class="comment">// 最多500个城市</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX; <span class="comment">// 最大距离</span></span><br><span class="line"><span class="keyword">int</span> cityDis[MAXN][MAXN]; <span class="comment">// 城市间的距离</span></span><br><span class="line"><span class="keyword">int</span> teamNum[MAXN]; <span class="comment">// 每个城市中有多少个救援队</span></span><br><span class="line"><span class="keyword">int</span> shortestPathDis[MAXN]; <span class="comment">// 起点城市c1到各个城市最短路径的距离</span></span><br><span class="line"><span class="keyword">int</span> shortestPathNum[MAXN]; <span class="comment">// 起点城市c1到各个城市最短路径的数量</span></span><br><span class="line"><span class="keyword">int</span> teamGatherNum[MAXN]; <span class="comment">// 从起点城市c1到各个城市的最短路径上，最多能聚集到多少个救援队</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];  <span class="comment">// 标记：是否已求出起点城市c1到某城市的最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化变量</span></span><br><span class="line">    fill(cityDis[<span class="number">0</span>], cityDis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(shortestPathDis, shortestPathDis + MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取输入</span></span><br><span class="line">    <span class="keyword">int</span> n, m, c1, c2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;c1, &amp;c2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;teamNum[i]);</span><br><span class="line">    <span class="keyword">int</span> a, b, d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;d);</span><br><span class="line">        cityDis[a][b] = cityDis[b][a] = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化起点城市c1</span></span><br><span class="line">    shortestPathDis[c1] = <span class="number">0</span>;</span><br><span class="line">    teamGatherNum[c1] = teamNum[c1];</span><br><span class="line">    shortestPathNum[c1] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代直至求出起点城市c1到所有城市的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 寻找未被标记的、距离起点城市c1最近的城市u（贪心）</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minDis = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; shortestPathDis[j] &lt; minDis)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minDis = shortestPathDis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 各城市都已被标记，则已求出结果，退出循环即可；否则根据贪心策略，现在已求出起点城市c1到城市u的最短距离</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果有边&lt;u,v&gt;，则更新城市v的相关变量（最简洁的dijkstra算法只更新shortestPathDis[v]即可）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; cityDis[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (shortestPathDis[v] &gt; shortestPathDis[u] + cityDis[u][v])&#123;</span><br><span class="line">                    shortestPathDis[v] = shortestPathDis[u] + cityDis[u][v];</span><br><span class="line">                    shortestPathNum[v] = shortestPathNum[u];</span><br><span class="line">                    teamGatherNum[v] = teamGatherNum[u] + teamNum[v];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (shortestPathDis[v] == shortestPathDis[u] + cityDis[u][v])&#123;</span><br><span class="line">                    shortestPathNum[v] = shortestPathNum[u] + shortestPathNum[v];</span><br><span class="line">                    <span class="keyword">if</span> (teamGatherNum[v] &lt; teamGatherNum[u] + teamNum[v])</span><br><span class="line">                        teamGatherNum[v] = teamGatherNum[u] + teamNum[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, shortestPathNum[c2], teamGatherNum[c2]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52300668" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52300668</a></p><p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">https://blog.csdn.net/qq_35644234/article/details/60870719</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="贪心" scheme="https://chouxianyu.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1146Topological Order</title>
    <link href="https://chouxianyu.github.io/2020/09/15/PAT%E7%94%B2%E7%BA%A71146Topological-Order/"/>
    <id>https://chouxianyu.github.io/2020/09/15/PAT甲级1146Topological-Order/</id>
    <published>2020-09-15T15:41:24.000Z</published>
    <updated>2020-09-15T15:44:37.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个有向图，请判断一个序列是否是该有向图的拓扑序列。</p><ul><li><p>输入</p><ul><li>N：正整数，不超过1000，图中顶点的数量，顶点索引为[1,N]</li><li>M：正整数，不超过10000，有向边的数量</li><li>M条有向边：开始顶点索引、结束顶点索引</li><li>K：不超过100，待检验的序列的个数</li><li>K个序列：索引为[0,K]</li></ul></li><li><p>输出</p><p>  对于每个排列，如果不是拓扑排序则输出其索引</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>保存每个结点的前驱结点</li><li>使用一维数组保存每个结点是否已访问</li><li>遍历序列判断每个结点的前驱结点是否已访问，如果未访问，则该序列不是拓扑序列</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1146</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760</span></span><br><span class="line"><span class="comment">// Tags: 拓扑序列 图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; before;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    before.resize(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        before[v2].push_back(v1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123; <span class="comment">// 判断k个序列</span></span><br><span class="line">        <span class="comment">// 保存一个序列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sequence[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断该序列是否是拓扑序列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">bool</span> isTopological = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            v2 = sequence[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = before[v2].begin(); iter != before[v2].end(); iter++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[*iter])&#123;</span><br><span class="line">                    isTopological = <span class="literal">false</span>;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isTopological)</span><br><span class="line">                visited[v2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">auto</span> iter = result.begin();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, *iter);</span><br><span class="line">    iter++;</span><br><span class="line">    <span class="keyword">while</span> (iter != result.end())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, *iter);</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="拓扑序列" scheme="https://chouxianyu.github.io/tags/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
</feed>
