<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2020-12-25T01:07:05.128Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>李宏毅机器学习课程笔记-2.5线性回归Python实战</title>
    <link href="https://chouxianyu.github.io/2020/12/25/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-5%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92Python%E5%AE%9E%E6%88%98/"/>
    <id>https://chouxianyu.github.io/2020/12/25/李宏毅机器学习课程笔记-2-5线性回归Python实战/</id>
    <published>2020-12-25T01:03:09.000Z</published>
    <updated>2020-12-25T01:07:05.128Z</updated>
    
    <content type="html"><![CDATA[<p>本文为作者学习李宏毅机器学习课程时参照样例完成homework1的记录。</p><ul><li><p>任务描述（Task Description）</p><p>  现在有某地空气质量的观测数据，请使用线性回归拟合数据，预测PM2.5。</p></li><li><p>数据集描述（Dataset Description）</p><ul><li><p>train.csv</p><p>  该文件中是2014年每月前20天每小时的观察数据，每小时的数据是18个维度的（其中之一是PM2.5）。</p></li><li><p>test.csv</p><p>  该文件中包含240组数据，每组数据是连续9个小时的所有观测数据（同样是18个维度）。</p><p>  请预测每组数据对应的第10个小时的PM2.5数值。</p></li></ul></li><li><p>结果格式</p><p>  要求上交结果的格式为CSV文件。</p><p>  第一行必须是<code>id,value</code>。</p><p>  从第二行开始每行分别为id值及预测的PM2.5数值，两者用逗号间隔</p></li><li><p>总结</p><ul><li>数据处理<ul><li>将数据处理、转换成什么形式，要根据数据集格式、任务来确定。</li><li>要熟练掌握pandas、numpy等数据处理工具，特别是要知道它们能实现什么功能。</li></ul></li></ul></li><li><p>参考链接</p><p>  <a href="https://colab.research.google.com/drive/131sSqmrmWXfjFZ3jWSELl8cm0Ox5ah3C" target="_blank" rel="noopener">https://colab.research.google.com/drive/131sSqmrmWXfjFZ3jWSELl8cm0Ox5ah3C</a></p></li><li><p>Python代码</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment">## 读取数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'./train.csv'</span>, encoding = <span class="string">'big5'</span>) <span class="comment"># 读取训练集</span></span><br><span class="line"><span class="comment"># print(data.describe())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 数据预处理</span></span><br><span class="line">data = data.iloc[:, <span class="number">3</span>:] <span class="comment"># 不需要使用前三列的表头，所以删除</span></span><br><span class="line">data[data == <span class="string">'NR'</span>] = <span class="number">0</span> <span class="comment"># 将非数值NR改为0</span></span><br><span class="line">raw_data = data.to_numpy() <span class="comment"># pandas转numpy数组，形状是4320(=18*20*12)*24</span></span><br><span class="line"><span class="comment"># print(raw_data.shape)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改数据格式</span></span><br><span class="line"><span class="comment"># 数据格式为12(month)*18(features)*480(=24*20hours)，即12个月、每个月有480小时的数据（18维）</span></span><br><span class="line">month_data = &#123;&#125; <span class="comment"># 字典</span></span><br><span class="line"><span class="keyword">for</span> month <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    sample = np.empty([<span class="number">18</span>, <span class="number">480</span>])</span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        sample[ : , <span class="number">24</span> * day : <span class="number">24</span> * (day + <span class="number">1</span>)] = raw_data[(month * <span class="number">20</span> + day) * <span class="number">18</span> : (month * <span class="number">20</span> + day + <span class="number">1</span>) * <span class="number">18</span>, : ]</span><br><span class="line">    month_data[month] = sample</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改数据格式</span></span><br><span class="line"><span class="comment"># 数据格式为每个月有连续的480个小时，每10个小时形成1个object，每个月就有471个object，12个月就有471*12个oeject，每个object包括x(18*9的featrues)和y(1个PM2.5数值)。</span></span><br><span class="line">x = np.empty([<span class="number">471</span>*<span class="number">12</span>, <span class="number">18</span>*<span class="number">9</span>], dtype=float) <span class="comment"># 471*12行，一行是一个object的x</span></span><br><span class="line">y = np.empty([<span class="number">471</span>*<span class="number">12</span>, <span class="number">1</span>], dtype=float) <span class="comment"># 471*12行，一行是一个object的y</span></span><br><span class="line"><span class="keyword">for</span> month <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        <span class="keyword">for</span> hour <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">            <span class="keyword">if</span> day == <span class="number">19</span> <span class="keyword">and</span> hour &gt; <span class="number">14</span>: <span class="comment"># 最后一个10小时从第20天14小时开始，防止越界</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            x[month * <span class="number">471</span> + day * <span class="number">24</span> + hour, :] = month_data[month][:,day * <span class="number">24</span> + hour : day * <span class="number">24</span> + hour + <span class="number">9</span>].reshape(<span class="number">1</span>, <span class="number">-1</span>) <span class="comment"># reshape时的(1, -1)指：1行、列数自动计算</span></span><br><span class="line">            y[month * <span class="number">471</span> + day * <span class="number">24</span> + hour, <span class="number">0</span>] = month_data[month][<span class="number">9</span>, day * <span class="number">24</span> + hour + <span class="number">9</span>] <span class="comment"># 取对应的第10个小时的PM2.5的值</span></span><br><span class="line"><span class="comment"># print(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 标准化</span></span><br><span class="line"><span class="comment">#关于标准化，可以看这篇文章https://www.cnblogs.com/chouxianyu/p/13872444.html</span></span><br><span class="line">mean_x = np.mean(x, axis=<span class="number">0</span>) <span class="comment"># 平均值，axis=0指沿着列计算平均值，即计算每列的平均值</span></span><br><span class="line">std_x = np.std(x, axis=<span class="number">0</span>) <span class="comment"># 标准差，axis=0指沿着列计算平均值，即计算每列的标准差</span></span><br><span class="line"><span class="comment"># print(mean_x.shape, std_x.shape)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(x[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">if</span> std_x[j] != <span class="number">0</span>:</span><br><span class="line">            x[i][j] = (x[i][j] - mean_x[j]) / std_x[j]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 训练</span></span><br><span class="line">dim = <span class="number">18</span> * <span class="number">9</span> + <span class="number">1</span> <span class="comment"># 这个+1是为了保存偏置</span></span><br><span class="line">w = np.zeros([dim, <span class="number">1</span>])</span><br><span class="line">x = np.concatenate((np.ones([<span class="number">471</span> * <span class="number">12</span>, <span class="number">1</span>]), x), axis=<span class="number">1</span>).astype(float) <span class="comment"># axis=1表示将两个数组按行拼接，向x中添加1是为了让其与weight中的偏置相乘</span></span><br><span class="line">learning_rate = <span class="number">100</span> <span class="comment"># 学习率</span></span><br><span class="line">iter_time = <span class="number">1000</span> <span class="comment"># 迭代次数</span></span><br><span class="line">adagrad = np.zeros([dim, <span class="number">1</span>])</span><br><span class="line">eps = <span class="number">1e-10</span>  <span class="comment"># eps是避免Adagrad分母为0而加的</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> range(iter_time):</span><br><span class="line">    loss = np.sqrt(np.sum(np.power(np.dot(x, w) - y, <span class="number">2</span>)) / <span class="number">471</span> / <span class="number">12</span>) <span class="comment"># RMSE</span></span><br><span class="line">    <span class="keyword">if</span> (t % <span class="number">100</span> == <span class="number">0</span>):</span><br><span class="line">        print(t, loss)</span><br><span class="line">    gradient = <span class="number">2</span> * np.dot(x.transpose(), np.dot(x, w) - y) <span class="comment"># dim*1</span></span><br><span class="line">    adagrad += gradient ** <span class="number">2</span></span><br><span class="line">    w -= learning_rate * gradient / np.sqrt(adagrad + eps)</span><br><span class="line">np.save(<span class="string">'weight.npy'</span>, w)</span><br><span class="line">print(<span class="string">'Training Done'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 测试</span></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">test_data = pd.read_csv(<span class="string">'./test.csv'</span>,header=<span class="keyword">None</span>, encoding=<span class="string">'big5'</span>)</span><br><span class="line">test_data = test_data.iloc[ : , <span class="number">2</span>:] <span class="comment"># 去除表头（前两列）</span></span><br><span class="line">test_data[test_data == <span class="string">'NR'</span>] = <span class="number">0</span></span><br><span class="line">test_data = test_data.to_numpy()</span><br><span class="line">test_x = np.empty([<span class="number">240</span>, <span class="number">18</span> * <span class="number">9</span>]) <span class="comment"># 240个object，一行是一个object的x</span></span><br><span class="line"><span class="comment"># 修改数据格式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">240</span>):</span><br><span class="line">    test_x[i, :] = test_data[i * <span class="number">18</span> : (i + <span class="number">1</span>) * <span class="number">18</span>, : ].reshape(<span class="number">1</span>, <span class="number">-1</span>) <span class="comment"># 格式和训练集一样</span></span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(test_x)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(test_x[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">if</span> std_x[j] != <span class="number">0</span>:</span><br><span class="line">            test_x[i, j] = (test_x[i, j] - mean_x[j]) / std_x[j]</span><br><span class="line">test_x = np.concatenate((np.ones([<span class="number">240</span>, <span class="number">1</span>]), test_x), axis=<span class="number">1</span>).astype(float) <span class="comment"># axis=1表示将两个数组按行拼接，向x中添加1是为了让其与weight中的偏置相乘</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 预测</span></span><br><span class="line">w = np.load(<span class="string">'weight.npy'</span>)</span><br><span class="line">ans_y = np.dot(test_x, w)</span><br><span class="line"><span class="comment"># print('ans_y.shape', ans_y.shape)</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'answer.csv'</span>, mode=<span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> answer_file:</span><br><span class="line">    csv_writer = csv.writer(answer_file)</span><br><span class="line">    csv_writer.writerow([<span class="string">'id'</span>, <span class="string">'value'</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">240</span>):</span><br><span class="line">        row = [<span class="string">'id_'</span> + str(i), ans_y[i][<span class="number">0</span>]]</span><br><span class="line">        csv_writer.writerow(row)</span><br><span class="line">        <span class="comment"># print(row)</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>Github（github.com）：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@chouxianyu</a></p><p>Github Pages（github.io）：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>知乎（zhihu.com）：<a href="https://www.zhihu.com/people/chouxianyu0" target="_blank" rel="noopener">@臭咸鱼</a></p><p>博客园（cnblogs.com）：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">@臭咸鱼</a></p><p>B站（bilibili.com）：<a href="https://space.bilibili.com/346368054" target="_blank" rel="noopener">@绝版臭咸鱼</a></p><p>微信公众号：<a href="">@臭咸鱼的快乐生活</a></p><p>转载请注明出处，欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文为作者学习李宏毅机器学习课程时参照样例完成homework1的记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;任务描述（Task Description）&lt;/p&gt;
&lt;p&gt;  现在有某地空气质量的观测数据，请使用线性回归拟合数据，预测PM2.5。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
      <category term="机器学习" scheme="https://chouxianyu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归" scheme="https://chouxianyu.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
      <category term="adgrad" scheme="https://chouxianyu.github.io/tags/adgrad/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅机器学习课程笔记-2.4交叉验证</title>
    <link href="https://chouxianyu.github.io/2020/12/24/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-4%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/"/>
    <id>https://chouxianyu.github.io/2020/12/24/李宏毅机器学习课程笔记-2-4交叉验证/</id>
    <published>2020-12-24T11:10:34.000Z</published>
    <updated>2020-12-24T11:34:54.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交叉验证（Cross-Validation）"><a href="#交叉验证（Cross-Validation）" class="headerlink" title="交叉验证（Cross Validation）"></a>交叉验证（Cross Validation）</h1><p>在机器学习中，通常不能将全部数据用于模型训练，否则将没有数据集可以用来评估模型。</p><h2 id="The-Validation-Set-Approach"><a href="#The-Validation-Set-Approach" class="headerlink" title="The Validation Set Approach"></a>The Validation Set Approach</h2><ul><li><p>定义</p><p>  将数据集划分成训练集（Training Set）和测试集（Test Set）两部分。</p></li><li><p>缺点</p><p>  这种方法的缺点是依赖于训练集和测试集的划分方法，并且只用了部分数据进行模型的训练。</p></li></ul><h2 id="LOOCV（Leave-One-Out-Cross-Validation）"><a href="#LOOCV（Leave-One-Out-Cross-Validation）" class="headerlink" title="LOOCV（Leave One Out Cross Validation）"></a>LOOCV（Leave One Out Cross Validation）</h2><ul><li><p>定义</p><p>  假设数据集中有N个数据，取其中1个数据作为测试集，将剩下的N-1个数据作为训练集，这样重复N次就得到N个模型以及N个误差值，最终使用这N个误差值的平均值评估该模型。</p></li><li><p>优点</p><p>  该方法不受训练集和测试集划分方法的影响，因为每个数据都单独做过测试集；同时该方法用了N-1个数据训练模型，也几乎用到了所有的数据，保证了模型的Bias更小。</p></li><li><p>缺点</p><p>  该方法的缺点是计算量过大，是The Validation Set Approach耗时的N-1倍。</p></li></ul><h2 id="K折交叉验证（K-fold-Cross-Validation）"><a href="#K折交叉验证（K-fold-Cross-Validation）" class="headerlink" title="K折交叉验证（K-fold Cross Validation）"></a>K折交叉验证（K-fold Cross Validation）</h2><ul><li><p>定义</p><p>  该方法是LOOCV的折中，即将数据集分成K份。</p></li><li><p>如何选取K的值</p><p>  K的选取是一个Bias和Variance的trade-off。一般选择K=5或10。</p><p>  K越大，每次训练时训练集的数据量就越大，则Bias越小；但每次训练时的训练集之间的相关性越大（考虑最极端的情况K=N，也就是LOOCV，每次训练使用的数据几乎是一样的），这种大相关性会导致最终的误差具有更大的Variance。</p></li></ul><hr><p>Github（github.com）：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@chouxianyu</a></p><p>Github Pages（github.io）：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>知乎（zhihu.com）：<a href="https://www.zhihu.com/people/chouxianyu0" target="_blank" rel="noopener">@臭咸鱼</a></p><p>博客园（cnblogs.com）：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">@臭咸鱼</a></p><p>B站（bilibili.com）：<a href="https://space.bilibili.com/346368054" target="_blank" rel="noopener">@绝版臭咸鱼</a></p><p>微信公众号：<a href="">@臭咸鱼的快乐生活</a></p><p>转载请注明出处，欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;交叉验证（Cross-Validation）&quot;&gt;&lt;a href=&quot;#交叉验证（Cross-Validation）&quot; class=&quot;headerlink&quot; title=&quot;交叉验证（Cross Validation）&quot;&gt;&lt;/a&gt;交叉验证（Cross Validatio
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://chouxianyu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="交叉验证" scheme="https://chouxianyu.github.io/tags/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅机器学习课程笔记-2.3欠拟合与过拟合</title>
    <link href="https://chouxianyu.github.io/2020/12/24/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-3%E6%AC%A0%E6%8B%9F%E5%90%88%E4%B8%8E%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    <id>https://chouxianyu.github.io/2020/12/24/李宏毅机器学习课程笔记-2-3欠拟合与过拟合/</id>
    <published>2020-12-24T11:10:08.000Z</published>
    <updated>2020-12-24T11:16:33.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欠拟合（Underfitting）"><a href="#欠拟合（Underfitting）" class="headerlink" title="欠拟合（Underfitting）"></a>欠拟合（Underfitting）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Bias较大、Variance较小。</p><p>如果模型在训练集上的误差很大，则此时Bias是大的，情况为欠拟合。</p><h2 id="Bias大时如何处理"><a href="#Bias大时如何处理" class="headerlink" title="Bias大时如何处理"></a>Bias大时如何处理</h2><p>使用更复杂的模型，比如添加考虑更多维度的输入、把线性模型换成非线性模型。</p><h1 id="过拟合（Overfitting）"><a href="#过拟合（Overfitting）" class="headerlink" title="过拟合（Overfitting）"></a>过拟合（Overfitting）</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Bias较小、Variance较大。</p><p>如果模型在训练集上的误差很小，但是在测试集上的误差很大，则此时Variance是大的，情况为过拟合。</p><h2 id="Variance大时如何处理"><a href="#Variance大时如何处理" class="headerlink" title="Variance大时如何处理"></a>Variance大时如何处理</h2><ul><li><p>使用更复杂的数据集</p><p>  比如添加数据（很有效，但不一定做得到）、数据增强等方法。</p></li><li><p>使用更简单的模型（不是根本方法）</p><p>  可能是模型过于复杂导致了过拟合，因此可以简化模型缓解过拟合。</p></li><li><p>正则化（Regularization）</p><p>  正则化可能会使Bias增大，所以需要调整正则化的参数。</p><p>  如$L_{new}=L_{old}+\lambda \sum(w_i)^2$，其中$\lambda$是一个常数。</p><p>  加上正则项$\lambda \sum(w_i)^2$的目的是让函数参数的值尽可能地接近0，使函数变得更平滑。</p></li></ul><h1 id="平滑（Smooth）"><a href="#平滑（Smooth）" class="headerlink" title="平滑（Smooth）"></a>平滑（Smooth）</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>平滑是指输入变化影响输出变化的程度（输出对输入的敏感程度）。</p><p>假设输入变化，如果函数越不平滑，则输出变化程度越大。</p><p>函数参数越接近0，这个函数就越平滑（smooth）。 </p><h2 id="我们为什么喜欢一个平滑的函数？"><a href="#我们为什么喜欢一个平滑的函数？" class="headerlink" title="我们为什么喜欢一个平滑的函数？"></a>我们为什么喜欢一个平滑的函数？</h2><p>适度平滑的函数可以缓解函数输入中包含的噪声对函数输出的影响。</p><p>如果输入中包含一些噪声/干扰（noise），那平滑函数的输出受输入中包含的噪声干扰的程度更小。</p><h2 id="我们为什么不喜欢过于平滑的函数？"><a href="#我们为什么不喜欢过于平滑的函数？" class="headerlink" title="我们为什么不喜欢过于平滑的函数？"></a>我们为什么不喜欢过于平滑的函数？</h2><p>函数过于平滑，就无法有效地提取数据的特征，这不是我们想要的函数。</p><p>假设有一个极限平滑的函数，即该函数的输出不受输入的影响，那当然不是个好的函数。</p><hr><p>Github（github.com）：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@chouxianyu</a></p><p>Github Pages（github.io）：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>知乎（zhihu.com）：<a href="https://www.zhihu.com/people/chouxianyu0" target="_blank" rel="noopener">@臭咸鱼</a></p><p>博客园（cnblogs.com）：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">@臭咸鱼</a></p><p>B站（bilibili.com）：<a href="https://space.bilibili.com/346368054" target="_blank" rel="noopener">@绝版臭咸鱼</a></p><p>微信公众号：<a href="">@臭咸鱼的快乐生活</a></p><p>转载请注明出处，欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;欠拟合（Underfitting）&quot;&gt;&lt;a href=&quot;#欠拟合（Underfitting）&quot; class=&quot;headerlink&quot; title=&quot;欠拟合（Underfitting）&quot;&gt;&lt;/a&gt;欠拟合（Underfitting）&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://chouxianyu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Bias" scheme="https://chouxianyu.github.io/tags/Bias/"/>
    
      <category term="Variance" scheme="https://chouxianyu.github.io/tags/Variance/"/>
    
      <category term="欠拟合" scheme="https://chouxianyu.github.io/tags/%E6%AC%A0%E6%8B%9F%E5%90%88/"/>
    
      <category term="过拟合" scheme="https://chouxianyu.github.io/tags/%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    
      <category term="正则化" scheme="https://chouxianyu.github.io/tags/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅机器学习课程笔记-2.2如何选择模型、减小误差</title>
    <link href="https://chouxianyu.github.io/2020/12/24/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-2%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%A8%A1%E5%9E%8B%E3%80%81%E5%87%8F%E5%B0%8F%E8%AF%AF%E5%B7%AE/"/>
    <id>https://chouxianyu.github.io/2020/12/24/李宏毅机器学习课程笔记-2-2如何选择模型、减小误差/</id>
    <published>2020-12-24T11:09:41.000Z</published>
    <updated>2020-12-24T11:40:32.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型选择（How-to-select-model）"><a href="#模型选择（How-to-select-model）" class="headerlink" title="模型选择（How to select model）"></a>模型选择（How to select model）</h1><ul><li><p>模型越复杂，一般其在训练集上的误差（Error）越小。</p><p>  因为更复杂的模型（函数集）包含了更多的函数。比如二次模型包含了线性（一次）模型。</p></li><li><p>模型越复杂，其在测试集上的误差（Error）不一定越小。</p><p>  因为模型过于复杂时，越容易被数据影响，可能导致过拟合。</p></li></ul><h1 id="误差（Error）"><a href="#误差（Error）" class="headerlink" title="误差（Error）"></a>误差（Error）</h1><h2 id="误差的来源"><a href="#误差的来源" class="headerlink" title="误差的来源"></a>误差的来源</h2><p>暂时称通过机器学习得到的函数为人工函数，它其实是对“上帝函数”的估计（Estimator），和“上帝函数”之间是有误差的。</p><p>误差来源于两方面：一是Bias，二是Variance，需要权衡（trade-off）两者以使总误差最小。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_201101071519VarianceAndBias.png" alt="VarianceAndBias" style="zoom: 50%;"></p><p>如上图所示，Bias是指人工函数（的期望）和上帝函数之间的距离，Variance是指人工函数的离散程度（或者说是不稳定程度）。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_201101071542BiasVSVariance.png" alt="BiasVSVariance" style="zoom:50%;"></p><p>如上图所示，横轴是模型的复杂程度（1次幂、2次幂、……），纵轴是误差大小。模型越复杂，Bias越小，Variance越大。</p><h2 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>使用相同模型在不同数据上拟合得到的函数是不同的，这些函数之间的离散程度就是Variance。</p><p>以射箭为例，Variance衡量的就是射得稳不稳。</p><h3 id="模型越复杂，Variance越大。"><a href="#模型越复杂，Variance越大。" class="headerlink" title="模型越复杂，Variance越大。"></a>模型越复杂，Variance越大。</h3><p>因为模型越简单，越不容易被数据影响（对数据不敏感，感知数据变化的能力较差），那Variance就越小。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_201101071610Variance.png" alt="Variance" style="zoom:50%;"></p><h2 id="Bias"><a href="#Bias" class="headerlink" title="Bias"></a>Bias</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>使用相同模型在不同数据上拟合得到的函数是不同的，取这些函数的“期望”，该期望与“真理”的差距就是Bias。</p><p>以射箭为例，Bias衡量的就是射得准不准（这里的“准”的含义有待商榷）。</p><h3 id="模型越简单，Bias越大。"><a href="#模型越简单，Bias越大。" class="headerlink" title="模型越简单，Bias越大。"></a>模型越简单，Bias越大。</h3><p>因为模型就是个函数集（Function Set）。模型越简单，则其包含的函数就越少、包含“上帝函数”的几率就越小，甚至可能不包括上帝函数。</p><p>在函数集很小的情况下，即使是其中最好的函数，它与“上帝函数”的差距也还是很大的。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_201101071635Bias.png" alt="Bias" style="zoom:50%;"></p><hr><p>Github（github.com）：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@chouxianyu</a></p><p>Github Pages（github.io）：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>知乎（zhihu.com）：<a href="https://www.zhihu.com/people/chouxianyu0" target="_blank" rel="noopener">@臭咸鱼</a></p><p>博客园（cnblogs.com）：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">@臭咸鱼</a></p><p>B站（bilibili.com）：<a href="https://space.bilibili.com/346368054" target="_blank" rel="noopener">@绝版臭咸鱼</a></p><p>微信公众号：<a href="">@臭咸鱼的快乐生活</a></p><p>转载请注明出处，欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模型选择（How-to-select-model）&quot;&gt;&lt;a href=&quot;#模型选择（How-to-select-model）&quot; class=&quot;headerlink&quot; title=&quot;模型选择（How to select model）&quot;&gt;&lt;/a&gt;模型选择（How to
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://chouxianyu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Bias" scheme="https://chouxianyu.github.io/tags/Bias/"/>
    
      <category term="Variance" scheme="https://chouxianyu.github.io/tags/Variance/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅机器学习课程笔记-2.1线性回归模型</title>
    <link href="https://chouxianyu.github.io/2020/12/24/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-2-1%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/"/>
    <id>https://chouxianyu.github.io/2020/12/24/李宏毅机器学习课程笔记-2-1线性回归模型/</id>
    <published>2020-12-24T11:09:06.000Z</published>
    <updated>2020-12-24T11:54:21.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回归模型应用案例（Regression-Cases）"><a href="#回归模型应用案例（Regression-Cases）" class="headerlink" title="回归模型应用案例（Regression Cases）"></a>回归模型应用案例（Regression Cases）</h1><ul><li><p>股票市场预测（Stock Market Forecast）</p><p>  预测某个公司明天的股票情况</p></li><li><p>自动驾驶车（Self-Driving Car）</p><p>  预测方向盘转动角度</p></li><li><p>推荐系统（Recommendation）</p><p>  预测某用户购买某商品的可能性</p></li></ul><h1 id="线性回归模型（Linear-Regression-Model）"><a href="#线性回归模型（Linear-Regression-Model）" class="headerlink" title="线性回归模型（Linear Regression Model）"></a>线性回归模型（Linear Regression Model）</h1><p>如$y=f(x)=w\cdot x+b$</p><ul><li><p>$y$是输出；</p><p>  $\hat y$是真实值/标签（label）</p></li><li><p>$w$是权重（weight）；</p></li><li><p>$b$是偏置（bias）；</p></li><li><p>$x$是输入（input），也可叫做特征（feature）</p><p>  数据集中一般包含多个object，每个object一般包含多个component。此时，上标是object的索引，下标是component的索引。</p></li><li><p>损失函数（Loss Function）</p><p>  如果不考虑模型的好坏，衡量一个函数的好坏，其实是衡量模型参数的好坏。</p><p>  以线性模型为例，就是衡量参数$w$和$b$的好坏。如$L(f)=L(w,b)=\sum_{n=1}^{10}(\hat y-(b+w\cdot x^n))^2$，把所有样本误差的平方和作为损失函数</p><ul><li><p>输入</p><p>  一个函数</p></li><li><p>输出</p><p>  多么地不好（how bad it is）。损失函数值越大，则这个函数越差、与数据集中内容越不相符。</p></li></ul></li></ul><h1 id="梯度下降（Gradient-Descent）"><a href="#梯度下降（Gradient-Descent）" class="headerlink" title="梯度下降（Gradient Descent）"></a>梯度下降（Gradient Descent）</h1><p>梯度下降可以优化损失函数的值，使其尽量小，即可找到最好（在数据集上拟合效果最好）的模型参数。</p><p>现在假设模型$f$中只有一个参数$w$，则损失函数为$L(f)=L(w)$，梯度下降算法如下（若模型有多个参数，按相同方法更新各参数）</p><ol><li><p>初始化参数</p><p> 随机选取一个$w^0$（$w^0$并不一定是随机选取），令$w=w^0$。</p></li><li><p>计算梯度</p><p> $\frac{dL(f)}{dw}|_{w=w^0}$</p><p> 如果小于0，此时$w$增大则$L(f)$会减小；如果大于0，此时$w$减小则$L(w)$会减小。</p><p> 如果模型有多个参数，则计算损失函数在各个参数方向上的偏导数。</p></li><li><p>更新模型参数</p><p> $w^1=w^0-lr\frac{dL(f)}{dw}|_{w=w^0}$</p><p> $w$的变化量取决于梯度和学习率（Learning Rate）的大小：梯度绝对值或学习率越大，则$w$变化量越大。</p><p> 如果模型有多个参数，则用上一步计算出的偏导数对应更新各参数。</p></li><li><p>重复第2步和第3步</p><p> 经过多次参数更新/迭代（iteration），可以使损失函数的值达到局部最小（即局部最优，Local Optimal），但不一定是全局最优。</p></li></ol><hr><p>Github（github.com）：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@chouxianyu</a></p><p>Github Pages（github.io）：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>知乎（zhihu.com）：<a href="https://www.zhihu.com/people/chouxianyu0" target="_blank" rel="noopener">@臭咸鱼</a></p><p>博客园（cnblogs.com）：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">@臭咸鱼</a></p><p>B站（bilibili.com）：<a href="https://space.bilibili.com/346368054" target="_blank" rel="noopener">@绝版臭咸鱼</a></p><p>微信公众号：<a href="">@臭咸鱼的快乐生活</a></p><p>转载请注明出处，欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回归模型应用案例（Regression-Cases）&quot;&gt;&lt;a href=&quot;#回归模型应用案例（Regression-Cases）&quot; class=&quot;headerlink&quot; title=&quot;回归模型应用案例（Regression Cases）&quot;&gt;&lt;/a&gt;回归模型应用案例
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://chouxianyu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归，梯度下降" scheme="https://chouxianyu.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%EF%BC%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>李宏毅机器学习课程笔记-1.机器学习概论</title>
    <link href="https://chouxianyu.github.io/2020/12/22/%E6%9D%8E%E5%AE%8F%E6%AF%85%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-1-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/"/>
    <id>https://chouxianyu.github.io/2020/12/22/李宏毅机器学习课程笔记-1-机器学习概论/</id>
    <published>2020-12-22T02:06:27.000Z</published>
    <updated>2020-12-22T03:13:10.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习是什么"><a href="#机器学习是什么" class="headerlink" title="机器学习是什么"></a>机器学习是什么</h1><p><strong>机器学习就是让机器能自动找到一个函数（function）</strong></p><ul><li><p>语音识别（Speech Recognition）</p><p>  输入是音频，输出是音频对应的文字。</p></li><li><p>图像分类</p><p>  输入是图片，输出是类别（比如猫、狗）。</p></li><li><p>AlphaGo下围棋</p><p>  输入是当前棋盘的状态，输出是下一步落棋的位置。</p></li><li><p>对话/问答系统</p></li></ul><h1 id="机器能够找到哪些函数？"><a href="#机器能够找到哪些函数？" class="headerlink" title="机器能够找到哪些函数？"></a>机器能够找到哪些函数？</h1><p>为解决不同的问题、完成不同的任务，需要找到不同的函数，那机器学习能找到哪些函数呢？</p><ul><li><p>回归（Regression）</p><p>  输出是一个连续的数值、标量，比如PM2.5预测。</p></li><li><p>分类（Classification）</p><p>  输出是一个离散的值。</p><p>  二分类（Binary Classification）的输出就是0或1、Yes或No、…，比如文本情感分析的输出可以是正面和负面。</p><p>  多分类（Multi-Category Classification）的输出就是[1,2,3,…,N]，比如图像分类里判断一张图片是猫还是狗还是杯子。</p></li><li><p>生成（Generation）</p><p>  很多教科书把机器学习划分为回归问题和分类问题，但其实不止这两种问题，还有其它问题，比如生成（Generation）。</p><p>  生成（Generation）指让机器学习如何创造/生成，比如生成文本、图片等。</p></li></ul><h1 id="如何告诉机器我们希望找到什么函数"><a href="#如何告诉机器我们希望找到什么函数" class="headerlink" title="如何告诉机器我们希望找到什么函数"></a>如何告诉机器我们希望找到什么函数</h1><p>我们该如何为机器提供学习资料？</p><ul><li><p>有监督学习（Supervised Learning）</p><p>  可以把有监督学习中的“监督”理解为“标签（Label）”，即数据集中不仅包括特征还包括标签。</p><p>  有了标签，我们就可以评价一个函数的好坏，进而优化这个函数。</p><p>  使用Loss判断函数的好坏，Loss越小，函数越好。<strong>个人想法：值得一提的是，Loss/评价指标是多样的、优化方法也是多样的。</strong></p></li><li><p>强化学习（Reinforcement Learning）</p><p>  原始的AlpahGo是先通过有监督学习优化到一定程度，然后用强化学习继续优化。</p><p>  新版本的AlphaGo是完全通过强化学习实现的，优于原始的AlphaGo。 </p></li><li><p>无监督学习（Unsupervised Learning）</p><p>  只给机器提供数据特征，但不提供数据标签。==那机器能学到什么呢？==</p></li></ul><p>下面以让机器学习下围棋为例：有监督学习VS强化学习。</p><ul><li><p>有监督学习</p><p>  函数的输入（数据特征）就是棋盘状态，函数的输出（数据标签）就是下一步落棋的位置。</p><p>  此时，我们需要为机器提供的数据就类似棋谱（如果现在棋局是这样，那下一步怎么落棋最好），<strong>但其实人类不一定知道怎么落棋最好</strong>。</p><p>  <strong>个人想法：理论上，通过这样的有监督学习，机器是无法超越人类的。因为这样的有监督学习的本质是人类把自己的下棋策略教给机器，机器学习的内容仅仅是人类的下棋策略而无法“自主进行思考”，所以理论上机器是无法超越人类的。同时要注意，这里的人类指全人类。</strong></p></li><li><p>强化学习</p><p>  让机器跟自己、别人下棋，把结果（赢或输）作为Reward，引导机器学习如何下棋。</p><p>  如果它赢了，那它就知道这一盘里有几步棋下得好，但不知道是哪几步；如果它输了，它就知道这一盘里有几步棋下得不好，但不知道是哪几步。</p><p>  <strong>个人想法：理论上，通过这样的强化学习，机器是可以超过人类的。因为两者的学习材料没有本质区别，但机器的机能却优于人类，这里讲的机能包括信息共享能力、记忆能力、执行能力等方面</strong></p></li></ul><h1 id="机器如何找出我们想找到的函数"><a href="#机器如何找出我们想找到的函数" class="headerlink" title="机器如何找出我们想找到的函数"></a>机器如何找出我们想找到的函数</h1><ul><li><p>我们要给定函数形式/范围（模型）</p><p>  比如假定函数是线性模型、神经网络等等。<strong>模型就是一个函数集，模型的参数确定以后，才得到一个函数。</strong></p></li><li><p>找到更好的函数：</p><p>  使用梯度下降（Gradient Descent），找到更好的函数。</p></li></ul><h1 id="前沿研究"><a href="#前沿研究" class="headerlink" title="前沿研究"></a>前沿研究</h1><ul><li><p>AI的可解释性（Explainable AI）</p><p>  比如，机器为什么认为这张图片里有一只猫？</p></li><li><p>对抗攻击（Adversarial Attack）</p><p>  对输入故意添加一些人无法察觉的细微的干扰，导致模型以高置信度给出一个错误的输出。</p></li><li><p>模型压缩（Network Compression）</p><p>  把模型压缩以减少模型对计算资源消耗。</p></li><li><p>异常检测（Anomaly Detection）</p><p>  使机器知道它遇到了自己不知道的东西。</p></li><li><p>迁移学习（Transfer Learning/Domain Adversarial Learning）</p><p>  一个模型已经学到了一些知识，将这些知识应用到另一个任务中。</p></li><li><p>元学习（Meta Learning）</p><p>  让机器学习如何学习。</p><p>  机器学习是我们教机器学习某种知识，元学习是我们教机器如何学习。</p></li><li><p>终身学习（Life-Long Learning）</p><p>  让机器终身学习，学习完任务1、再继续学任务2、……</p></li></ul><h1 id="机器学习的三个步骤"><a href="#机器学习的三个步骤" class="headerlink" title="机器学习的三个步骤"></a>机器学习的三个步骤</h1><ol><li>确定模型（Model）/函数集（Function Set）</li><li>确定如何评价函数的好坏</li><li>确定如何找到最好的函数</li></ol><hr><p>Github（github.com）：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@chouxianyu</a></p><p>Github Pages（github.io）：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>知乎（zhihu.com）：<a href="https://www.zhihu.com/people/chouxianyu0" target="_blank" rel="noopener">@臭咸鱼</a></p><p>博客园（cnblogs.com）：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">@臭咸鱼</a></p><p>B站（bilibili.com）：<a href="https://space.bilibili.com/346368054" target="_blank" rel="noopener">@绝版臭咸鱼</a></p><p>微信公众号：<a href="">@臭咸鱼的快乐生活</a></p><p>转载请注明出处，欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习是什么&quot;&gt;&lt;a href=&quot;#机器学习是什么&quot; class=&quot;headerlink&quot; title=&quot;机器学习是什么&quot;&gt;&lt;/a&gt;机器学习是什么&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;机器学习就是让机器能自动找到一个函数（function）&lt;/strong&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://chouxianyu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>浙江理工大学计算机科学与技术专业课程笔记、试题、课件等复习资料大礼包</title>
    <link href="https://chouxianyu.github.io/2020/11/26/%E6%B5%99%E6%B1%9F%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%E3%80%81%E8%AF%95%E9%A2%98%E3%80%81%E8%AF%BE%E4%BB%B6%E7%AD%89%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
    <id>https://chouxianyu.github.io/2020/11/26/浙江理工大学计算机科学与技术专业课程笔记、试题、课件等复习资料大礼包/</id>
    <published>2020-11-26T06:53:20.000Z</published>
    <updated>2020-12-12T02:24:38.609Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>模拟电路与数字电路</p><p>链接：<a href="https://pan.baidu.com/s/1KTUmyqRAG0ilQrBEB72eFQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1KTUmyqRAG0ilQrBEB72eFQ</a><br>提取码：5n4y<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p><p><strong>百度网盘不让分享，请尽快保存</strong></p></li><li><p>C++试题</p><p>  链接：<a href="https://pan.baidu.com/s/1QtMMzJxFOl6fsDHVzKIeyw" target="_blank" rel="noopener">https://pan.baidu.com/s/1QtMMzJxFOl6fsDHVzKIeyw</a><br>  提取码：os8k</p><p>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>C语言试题</p><p>  链接：<a href="https://pan.baidu.com/s/1OsE0BsLJ-kXGibNTg1GfgQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1OsE0BsLJ-kXGibNTg1GfgQ</a><br>  提取码：kaso<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>JAVA试题</p><p>  链接：<a href="https://pan.baidu.com/s/11EpvCdIeQokMbMDR2MdZCQ" target="_blank" rel="noopener">https://pan.baidu.com/s/11EpvCdIeQokMbMDR2MdZCQ</a><br>  提取码：knly<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>汇编语言（试题、笔记、实验、参考书）</p><p>  链接：<a href="https://pan.baidu.com/s/1OxCLyAbOB2Egp6jJLdN2kg" target="_blank" rel="noopener">https://pan.baidu.com/s/1OxCLyAbOB2Egp6jJLdN2kg</a><br>  提取码：44eg<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>概率论与数理统计</p><p>  链接：<a href="https://pan.baidu.com/s/1qgyFsn-2JHO0hwxK08uUQw" target="_blank" rel="noopener">https://pan.baidu.com/s/1qgyFsn-2JHO0hwxK08uUQw</a><br>  提取码：e0is<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>高等数学</p><p>  链接：<a href="https://pan.baidu.com/s/1n7sTD9tutaQTuca-eI1jKg" target="_blank" rel="noopener">https://pan.baidu.com/s/1n7sTD9tutaQTuca-eI1jKg</a><br>  提取码：95xp<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>离散数学</p><p>  链接：<a href="https://pan.baidu.com/s/1ltfwSqB5or90wRFQVOYncQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1ltfwSqB5or90wRFQVOYncQ</a><br>  提取码：yagu<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>线性代数</p><p>  链接：<a href="https://pan.baidu.com/s/19DgVokKrFj9aA2KMC7HVtw" target="_blank" rel="noopener">https://pan.baidu.com/s/19DgVokKrFj9aA2KMC7HVtw</a><br>  提取码：mac6<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>普通物理</p><p>  链接：<a href="https://pan.baidu.com/s/13OtioAw5SX1sA_fmO-n4Zw" target="_blank" rel="noopener">https://pan.baidu.com/s/13OtioAw5SX1sA_fmO-n4Zw</a><br>  提取码：gkwr<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>电子服务信任与信誉</p><p>  链接：<a href="https://pan.baidu.com/s/1WMWf8tz_QYySrZ7E5wq25w" target="_blank" rel="noopener">https://pan.baidu.com/s/1WMWf8tz_QYySrZ7E5wq25w</a><br>  提取码：zusz<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>编译原理</p><p>  链接：<a href="https://pan.baidu.com/s/1QNAigX7gtjNxVE5hdgysWg" target="_blank" rel="noopener">https://pan.baidu.com/s/1QNAigX7gtjNxVE5hdgysWg</a><br>  提取码：5n5g<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>操作系统</p><p>  链接：<a href="https://pan.baidu.com/s/1cHQ7yfFFmKLWSmhTp-FdrQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1cHQ7yfFFmKLWSmhTp-FdrQ</a><br>  提取码：qcjn<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>服务外包概论</p><p>  链接：<a href="https://pan.baidu.com/s/1ICG6Z6tiIa7ViL2JMdFYPQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1ICG6Z6tiIa7ViL2JMdFYPQ</a><br>  提取码：jaa2<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>软件工程</p><p>  链接：<a href="https://pan.baidu.com/s/1YoT2-vTHM_tX_UysTpwlHw" target="_blank" rel="noopener">https://pan.baidu.com/s/1YoT2-vTHM_tX_UysTpwlHw</a><br>  提取码：8csu<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>数据库系统与应用设计</p><p>  链接：<a href="https://pan.baidu.com/s/1s1Y92c00PPjtAl5pEjjlSQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1s1Y92c00PPjtAl5pEjjlSQ</a><br>  提取码：ql1g<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>计算机网络</p><p>  链接：<a href="https://pan.baidu.com/s/1YJ8vW7aHVjFYhkWRL0kCbQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1YJ8vW7aHVjFYhkWRL0kCbQ</a><br>  提取码：jh0j<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>计算机系统结构</p><p>  链接：<a href="https://pan.baidu.com/s/1-LZ4RFh5tOOxukwXIyO7OQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1-LZ4RFh5tOOxukwXIyO7OQ</a><br>  提取码：kxkq<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>计算机组成原理</p><p>  链接：<a href="https://pan.baidu.com/s/1Uk08FMucWBFotmjD0cIKgA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Uk08FMucWBFotmjD0cIKgA</a><br>  提取码：ea1t<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li><li><p>数据结构与算法</p><p>  链接：<a href="https://pan.baidu.com/s/1rxLY0hKenxFBd2692LG1vQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1rxLY0hKenxFBd2692LG1vQ</a><br>  提取码：xyfz<br>  复制这段内容后打开百度网盘手机App，操作更方便哦</p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;模拟电路与数字电路&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1KTUmyqRAG0ilQrBEB72eFQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.c
      
    
    </summary>
    
    
      <category term="期末大礼包" scheme="https://chouxianyu.github.io/tags/%E6%9C%9F%E6%9C%AB%E5%A4%A7%E7%A4%BC%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>一文详解特征缩放、标准化、归一化的定义、区别、特点和作用</title>
    <link href="https://chouxianyu.github.io/2020/10/25/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE%E3%80%81%E6%A0%87%E5%87%86%E5%8C%96%E3%80%81%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%81%E5%8C%BA%E5%88%AB%E3%80%81%E7%89%B9%E7%82%B9%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>https://chouxianyu.github.io/2020/10/25/一文详解特征缩放、标准化、归一化的定义、区别、特点和作用/</id>
    <published>2020-10-25T02:30:54.000Z</published>
    <updated>2020-10-28T07:52:20.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我在学李宏毅的机器学习课程，助教给的回归作业代码中有数据标准化的操作。</p><p>我听过数据标准化，还有归一化、批量归一化等等，但不是很懂，不知道他们具体是什么、有什么区别。</p><p>百度上找了挺多文章，讲得都不是很系统，比如大多文章都没讲懂标准化和归一化的区别或者是不同文章讲的内容矛盾了。</p><p>用谷歌一搜，就找到了很多很有价值的相关文章，然后我也写了这篇文章做个记录。</p><p>相对来讲，中文社区要比英文社区差些，部分原因是名词滥用或中英翻译问题，比如标准化和归一化、常量指针和指针常量。emmm</p><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本文主要讲解了以下内容</p><ol><li>特征缩放是什么/特征缩放的定义</li><li>归一化是什么/归一化的定义</li><li>标准化是什么/标准化的定义</li><li>归一化和标准化的区别</li><li>为什么要进行特征缩放/特征缩放有什么作用</li><li>有哪些常见的特征缩放方法</li><li>什么时候适合进行特征缩放/特征缩放方法的应用</li></ol><h1 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h1><p>这几个词是有区别的，特别是标准化和归一化，不要滥用（在本文中也请区分这几个词）。</p><div class="table-container"><table><thead><tr><th style="text-align:center">中文</th><th style="text-align:center">英文</th></tr></thead><tbody><tr><td style="text-align:center">特征缩放</td><td style="text-align:center">Feature Scaling</td></tr><tr><td style="text-align:center">标准化</td><td style="text-align:center">Standardization(Z-Score Normalization)</td></tr><tr><td style="text-align:center">归一化</td><td style="text-align:center">Normalization</td></tr></tbody></table></div><p>可以认为Feature Scaling包括Standardization和Normalization，其中Standardization可以叫做Z-Score Normalization。</p><h1 id="为什么需要进行特征缩放"><a href="#为什么需要进行特征缩放" class="headerlink" title="为什么需要进行特征缩放"></a>为什么需要进行特征缩放</h1><h2 id="背景：多指标量纲和数量级不同"><a href="#背景：多指标量纲和数量级不同" class="headerlink" title="背景：多指标量纲和数量级不同"></a>背景：多指标量纲和数量级不同</h2><p>使用单一指标对某事物进行评价并不合理，因此需要多指标综合评价方法。多指标综合评价方法，就是把描述某事物不同方面的多个指标综合起来得到一个综合指标，并通过它评价、比较该事物。</p><p>由于性质不同，不同评价指标通常具有不同的量纲和数量级。当各指标相差很大时，如果直接使用原始指标值计算综合指标，就会突出数值较大的指标在分析中的作用、削弱数值较小的指标在分析中的作用。</p><p>为消除各评价指标间量纲和数量级的差异、保证结果的可靠性，就需要对各指标的原始数据进行特征缩放（也有数据标准化、数据归一化的说法，但这些叫法不准确，所以不推荐）。</p><p>由于量纲和数量级不同，所以需要特征缩放。特征缩放可以显著提升部分机器学习算法的性能，但它对部分算法没有帮助。</p><h2 id="不进行特征缩放会有什么后果"><a href="#不进行特征缩放会有什么后果" class="headerlink" title="不进行特征缩放会有什么后果"></a>不进行特征缩放会有什么后果</h2><p>假如特征$x_1$的数值是100左右，特征$x_2$的数值是1左右，方程为$y=b+w_1x_1+w_2x_2$，那$w_1$对$y$的影响就更大，对Loss的影响也更大，损失函数关于$w_1$的梯度也更大，而损失函数关于$w_2$的梯度却很小，因此两个特征就不能使用相同的学习率。</p><p>不进行特征缩放的话，Error Surface就是一个椭圆，梯度下降时不一定是朝着最优点（圆心），速度就慢。</p><p>如果进行了特征缩放，Error Surface会尽可能趋近于圆，因此梯度下降时会一直朝着最优点（圆心），所以速度快。</p><h1 id="各类算法是否需要进行特征缩放"><a href="#各类算法是否需要进行特征缩放" class="headerlink" title="各类算法是否需要进行特征缩放"></a>各类算法是否需要进行特征缩放</h1><h2 id="基于梯度下降的算法（Gradient-Descent-Based-Algorithms）"><a href="#基于梯度下降的算法（Gradient-Descent-Based-Algorithms）" class="headerlink" title="基于梯度下降的算法（Gradient Descent Based Algorithms）"></a>基于梯度下降的算法（Gradient Descent Based Algorithms）</h2><p>在基于梯度下降进行优化的算法中，需要进行特征缩放，比如线性回归、逻辑回归、神经网络等。</p><p>因为计算梯度时会使用特征的值，如果各特征的的取值范围差异很大，不同特征对应梯度的值就会差异很大。</p><p>为保证平滑走到最优点、按相同速率更新各特征的权重，需要进行特征放缩。</p><p>通过特征放缩，可以使数值范围变小，进而加速梯度下降。</p><h2 id="基于距离的算法（Distance-Based-Algorithms）"><a href="#基于距离的算法（Distance-Based-Algorithms）" class="headerlink" title="基于距离的算法（Distance-Based Algorithms）"></a>基于距离的算法（Distance-Based Algorithms）</h2><p>在基于距离进行优化的算法中，需要进行特征缩放，比如K近邻、K-Means、SVM、PCA等。</p><p>因为这些算法是基于数据点的特征值计算它们的距离，距离越小则两者越相似。</p><h2 id="基于树的算法（Tree-Based-Algorithms）"><a href="#基于树的算法（Tree-Based-Algorithms）" class="headerlink" title="基于树的算法（Tree-Based Algorithms）"></a>基于树的算法（Tree-Based Algorithms）</h2><p>基于树的算法（比如决策树）对特征（features）的数值范围并不敏感，不需要进行特征缩放。</p><p>决策树仅基于单个feature拆分节点，并不受其它feature的影响。</p><h2 id="线性判别分析、朴素贝叶斯等算法"><a href="#线性判别分析、朴素贝叶斯等算法" class="headerlink" title="线性判别分析、朴素贝叶斯等算法"></a>线性判别分析、朴素贝叶斯等算法</h2><p>这两个算法处理了特征数量级差异大的问题，因此不需要进行特征缩放。</p><h1 id="四种特征缩放的方法"><a href="#四种特征缩放的方法" class="headerlink" title="四种特征缩放的方法"></a>四种特征缩放的方法</h1><p>标准化和归一化都可以实现特征缩放，但两者是有区别的。</p><p>假设我们有一份数据$x$，它有$N$行$M$列，即有$N$个对象，每个对象有$M$个特征，$x^i_j$表示对象$i$的特征$j$。</p><ul><li>Standardization（Z-Score Normalization）</li><li>Mean Normalization</li><li>Min-Max Normalization</li><li>Unit Vector Normalization/Scaling to unit length</li></ul><h1 id="标准化（Standardization-Z-Score-Normalization）"><a href="#标准化（Standardization-Z-Score-Normalization）" class="headerlink" title="标准化（Standardization/Z-Score Normalization）"></a>标准化（Standardization/Z-Score Normalization）</h1><ul><li><p>定义</p><p>  公式为$\hat x[:,j]=\frac{x[:,j]-mean(x[:,j])}{std(x[:,j])}$，其中$mean$代表平均值，$std$代表标准差，</p><p>  $mean(x[:,j])=\frac{1}{N}\cdot\sum_{i=1}^Nx[i,j]$，</p><p>  $std(x[:,j])=\sqrt{\frac{1}{N-1}\cdot\sum^N_{i=1}(x[i,j]-\mu_j)^2}$。</p></li><li><p>特点</p><p>  使数据的平均值变为0、标准差变为1，不改变数据的分布类型，数值范围不一定，消除了数据的量纲差异。</p></li><li><p>假设</p><p>  标准化假设数据是正态分布，但这个要求并不十分严格，如果数据是正态分布则该技术会更有效。</p></li><li><p>何时使用</p><p>  当我们使用的算法假设数据是正态分布时，可以使用Standardization，比如线性回归、逻辑回归、线性判别分析。</p><p>  因为Standardization使数据平均值为0，也可以在一些假设数据中心为0（zero centric data）的算法中使用，比如主成分分析（PCA）。</p></li></ul><h1 id="归一化（Normalization）"><a href="#归一化（Normalization）" class="headerlink" title="归一化（Normalization）"></a>归一化（Normalization）</h1><ul><li><p>特点</p><p>  把数据调整到[0,1]，并且消除了数据的量纲差异。</p><p>  也可以把数据调到[-1,1]，在使用SVM和Adaboost时就需要这样。</p></li><li><p>何时使用</p><p>  当我们不知道数据分布时或者我们知道数据不是正态分布时，这是一个很好的方法。</p><p>  换种说法就是，当我们使用的算法没有假设数据的分布类型时，就可以使用Normalization，比如K近邻算法和人工神经网络。</p></li></ul><h2 id="Mean-Normalization"><a href="#Mean-Normalization" class="headerlink" title="Mean Normalization"></a>Mean Normalization</h2><ul><li><p>定义</p><p>  $\hat x[:,j]=\frac{x[:,j]-mean(x[:,j])}{max(x[:,j])-min(x[:,j])}$</p><p>  其中$mean$代表平均值，$max$代表最大值，$min$代表最小值。</p></li><li><p>特点</p><p>  把数据调到[-1,1]，平均值为0</p></li><li><p>何时使用</p><p>  一些假设数据中心为0（zero centric data）的算法，比如主成分分析（PCA）。</p></li></ul><h2 id="Min-Max-Normalization"><a href="#Min-Max-Normalization" class="headerlink" title="Min-Max Normalization"></a>Min-Max Normalization</h2><ul><li><p>定义</p><p>  $\hat x[:,j]=\frac{x[:,j]-min(x[:,j])}{max(x[:,j])-min(x[:,j])}$</p><p>  其中$max$代表最大值，$min$代表最小值。</p></li><li><p>特点</p><p>  把数据调到[0,1]</p></li><li><p>何时使用</p><p>  当处理具有严格数值范围要求的数据（比如图片）时，这非常有用。</p></li></ul><h2 id="Unit-Vector-Normalization-Scaling-to-unit-length"><a href="#Unit-Vector-Normalization-Scaling-to-unit-length" class="headerlink" title="Unit Vector Normalization/Scaling to unit length"></a>Unit Vector Normalization/Scaling to unit length</h2><ul><li><p>定义</p><p>  $\hat x[i,:]=\frac{x[i,:]}{||x[i,:]||}$</p><p>  把每个对象的特征向量变成单位长度。</p></li><li><p>特点</p><p>  把数据调到[0,1]</p></li><li><p>何时使用</p><p>  当处理具有严格数值范围要求的数据（比如图片）时，这非常有用。</p></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>下面几篇文章确实讲得很清晰、精准，作为机器学习新手的我都能看懂。</p><p>这篇文章的内容也都是从下面这些文章里提取总结出来的，所以如果我上面哪里讲得不清楚、不好的话，建议直接查看下面几篇文章或者直接谷歌搜索相关名词。</p><ol><li><p><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96</a></p></li><li><p><a href="https://www.analyticsvidhya.com/blog/2020/04/feature-scaling-machine-learning-normalization-standardization/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2020/04/feature-scaling-machine-learning-normalization-standardization/</a></p><p> 这篇文章讲得很不错，建议参考。</p></li><li><p><a href="https://medium.com/greyatom/why-how-and-when-to-scale-your-features-4b30ab09db5e" target="_blank" rel="noopener">https://medium.com/greyatom/why-how-and-when-to-scale-your-features-4b30ab09db5e</a></p><p> 这篇文章讲得很不错，建议参考。</p></li><li><p><a href="https://machinelearningmastery.com/normalize-standardize-machine-learning-data-weka/" target="_blank" rel="noopener">https://machinelearningmastery.com/normalize-standardize-machine-learning-data-weka/</a></p><p> 这篇文章讲了Weka的使用，但我们并不需要看Weka怎么用，看文章里其它理论部分即可。</p></li><li><p><a href="https://towardsdatascience.com/understand-data-normalization-in-machine-learning-8ff3062101f0" target="_blank" rel="noopener">https://towardsdatascience.com/understand-data-normalization-in-machine-learning-8ff3062101f0</a></p><p> 这篇文章更偏向于实践一些，也很不错。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Feature_scaling" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Feature_scaling</a></p></li></ol><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我在学李宏毅的机器学习课程，助教给的回归作业代码中有数据标准化的操作。&lt;/p&gt;
&lt;p&gt;我听过数据标准化，还有归一化、批量归一化等等，但不是很
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://chouxianyu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="特征缩放" scheme="https://chouxianyu.github.io/tags/%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE/"/>
    
      <category term="标准化" scheme="https://chouxianyu.github.io/tags/%E6%A0%87%E5%87%86%E5%8C%96/"/>
    
      <category term="归一化" scheme="https://chouxianyu.github.io/tags/%E5%BD%92%E4%B8%80%E5%8C%96/"/>
    
      <category term="梯度下降" scheme="https://chouxianyu.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    
  </entry>
  
  <entry>
    <title>ModuleNotFoundError-No module named jupyter_nbextensions_configurator</title>
    <link href="https://chouxianyu.github.io/2020/10/24/ModuleNotFoundError-No-module-named-jupyter-nbextensions-configurator/"/>
    <id>https://chouxianyu.github.io/2020/10/24/ModuleNotFoundError-No-module-named-jupyter-nbextensions-configurator/</id>
    <published>2020-10-24T00:50:46.000Z</published>
    <updated>2020-10-24T00:53:37.452Z</updated>
    
    <content type="html"><![CDATA[<p>启动Anaconda中的Jupyter Notebook的时候，出现如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[W 08:37:25.964 NotebookApp] Error loading server extension jupyter_nbextensions_configurator</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">      File &quot;D:\WorkingSoftware\Anaconda3\lib\site-packages\notebook\notebookapp.py&quot;, line 1615, in init_server_extensions</span><br><span class="line">        mod = importlib.import_module(modulename)</span><br><span class="line">      File &quot;D:\WorkingSoftware\Anaconda3\lib\importlib\__init__.py&quot;, line 127, in import_module</span><br><span class="line">        return _bootstrap._gcd_import(name[level:], package, level)</span><br><span class="line">      File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1006, in _gcd_import</span><br><span class="line">      File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 983, in _find_and_load</span><br><span class="line">      File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 965, in _find_and_load_unlocked</span><br><span class="line">    ModuleNotFoundError: No module named &apos;jupyter_nbextensions_configurator&apos;</span><br></pre></td></tr></table></figure><p>经查询，在Anaconda Prompt某Python环境（我使用的是Anaconda默认的base环境）中运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install jupyter_nbextensions_configurator</span><br></pre></td></tr></table></figure><p>再次打开Jupyter Notebook时就可以发现问题已经解决。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;启动Anaconda中的Jupyter Notebook的时候，出现如下错误&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://chouxianyu.github.io/tags/Bug/"/>
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
      <category term="Jupyter" scheme="https://chouxianyu.github.io/tags/Jupyter/"/>
    
      <category term="Anaconda" scheme="https://chouxianyu.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>VSCode运行Python代码:文件存在但出现FileNotFoundError</title>
    <link href="https://chouxianyu.github.io/2020/10/23/VSCode%E8%BF%90%E8%A1%8CPython%E4%BB%A3%E7%A0%81-%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E4%BD%86%E5%87%BA%E7%8E%B0FileNotFoundError/"/>
    <id>https://chouxianyu.github.io/2020/10/23/VSCode运行Python代码-文件存在但出现FileNotFoundError/</id>
    <published>2020-10-23T13:25:39.000Z</published>
    <updated>2020-10-23T13:28:51.229Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用VSCode运行Python代码，读取当前目录下的CSV文件，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">'./train.csv'</span>)</span><br></pre></td></tr></table></figure><p>我已确认过我的Python代码文件和<code>train.csv</code>在同一个目录，正常情况下这份代码不应该报错的。</p><p>但我运行这份代码时，终端内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\Study\LHYMachineLearning&gt;python -u "e:\Study\LHYMachineLearning\LHYMLCode\hw1_regression\hw1_regression.py"</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">………………&lt;此处内容省略&gt;</span><br><span class="line">FileNotFoundError: [Errno 2] File b'./train.csv' does not exist: b'./train.csv'</span><br></pre></td></tr></table></figure><p>但是如果我修改VSCode终端的所在路径，<strong>这样运行就不会报错</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Study\LHYMachineLearning\LHYMLCode\hw1_regression&gt;python -u hw1_regression.py</span><br></pre></td></tr></table></figure><p>所以问题就在于运行命令时VSCode终端的所在路径，这里不再过多解释，上面两条命令的对比十分明显了。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天使用VSCode运行Python代码，读取当前目录下的CSV文件，代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://chouxianyu.github.io/tags/Bug/"/>
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
      <category term="VSCode" scheme="https://chouxianyu.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>(hexo)YAMLException can not read a block mapping entry; a multiline key may not be an implicit key</title>
    <link href="https://chouxianyu.github.io/2020/10/19/hexo-YAMLException-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key/"/>
    <id>https://chouxianyu.github.io/2020/10/19/hexo-YAMLException-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key/</id>
    <published>2020-10-19T11:19:09.000Z</published>
    <updated>2020-10-19T11:20:52.850Z</updated>
    
    <content type="html"><![CDATA[<p>运行<code>hexo g</code>后，报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YAMLException can not read a block mapping entry; a multiline key may not be an implicit key</span><br></pre></td></tr></table></figure><p>根据报错定位（一般会定位到文件的某行某列），检查一下是不是哪里少了空格，我的情况是文章开头的tags后边少了个空格。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;运行&lt;code&gt;hexo g&lt;/code&gt;后，报错如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://chouxianyu.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1118Birds in Forest</title>
    <link href="https://chouxianyu.github.io/2020/10/19/PAT%E7%94%B2%E7%BA%A71118Birds-in-Forest/"/>
    <id>https://chouxianyu.github.io/2020/10/19/PAT甲级1118Birds-in-Forest/</id>
    <published>2020-10-19T09:32:57.000Z</published>
    <updated>2020-10-19T09:33:46.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>输入<ul><li>N：正整数，不超过1000，照片的数量</li><li>N张照片：每张照片中有K只鸟，鸟的索引从1开始，不超过10000。假设一张图片中出现的所有鸟属于同一棵树</li><li>Q：正整数，不超过10000，查询的数量</li><li>Q个查询</li></ul></li><li>输出<ul><li>有多少颗树、多少只鸟</li><li>判断Q对鸟是否属于同一颗树</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>用并查集做就行，这道题和<a href="https://www.cnblogs.com/chouxianyu/p/13839712.html" target="_blank" rel="noopener">PAT甲级1114Family Property</a>很相似，但简单很多。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1118</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805354108403712</span></span><br><span class="line"><span class="comment">// Tags: 并查集 路径压缩</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10001</span>;</span><br><span class="line"><span class="keyword">int</span> tree[MAXN];</span><br><span class="line"><span class="keyword">int</span> birdNum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTree</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="number">-1</span> || x == tree[x]) ? x : tree[x] = findTree(tree[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UNION</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ta = findTree(a), tb = findTree(b);</span><br><span class="line">    <span class="keyword">if</span> (ta != tb)</span><br><span class="line">        tree[tb] = ta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(tree, tree + MAXN, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> n, q, k, bird1, bird2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bird1);</span><br><span class="line">        <span class="keyword">if</span> (tree[bird1] == <span class="number">-1</span>)</span><br><span class="line">            tree[bird1] = bird1; <span class="comment">// 记录该鸟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;bird2);</span><br><span class="line">            <span class="keyword">if</span> (tree[bird2] == <span class="number">-1</span>)</span><br><span class="line">                tree[bird2] = bird2; <span class="comment">// 记录该鸟</span></span><br><span class="line">            UNION(bird1, bird2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tempTree;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        tempTree = findTree(i);</span><br><span class="line">        <span class="keyword">if</span> (tempTree != <span class="number">-1</span>)&#123;</span><br><span class="line">            birdNum[tempTree] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> treeCount = <span class="number">0</span>, birdCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (birdNum[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            treeCount += <span class="number">1</span>;</span><br><span class="line">            birdCount += birdNum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, treeCount, birdCount);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">int</span> tree1, tree2;</span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;bird1, &amp;bird2);</span><br><span class="line">        tree1 = findTree(bird1);</span><br><span class="line">        tree2 = findTree(bird2);</span><br><span class="line">        <span class="keyword">if</span> (tree1 != <span class="number">-1</span> &amp;&amp; tree2 != <span class="number">-1</span> &amp;&amp; tree1 == tree2)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="并查集" scheme="https://chouxianyu.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="路径压缩" scheme="https://chouxianyu.github.io/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1114Family Property</title>
    <link href="https://chouxianyu.github.io/2020/10/19/PAT%E7%94%B2%E7%BA%A71114Family-Property/"/>
    <id>https://chouxianyu.github.io/2020/10/19/PAT甲级1114Family-Property/</id>
    <published>2020-10-19T05:13:41.000Z</published>
    <updated>2020-10-19T05:15:20.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>给出每个人的家庭成员和属于他的房产信息，请计算每个家庭的成员数、房产平均面积、房产数</li><li>输入<ul><li>N：不超过1000，人的数量</li><li>N个有房产的人的信息：id、父亲、母亲、孩子、房产数、房产面积</li></ul></li><li>输出<ul><li>输出家庭数量</li><li>输出每个家庭的最小id、人数、平均房产数、平均房产面积（按平均房产面积降序，然后按最小id升序）</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>题目只给了N个有房产的人的信息，但人并不一定是N个，也不一定是10000个，因此需要标记一个id是否有效（即这个人是否存在）</p><p>  如果一个人的代表人是-1，则这个人不存在</p></li><li><p>题目要求输出每个家庭的最小id，这个最小id可以在建立家族关系时保存，即合并两个家族时取较小的id</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1114</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805356599820288</span></span><br><span class="line"><span class="comment">// Tags: 并查集 路径压缩</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Family</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, memberNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> estateNum = <span class="number">0</span>, estateArea = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> representative[MAXN];</span><br><span class="line"><span class="keyword">int</span> estateArea[MAXN];</span><br><span class="line"><span class="keyword">int</span> estateNum[MAXN];</span><br><span class="line">Family families[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepresentative</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="number">-1</span> || x == representative[x]) ? x : representative[x] = findRepresentative(representative[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UNION</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ra = findRepresentative(a), rb = findRepresentative(b);</span><br><span class="line">    <span class="comment">// 取家族中的最小id作为representative</span></span><br><span class="line">    <span class="keyword">if</span> (rb &lt; ra)</span><br><span class="line">        representative[ra] = rb;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ra &lt; rb)</span><br><span class="line">        representative[rb] = ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">familyCmp</span><span class="params">(Family&amp; f1, Family&amp; f2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f1.estateArea == f2.estateArea ? f1.id &lt; f2.id : f1.estateArea &gt; f2.estateArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化家族关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        representative[i] = <span class="number">-1</span>; <span class="comment">// representative为-1代表该人不存在</span></span><br><span class="line">        families[i].id = i; <span class="comment">// 该人作为代表者时，对应一个家族。该id是为了排序用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立家族关系</span></span><br><span class="line">    <span class="keyword">int</span> n, id, fatherID, motherID, k, childID, num, area;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;id, &amp;fatherID, &amp;motherID, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (representative[id] == <span class="number">-1</span>)</span><br><span class="line">            representative[id] = id; <span class="comment">// 记录：该人存在</span></span><br><span class="line">        <span class="keyword">if</span> (fatherID != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (representative[fatherID] == <span class="number">-1</span>)</span><br><span class="line">                representative[fatherID] = fatherID; <span class="comment">// 记录：该人存在</span></span><br><span class="line">            UNION(id, fatherID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (motherID != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (representative[motherID] == <span class="number">-1</span>)</span><br><span class="line">                representative[motherID] = motherID; <span class="comment">// 记录：该人存在</span></span><br><span class="line">            UNION(id, motherID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;childID);</span><br><span class="line">            <span class="keyword">if</span> (representative[childID] == <span class="number">-1</span>)</span><br><span class="line">                representative[childID] = childID; <span class="comment">// 记录：该人存在</span></span><br><span class="line">            UNION(id, childID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;estateNum[id], &amp;estateArea[id]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计家族数据</span></span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        tmp = findRepresentative(i);</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="number">-1</span>)&#123; <span class="comment">// 如果这个人存在</span></span><br><span class="line">            families[tmp].memberNum += <span class="number">1</span>;</span><br><span class="line">            families[tmp].estateNum += estateNum[i];</span><br><span class="line">            families[tmp].estateArea += estateArea[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;Family&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (families[i].memberNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            families[i].estateArea = families[i].estateArea / families[i].memberNum;</span><br><span class="line">            families[i].estateNum = families[i].estateNum / families[i].memberNum;</span><br><span class="line">            v.push_back(families[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v.size());</span><br><span class="line">    sort(v.begin(), v.end(), familyCmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04d %d %.3f %.3f\n"</span>, v[i].id, v[i].memberNum, v[i].estateNum, v[i].estateArea);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="并查集" scheme="https://chouxianyu.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="路径压缩" scheme="https://chouxianyu.github.io/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1107Social Clusters</title>
    <link href="https://chouxianyu.github.io/2020/10/18/PAT%E7%94%B2%E7%BA%A71107Social-Clusters/"/>
    <id>https://chouxianyu.github.io/2020/10/18/PAT甲级1107Social-Clusters/</id>
    <published>2020-10-18T13:54:41.000Z</published>
    <updated>2020-10-18T13:56:21.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>输入<ul><li>N：正整数，不超过1000，人的数量，索引为[1,N]</li><li>N个人的爱好：爱好的索引为[1,1000]</li></ul></li><li>输出<ul><li>有几个类（如果两人有共同爱好，则他们属于同一类）</li><li>每类的人数</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1107</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805361586847744</span></span><br><span class="line"><span class="comment">// Tags: 并查集 路径压缩</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, clusterSize;</span><br><span class="line"><span class="keyword">int</span> likeHobby[<span class="number">1001</span>]; <span class="comment">// 保存这一爱好的代表人（任意）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> father[x] == x ? x : father[x] = findFather(father[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">    <span class="comment">// return father[x] == x ? x : findFather(father[x]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UNION</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = findFather(a), fb = findFather(b);</span><br><span class="line">    <span class="keyword">if</span> (fa != fb)</span><br><span class="line">        father[fa] = fb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, hobby;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    father.resize(n+<span class="number">1</span>);</span><br><span class="line">    clusterSize.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; father.size(); i++) <span class="comment">// 初始化，每人都是一个cluster</span></span><br><span class="line">        father[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;hobby);</span><br><span class="line">            <span class="keyword">if</span> (likeHobby[hobby] == <span class="number">0</span>)</span><br><span class="line">                likeHobby[hobby] = i;</span><br><span class="line">            UNION(i, likeHobby[hobby]); <span class="comment">// 将i和他的爱好的代表人合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个cluster的人数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        clusterSize[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(clusterSize.begin(), clusterSize.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (clusterSize[cnt] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, clusterSize[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, clusterSize[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/93647900" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93647900</a></p><p><a href="https://blog.csdn.net/liuchuo/article/details/52191082" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52191082</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="并查集" scheme="https://chouxianyu.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="路径压缩" scheme="https://chouxianyu.github.io/tags/%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1098Insertion or Heap Sort</title>
    <link href="https://chouxianyu.github.io/2020/10/18/PAT%E7%94%B2%E7%BA%A71098Insertion-or-Heap-Sort/"/>
    <id>https://chouxianyu.github.io/2020/10/18/PAT甲级1098Insertion-or-Heap-Sort/</id>
    <published>2020-10-18T12:00:10.000Z</published>
    <updated>2020-10-18T12:00:57.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805368847187968" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805368847187968</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>给定一个序列，及用某种排序方法经过几次迭代后的结果，请指出用了什么排序方法。（升序）</li><li>输入<ul><li>N：正整数，不超过100，给定序列中元素的个数</li><li>给定序列：N个整数</li><li>未完全排序的序列</li></ul></li><li>输出<ul><li>输出是堆排序还是插入排序</li><li>输出该排序算法下一步迭代的结果</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>插入排序特征：序列分成左右两部分，左半部分是从小到大，右半部分是原序列。据此可以检测是否是插入排序，否则是堆排序。</p></li><li><p>堆排序特征：序列分成左右两部分，左半部分是大顶堆，右半部分是从小到大。</p><p>  步骤如下：</p><ol><li>将序列[1,N]构建成大顶堆（最终得到升序序列）</li><li>将堆顶元素(值最大)与末尾元素交换</li><li>将序列[1,N-1]构建/调整为大顶堆（重复步骤1、2）</li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1098</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805368847187968</span></span><br><span class="line"><span class="comment">// Tags: 堆 排序 堆排序 插入排序 完全二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> father = start, child = father * <span class="number">2</span>; <span class="comment">// 结点从1开始编号</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= end &amp;&amp; b[child] &lt; b[child + <span class="number">1</span>]) <span class="comment">// 取值较大的子结点</span></span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span> (b[father] &gt;= b[child]) <span class="comment">//如果父结点大于子结点，则不需调整，函数结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(b[father], b[child]);</span><br><span class="line">        father = child;</span><br><span class="line">        child = father * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n+<span class="number">1</span>), b(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n &amp;&amp; b[p] &gt;= b[p - <span class="number">1</span>])</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">int</span> index = p;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n &amp;&amp; a[p] == b[p])</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">if</span> (p == n+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> key = b[index];</span><br><span class="line">        p = index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">0</span> &amp;&amp; b[p] &gt;= b[index])</span><br><span class="line">            p--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt; p + <span class="number">1</span>; i--)</span><br><span class="line">            b[i] = b[i<span class="number">-1</span>];</span><br><span class="line">        b[p+<span class="number">1</span>] = key;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Heap Sort\n"</span>);</span><br><span class="line">        p = n;</span><br><span class="line">        <span class="keyword">while</span> (p &gt; <span class="number">2</span> &amp;&amp; b[p] &gt;= b[<span class="number">1</span>])</span><br><span class="line">            p--;</span><br><span class="line">        swap(b[<span class="number">1</span>], b[p]);</span><br><span class="line">        max_heapify(b, <span class="number">1</span>, p - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, b[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52252172" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52252172</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6129630.html</a></p><p><a href="https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="排序" scheme="https://chouxianyu.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆" scheme="https://chouxianyu.github.io/tags/%E5%A0%86/"/>
    
      <category term="堆排序" scheme="https://chouxianyu.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入排序" scheme="https://chouxianyu.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
      <category term="完全二叉树" scheme="https://chouxianyu.github.io/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1051Pop Sequence</title>
    <link href="https://chouxianyu.github.io/2020/10/17/PAT%E7%94%B2%E7%BA%A71051Pop-Sequence/"/>
    <id>https://chouxianyu.github.io/2020/10/17/PAT甲级1051Pop-Sequence/</id>
    <published>2020-10-17T05:55:26.000Z</published>
    <updated>2020-10-17T05:56:02.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>背景</p><p>  给定一个最大容量为M的栈，随机压入和弹出N个数(从1到N)。请判断一个序列是否有可能是该栈弹出的序列</p></li><li><p>输入</p><ul><li>M：不超过1000，栈的最大容量</li><li>N：不超过1000，输入序列的长度</li><li>K：不超过1000，待检查的序列的数量</li><li>K个序列</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>模拟入栈和出栈的过程，参考了柳婼的题解。</p><p>从1到N入栈：每入栈一个数字，便判断是否出栈，如果可以出栈则出栈（重复此步骤）。如果入栈后，栈大小超过M，则跳出循环停止入栈，结果为NO；如果正确模拟了入栈和出栈，则结果为YES。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1051</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944</span></span><br><span class="line"><span class="comment">// Tags: 栈</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            s.push(i);</span><br><span class="line">            <span class="keyword">if</span> (s.size() &gt; m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() == v[current])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current == n + <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52215337" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52215337</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://chouxianyu.github.io/tags/%E6%A0%88/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1091Acute Stroke</title>
    <link href="https://chouxianyu.github.io/2020/10/16/PAT%E7%94%B2%E7%BA%A71091Acute-Stroke/"/>
    <id>https://chouxianyu.github.io/2020/10/16/PAT甲级1091Acute-Stroke/</id>
    <published>2020-10-16T05:56:13.000Z</published>
    <updated>2020-10-19T11:14:01.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><ul><li>输入<ul><li>M：正整数</li><li>N：正整数</li><li>L：正整数，不超过60，一个大脑中slice的数量</li><li>T：正整数，阈值，如果一个connected core的体积小于T，则这个core不能被计数</li><li>L个slice：每个slice是一个M×N的二值矩阵（1代表stroke，0代表正常），</li></ul></li><li>输出<ul><li>输出所有core的体积之和</li></ul></li></ul><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>三维的图，一个结点和周围六个结点是相邻的，本质上还是求连通分量。</p><p>DFS，会段错误（Segmentation Fault），因为递归层数太多，堆栈溢出了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1091</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072</span></span><br><span class="line"><span class="comment">// Tags: BFS 图 连通分量 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, l, t, volume;</span><br><span class="line"><span class="keyword">int</span> brain[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line"><span class="keyword">int</span> bias[<span class="number">6</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    visit[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">    volume++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> biasIndex = <span class="number">0</span>, ii, jj, kk; biasIndex &lt; <span class="number">6</span>; biasIndex++)&#123;</span><br><span class="line">        ii = i + bias[biasIndex][<span class="number">0</span>];</span><br><span class="line">        jj = j + bias[biasIndex][<span class="number">1</span>];</span><br><span class="line">        kk = k + bias[biasIndex][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (!visit[ii][jj][kk] &amp;&amp; brain[ii][jj][kk] == <span class="number">1</span>)&#123;</span><br><span class="line">            dfs(ii, jj, kk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;m, &amp;n, &amp;l, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;brain[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> volumeSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visit[i][j][k] &amp;&amp; brain[i][j][k] == <span class="number">1</span>)&#123;</span><br><span class="line">                    volume = <span class="number">0</span>;</span><br><span class="line">                    dfs(i, j, k);</span><br><span class="line">                    <span class="keyword">if</span> (volume &gt;= t)&#123;</span><br><span class="line">                        volumeSum += volume;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, volumeSum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>用BFS方法遍历求连通分量</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1091</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805375457411072</span></span><br><span class="line"><span class="comment">// Tags: BFS 图 连通分量 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, l, t, volume;</span><br><span class="line"><span class="keyword">int</span> brain[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">65</span>][<span class="number">1300</span>][<span class="number">130</span>];</span><br><span class="line">Node bias[<span class="number">6</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; nodes;</span><br><span class="line">    nodes.push(node);</span><br><span class="line">    visit[node.i][node.j][node.k] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!nodes.empty())&#123;</span><br><span class="line">        node = nodes.front();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        volume++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> biasIndex = <span class="number">0</span>, ii, jj, kk; biasIndex &lt; <span class="number">6</span>; biasIndex++)&#123;</span><br><span class="line">            ii = node.i + bias[biasIndex].i;</span><br><span class="line">            jj = node.j + bias[biasIndex].j;</span><br><span class="line">            kk = node.k + bias[biasIndex].k;</span><br><span class="line">            <span class="keyword">if</span> (!visit[ii][jj][kk] &amp;&amp; brain[ii][jj][kk])&#123;</span><br><span class="line">                nodes.push(&#123;ii, jj, kk&#125;);</span><br><span class="line">                visit[ii][jj][kk] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;m, &amp;n, &amp;l, &amp;t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;brain[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visit[i][j][k] &amp;&amp; brain[i][j][k])&#123;</span><br><span class="line">                    volume = <span class="number">0</span>;</span><br><span class="line">                    bfs(&#123;i, j, k&#125;);</span><br><span class="line">                    <span class="keyword">if</span> (volume &gt;= t)&#123;</span><br><span class="line">                        result += volume;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="连通分量" scheme="https://chouxianyu.github.io/tags/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1076Forwards on Weibo</title>
    <link href="https://chouxianyu.github.io/2020/10/10/PAT%E7%94%B2%E7%BA%A71076Forwards-on-Weibo/"/>
    <id>https://chouxianyu.github.io/2020/10/10/PAT甲级1076Forwards-on-Weibo/</id>
    <published>2020-10-10T02:03:14.000Z</published>
    <updated>2020-10-10T02:05:15.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>给定一个社交网络，请计算某用户的最大转发量（只计算L层间接关注者，假设一条微博，每个人只能转发一次）。</li><li>输入<ul><li>N：正整数，不超过1000，用户的数量，索引为[1,N]</li><li>L：正整数，不超过6，需要计算的间接关注者的层数</li><li>N个用户分别关注了哪些用户：每个用户关注的用户列表</li><li>K：正整数，要查询的用户的数量</li><li>K个要查询的用户：</li></ul></li><li>输出</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>需要判断层次的BFS：通过类来保存每个结点的层次即可</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1076</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805392092020736</span></span><br><span class="line"><span class="comment">// Tags: 图 BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">int</span> n, l;</span><br><span class="line"><span class="keyword">bool</span> visit[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; followers[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,layer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> tempID)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;User&gt; users;</span><br><span class="line">    users.push(&#123;tempID, <span class="number">0</span>&#125;);</span><br><span class="line">    visit[tempID] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!users.empty())&#123;</span><br><span class="line">        User u = users.front();</span><br><span class="line">        users.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = followers[u.id].begin(); it != followers[u.id].end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[*it] &amp;&amp; u.layer &lt; l)&#123;</span><br><span class="line">                visit[*it] = <span class="literal">true</span>;</span><br><span class="line">                users.push(&#123;*it, u.layer + <span class="number">1</span>&#125;);</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;l);</span><br><span class="line">    <span class="keyword">int</span> tempUser, m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tempUser);</span><br><span class="line">            followers[tempUser].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tempUser);</span><br><span class="line">        fill(visit, visit + MAXN, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs(tempUser));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1131Subway Map</title>
    <link href="https://chouxianyu.github.io/2020/10/05/PAT%E7%94%B2%E7%BA%A71131Subway-Map/"/>
    <id>https://chouxianyu.github.io/2020/10/05/PAT甲级1131Subway-Map/</id>
    <published>2020-10-05T15:04:38.000Z</published>
    <updated>2020-10-05T15:05:18.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>给定起点和目标地，找到最快的路</p></li><li><p>输入</p><ul><li>N：正整数，不超过100，地铁线路的数量，索引为[1,n]</li><li>N条地铁线路：M个站点，站点索引为[0000,9999]<ul><li>两条地铁线路不会经过同一条边（站到站）</li><li>可能存在环，但没有自环</li><li>每个站点最多有5条线路经过</li></ul></li><li>K：正整数，不超过10，查询的数量</li><li>K对起点和终点</li></ul></li><li><p>输出</p><p>  对于每个查询，输出最少经过的站数。如果有多个解，输出换线最少的解。</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>因为存在环，所以在DFS时需要用visit数组表示某个车站是否已经DFS过。其实只要存在可以从多个结点到达某个结点V的情况，就应该设置visit数组标记是否已访问过结点V，如果访问过则不用再访问。</li><li><strong>注意输出要按四位输出</strong></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1131</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347523346432</span></span><br><span class="line"><span class="comment">// Tags: 图 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> line[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextStop[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempPath, ansPath;</span><br><span class="line"><span class="keyword">int</span> tempTransfer, ansTransfer;</span><br><span class="line"><span class="keyword">int</span> n, m, k, start, destination;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> stop,<span class="keyword">int</span> preLine)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[stop])</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    tempPath.push_back(stop);</span><br><span class="line">    visited[stop] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (stop == destination)&#123;</span><br><span class="line">        <span class="keyword">if</span> (tempPath.size() &lt; ansPath.size())&#123;</span><br><span class="line">            ansPath = tempPath;</span><br><span class="line">            ansTransfer = tempTransfer;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tempPath.size() == ansPath.size() &amp;&amp; tempTransfer &lt; ansTransfer)&#123;</span><br><span class="line">            ansPath = tempPath;</span><br><span class="line">            ansTransfer = tempTransfer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = nextStop[stop].begin(); it != nextStop[stop].end(); it++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> transferFlag = (line[stop][*it] != preLine);</span><br><span class="line">            <span class="keyword">if</span> (transferFlag)</span><br><span class="line">                tempTransfer++;</span><br><span class="line">            dfs(*it, line[stop][*it]);</span><br><span class="line">            <span class="keyword">if</span> (transferFlag)</span><br><span class="line">                tempTransfer--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">    visited[stop] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">            line[u][v] = i;</span><br><span class="line">            line[v][u] = i;</span><br><span class="line">            nextStop[u].push_back(v);</span><br><span class="line">            nextStop[v].push_back(u);</span><br><span class="line">            u = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;start, &amp;destination);</span><br><span class="line">        tempTransfer = <span class="number">-1</span>;</span><br><span class="line">        ansTransfer = MAXN;</span><br><span class="line">        tempPath.clear();</span><br><span class="line">        ansPath.resize(MAXN);</span><br><span class="line">        dfs(start, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ansPath.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> tempStart = start, preLine = line[ansPath[<span class="number">0</span>]][ansPath[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansPath.size() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (preLine != line[ansPath[i]][ansPath[i + <span class="number">1</span>]])&#123; <span class="comment">// 要换线</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Take Line#%d from %04d to %04d.\n"</span>, preLine, tempStart, ansPath[i]);</span><br><span class="line">                tempStart = ansPath[i];</span><br><span class="line">                preLine = line[ansPath[i]][ansPath[i + <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Take Line#%d from %04d to %04d.\n"</span>, preLine, tempStart, ansPath.back());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1130Infix Expression</title>
    <link href="https://chouxianyu.github.io/2020/09/29/PAT%E7%94%B2%E7%BA%A71130Infix-Expression/"/>
    <id>https://chouxianyu.github.io/2020/09/29/PAT甲级1130Infix-Expression/</id>
    <published>2020-09-29T05:14:35.000Z</published>
    <updated>2020-09-29T05:19:45.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>给定语法树，请输出其中缀表达式，用圆括号表示优先级，最后一层不要圆括号。</li><li>输入<ul><li>N：正整数，不超过20，语法树中结点的个数</li><li>N个结点：结点索引为[1,N]，-1代表空</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是二叉树的中序遍历而已，DFS就行。</p><p>最外层不需要括号，这时手动遍历根结点即可。</p><p>妙的是：<strong>所有结点中没有作为子结点的结点就是根结点</strong>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1130</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347921805312</span></span><br><span class="line"><span class="comment">// Tags: 二叉树 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> data;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root &lt; <span class="number">1</span> || root &gt; n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].left != <span class="number">-1</span> || nodes[root].right != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    dfs(nodes[root].left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nodes[root].data;</span><br><span class="line">    dfs(nodes[root].right);</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].left != <span class="number">-1</span> || nodes[root].right != <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    nodes.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nodes[i].data;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;nodes[i].left, &amp;nodes[i].right);</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].left != <span class="number">-1</span>)</span><br><span class="line">            visited[nodes[i].left] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].right != <span class="number">-1</span>)</span><br><span class="line">            visited[nodes[i].right] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(visited[root])</span><br><span class="line">        root++;</span><br><span class="line"></span><br><span class="line">    dfs(nodes[root].left);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nodes[root].data;</span><br><span class="line">    dfs(nodes[root].right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
</feed>
