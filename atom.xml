<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2020-09-21T14:37:15.808Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT甲级1087All Roads Lead to Rome</title>
    <link href="https://chouxianyu.github.io/2020/09/21/PAT%E7%94%B2%E7%BA%A71087All-Roads-Lead-to-Rome/"/>
    <id>https://chouxianyu.github.io/2020/09/21/PAT甲级1087All-Roads-Lead-to-Rome/</id>
    <published>2020-09-21T14:34:33.000Z</published>
    <updated>2020-09-21T14:37:15.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>找到成本最低、快乐值总和最高的路径。<strong>优先找成本最低的，然后再找快乐值最高的，然后再找平均快乐值最高的。</strong></p><ul><li>输入<ul><li>N：正整数，[2,200]，城市的数量</li><li>K：正整数，路径的数量</li><li>起始城市的名称</li><li>N-1个城市的名字及其快乐值</li><li>K条路径</li></ul></li><li>输出<ul><li>成本最低的路径的数量</li><li>成本</li><li>快乐值总和</li><li>平均快乐值（只输出整数部分）</li><li>路径</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这是一道dijkstra+DFS的题，和<a href="https://www.cnblogs.com/chouxianyu/p/13690906.html" target="_blank" rel="noopener">PAT甲级1018Public Bike Management</a>很类似，所以详细思路不再说明。</p><ul><li>用两个map将城市的名字和索引相互对应</li><li>用dijkstra算法求出起始城市到所有城市的最短距离，并记录每个城市的前驱城市</li><li>使用DFS求出路径（并计算、比较快乐值总和与平均值）</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1087</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805379664297984</span></span><br><span class="line"><span class="comment">// Tags: 图 最短路 单源最短路 dijkstra BFS DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">string</span> startCity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sti;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; its;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">9999999</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">201</span>;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> minDis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"><span class="keyword">int</span> happiness[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempPath;</span><br><span class="line"><span class="keyword">int</span> ansHappinessSum = -INF, ansPathNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> ansHappinessAve = -INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">1</span>)&#123; <span class="comment">// 到达起点</span></span><br><span class="line">        <span class="keyword">int</span> happinessSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = tempPath.begin(); iter != tempPath.end(); iter++)</span><br><span class="line">            happinessSum += happiness[*iter];</span><br><span class="line">        <span class="keyword">double</span> happinessAve = happinessSum * <span class="number">1.0</span> / (tempPath.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ansHappinessSum &lt; happinessSum)&#123;</span><br><span class="line">            path = tempPath;</span><br><span class="line">            ansHappinessSum = happinessSum;</span><br><span class="line">            ansHappinessAve = happinessAve;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ansHappinessSum == happinessSum &amp;&amp; ansHappinessAve &lt; happinessAve)&#123;</span><br><span class="line">            path = tempPath;</span><br><span class="line">            ansHappinessAve = happinessAve;</span><br><span class="line">        &#125;</span><br><span class="line">        ansPathNum++;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].size(); i++)</span><br><span class="line">        dfs(pre[v][i]);</span><br><span class="line"></span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(minDis, minDis + MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; startCity;</span><br><span class="line">    sti[startCity] = <span class="number">1</span>;</span><br><span class="line">    its[<span class="number">1</span>] = startCity;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        sti[s] = i;</span><br><span class="line">        its[i] = s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h);</span><br><span class="line">        happiness[i] = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;dis[sti[s]][sti[t]]);</span><br><span class="line">        dis[sti[t]][sti[s]] = dis[sti[s]][sti[t]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempMin = INF, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; tempMin &gt; minDis[j])&#123;</span><br><span class="line">                tempMin = minDis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dis[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (minDis[v] &gt; minDis[u] + dis[u][v])&#123;</span><br><span class="line">                    minDis[v] = minDis[u] + dis[u][v];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (minDis[v] == minDis[u] + dis[u][v])&#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(sti[<span class="string">"ROM"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n%s"</span>, ansPathNum, minDis[sti[<span class="string">"ROM"</span>]], ansHappinessSum, <span class="keyword">int</span>(ansHappinessAve), startCity.c_str());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%s"</span>, its[path[i]].c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1072Gas Station</title>
    <link href="https://chouxianyu.github.io/2020/09/20/PAT%E7%94%B2%E7%BA%A71072Gas-Station/"/>
    <id>https://chouxianyu.github.io/2020/09/20/PAT甲级1072Gas-Station/</id>
    <published>2020-09-20T10:41:01.000Z</published>
    <updated>2020-09-20T10:41:50.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>加油站要离各个住宅的最小距离应该尽可能地大，但也要保证住宅在加油区的服务距离内。</p><p>现在给出几个加油站的候选位置，请你找出最好的一个（<strong>距离各住宅的最小距离最大）。如果有多个解，则选择离住宅平均距离最短的那个。如果还是有多个解，则选择索引较小的那个。</strong></p><ul><li><p>输入</p><ul><li>N：正整数，不超过1000，住宅的数量，住宅索引为[1,N]</li><li>M：正整数，不超过10，加油站候选位置的数量，索引为[G1,GM]</li><li>K：正整数，不超过10000，边的数量</li><li>Ds：正整数，加油站的最大服务距离</li><li>K条边</li></ul></li><li><p>输出</p><ul><li><p>加油站候选位置的索引</p></li><li><p>加油站与住宅的最短距离和平均距离</p><p>  数字必须精确到小数点后一位。</p></li><li><p>解不存在则输出<code>No Solution</code></p></li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>除了输入输出需要懂点心思，这道题就是一道简单的单源最短路题目了。</p><ul><li>这里有两类结点：住宅和加油站，可以对输入进行处理，规定索引[1,n]是住宅，索引[n+1,n+m]是加油站</li><li>然后对每个加油站运行dijkstra算法，在不超过加油站服务距离的前提下求解</li><li>注意是优先求距离各住宅的最小距离最大的解</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1072</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805396953219072</span></span><br><span class="line"><span class="comment">// Tags: 图 最短路 单源最短路 dijkstra BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1011</span>; <span class="comment">// [1,n]是住宅，[n+1,n+m]是加油站</span></span><br><span class="line"><span class="keyword">int</span> n, m, k, ds;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN]; </span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> minDis[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;k, &amp;ds);</span><br><span class="line">    <span class="built_in">string</span> aStr, bStr;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; aStr &gt;&gt; bStr;</span><br><span class="line">        a = (aStr[<span class="number">0</span>] == <span class="string">'G'</span>) ? stoi(aStr.substr(<span class="number">1</span>)) + n : stoi(aStr);</span><br><span class="line">        b = (bStr[<span class="number">0</span>] == <span class="string">'G'</span>) ? stoi(bStr.substr(<span class="number">1</span>)) + n : stoi(bStr);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; dis[a][b]) <span class="comment">// 处理输入的特殊情况</span></span><br><span class="line">            dis[a][b] = dis[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个加油站运行dijkstra算法</span></span><br><span class="line">    <span class="keyword">int</span> ansStation = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">double</span> ansDis = -INF, ansAverDis = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> station = n + <span class="number">1</span>; station &lt;= n + m; station++)&#123;</span><br><span class="line">        <span class="keyword">double</span> tempMin = INF, averDis = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        fill(minDis, minDis + MAXN, INF);</span><br><span class="line">        fill(visited, visited + MAXN, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行dijkstra算法，求该加油站到其它加油站和住宅的最短路径</span></span><br><span class="line">        minDis[station] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tempMin = INF, u = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[j] &amp;&amp; minDis[j] &lt; tempMin)&#123;</span><br><span class="line">                    u = j;</span><br><span class="line">                    tempMin = minDis[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            visited[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n + m; v++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; dis[u][v] != INF)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (minDis[v] &gt; minDis[u] + dis[u][v])&#123;</span><br><span class="line">                        minDis[v] = minDis[u] + dis[u][v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新最终结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (minDis[i] &gt; ds)&#123;</span><br><span class="line">                tempMin = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minDis[i] &lt; tempMin)&#123;</span><br><span class="line">                tempMin = minDis[i];</span><br><span class="line">            &#125;</span><br><span class="line">            averDis += minDis[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tempMin == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        averDis /= n;</span><br><span class="line">        <span class="keyword">if</span> (tempMin &gt; ansDis)&#123;</span><br><span class="line">            ansDis = tempMin;</span><br><span class="line">            ansStation = station;</span><br><span class="line">            ansAverDis = averDis;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tempMin == ansDis &amp;&amp; averDis &lt; ansAverDis)&#123;</span><br><span class="line">            ansStation = station;</span><br><span class="line">            ansAverDis = averDis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ansStation == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No Solution"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"G%d\n%.1f %.1f"</span>, ansStation - n, ansDis, ansAverDis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1030Travel Plan</title>
    <link href="https://chouxianyu.github.io/2020/09/18/PAT%E7%94%B2%E7%BA%A71030Travel-Plan/"/>
    <id>https://chouxianyu.github.io/2020/09/18/PAT甲级1030Travel-Plan/</id>
    <published>2020-09-18T09:31:06.000Z</published>
    <updated>2020-09-18T09:33:06.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>输入<ul><li>N：正整数，不超过500，结点的数量，索引为[0,N-1]</li><li>M：正整数，边的数量</li><li>S：起点索引</li><li>D：终点索引</li><li>M条边</li></ul></li><li>输出<ul><li>最短路径经过的结点</li><li>总距离</li><li>总成本</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题在普通最短路径题目基础上补充了2点</p><p>我是先做了<a href="https://www.cnblogs.com/chouxianyu/p/13690906.html" target="_blank" rel="noopener">PAT甲级1018Public Bike Management</a>，这两题很相似，1018更难，这题更简单。</p><ol><li><p>输出最短路径经过的结点</p><p> 因为最终的最短路径只有一条，所以保存最短路径中每个结点的前一个结点，最终从D往回遍历即可</p></li><li><p>优先考虑距离，再考虑成本</p><p> 通过if语句实现</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>最后生成path时我是递归存入vector，其实也可以直接迭代生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1030</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805464397627392</span></span><br><span class="line"><span class="comment">// Tags: 最短路 图 dijkstra 单源最短路 BFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">9999999</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, s, d;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];</span><br><span class="line"><span class="keyword">int</span> minDis[MAXN];</span><br><span class="line"><span class="keyword">int</span> minCost[MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> cost[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    path.push_back(v);</span><br><span class="line">    <span class="keyword">if</span> (v != s)&#123;</span><br><span class="line">        getPath(pre[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(minDis, minDis + MAXN, INF);</span><br><span class="line">    fill(minCost, minCost + MAXN, INF);</span><br><span class="line">    fill(dis[<span class="number">0</span>], dis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(cost[<span class="number">0</span>], cost[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;s, &amp;d);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;dis[a][b], &amp;cost[a][b]);</span><br><span class="line">        dis[b][a] = dis[a][b];</span><br><span class="line">        cost[b][a] = cost[a][b];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    minDis[s] = <span class="number">0</span>;</span><br><span class="line">    minCost[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minD = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; minDis[j] &lt; minD)&#123;</span><br><span class="line">                    minD = minDis[j];</span><br><span class="line">                    u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; dis[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (minDis[u] + dis[u][v] &lt; minDis[v])&#123;</span><br><span class="line">                    minDis[v] = minDis[u] + dis[u][v];</span><br><span class="line">                    minCost[v] = minCost[u] + cost[u][v];</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (minDis[u] + dis[u][v] == minDis[v] &amp;&amp; minCost[u] + cost[u][v] &lt; minCost[v])&#123;</span><br><span class="line">                    minCost[v] = minCost[u] + cost[u][v];</span><br><span class="line">                    pre[v] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getPath(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = path.rbegin(); iter != path.rend(); iter++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *iter);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, minDis[d], minCost[d]);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1018Public Bike Management</title>
    <link href="https://chouxianyu.github.io/2020/09/18/PAT%E7%94%B2%E7%BA%A71018Public-Bike-Management/"/>
    <id>https://chouxianyu.github.io/2020/09/18/PAT甲级1018Public-Bike-Management/</id>
    <published>2020-09-18T05:53:15.000Z</published>
    <updated>2020-09-18T09:35:37.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>如果有多个最短路径，则选择PBMC送出自行车的数量最少的路径</p><p>  如果还是有多条最短路径，那么就选择从车站带回的自行车数目最少的（带回的时候是不调整路过的车站的）</p></li><li><p>PBMC携带或者从经过的车站收集一定数量的自行车前往某车站，并使路过的车站都达到半满。</p></li><li><p>输入</p><ul><li>Cmax：不超过100，偶数，每个站点中最多有多少辆自行车</li><li>N：不超过500，站点的数量，站点索引为[1,N]，PBMC索引为0</li><li>Sp：有问题的站点</li><li>M：边的数量</li><li>N个站点中自行车的数量</li><li>M条边</li></ul></li><li><p>输出</p><ul><li>PBMC要送多少辆自行车</li><li>路径</li><li>要送多少辆自行车到PBMC</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="https://www.cnblogs.com/chouxianyu/p/13692483.html" target="_blank" rel="noopener">PAT甲级1030Travel Plan</a>和这题很类似，但比这题简单，大概是比这题少了一个DFS。</p><ul><li><p>dijkstra</p><p>  除了要求出PBMC到所有结点的最短路径长度，还要在算法过程中记录所有最短路径上每个结点的前一个结点，进而进行下一步的DFS。</p></li><li><p>DFS</p><p>  运行dijkstra算法后，已经记录了所有最短路径上每个结点的前一个结点（可以有多个），然后从结点sp开始DFS，相当于从sp走到PBMC。</p><p>  DFS过程中要记录当前路径</p></li><li><p>求路径上多余或缺少的自行车的数量</p><p>  DFS过程中，如果当前结点是PBMC，则从PBMC走到sp，求多余或缺少的自行车的数量，再和全局最小值比较、更新</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1018</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805489282433024</span></span><br><span class="line"><span class="comment">// Tags: 最短路 dijkstra BFS DFS 单源最短路 图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> cmax, n, sp, m;</span><br><span class="line"><span class="keyword">int</span> minStationNeed = INF, minStationExtra = INF; <span class="comment">// PBMC最少需要送出多少辆车，最少要送多少辆车到PBMC</span></span><br><span class="line"><span class="keyword">int</span> e[MAXN][MAXN]; <span class="comment">// 车站间的距离</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN]; <span class="comment">// PBMC到各车站的最短路径的长度</span></span><br><span class="line"><span class="keyword">int</span> extraBikeNum[MAXN]; <span class="comment">// 各车站中有多少辆自行车是多余的</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXN]; <span class="comment">// 是否已求出PBMC到各车站的最短路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXN]; <span class="comment">// 在保证路径最短的前提下，最短路径中每个车站的前一个车站</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempPath;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历当前结点</span></span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>)&#123; <span class="comment">// 此时已形成一条最短路径的逆序，存储在tempPath中</span></span><br><span class="line">        <span class="keyword">int</span> stationNeed = <span class="number">0</span>, stationExtra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tempPath.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = tempPath[i];</span><br><span class="line">            <span class="keyword">if</span> (extraBikeNum[u] &gt; <span class="number">0</span>)&#123; <span class="comment">// 当前站点中自行车数量超过容量的一半，则可以送给后面的车站或者送回PBMC</span></span><br><span class="line">                stationExtra += extraBikeNum[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (extraBikeNum[u] &lt; <span class="number">0</span>)&#123; <span class="comment">// 当前站点中自行车数量少于容量的一半</span></span><br><span class="line">                <span class="keyword">if</span> (stationExtra + extraBikeNum[u] &gt;= <span class="number">0</span>)&#123; <span class="comment">// 前边车站多出来的自行车足够使当前车站半满</span></span><br><span class="line">                    stationExtra += extraBikeNum[u];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    stationNeed -= (stationExtra + extraBikeNum[u]);</span><br><span class="line">                    stationExtra = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stationNeed &lt; minStationNeed)&#123;</span><br><span class="line">            path = tempPath;</span><br><span class="line">            minStationNeed = stationNeed;</span><br><span class="line">            minStationExtra = stationExtra;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stationNeed == minStationNeed &amp;&amp; stationExtra &lt; minStationExtra)&#123;</span><br><span class="line">            path = tempPath;</span><br><span class="line">            minStationExtra = stationExtra;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; pre[v].size(); i++)</span><br><span class="line">        dfs(pre[v][i]);</span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    fill(e[<span class="number">0</span>], e[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(dis, dis + MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;cmax, &amp;n, &amp;sp, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;extraBikeNum[i]);</span><br><span class="line">        extraBikeNum[i] = extraBikeNum[i] - cmax / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        e[a][b] = e[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// PBMC为起点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minDis = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; dis[j] &lt; minDis)&#123;</span><br><span class="line">                minDis = dis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; e[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[u] + e[u][v] &lt; dis[v])&#123;</span><br><span class="line">                    dis[v] = dis[u] + e[u][v];</span><br><span class="line">                    pre[v].clear(); <span class="comment">// 新的最短路径，所以要clear</span></span><br><span class="line">                    pre[v].push_back(u); <span class="comment">// u是v的最短路径中v的前一个车站</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dis[u] + e[u][v] == dis[v])&#123;</span><br><span class="line">                    pre[v].push_back(u); <span class="comment">// u是v的最短路径中v的前一个车站</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(sp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d 0"</span>, minStationNeed);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = path.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-&gt;%d"</span>, path[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, minStationExtra);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52316405" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52316405</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1003Emergency</title>
    <link href="https://chouxianyu.github.io/2020/09/17/PAT%E7%94%B2%E7%BA%A71003Emergency/"/>
    <id>https://chouxianyu.github.io/2020/09/17/PAT甲级1003Emergency/</id>
    <published>2020-09-17T09:36:18.000Z</published>
    <updated>2020-09-20T10:27:05.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>有几个城市，每个城市中有多个救援队，城市间由公路相连，公路的长度不一</p></li><li><p>输入</p><ul><li><p>N：正整数，不超过500，城市的数量，城市索引为[0,N-1]</p></li><li><p>M：公路的数量</p></li><li><p>c1：你现在所在的城市</p></li><li><p>c2：你需要去的城市</p></li><li><p>各城市中救援队数量：N个整数</p></li><li><p>各条公路连接的两个城市其该公路的长度：M行</p><p>  保证c1到c2至少有一条路径</p></li></ul></li><li><p>输出</p><ul><li>c1到c2的最短路径的数量</li><li>在保证路径最短的前提下，最多可以聚集多少只救援队</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>dijkstra算法</p><ul><li><p>特点</p><ul><li>适用于边权为正的情况</li><li>单源最短路（Single-Source Shortest Paths，SSSP），求单个源点到所有结点的最短路</li><li>同时适用于有向图和无向图</li></ul></li><li><p>伪代码</p><p>  n个结点</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[n];  <span class="comment">// 标记：是否找到源点s到某点的最短路径</span></span><br><span class="line"><span class="keyword">int</span> dis[n]; <span class="comment">// 记录源点s到某点的最短路径的长度</span></span><br><span class="line"><span class="keyword">int</span> w[n][n]; <span class="comment">// 结点间的距离</span></span><br><span class="line"></span><br><span class="line">visited数组置<span class="literal">false</span>;</span><br><span class="line">dis数组置无穷大，dis[s]置<span class="number">0</span>;</span><br><span class="line">循环n次&#123;</span><br><span class="line">    寻找未被标记的、距离结点s最近的结点u;</span><br><span class="line">    如果找到u则将其标记(visited[u] = <span class="literal">true</span>),否则结束循环;</span><br><span class="line">    如果存在边&lt;u,v&gt;,则更新dis[v] = min(dis[v], dis[u] + w[u][v]); <span class="comment">// 贪心</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>其它</p><ul><li><p>c1到c2的最短路径的数量<code>pathNum</code></p><ul><li><p>如果<code>dis[v] &lt; dis[u] + w[u][v]</code>，则<code>pathNum[v] = path[u]</code></p><p>  u到v只有一条边，所以源点到u和v的路径的数量相等</p></li><li><p>如果<code>dis[v] == dis[u] + w[u][v]</code>，则<code>pathNum[v] = path[u] + path[v]</code></p><p>  在距离相等的情况下，除了经过u，还可以从其他结点到达v</p></li></ul></li><li><p>在保证路径最短的前提下，<strong>最多</strong>可以聚集多少只救援队</p><ul><li><p>如果<code>dis[v] &lt; dis[u] + w[u][v]</code>，则<code>teamGatherNum[v] = teamGatherNum[u] + teamNum[v]</code></p></li><li><p>如果<code>dis[v] == dis[u] + w[u][v]</code>，则<code>teamGatherNum[v] = min(teamGatherNum[v], teamGatherNum[u] + teamNum[v])</code></p><p>  此时最短路径不止一条，所以要判断哪条路径聚集的救援队更多</p></li></ul></li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1003</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376</span></span><br><span class="line"><span class="comment">// Tags: 最短路 djikstra DFS 单源最短路 贪心</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN =  <span class="number">500</span>; <span class="comment">// 最多500个城市</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = INT_MAX; <span class="comment">// 最大距离</span></span><br><span class="line"><span class="keyword">int</span> cityDis[MAXN][MAXN]; <span class="comment">// 城市间的距离</span></span><br><span class="line"><span class="keyword">int</span> teamNum[MAXN]; <span class="comment">// 每个城市中有多少个救援队</span></span><br><span class="line"><span class="keyword">int</span> shortestPathDis[MAXN]; <span class="comment">// 起点城市c1到各个城市最短路径的距离</span></span><br><span class="line"><span class="keyword">int</span> shortestPathNum[MAXN]; <span class="comment">// 起点城市c1到各个城市最短路径的数量</span></span><br><span class="line"><span class="keyword">int</span> teamGatherNum[MAXN]; <span class="comment">// 从起点城市c1到各个城市的最短路径上，最多能聚集到多少个救援队</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXN];  <span class="comment">// 标记：是否已求出起点城市c1到某城市的最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化变量</span></span><br><span class="line">    fill(cityDis[<span class="number">0</span>], cityDis[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    fill(shortestPathDis, shortestPathDis + MAXN, INF);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取输入</span></span><br><span class="line">    <span class="keyword">int</span> n, m, c1, c2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;n, &amp;m, &amp;c1, &amp;c2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;teamNum[i]);</span><br><span class="line">    <span class="keyword">int</span> a, b, d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;a, &amp;b, &amp;d);</span><br><span class="line">        cityDis[a][b] = cityDis[b][a] = d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化起点城市c1</span></span><br><span class="line">    shortestPathDis[c1] = <span class="number">0</span>;</span><br><span class="line">    teamGatherNum[c1] = teamNum[c1];</span><br><span class="line">    shortestPathNum[c1] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代直至求出起点城市c1到所有城市的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 寻找未被标记的、距离起点城市c1最近的城市u（贪心）</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minDis = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; shortestPathDis[j] &lt; minDis)&#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minDis = shortestPathDis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 各城市都已被标记，则已求出结果，退出循环即可；否则根据贪心策略，现在已求出起点城市c1到城市u的最短距离</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果有边&lt;u,v&gt;，则更新城市v的相关变量（最简洁的dijkstra算法只更新shortestPathDis[v]即可）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[v] &amp;&amp; cityDis[u][v] != INF)&#123;</span><br><span class="line">                <span class="keyword">if</span> (shortestPathDis[v] &gt; shortestPathDis[u] + cityDis[u][v])&#123;</span><br><span class="line">                    shortestPathDis[v] = shortestPathDis[u] + cityDis[u][v];</span><br><span class="line">                    shortestPathNum[v] = shortestPathNum[u];</span><br><span class="line">                    teamGatherNum[v] = teamGatherNum[u] + teamNum[v];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (shortestPathDis[v] == shortestPathDis[u] + cityDis[u][v])&#123;</span><br><span class="line">                    shortestPathNum[v] = shortestPathNum[u] + shortestPathNum[v];</span><br><span class="line">                    <span class="keyword">if</span> (teamGatherNum[v] &lt; teamGatherNum[u] + teamNum[v])</span><br><span class="line">                        teamGatherNum[v] = teamGatherNum[u] + teamNum[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, shortestPathNum[c2], teamGatherNum[c2]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/52300668" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/52300668</a></p><p><a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">https://blog.csdn.net/qq_35644234/article/details/60870719</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="贪心" scheme="https://chouxianyu.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="dijkstra" scheme="https://chouxianyu.github.io/tags/dijkstra/"/>
    
      <category term="最短路" scheme="https://chouxianyu.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="单源最短路" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1146Topological Order</title>
    <link href="https://chouxianyu.github.io/2020/09/15/PAT%E7%94%B2%E7%BA%A71146Topological-Order/"/>
    <id>https://chouxianyu.github.io/2020/09/15/PAT甲级1146Topological-Order/</id>
    <published>2020-09-15T15:41:24.000Z</published>
    <updated>2020-09-15T15:44:37.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个有向图，请判断一个序列是否是该有向图的拓扑序列。</p><ul><li><p>输入</p><ul><li>N：正整数，不超过1000，图中顶点的数量，顶点索引为[1,N]</li><li>M：正整数，不超过10000，有向边的数量</li><li>M条有向边：开始顶点索引、结束顶点索引</li><li>K：不超过100，待检验的序列的个数</li><li>K个序列：索引为[0,K]</li></ul></li><li><p>输出</p><p>  对于每个排列，如果不是拓扑排序则输出其索引</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>保存每个结点的前驱结点</li><li>使用一维数组保存每个结点是否已访问</li><li>遍历序列判断每个结点的前驱结点是否已访问，如果未访问，则该序列不是拓扑序列</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1146</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343043829760</span></span><br><span class="line"><span class="comment">// Tags: 拓扑序列 图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; before;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    before.resize(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        before[v2].push_back(v1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123; <span class="comment">// 判断k个序列</span></span><br><span class="line">        <span class="comment">// 保存一个序列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sequence[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断该序列是否是拓扑序列</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">bool</span> isTopological = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            v2 = sequence[j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = before[v2].begin(); iter != before[v2].end(); iter++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[*iter])&#123;</span><br><span class="line">                    isTopological = <span class="literal">false</span>;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isTopological)</span><br><span class="line">                visited[v2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">auto</span> iter = result.begin();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, *iter);</span><br><span class="line">    iter++;</span><br><span class="line">    <span class="keyword">while</span> (iter != result.end())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>, *iter);</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="拓扑序列" scheme="https://chouxianyu.github.io/tags/%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1135Is It A Red-Black Tree</title>
    <link href="https://chouxianyu.github.io/2020/09/15/PAT%E7%94%B2%E7%BA%A71135Is-It-A-Red-Black-Tree/"/>
    <id>https://chouxianyu.github.io/2020/09/15/PAT甲级1135Is-It-A-Red-Black-Tree/</id>
    <published>2020-09-15T09:09:22.000Z</published>
    <updated>2020-09-15T09:10:37.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>红黑树</p><p>  在二叉搜索树的基础上，红黑树还具有以下特征</p><ol><li><p>每个结点是红色或者黑色</p></li><li><p>根结点是黑色的</p></li><li><p>叶子结点（NULL）都是黑色</p></li><li><p>每个红色结点的两个子结点都是黑色</p><p> 从每个叶子到根的所有路径上不能有两个连续的红色结点</p></li><li><p>每个结点到其每个叶子结点的所有路径都包含相同数目的黑色节点。</p></li></ol></li></ul><p>给定一颗二叉搜索树，请判断它是否是一个合法的红黑树。</p><ul><li><p>输入</p><ul><li>K：正整数，不超过30，测试用例的数量</li><li>N：正整数，不超过30，二叉树中结点的数量</li><li>二叉树的先序遍历结果：结点的值都是正整数，用负数代表红色结点</li></ul></li><li><p>输出</p><p>  判断每颗二叉搜索树是否是红黑树，是则输出<code>Yes</code>，否则输出<code>No</code>。</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>根据先序遍历结果和二叉搜索树的性质（左子树小于根结点小于右子树），递归构建二叉树</li><li>判断性质3：根结点是否是黑色</li><li>判断性质4，见代码中的函数judge1</li><li>判断性质5，见代码中的函数judge2</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1135</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346063728640</span></span><br><span class="line"><span class="comment">// Tags: Tree BST RBTree</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* left = <span class="literal">nullptr</span>;</span><br><span class="line">    Node* right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">build</span><span class="params">(Node* root, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">        root-&gt;val = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(v) &lt;= <span class="built_in">abs</span>(root-&gt;val))</span><br><span class="line">        root-&gt;left = build(root-&gt;left, v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        root-&gt;right = build(root-&gt;right, v);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge1</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;val &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span> &amp;&amp; root-&gt;right-&gt;val &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judge1(root-&gt;left) &amp;&amp; judge1(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Node* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = max(getDepth(root-&gt;left), getDepth(root-&gt;right));</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val &gt; <span class="number">0</span> ? ret + <span class="number">1</span> : ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge2</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (getDepth(root-&gt;left) != getDepth(root-&gt;right))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> judge2(root-&gt;left) &amp;&amp; judge2(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, n, val;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        Node* root = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val);</span><br><span class="line">            root = build(root, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; <span class="number">0</span> || !judge1(root) || !judge2(root))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/78037334" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/78037334</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BST" scheme="https://chouxianyu.github.io/tags/BST/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="红黑树" scheme="https://chouxianyu.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1138Postorder Traversal</title>
    <link href="https://chouxianyu.github.io/2020/09/08/PAT%E7%94%B2%E7%BA%A71138Postorder-Traversal/"/>
    <id>https://chouxianyu.github.io/2020/09/08/PAT甲级1138Postorder-Traversal/</id>
    <published>2020-09-08T11:12:13.000Z</published>
    <updated>2020-09-08T11:13:50.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>假设二叉树中所有结点的值都是互异的正整数，给定二叉树的先序和后序遍历，请输出该树后序遍历的第一个数字。</p><ul><li>输入<ul><li>N：正整数，不超过50000，二叉树中结点的数量</li><li>先序遍历结果</li><li>中序遍历结果</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>根据先序遍历和中序遍历结果可以确定一颗树，这道题的关键就是如何确定出这颗树并遍历它。</p><p>  可以参考<a href="https://www.cnblogs.com/chouxianyu/p/13627616.html" target="_blank" rel="noopener">PAT甲级1151LCA in a Binary Tree</a>，这道题里也是根据先序遍历和中序遍历结果确定出了一棵树。</p></li><li><p>设置全局flag判断是否是该树后序遍历的第一个数字，如果是则输出，不是则不输出</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1138</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345078067200</span></span><br><span class="line"><span class="comment">// Tags: Tree DFS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preOrder; <span class="comment">// 先序遍历结果</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inOrder; <span class="comment">// 中序遍历结果</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inPos; <span class="comment">// 结点到中序遍历结果inOrder索引的映射</span></span><br><span class="line"><span class="keyword">bool</span> firstIsPrinted = <span class="literal">false</span>; <span class="comment">// 为true代表后序遍历时的第一个结点已经输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(<span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight, <span class="keyword">int</span> preRoot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstIsPrinted) <span class="comment">// 只输出后序遍历的第一个结点即可</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (inRight &lt; inLeft) <span class="comment">// 该树不存在</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> inRoot = inPos[preOrder[preRoot]]; <span class="comment">// 当前树的根结点在中序遍历结果inOrder中的索引</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    postOrderTraverse(inLeft, inRoot - <span class="number">1</span>, preRoot + <span class="number">1</span>);        <span class="comment">// 遍历左子树并判断左子树是否存在</span></span><br><span class="line">    postOrderTraverse(inRoot + <span class="number">1</span>, inRight, preRoot + <span class="number">1</span> + (inRoot - inLeft)); <span class="comment">// 遍历右子树并判断右子树是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!firstIsPrinted)&#123; <span class="comment">// 只输出后序遍历的第一个结点即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, inOrder[inRoot]);</span><br><span class="line">        firstIsPrinted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    preOrder.resize(n + <span class="number">1</span>);</span><br><span class="line">    inOrder.resize(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 读取先序遍历结果</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;preOrder[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;  <span class="comment">// 读取中序遍历结果</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inOrder[i]);</span><br><span class="line">        inPos[inOrder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postOrderTraverse(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1143Lowest Common Ancestor</title>
    <link href="https://chouxianyu.github.io/2020/09/07/PAT%E7%94%B2%E7%BA%A71143Lowest-Common-Ancestor/"/>
    <id>https://chouxianyu.github.io/2020/09/07/PAT甲级1143Lowest-Common-Ancestor/</id>
    <published>2020-09-07T13:47:30.000Z</published>
    <updated>2020-09-07T13:49:27.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>最近公共祖先（LCA，The lowest common ancestor）</p><p>  在一颗树中，结点U和V的LCA是U和V为其后代的深度最大的结点。</p></li><li><p>二叉搜索树（BST，binary search tree）</p><ul><li>树中的每个结点的值都大于其左子树中结点的值</li><li>树中的每个结点的值都不超过其右子树中结点的值</li><li>每个结点的左子树和右子树都是二叉搜索树</li></ul></li></ul><p>给定一个二叉搜索树中的任意两个结点，请找到他们的LCA。</p><ul><li><p>输入</p><ul><li>M：正整数，不超过1000，需要测试的结点对的数量</li><li>N：正整数，不超过10000，二叉搜索树中结点的数量</li><li>N个结点（互异）：按照先序遍历的顺序给出，值都在int范围内</li><li>M个结点对</li></ul></li><li><p>输出</p><p>  对于每个结点对，判断结点对中每个结点是否存在，如果都存在则找到他们的LCA。</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>不需建树</p><ul><li><p>判断结点是否在树中</p><p>  读取树的先序遍历时使用map记录一个结点是否在树中</p></li><li><p>寻找LCA</p><p>  根据BST的性质，如果一个结点的值处于u和v的值之间，那这个结点就是u和v的LCA。</p></li></ul><p>这道题涉及LCA，也可以看看另外一道题：<a href="https://www.cnblogs.com/chouxianyu/p/13627616.html" target="_blank" rel="noopener">PAT甲级1151 LCA in a Binary Tree</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1143</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343727501312</span></span><br><span class="line"><span class="comment">// Tags: Tree BST LCA map</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, u, v, a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preOrder(n);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; exists;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// 读取先序遍历结果并记录结点是否出现过</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;preOrder[i]);</span><br><span class="line">        exists[preOrder[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123; <span class="comment">// m个结点对</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123; <span class="comment">// 寻找LCA</span></span><br><span class="line">            a = preOrder[i];</span><br><span class="line">            <span class="keyword">if</span> (u &lt; a &amp;&amp; v &gt; a || v &lt; a &amp;&amp; u &gt; a || (a == u) || (a == v) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exists[u] == <span class="literal">false</span> &amp;&amp; exists[v] == <span class="literal">false</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d and %d are not found.\n"</span>, u, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (exists[u] == <span class="literal">false</span> || exists[v] == <span class="literal">false</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>, exists[u]==<span class="literal">false</span> ? u : v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == u || a == v)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, a, a == u ?  v : u);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>, u, v, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="BST" scheme="https://chouxianyu.github.io/tags/BST/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
      <category term="LCA" scheme="https://chouxianyu.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1151LCA in a Binary Tree</title>
    <link href="https://chouxianyu.github.io/2020/09/07/PAT%E7%94%B2%E7%BA%A71151LCA-in-a-Binary-Tree/"/>
    <id>https://chouxianyu.github.io/2020/09/07/PAT甲级1151LCA-in-a-Binary-Tree/</id>
    <published>2020-09-07T08:26:28.000Z</published>
    <updated>2020-09-08T11:16:47.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1038430130011897856" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1038430130011897856</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>最近公共祖先（LCA，The lowest common ancestor）</p><p>  在一颗树中，结点U和V的LCA是U和V为其后代的深度最大的结点。</p></li></ul><p>给定一颗二叉树中的任意两个结点，请找到它们的LCA。</p><ul><li><p>输入</p><ul><li>M：正整数，不超过1000，需要测试的结点对的数量</li><li>N：正整数，不超过10000，二叉树中结点的数量，结点值都在int范围内</li><li>二叉树中序遍历结果：N个数字</li><li>二叉树先序遍历结果：N个数字</li><li>M个结点对：</li></ul></li><li><p>输出</p><p>  对于每个结点对，判断结点对中每个结点是否存在，如果都存在则找到他们的LCA。</p></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="根据先序遍历结果和中序遍历结果可以确定一颗树"><a href="#根据先序遍历结果和中序遍历结果可以确定一颗树" class="headerlink" title="根据先序遍历结果和中序遍历结果可以确定一颗树"></a>根据先序遍历结果和中序遍历结果可以确定一颗树</h3><p>中序遍历结果加先序遍历结果可以唯一确定一棵树，在不构建树的情况下，在每一层的递归中，可以得到树的根结点。</p><ol><li><p>使用两个数组分别保存树的先序遍历结果和后序遍历结果</p></li><li><p>根据先序遍历结果可以确定根节点</p><p> 比如刚开始的第一个结点就是整棵树的根结点</p></li><li><p>根据中序遍历结果和整棵树的根结点可以确定整棵树的左右子树</p><p> 中序遍历结果中，根结点左侧就是整棵树的左子树的中序遍历结果，根结点右侧就是整棵树的右子树的中序遍历结果</p></li><li><p>递归确定左右子树的结构</p><p> 某颗树的结构可根据2个变量确定：其根结点在整颗树先序遍历结果中的索引、其中序遍历结果序列（可通过起始索引和结束索引2个变量确定）</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> leftPosBoundOfInOrder, <span class="keyword">int</span> rightPosBoundOfInOrder, <span class="keyword">int</span> rootPosOfPreOrder)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    当前这颗树在整棵树中序遍历结果inOrder的范围索引为[leftPosBoundOfInOrder,rightPosBoundOfInOrder]</span></span><br><span class="line"><span class="comment">    rootPosOfPreOrder指当前这颗树根结点在整棵树先序遍历结果preOrder中的索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 越界判断</span></span><br><span class="line">    <span class="keyword">if</span> (leftPosBoundOfInOrder &gt; rightPosBoundOfInOrder) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    lca(leftPosBoundOfInOrder, rootPosOfInOrder - <span class="number">1</span>, rootPosOfPreOrder + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 右子树</span></span><br><span class="line">    lca(rootPosOfInOrder + <span class="number">1</span>, rightPosBoundOfInOrder, rootPosOfPreOrder + (rootPosOfInOrder - leftPosBoundOfInOrder) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>, n, <span class="number">1</span>); <span class="comment">// 调用（假设整颗树有n个结点，在数组中的索引为[1,n]）</span></span><br></pre></td></tr></table></figure></li></ol><p><a href="https://www.cnblogs.com/chouxianyu/p/13634613.html" target="_blank" rel="noopener">PAT甲级1138Postorder Traversal</a>这道题也涉及如何根据先序遍历结果和中序遍历结果确定一棵树并遍历它，可以看一看。</p><h3 id="最近公共祖先LCA"><a href="#最近公共祖先LCA" class="headerlink" title="最近公共祖先LCA"></a>最近公共祖先LCA</h3><p>已知某颗树的根结点，</p><ol><li>若u和u在根结点的左边，则u和v的最近公共祖先在当前子树根结点的左子树寻找；</li><li>如果u和v在当前子树根结点的右边，则u和v的最近公共祖先就在当前子树的右子树寻找；</li><li>如果u和v在当前子树根结点的两边，在当前子树的根结点就是u和v的最近公共祖先；</li><li>如果u或v就是根结点，那其就是这两个结点的最近公共祖先。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1151</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038430130011897856</span></span><br><span class="line"><span class="comment">// Tags: Tree LCA Map</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inOrder, preOrder;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> leftPosBoundOfInOrder, <span class="keyword">int</span> rightPosBoundOfInOrder, <span class="keyword">int</span> rootPosOfPreOrder)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    当前这颗树在整棵树中序遍历结果inOrder的范围索引为[leftPosBoundOfInOrder,rightPosBoundOfInOrder]</span></span><br><span class="line"><span class="comment">    rootPosOfPreOrder指当前这颗树根结点在整棵树先序遍历结果preOrder中的索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (leftPosBoundOfInOrder &gt; rightPosBoundOfInOrder) <span class="keyword">return</span>; <span class="comment">// 越界判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rootPosOfInOrder = pos[preOrder[rootPosOfPreOrder]]; <span class="comment">// 根结点在中序遍历结果中的索引</span></span><br><span class="line">    <span class="keyword">int</span> uPosOfInorder = pos[u]; <span class="comment">// 结点u在中序遍历结果中的索引</span></span><br><span class="line">    <span class="keyword">int</span> vPosOfInorder = pos[v]; <span class="comment">// 结点v在中序遍历结果中的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// u和v都在左子树就去左子树找</span></span><br><span class="line">    <span class="keyword">if</span> (uPosOfInorder &lt; rootPosOfInOrder &amp;&amp; vPosOfInorder &lt; rootPosOfInOrder)</span><br><span class="line">        lca(leftPosBoundOfInOrder, rootPosOfInOrder - <span class="number">1</span>, rootPosOfPreOrder + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// u和v都在右子树就去右子树找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (uPosOfInorder &gt; rootPosOfInOrder &amp;&amp; vPosOfInorder &gt; rootPosOfInOrder)</span><br><span class="line">        lca(rootPosOfInOrder + <span class="number">1</span>, rightPosBoundOfInOrder, rootPosOfPreOrder + (rootPosOfInOrder - leftPosBoundOfInOrder) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// u和v在分别在左右子树，则当前树的根节点就是LCA</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((uPosOfInorder &lt; rootPosOfInOrder &amp;&amp; vPosOfInorder &gt; rootPosOfInOrder) || (uPosOfInorder &gt; rootPosOfInOrder &amp;&amp; vPosOfInorder &lt; rootPosOfInOrder))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>, u, v, preOrder[rootPosOfPreOrder]);</span><br><span class="line">    <span class="comment">// 结点u就是根结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (uPosOfInorder == rootPosOfInOrder)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, u, v);</span><br><span class="line">    <span class="comment">// 结点v就是根结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vPosOfInorder == rootPosOfInOrder)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n; <span class="comment">// 结点对个数，结点个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    inOrder.resize(n + <span class="number">1</span>), preOrder.resize(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 记录中序遍历结果，并记录各结点的索引</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inOrder[i]);</span><br><span class="line">        pos[inOrder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 记录先序遍历结果</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;preOrder[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pos[u] == <span class="number">0</span> &amp;&amp; pos[v] == <span class="number">0</span>) <span class="comment">// 判断元素是否存在</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d and %d are not found.\n"</span>, u, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos[u] == <span class="number">0</span> || pos[v] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>, pos[u] == <span class="number">0</span> ? u : v);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lca(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/80452127" target="_blank" rel="noopener">https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/80452127</a></p><p><a href="https://blog.csdn.net/liuchuo/article/details/82560863" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/82560863</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
      <category term="LCA" scheme="https://chouxianyu.github.io/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1142Maximal Clique</title>
    <link href="https://chouxianyu.github.io/2020/09/06/PAT%E7%94%B2%E7%BA%A71142Maximal-Clique/"/>
    <id>https://chouxianyu.github.io/2020/09/06/PAT甲级1142Maximal-Clique/</id>
    <published>2020-09-06T10:55:23.000Z</published>
    <updated>2020-09-06T11:21:04.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>团：某无向图的一个顶点子集，其中任意两个不同的顶点相邻，则这个顶点子集是这个图的一个团。</li><li>极大团：如果一个团在加入任何一个顶点后都不再是一个团，则这个团是一个极大团。</li></ul><p>现在给你一个图，请你判断一些点集是否是团或极大团。</p><ul><li><p>输入</p><ul><li>Nv：正整数，不超过200，图中顶点的数量</li><li>Ne：正整数，图中边的数量</li><li>Ne条边：顶点索引为[1,Nv]</li><li>M：正整数，不超过100，需要判断的顶点子集的个数</li><li>M个顶点子集：第一个数字k是顶点个数（不超过Nv），剩下的数字是顶点索引</li></ul></li><li><p>输出</p><p>  对于每个顶点子集，请判断它是最大团还是最大团以外的团或者不是团</p></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>使用邻接矩阵保存边，用二维数组表示</p></li><li><p>使用vector保存顶点子集，并使用set保存顶点子集以外的顶点</p></li><li><p>根据定义判断顶点子集中的顶点是否两两相邻，如果是则为团，不是则不是团</p></li><li><p>如果是团，根据最大团的定义，遍历顶点子集以外的顶点，判断是否可以再添加一个顶点且该顶点与顶点子集中每个顶点都相邻</p><p> 如果可以则说明不是极大团，不可以则不是极大团</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1142</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343979159552</span></span><br><span class="line"><span class="comment">// Tags: Graph Clique Maximal Clique</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> edge[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ne, nv, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;nv, &amp;ne);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ne; i++)&#123; <span class="comment">// 记录边</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        edge[v1][v2] = edge[v2][v1] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--)&#123; <span class="comment">// 判断m个顶点子集</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; leftV; <span class="comment">// 该顶点子集以外的结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nv; i++)&#123;</span><br><span class="line">            leftV.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123; <span class="comment">// 记录顶点子集</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[i]);</span><br><span class="line">            leftV.erase(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isClique = <span class="literal">true</span>; <span class="comment">// 先判断是否是团</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (edge[v[i]][v[j]] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    isClique = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isClique == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isClique == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Not a Clique\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isMaximalClique = <span class="literal">true</span>; <span class="comment">// 如果是团，再判断是不是极大团（按照定义判断）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = leftV.begin(); it != leftV.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (edge[*it][v[i]] == <span class="literal">true</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k)&#123;</span><br><span class="line">                isMaximalClique = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isMaximalClique) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not Maximal\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="set" scheme="https://chouxianyu.github.io/tags/set/"/>
    
      <category term="团" scheme="https://chouxianyu.github.io/tags/%E5%9B%A2/"/>
    
      <category term="极大团" scheme="https://chouxianyu.github.io/tags/%E6%9E%81%E5%A4%A7%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1155Heap Paths</title>
    <link href="https://chouxianyu.github.io/2020/09/06/PAT%E7%94%B2%E7%BA%A71155Heap-Paths/"/>
    <id>https://chouxianyu.github.io/2020/09/06/PAT甲级1155Heap-Paths/</id>
    <published>2020-09-06T06:13:32.000Z</published>
    <updated>2020-09-07T02:56:41.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>堆（大顶堆或小顶堆）中，任意一条从根结点到叶子结点的路径上的值一定是非递增序列或者非递减序列。</p><p>现在给定一个完全二叉树，请检查它的每一条路径，判断这棵树是不是堆。</p><ul><li><p>输入</p><ul><li>N：正整数，大于1，不超过1000，树中结点的数量</li><li>N个结点的值（互异）：都是int范围内，按照层次遍历的顺序给出</li></ul></li><li><p>输出</p><p>  对于每棵树</p><ol><li><p>先输出所有从根结点到叶子结点的路径，每条路径占一行，数字间用一个空格间隔，首尾不能有多余空格</p><p> 输出顺序：对于每个结点，其右子树的所有路径要先于其左子树的所有路径输出</p></li><li><p>输出这颗树是大顶堆还是小顶堆，或者它不是堆</p></li></ol></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>利用完全二叉树的性质，将结点记录到一维数组中</li><li>使用DFS，使用vecotr记录当前遍历到的所有结点（即路径），如果当前结点是叶子结点则输出这条路径，否则先遍历右子树再遍历左子树</li><li>在DFS过程中判断是否违背大小顶堆性质</li><li>最后输出该树是否是大小顶堆</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1155</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785408849047552</span></span><br><span class="line"><span class="comment">// Tags: Tree DFS Heap</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> isMaxHeap = <span class="literal">true</span>, isMinHeap = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> nodes[<span class="number">2010</span>]; <span class="comment">// 索引为[1,n]的元素有效</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 目前遍历到的所有结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) <span class="keyword">return</span>; <span class="comment">// 越界则无操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1</span>)&#123; <span class="comment">// 检查是否是大小顶堆</span></span><br><span class="line">        <span class="keyword">if</span> (nodes[i] &gt; nodes[i / <span class="number">2</span>]) isMaxHeap = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nodes[i] &lt; nodes[i / <span class="number">2</span>]) isMinHeap = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.push_back(nodes[i]); <span class="comment">// 遍历当前结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * i &gt; n &amp;&amp; <span class="number">2</span> * i + <span class="number">1</span> &gt; n)&#123; <span class="comment">// 是叶子结点则输出当前遍历到的所有结点</span></span><br><span class="line">        <span class="keyword">auto</span> it = path.begin();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, *it);</span><br><span class="line">        it++;</span><br><span class="line">        <span class="keyword">while</span> (it != path.end())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, *it);</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 不是叶子结点</span></span><br><span class="line">        dfs(<span class="number">2</span> * i + <span class="number">1</span>); <span class="comment">// 遍历右子树</span></span><br><span class="line">        dfs(<span class="number">2</span> * i); <span class="comment">// 遍历左子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;  <span class="comment">// 记录结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, nodes+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>); <span class="comment">// 深度优先遍历树并在过程中判断是否为大顶堆或小顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isMaxHeap) <span class="built_in">printf</span>(<span class="string">"Max Heap"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isMinHeap) <span class="built_in">printf</span>(<span class="string">"Min Heap"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not Heap"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="回溯" scheme="https://chouxianyu.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="堆" scheme="https://chouxianyu.github.io/tags/%E5%A0%86/"/>
    
      <category term="完全二叉树" scheme="https://chouxianyu.github.io/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1147Heaps</title>
    <link href="https://chouxianyu.github.io/2020/09/05/PAT%E7%94%B2%E7%BA%A71147Heaps/"/>
    <id>https://chouxianyu.github.io/2020/09/05/PAT甲级1147Heaps/</id>
    <published>2020-09-05T07:08:26.000Z</published>
    <updated>2020-09-06T08:33:34.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个完全二叉树，请判断它是不是堆（大顶堆指父结点的值大于等于子结点的值，小顶堆指父结点的值小于等于子结点的值）</p><ul><li>输入<ul><li>M：需要测试的树的数量，不超过100</li><li>N：每颗树中值的数量，大于1，不超过1000</li><li>M颗树：每颗树包含N个互异的值（int范围内），按照层次遍历的顺序给出</li></ul></li><li>输出<ul><li>对于每颗树，输出它是最大堆还是最小堆，或者它不是个堆，然后后序遍历输出这个树，值之间用空格间隔</li></ul></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>完全二叉树性质<ul><li>如果某结点的序号为<code>i</code>，如果它的左右子结点存在，那左子结点序号为<code>2i</code>，右子结点序号为<code>2i+1</code>。</li><li>相应地，如果某子结点的序号为<code>i</code>，那其父结点的序号为<code>i/2</code>，其中<code>i</code>为int类型、只取<code>i/2</code>所得结果的整数部分。</li></ul></li></ul><ol><li>因为是完全二叉树，所以不用建树，将所有结点按层次遍历的顺序存入数组即可</li><li>遍历除了根结点以外的结点，判断是否违反大顶堆或小顶堆的特点，然后输出是否是堆</li><li>递归实现后序遍历</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1147</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805342821531648</span></span><br><span class="line"><span class="comment">// Tags: Tree DFS Heap</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nodes[<span class="number">1005</span>]; <span class="comment">// 存储n个结点</span></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTrace</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) <span class="keyword">return</span> ; <span class="comment">// 避免越界</span></span><br><span class="line">    postOrderTrace(<span class="number">2</span> * i);</span><br><span class="line">    postOrderTrace(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, nodes[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, nodes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 读取树</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, nodes+i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isMaxHeap = <span class="literal">true</span>, isMinHeap = <span class="literal">true</span>; <span class="comment">// 遍历判断是否是大小顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (nodes[i] &gt; nodes[i/<span class="number">2</span>]) isMaxHeap = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nodes[i] &lt; nodes[i/<span class="number">2</span>]) isMinHeap = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isMaxHeap) <span class="built_in">printf</span>(<span class="string">"Max Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(isMinHeap) <span class="built_in">printf</span>(<span class="string">"Min Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line"></span><br><span class="line">        postOrderTrace(<span class="number">1</span>); <span class="comment">// 后序遍历完全二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/chouxianyu/p/13293152.html" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/p/13293152.html</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="堆" scheme="https://chouxianyu.github.io/tags/%E5%A0%86/"/>
    
      <category term="完全二叉树" scheme="https://chouxianyu.github.io/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1150Travelling Salesman Problem</title>
    <link href="https://chouxianyu.github.io/2020/09/05/PAT%E7%94%B2%E7%BA%A71150Travelling-Salesman-Problem/"/>
    <id>https://chouxianyu.github.io/2020/09/05/PAT甲级1150Travelling-Salesman-Problem/</id>
    <published>2020-09-05T05:03:36.000Z</published>
    <updated>2020-09-05T05:04:26.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>现在给你一些环，请你找到其中与旅行商问题答案最接近的那个环（旅行商问题的定义在此不再说明）</li><li>输入<ul><li>N：大于2，不超过200，城市的数量</li><li>M：无向图中边的数量，</li><li>M条边：每条边表示为<code>City1 City2 Dist</code>，其中城市索引为[1,N]，城市间距离为不超过100的正数</li><li>K：正整数，path的数量</li><li>K条path：每条path的格式为：<code>n c1 c2 c3 … cn</code>，其中n是path中城市的数量，ci是城市索引</li></ul></li><li>输出<ul><li>对于每条path，输出<code>Path X: TotalDist (Description)</code>，其中X是[1,K]，TotalDist是总距离（不存在则输出NA），Description是<ul><li>经过每个城市的简单环：<code>TS simple cycle</code></li><li>经过每个城市的环，但不是简单环：<code>TS cycle</code></li><li>不是经过每个城市的环：<code>Not a TS cycle</code></li></ul></li><li>最终输出<code>Shortest Dist(X) = TotalDist</code>，其中X是和旅行商问题解最接近的那个环的索引，TotalDist是其距离总和。（已确保只有一个解）</li></ul></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>距离用二维数组表示，默认值为0，为0则说明两个城市间不存在边</p></li><li><p>读取每条path时，用一维数组存储某个节点被访问的次数（注意城市索引是1到N）</p><p>  在路径合法的前提下</p><ul><li>TS cycle：即经过每个城市并且是一个环，即每个城市被访问的次数都大于0且首尾城市相同</li><li>TS simple cycle：在TS cycle的基础上，要求没有子环，只有起点城市被访问过2次，其它城市都只被访问过一次</li></ul></li><li><p>将k个path的结果存放在一维数组中</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1150</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038430013544464384</span></span><br><span class="line"><span class="comment">// Tags: Graph TSP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> distances[<span class="number">205</span>][<span class="number">205</span>]; <span class="comment">// 各个城市之间的距离。如果为0，则说明两个城市间无边、不可直达</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c1, c2, dist;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 存储各个城市之间的距离</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;c1, &amp;c2, &amp;dist);</span><br><span class="line">        distances[c1][c2] = distances[c2][c1] = dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bestX, bestDist = INT_MAX;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= k; x++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> numOfCities, firstCity, pathTotalDist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> pathIslegal = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;numOfCities, &amp;firstCity);</span><br><span class="line">        visited[firstCity] += <span class="number">1</span>; <span class="comment">// 访问第一个城市</span></span><br><span class="line">        c1 = firstCity; <span class="comment">// 更新上一个城市</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numOfCities - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c2); <span class="comment">// 读取当前城市</span></span><br><span class="line">            <span class="keyword">if</span> (distances[c1][c2] != <span class="number">0</span>)&#123;</span><br><span class="line">                visited[c2] += <span class="number">1</span>;</span><br><span class="line">                pathTotalDist += distances[c1][c2]; <span class="comment">// 计算该路径的总距离</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// path中两个城市不存在边</span></span><br><span class="line">                pathIslegal = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c1 = c2; <span class="comment">// 更新上一个城市</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pathIslegal)&#123; <span class="comment">// 路径非法</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: NA (Not a TS cycle)\n"</span>, x);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstCity != c2)&#123; <span class="comment">// 在路径合法的前提下，第一个城市和最后一个城市不同，则该路径不是环</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (Not a TS cycle)\n"</span>, x, pathTotalDist);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isTS = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                isTS = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isTS)&#123; <span class="comment">// 该路径没有经过所有城市</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (Not a TS cycle)\n"</span>, x, pathTotalDist);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isSimple = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123; <span class="comment">// 已确保是环且经过所有城市，判断是否是简单环，并更新最短TS环路</span></span><br><span class="line">            <span class="keyword">if</span> (pathTotalDist &lt; bestDist)&#123;</span><br><span class="line">                bestX = x;</span><br><span class="line">                bestDist = pathTotalDist;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != firstCity &amp;&amp; visited[i] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                isSimple = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSimple)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (TS simple cycle)\n"</span>, x, pathTotalDist);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (TS cycle)\n"</span>, x, pathTotalDist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Shortest Dist(%d) = %d\n"</span>, bestX, bestDist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="TSP" scheme="https://chouxianyu.github.io/tags/TSP/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1149Dangerous Goods Packaging</title>
    <link href="https://chouxianyu.github.io/2020/09/02/PAT%E7%94%B2%E7%BA%A71149Dangerous-Goods-Packaging/"/>
    <id>https://chouxianyu.github.io/2020/09/02/PAT甲级1149Dangerous-Goods-Packaging/</id>
    <published>2020-09-02T08:09:05.000Z</published>
    <updated>2020-09-02T08:10:47.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>当用容器运输货物时，一些货物是不能装在一起的。现在告诉你哪些货物能装在一起，给你一些货物，请判断这些货物是否可以被装在一起</p><ul><li><p>输入</p><ul><li><p>N：不能装在一起的货物对的数量，不超过10000</p></li><li><p>M：要运输的货物的组数，不超过100</p></li><li><p>N组不能装在一起的货物：每组包括两个货物索引</p></li><li><p>M组货物</p><p>  第一个数字K（不超过1000）是货物的数量，然后剩下的是货物索引（5位数字）</p></li></ul></li><li><p>输出</p><p>  对于M组货物中的每组，如果其中没有不可以装在一起的货物则输出Yes，否则输出No</p></li></ul><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>这个思路会超时</strong></p><ol><li>通过map和hash记录两个货物是否可以被装在一起，相当于一个邻接矩阵<ul><li>为什么不定义矩阵？如果要用矩阵，在这里就需要定义一个100000×100000的bool矩阵，大概会占用10GB，而内存限制是64MB。</li></ul></li><li>对于每组货物，两两判断是否不相容，是一个两层循环，时间复杂度是$K^2$，再算上M组查询，时间复杂度就是$MK^2$，最大值为100×1000×1000=1e8，大概会耗时1秒，肯定会超过400ms的时间限制。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1149</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176</span></span><br><span class="line"><span class="comment">// Tags: Graph Map Hash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> good1, good2;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; incompatible; <span class="comment">// 通过map和hash记录两个货物是否可以被装在一起</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n--)&#123; <span class="comment">// 通过map和hash记录两个货物是否可以被装在一起</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;good1, &amp;good2);</span><br><span class="line">        incompatible[good1 * <span class="number">100000</span> + good2] = <span class="literal">true</span>;</span><br><span class="line">        incompatible[good2 * <span class="number">100000</span> + good1] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)&#123; <span class="comment">//判断m组货物</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goods(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) <span class="comment">// 记录k个货物</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;goods[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> isYes = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123; <span class="comment">//判断k个货物是否可以放在一起</span></span><br><span class="line">            good1 = goods[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; k; j++)&#123;</span><br><span class="line">                good2 = goods[j];</span><br><span class="line">                <span class="keyword">if</span> (incompatible[good1 * <span class="number">100000</span> + good2] || incompatible[good2 * <span class="number">100000</span> + good1])&#123;</span><br><span class="line">                    isYes = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (isYes)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol><li><p>使用邻接表保存每个货物的不能装在一起的货物</p></li><li><p>对于每组货物，使用一维数组保存每个货物是否在这组货物中</p></li><li><p>查询邻接表，并通过一维数组判断每个货物的不相容货物是否出现在这组货物中</p><p> 这里也是用了两层循环，但这两层循环的时间复杂度是$N$，再算上M组查询，时间复杂度就是$MN$，最大值为100×10000=1e6。</p></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1149</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429908921778176</span></span><br><span class="line"><span class="comment">// Tags: Graph Map Hash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; incompatible[<span class="number">100000</span>]; <span class="comment">// 邻接表，货物与哪些货物不能装在一起</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, good1, good2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;  <span class="comment">// 建立邻接表</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;good1, &amp;good2);</span><br><span class="line">        incompatible[good1].push_back(good2);</span><br><span class="line">        incompatible[good2].push_back(good1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--)&#123; <span class="comment">// m组货物</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; goods(k); <span class="comment">// 该组货物</span></span><br><span class="line">        <span class="keyword">bool</span> contained[<span class="number">100000</span>]=&#123;<span class="literal">false</span>&#125;; <span class="comment">// 该组货物中有哪些货物</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123; <span class="comment">// 记录该组货物</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;goods[i]);</span><br><span class="line">            contained[goods[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isYes = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123; <span class="comment">// 查询邻接表，并通过一维数组判断每个货物的不相容货物是否出现在这组货物中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; incompatible[goods[i]].size(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (contained[incompatible[goods[i]][j]])&#123;</span><br><span class="line">                    isYes = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (isYes)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/82560836" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/82560836</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="哈希" scheme="https://chouxianyu.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1134Vertex Cover</title>
    <link href="https://chouxianyu.github.io/2020/09/01/PAT%E7%94%B2%E7%BA%A71134Vertex-Cover/"/>
    <id>https://chouxianyu.github.io/2020/09/01/PAT甲级1134Vertex-Cover/</id>
    <published>2020-09-01T14:18:12.000Z</published>
    <updated>2020-09-06T08:32:36.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088</a></p><h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><ul><li><p>vertex cover</p><p>  vertex cover指图中的每条边都和这组顶点中至少一个顶点相关，先给定一个图和几组顶点，请判断这几组顶点是否为vertex cover</p></li><li><p>输入</p><ul><li><p>N：顶点数量，不超过10000</p></li><li><p>M：边的数量，不超过10000</p></li><li><p>M条边：顶点通过[0,N-1]表示/索引</p></li><li><p>K：有几组顶点，不超过100</p></li><li><p>K组顶点</p><p>  一组顶点的第一个数字是顶点数量，剩下的是顶点索引</p></li></ul></li><li><p>输出</p><ul><li>是vertex则输出Yes，不是则输出No</li></ul></li></ul><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>定义Edge结构体，包括两个端点</p></li><li><p>把M条边存入vector</p></li><li><p>将顶点组存入set（vector也可以）</p></li><li><p>遍历每条边判断其两个端点是否在set中</p><p>  只要有一条边的两个端点都不在set中，则不是vertex cover</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1134</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088</span></span><br><span class="line"><span class="comment">// Tags: Graph Hash Set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges(m); <span class="comment">// 存储边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;edges[i].v1, &amp;edges[i].v2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; vertices;</span><br><span class="line">        <span class="keyword">int</span> vertexNum, vertex;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vertexNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++)&#123; <span class="comment">// 将一组顶点存入set</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vertex);</span><br><span class="line">            vertices.insert(vertex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> isVertexCover = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = edges.begin(); it != edges.end(); it++)&#123;</span><br><span class="line">            <span class="comment">// 只要有一条边的两个端点都不在set中，则不是vertex cover</span></span><br><span class="line">            <span class="keyword">if</span> (vertices.find(it-&gt;v1) == vertices.end() &amp;&amp; vertices.find(it-&gt;v2) == vertices.end())&#123;</span><br><span class="line">                isVertexCover = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isVertexCover)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><p>比上一个方法快</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>给M条边编号为[0,M-1]</li><li>读取每条边时，保存每个顶点与哪条边相关，将这个信息存入vector</li><li>定义vector表示各条边是否被覆盖，遍历上一步得到的vector标记各条边是否被覆盖，最后遍历这一步定义的vector判断是否符合vertex cover的条件</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>一个顶点可以和多条边相关</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1134</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346428633088</span></span><br><span class="line"><span class="comment">// Tags: Graph Hash Set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cover[n]; <span class="comment">// cover[2].push_back(3) 代表顶点2覆盖了边3</span></span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">        cover[v1].push_back(i);</span><br><span class="line">        cover[v2].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; isCovered(m, <span class="literal">false</span>); <span class="comment">// m条边是否被覆盖</span></span><br><span class="line">        <span class="keyword">int</span> vertexNum, vertex;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vertexNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++)&#123; <span class="comment">// 遍历顶点，将其覆盖的边标记</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vertex);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cover[vertex].size(); j++)</span><br><span class="line">                isCovered[cover[vertex][j]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isVertexCover = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isCovered[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">                isVertexCover = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;       </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isVertexCover)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/78037329" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/78037329</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="set" scheme="https://chouxianyu.github.io/tags/set/"/>
    
      <category term="点覆盖" scheme="https://chouxianyu.github.io/tags/%E7%82%B9%E8%A6%86%E7%9B%96/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1139First Contact</title>
    <link href="https://chouxianyu.github.io/2020/09/01/PAT%E7%94%B2%E7%BA%A71139First-Contact/"/>
    <id>https://chouxianyu.github.io/2020/09/01/PAT甲级1139First-Contact/</id>
    <published>2020-09-01T09:16:39.000Z</published>
    <updated>2020-09-01T09:18:59.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>背景</p><p>  男生A喜欢女孩B，A找男生C让女孩D跟B说，其中C是A的朋友，D是B和C的朋友。女生也是这样联系男生</p></li><li><p>输入</p><ul><li>N：人的数量，1到300</li><li>M：朋友关系的数量</li><li>M个朋友关系：用4位数字表示一个人，其中负数代表性别是女生</li><li>K：查询数量，不超过100</li><li>K次查询：每次查询是A和B的ID，假设A喜欢B</li></ul></li><li><p>输出</p><ul><li><p>输出有几对C和D可以帮助A联系B</p></li><li><p>输出这几对C和D</p><ul><li><p>如果A和B是异性，则A和C应该是同性，B和D同性；如果A和B是同性，则这4人性别应该相同</p><p>  即A和C同性，B和D同性</p></li><li><p>先按C的ID非降序输出，再按D的ID增序输出</p></li></ul></li></ul></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>使用邻接矩阵表示两个人是否是朋友，用邻接表存储一个人的同性朋友</li><li>给定A和B以后，枚举A的朋友C，枚举B的朋友D，如果C和D是朋友则保存C和D</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>输出时要以4位数字输出，用<code>printf(&quot;%04d&quot;)</code>，第二和第三个测试点都测试了这个</li><li>如果用int接收一对朋友，-0000和0000对于int来说都是0，将无法得知这个人的性别<ul><li>在这里我对他们的id进行了处理：把女生映射到[0,9999]，男生映射到[10000,19999]</li><li>也可以使用其他的哈希方法</li></ul></li><li>正常回路为A-C-D-B，不可以形成A-B-D-B或A-C-A-B的回路，即AD不相等、BC不相等</li><li><strong>写循环代码时注意一些变量是否会随着循环运行而改变，比如数组大小、外层循环变量是否被内层循环改变</strong></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1139</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312</span></span><br><span class="line"><span class="comment">// Tags: Graph Hash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isFriend[<span class="number">20000</span>][<span class="number">20000</span>]; <span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; friends[<span class="number">20000</span>]; <span class="comment">// 邻接表，同性朋友</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Helper</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transform</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将负数映射到[0,9999]，将正数映射到[10000,19999]</span></span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'-'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(stoi(s));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000</span> + stoi(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">restore</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将transform得到的[0,19999]的数字映射到[0,9999]，即原来的[-9999,9999]取绝对值得到[0,9999]，以进行输出</span></span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">9999</span>)</span><br><span class="line">        <span class="keyword">return</span> num - <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helperCmp</span><span class="params">(Helper&amp; h1, Helper&amp; h2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h1.c == h2.c ? h1.d &lt; h2.d : h1.c &lt; h2.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, a, b, c ,d;</span><br><span class="line">    <span class="built_in">string</span> s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 将图存入邻接矩阵和邻接表</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        a = transform(s);</span><br><span class="line">        b = transform(t);</span><br><span class="line">        isFriend[a][b] = isFriend[b][a] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (a&lt;<span class="number">10000</span> &amp;&amp; b&lt;<span class="number">10000</span>) || (a&gt;<span class="number">9999</span> &amp;&amp; b&gt;<span class="number">9999</span>) )&#123; <span class="comment">// 同性则存储到邻接表</span></span><br><span class="line">            friends[a].push_back(b);</span><br><span class="line">            friends[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        a = transform(s);</span><br><span class="line">        b = transform(t);</span><br><span class="line">        <span class="built_in">vector</span>&lt;Helper&gt; helpers;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = friends[a].begin(); it1 != friends[a].end(); it1++)&#123;</span><br><span class="line">            c = *it1;</span><br><span class="line">            <span class="keyword">if</span> (c == b) <span class="comment">// C和B不能是一个人</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it2 = friends[b].begin(); it2 != friends[b].end(); it2++)&#123;</span><br><span class="line">                d = *it2;</span><br><span class="line">                <span class="keyword">if</span> (d == a) <span class="comment">// D和A不能是一个人</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (isFriend[c][d])</span><br><span class="line">                    helpers.push_back(&#123;restore(c), restore(d)&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(helpers.begin(), helpers.end(), helperCmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, helpers.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = helpers.begin(); it != helpers.end(); it++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%04d %04d\n"</span>, it-&gt;c, it-&gt;d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一份超时的代码"><a href="#一份超时的代码" class="headerlink" title="一份超时的代码"></a>一份超时的代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1139</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344776077312</span></span><br><span class="line"><span class="comment">// Tags: Graph Hash Map</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Helper</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helperCmp</span><span class="params">(Helper&amp; h1, Helper&amp; h2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(stoi(h1.c)) == <span class="built_in">abs</span>(stoi(h2.c)) ? <span class="built_in">abs</span>(stoi(h1.d)) &lt; <span class="built_in">abs</span>(stoi(h2.d)) : <span class="built_in">abs</span>(stoi(h1.c)) &lt; <span class="built_in">abs</span>(stoi(h2.c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">string</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; friends; <span class="comment">// 会很耗时</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 存储朋友关系</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            a = <span class="string">'+'</span> + a;</span><br><span class="line">        <span class="keyword">if</span> (b[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            b = <span class="string">'+'</span> + b;</span><br><span class="line">        friends[a].push_back(b);</span><br><span class="line">        friends[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b; <span class="comment">// a喜欢b</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            a = <span class="string">'+'</span> + a;</span><br><span class="line">        <span class="keyword">if</span> (b[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            b = <span class="string">'+'</span> + b;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Helper&gt; helpers;</span><br><span class="line">        <span class="comment">// 下边这个大的for循环也很耗时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it1 = friends[a].begin(); it1 != friends[a].end(); it1++)&#123;</span><br><span class="line">            c = *it1; <span class="comment">// a的朋友c</span></span><br><span class="line">            <span class="keyword">if</span> (b == c || a[<span class="number">0</span>] != c[<span class="number">0</span>]) <span class="comment">// a和c不可以是同一个人，且应该是同性</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it2 = friends[c].begin(); it2 != friends[c].end(); it2++)&#123;</span><br><span class="line">                d = *it2; <span class="comment">// c的朋友d</span></span><br><span class="line">                <span class="keyword">if</span> (a == d || b[<span class="number">0</span>] != d[<span class="number">0</span>]) <span class="comment">// a和d不可以是同一个人，且应该是同性</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (find(friends[d].begin(), friends[d].end(), b) != friends[d].end())&#123;</span><br><span class="line">                    helpers.push_back(&#123;c, d&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(helpers.begin(), helpers.end(), helperCmp); <span class="comment">// 按id升序存储，达到题目输出要求</span></span><br><span class="line">        <span class="keyword">int</span> num = helpers.size();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%04d %04d\n"</span>, <span class="built_in">abs</span>(stoi(helpers[i].c)), <span class="built_in">abs</span>(stoi(helpers[i].d)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/79065004" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/79065004</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
      <category term="哈希" scheme="https://chouxianyu.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1154Vertex Coloring</title>
    <link href="https://chouxianyu.github.io/2020/08/30/PAT%E7%94%B2%E7%BA%A71154Vertex-Coloring/"/>
    <id>https://chouxianyu.github.io/2020/08/30/PAT甲级1154Vertex-Coloring/</id>
    <published>2020-08-30T09:49:06.000Z</published>
    <updated>2020-09-06T08:31:26.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li>k着色：相邻（有共享边）点的颜色不同</li><li>输入<ul><li>N：点的数量，点的编号为[0,N-1]，不超过10000</li><li>M：边的数量，不超过10000</li><li>M条边</li><li>K：着色方案的数量，不超过100</li><li>K个着色方案：每行有N个数字，第i个数字就是第i个点的颜色，相同数字代表同色</li></ul></li><li>输出<ul><li>对于每个着色方案，如果它是某个k着色，则输出<code>k-coloring</code>，否则输出<code>No</code></li></ul></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>把所有边存起来</li><li>把所有点的颜色存起来，并把颜色放入set中统计颜色个数</li><li>检查每条边两个点的颜色是否相同</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>cin、cout是会比scanf、printf慢的，如果用cin、cout，第三个测试点可能会超时</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1154</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785301894295552</span></span><br><span class="line"><span class="comment">// Tags: Graph Map Set</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span><span class="keyword">int</span> v1, v2;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; edges(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="comment">// 获取边</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;edges[i].v1, &amp;edges[i].v2);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123; <span class="comment">// k个着色方案</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; vColors;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; colors;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123; <span class="comment">// 获取着色方案</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;vColors[i]);</span><br><span class="line">            colors.insert(vColors[i]); <span class="comment">// 存储颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> isYes = <span class="literal">true</span>;  <span class="comment">// 判断着色方案是否符合k着色标准</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">if</span> (vColors[edges[i].v1] == vColors[edges[i].v2])&#123;</span><br><span class="line">                isYes = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (isYes)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d-coloring\n"</span>, colors.size());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="图" scheme="https://chouxianyu.github.io/tags/%E5%9B%BE/"/>
    
      <category term="set" scheme="https://chouxianyu.github.io/tags/set/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
      <category term="点着色" scheme="https://chouxianyu.github.io/tags/%E7%82%B9%E7%9D%80%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1137Final Grading</title>
    <link href="https://chouxianyu.github.io/2020/08/28/PAT%E7%94%B2%E7%BA%A71137Final-Grading/"/>
    <id>https://chouxianyu.github.io/2020/08/28/PAT甲级1137Final-Grading/</id>
    <published>2020-08-28T15:16:44.000Z</published>
    <updated>2020-08-28T15:17:37.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>要获得证书，一个学生的在线编程作业至少要拿到200分，最后评分G至少要拿到60分。</p><p>  如果期中分数大于期末分数，则G等于期中成绩乘以40%+期末成绩乘以60%，否则G等于期末成绩</p></li><li><p>输入</p><ul><li><p>第一行</p><p>  三个数字，都不超过10000</p><ul><li>P：完成网上在线作业的学生的数量</li><li>M：参加期中考试的学生的数量</li><li>N：参加期末考试的学生的数量</li></ul></li><li><p>P个学生网上在线作业的成绩</p></li><li><p>M个学生期中考试的成绩</p></li><li><p>N个学生期末考试的成绩</p></li></ul></li><li><p>输出</p><p>  输出获得证书的学生的ID及其3个成绩，按G(四舍五入到整数)降序输出，如果G相等，则按ID升序输出。如果某学生某些成绩不存在，则输出-1</p></li></ul><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li><p>assignment</p><p>  工作、任务</p><p>  分配、指派</p></li><li><p>certificate</p><p>  证明</p></li><li><p>round</p><p>  四舍五入</p></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>先读取在线编程作业分数，如果小于200，就不记录该学生的信息</li><li>在第一步记录的学生范围内，记录其期中分数</li><li>在第一步记录的学生范围内，记录其期末分数，同时计算其最后分数G，如果G大于60，则存入vector</li><li>将vector排序</li><li>输出</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1137</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345401028608</span></span><br><span class="line"><span class="comment">// Tags: unordered_map vector sort</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">int</span> gp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> gm=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> gf=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> g=<span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">studentCmp</span><span class="params">(Student&amp; s1, Student&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.g == s2.g ? s1.id &lt; s2.id : s1.g &gt; s2.g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p, m, n;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, Student&gt; students_map;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (score &gt;= <span class="number">200</span>)&#123;  <span class="comment">// 在线编程分数大于200才行（不允许该分数不存在）</span></span><br><span class="line">            students_map[str].id = str;</span><br><span class="line">            students_map[str].gp = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (students_map.find(str) != students_map.end()) <span class="comment">// 避免创建新的学生</span></span><br><span class="line">            students_map[str].gm = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Student&gt; students_vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; score;</span><br><span class="line">        <span class="keyword">if</span> (students_map.find(str) != students_map.end())&#123; <span class="comment">// 避免创建新的学生</span></span><br><span class="line">            students_map[str].gf = score;</span><br><span class="line">            <span class="keyword">if</span> (students_map[str].gm &gt; students_map[str].gf)</span><br><span class="line">                students_map[str].g = round(students_map[str].gm * <span class="number">0.4</span> + students_map[str].gf * <span class="number">0.6</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                students_map[str].g = students_map[str].gf;</span><br><span class="line">            <span class="keyword">if</span> (students_map[str].g &gt;= <span class="number">60</span>)</span><br><span class="line">                students_vec.push_back(students_map[str]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(students_vec.begin(), students_vec.end(), studentCmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = students_vec.begin(); it != students_vec.end(); it++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d %d %d %d\n"</span>, it-&gt;id.c_str(), it-&gt;gp, it-&gt;gm, it-&gt;gf, it-&gt;g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/weixin_44385565/article/details/88669948" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44385565/article/details/88669948</a></p><p><a href="https://blog.csdn.net/liuchuo/article/details/79064895" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/79064895</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1141PAT Ranking of Institutions</title>
    <link href="https://chouxianyu.github.io/2020/08/11/PAT%E7%94%B2%E7%BA%A71141PAT-Ranking-of-Institutions/"/>
    <id>https://chouxianyu.github.io/2020/08/11/PAT甲级1141PAT-Ranking-of-Institutions/</id>
    <published>2020-08-11T06:14:01.000Z</published>
    <updated>2020-08-11T06:17:01.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>n个考生，每个考生信息为：</p><ul><li><p>ID</p><p>  6个字符的字符串，第一位是考试等级（B、A、T）</p></li><li><p>score</p><p>  分数，[0,100]的整数</p></li><li><p>school</p><p>  不超6位的学校码，由英文字母组成，不区分大小写，但输入中有大小写</p></li></ul><p>请输出：</p><ul><li><p>第一行输出学校的数量</p></li><li><p>然后按rank的非降序输出Rank School TWS Ns</p><ul><li><p>rank是排名，从1开始，根据TWS非升序排序。</p><p>  如果TWS相等，则两校的rank也相等，且应按NS增序输出；如果Ns也相等，则按学校码的字母表顺序输出</p></li><li><p>school是学校码，用小写输出</p></li><li><p>TWS是加权分，等于该校B级考生总分/1.5+该校A级考生总分+该校T级考生总分*1.5，只取计算结果的整数部分</p></li><li><p>Ns是该校的考生数</p></li></ul></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>注意将学校码转换为小写</p></li><li><p>输出顺序有两方面：</p><ul><li>如果TWS相等，则两校的rank也相等，这一点要在最后控制</li><li>其它输出顺序通过sort函数使用的cmp函数控制</li></ul></li><li><p>我这里是使用了一个map，最后存入vector排序；也可以使用两个map（键都为学校码），一个存每个TWS，一个存Ns，最后都存入vector</p><p>  我计算TWS的方法比较麻烦，因为刚开始理解错了TWS的公式</p></li><li><p>用map而不是unorder_map的话，最后一个测试点会超时</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1141</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344222429184</span></span><br><span class="line"><span class="comment">// Tags: map unordered_map sort</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">School</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> code;  <span class="comment">// 小写的学校码</span></span><br><span class="line">    <span class="keyword">double</span> testeeScoreSums[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> TWS;</span><br><span class="line">    <span class="keyword">int</span> Ns = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calcTWS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;TWS = testeeScoreSums[<span class="number">0</span>] / <span class="number">1.5</span> + testeeScoreSums[<span class="number">1</span>] + testeeScoreSums[<span class="number">2</span>] * <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照要求比较两个学校</span></span><br><span class="line"><span class="comment">// 根据TWS非升序排序。如果TWS相等，则按Ns增序输出；如果Ns也相等，则按学校码的字母表顺序输出</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schoolCmp</span><span class="params">(School &amp;s1, School &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.TWS == s2.TWS)</span><br><span class="line">        <span class="keyword">if</span> (s1.Ns == s2.Ns)</span><br><span class="line">            <span class="keyword">return</span> s1.code &lt; s2.code;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> s1.Ns &lt; s2.Ns;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s1.TWS &gt; s2.TWS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, score; <span class="comment">// the number of testees, the score of a testee</span></span><br><span class="line">    <span class="built_in">string</span> id, schoolCode, testLevels=<span class="string">"BAT"</span>; <span class="comment">// the id of a testee, the school of a testee, three test levels</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, School&gt; schoolsMap;  <span class="comment">// 键为学校码，值为学校</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; score &gt;&gt; schoolCode;</span><br><span class="line">        transform(schoolCode.begin(), schoolCode.end(), schoolCode.begin(), ::<span class="built_in">tolower</span>);  <span class="comment">// 将学校码转为小写</span></span><br><span class="line">        schoolsMap[schoolCode].code = schoolCode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(id[<span class="number">0</span>] == testLevels[j])&#123;</span><br><span class="line">                schoolsMap[schoolCode].testeeScoreSums[j] += score; <span class="comment">// 分别统计该校三个等级考生的总分</span></span><br><span class="line">                schoolsMap[schoolCode].Ns += <span class="number">1</span>;  <span class="comment">// 统计该校考生数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将学校存入vector并排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;School&gt; schools;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, School&gt;::iterator it = schoolsMap.begin(); it != schoolsMap.end(); it++)&#123;</span><br><span class="line">        it-&gt;second.calcTWS();</span><br><span class="line">        schools.push_back(it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(schools.begin(), schools.end(), schoolCmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果，如果TWS相等，则两校的rank也相等，其它输出顺序要求已通过schoolCmp控制</span></span><br><span class="line">    <span class="keyword">int</span> schoolNum = schools.size(), rank = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n%d %s %d %d\n"</span>, schoolNum, rank, schools[<span class="number">0</span>].code.c_str(), schools[<span class="number">0</span>].TWS, schools[<span class="number">0</span>].Ns);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; schoolNum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(schools[i].TWS &lt; schools[i<span class="number">-1</span>].TWS)</span><br><span class="line">            rank = i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %d %d\n"</span>, rank, schools[i].code.c_str(), schools[i].TWS, schools[i].Ns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
</feed>
