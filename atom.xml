<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2018-11-03T02:25:06.981Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java.util.NoSuchElementException</title>
    <link href="https://chouxianyu.github.io/2018/11/03/java.util.NoSuchElementException/"/>
    <id>https://chouxianyu.github.io/2018/11/03/java.util.NoSuchElementException/</id>
    <published>2018-11-03T02:23:02.000Z</published>
    <updated>2018-11-03T02:25:06.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>Java商店作业不同函数里需要获取用户输入，用<code>Scanner</code>的时候,出现了异常<code>java.util.NoSuchElementException</code></p><p>作业中代码模式如下，<code>func1</code>和<code>func2</code>中都使用<code>Scanner</code>并关闭它。然后在main中依次调用<code>func1</code>和<code>func2</code>，<code>func2</code>产生异常。说<code>func1</code>和<code>func2</code>其实不合适，应该加个括号……..懒得加了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demo.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出用户输入，替代作业里的使用Scanner</span></span><br><span class="line">System.out.print(<span class="string">"Func1请输入内容："</span>);</span><br><span class="line">System.out.println(<span class="string">"Func1输出"</span>+sc.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭Scanner</span></span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出用户输入，替代作业里的使用Scanner</span></span><br><span class="line">System.out.print(<span class="string">"Func2请输入内容："</span>);</span><br><span class="line">System.out.println(<span class="string">"Func2输出"</span>+sc.nextInt());</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭Scanner</span></span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Test t=<span class="keyword">new</span> Test();</span><br><span class="line">t.func1();</span><br><span class="line">t.func2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Console输出如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Func1请输入内容：小姐，请问你喜欢吃青椒吗？</span></span><br><span class="line"><span class="comment">Func1输出：小姐，请问你喜欢吃青椒吗？</span></span><br><span class="line"><span class="comment">Func2请输入内容：Exception in thread "main" java.util.NoSuchElementException</span></span><br><span class="line"><span class="comment">at java.base/java.util.Scanner.throwFor(Unknown Source)</span></span><br><span class="line"><span class="comment">at java.base/java.util.Scanner.next(Unknown Source)</span></span><br><span class="line"><span class="comment">at java.base/java.util.Scanner.nextInt(Unknown Source)</span></span><br><span class="line"><span class="comment">at java.base/java.util.Scanner.nextInt(Unknown Source)</span></span><br><span class="line"><span class="comment">at Test.func2(Demo.java:21)</span></span><br><span class="line"><span class="comment">at Demo.main(Demo.java:31)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常产生原因"><a href="#异常产生原因" class="headerlink" title="异常产生原因"></a>异常产生原因</h1><p><code>func1</code>中<code>sc.close();</code>语句关闭了<code>Scanner</code>，<code>func2</code>中使用<code>Scanner</code>产生异常</p><p>因为<code>System.in</code>是<code>System</code>类的静态成员，所以不同<code>Scanner</code>对象内的in<code>是同一个</code>in`</p><p><code>func1</code>和<code>func2</code>中都用<code>System.in</code>创建了<code>Scanner</code></p><p><strong><code>func1</code>打开<code>Scanner</code>后将其关闭，这里间接地将<code>System.in</code>也关闭了</strong></p><p><code>func1</code>结束后运行<code>func2</code>，这时再调用<code>nextInt</code>，在<code>System.in</code>已经关闭了的情况下，不能读取到任何数据，就会产生 <code>java.util.NoSuchElementException</code></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>系统资源一旦释放就不能再开启了，所以只有确定不在使用系统的时候，才能将流关闭</p><p>所以应该在整个程序结束时释放<code>Scanner</code>等资源，而不是某个函数中每次使用<code>Scanner</code>等资源后都释放一次</p><p>问题引入中的代码只是个模式，上边的两句话用在作业实际代码里就好了</p><h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner()"></a><code>Scanner()</code></h2><p>创建<code>Scanner</code>对象代码为<code>Scanner sc=new Scanner(System.in);</code>构造函数源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(InputStream source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> InputStreamReader(source), WHITESPACE_PATTERN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出是调用了另外一个构造函数，继续查看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Scanner</span><span class="params">(Readable source, Pattern pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> source != <span class="keyword">null</span> : <span class="string">"source should not be null"</span>;</span><br><span class="line">        <span class="keyword">assert</span> pattern != <span class="keyword">null</span> : <span class="string">"pattern should not be null"</span>;</span><br><span class="line">        <span class="keyword">this</span>.source = source;<span class="comment">//看这句</span></span><br><span class="line">        delimPattern = pattern;</span><br><span class="line">        buf = CharBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">        buf.limit(<span class="number">0</span>);</span><br><span class="line">        matcher = delimPattern.matcher(buf);</span><br><span class="line">        matcher.useTransparentBounds(<span class="keyword">true</span>);</span><br><span class="line">        matcher.useAnchoringBounds(<span class="keyword">false</span>);</span><br><span class="line">        useLocale(Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至少知道了<code>Scanner</code>内部还是用到了流，算是对流进行了封装吧，使用起来更方便一些</p><h2 id="close"><a href="#close" class="headerlink" title="close()"></a><code>close()</code></h2><p>调用语句为<code>sc.close();</code>，查看<code>close()</code>源码，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed)                             <span class="comment">//1.通过closed标志校验Scanner是否已关闭；</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (source <span class="keyword">instanceof</span> Closeable) &#123;      <span class="comment">//2.执行source的close()方法，</span></span><br><span class="line">            <span class="keyword">try</span> &#123;                               <span class="comment">//将source关闭（这里为System.in）；</span></span><br><span class="line">                ((Closeable)source).close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                lastException = ioe;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sourceClosed = <span class="keyword">true</span>;    <span class="comment">//3.将sourceClosed标志设置为true，表示source已关闭；</span></span><br><span class="line">        source = <span class="keyword">null</span>;          <span class="comment">//4.将source置为null，不再引用，处于可回收状态；</span></span><br><span class="line">        closed = <span class="keyword">true</span>;          <span class="comment">//5.将closed标志设置为true，表示Scanner已关闭；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以知道关闭<code>Scanner</code>的时候，<code>((Closeable)source).close();</code>把<code>System.in</code>关闭了</p><p>关闭后下次想再使用就当然有错了~（除非构造函数里还再把<code>in</code>给打开，但这样也不太合理）</p><p>其实如果还可以再仔细看看<code>Scanner</code>的构造方法，和<code>Scanner</code>的<code>next()</code>，能力有限，点到为止</p><p>作者：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io/2018/11/03/java.util.NoSuchElementException/#more">https://chouxianyu.github.io/2018/11/03/java.util.NoSuchElementException/#more</a></p><p>欢迎转发和评论</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h1&gt;&lt;p&gt;Java商店作业不同函数里需要获取用户输入，用&lt;code&gt;Scanner&lt;/code&gt;的时候,出现了异常&lt;code&gt;java
      
    
    </summary>
    
    
      <category term="Java" scheme="https://chouxianyu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java字节流read函数</title>
    <link href="https://chouxianyu.github.io/2018/09/22/Java%E5%AD%97%E8%8A%82%E6%B5%81read%E5%87%BD%E6%95%B0/"/>
    <id>https://chouxianyu.github.io/2018/09/22/Java字节流read函数/</id>
    <published>2018-09-22T14:50:12.000Z</published>
    <updated>2018-09-22T15:04:18.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>做Java作业从标准输入流获取用户输入，用到了<code>System.in.read()</code>,然后出现了bug。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机生成一个小写字母，用户猜5次，读取用户输入，并判断是否猜对</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterGuessing</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch,answer;</span><br><span class="line"><span class="comment">//随机生成字母</span></span><br><span class="line">answer=(<span class="keyword">char</span>)(Math.random()*<span class="number">26</span>+<span class="string">'a'</span>);</span><br><span class="line">System.out.print(<span class="string">"请输入一个小写字母："</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++) &#123;</span><br><span class="line"><span class="comment">//获取用户输入，可能抛出异常</span></span><br><span class="line">ch=(<span class="keyword">char</span>)System.in.read();</span><br><span class="line"><span class="comment">//比较大小</span></span><br><span class="line"><span class="keyword">if</span>(ch == answer)&#123;</span><br><span class="line">System.out.println(<span class="string">"恭喜，正确！用了"</span>+i+<span class="string">"次猜对"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch &gt; answer)</span><br><span class="line">System.out.println(<span class="string">"您猜大了，还有"</span>+ (<span class="number">5</span>-i) +<span class="string">"次机会"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"您猜小了，还有"</span>+ (<span class="number">5</span>-i) +<span class="string">"次机会"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入字符<code>&#39;a&#39;</code>，按下Enter,却没有等我下次输入，循环就运行了三次。</p><h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><p><code>System.in.read()</code>按字节读，一次读入一个字节。后边有详细讲解。</p><p>经调试，可知三次循环中<code>ch</code>分别为<code>a</code>,<code>\r</code>,<code>\n</code>。</p><p><strong>为什么a+Enter,会变成a\r\n呢</strong></p><p><strong>Windows下存在两种文件读写方式，一个是二进制方式，另一种是文本方式</strong>。</p><p><strong>文本方式</strong>中写时”换行”会变成”回车-换行”，即\r\n；读时”回车-换行”会变成”换行”。</p><p><strong>二进制方式</strong>中读写是严格按照一个字节一个字节的方式进行的。</p><p><strong>在这里虽然没有用到文件，但道理应该是一样的</strong></p><p>用<code>read()</code>函数是按照一个字节一个字节读取的，即二进制方式。</p><p>可能可以推导出，我们向输入流中输入数据默认是按照文本方式。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>在代码第10行后，加两行<code>System.in.read()</code>;</p><p>目的是读取掉输入流中的/r和/n。</p><p>这种方法的局限性就是输入字母前后不能加空格，因为它不会使空格从输入流中删除。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>不用<code>read()</code>读取，用以下代码代替</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner input=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">ch=input.next().charAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这种方法就比较好，读取字符串（忽略空格和换行，空格和换行不会留在输入流里），然后取字符串的第一个字符。</p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a><code>System.in</code></h2><p>官方文档：<a href="https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#in" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/java/lang/System.html#in</a></p><p><code>System</code>是个类，in是<code>System</code>的一个成员，官方介绍如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InputStream in</span><br></pre></td></tr></table></figure><p>The “standard” input stream. This stream is already  open and ready to supply input data. Typically this stream  corresponds to keyboard input or another input source specified by  the host environment or user.</p><p><code>in</code>是一个<code>InputStream</code>类型的对象,所以只需要了解<code>InputStream</code>即可。</p><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a><code>InputStream</code></h2><p>官方文档： <a href="https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span>//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span>//继承<span class="title">Object</span>类</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Closeable</span>//实现<span class="title">Closeable</span>接口</span></span><br></pre></td></tr></table></figure><p>官方介绍如下：</p><p>This abstract class is the superclass of all classes representing  an input stream of bytes.</p><p>翻译为：这个抽象类是所有字节流类的父类。</p><p>字节流的含义：<strong>读取方式为一个字节一个字节地读取</strong>,而字符流是二个字节二个字节的读。</p><p>Applications that need to define a subclass of <code>InputStream</code>  must always provide a method that returns the next byte of input.</p><p>翻译为：需要定义一个<code>InputStream</code>子类的应用必须提供一个返回输入下一字节的方法（函数）。</p><h2 id="read"><a href="#read" class="headerlink" title="read()"></a><code>read()</code></h2><p>官方文档：<a href="https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html#read()" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/java/io/InputStream.html#read()</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>Reads the next byte of data from the input stream. The value byte is returned as an <code>int</code> in the range <code>0</code> to<code>255</code>.</p><p>这个是重点，它<strong>返回下一字节的ASCII码</strong></p><p>If no byte is available because the end of the stream has been reached, the value <code>-1</code> is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown.</p><p>A subclass must provide an implementation of this method.</p><p><strong>Returns:</strong></p><p>the next byte of data, or <code>-1</code> if the end of the stream is reached.</p><p><strong>Throws:</strong></p><p><code>IOException</code> - if an I/O error occurs.</p><p>作者：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io/2018/09/22/Java字节流read函数/#more">https://chouxianyu.github.io/2018/09/22/Java字节流read函数/#more</a></p><p>欢迎转发和评论</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h1&gt;&lt;p&gt;做Java作业从标准输入流获取用户输入，用到了&lt;code&gt;System.in.read()&lt;/code&gt;,然后出现了bug。
      
    
    </summary>
    
    
      <category term="Java" scheme="https://chouxianyu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何获取文件夹下所有文件的路径</title>
    <link href="https://chouxianyu.github.io/2018/09/09/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://chouxianyu.github.io/2018/09/09/如何获取文件夹下所有文件的路径/</id>
    <published>2018-09-09T09:46:38.000Z</published>
    <updated>2018-09-09T10:08:55.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><code>getFiles()</code>函数的作用：</p><p>path是一个文件夹路径，函数在<code>path</code>文件夹下寻找所有文件（包括子文件夹下的文件），然后将所有文件的路径存入<code>files</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;io.h&gt;//实现功能需要包含头文件io.h</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFiles</span><span class="params">(<span class="built_in">string</span> path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; files)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">intptr_t</span>   hFile = <span class="number">0</span>;<span class="comment">//文件句柄，过会儿用来查找</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">finddata_t</span> <span class="title">fileinfo</span>;</span><span class="comment">//文件信息</span></span><br><span class="line"><span class="built_in">string</span> p;</span><br><span class="line"><span class="keyword">if</span> ((hFile = _findfirst(p.assign(path).append(<span class="string">"\\*"</span>).c_str(), &amp;fileinfo)) != <span class="number">-1</span>)</span><br><span class="line">     <span class="comment">//如果查找到第一个文件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((fileinfo.attrib &amp;  _A_SUBDIR))<span class="comment">//如果是文件夹</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(fileinfo.name, <span class="string">"."</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(fileinfo.name, <span class="string">".."</span>) != <span class="number">0</span>)</span><br><span class="line">getFiles(p.assign(path).append(<span class="string">"\\"</span>).append(fileinfo.name), files);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果是文件</span></span><br><span class="line">&#123;</span><br><span class="line">files.push_back(p.assign(path).append(<span class="string">"\\"</span>).append(fileinfo.name));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (_findnext(hFile, &amp;fileinfo) == <span class="number">0</span>);<span class="comment">//能寻找到其他文件</span></span><br><span class="line"></span><br><span class="line">_findclose(hFile);<span class="comment">//结束查找，关闭句柄</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h1><h2 id="finddata-t"><a href="#finddata-t" class="headerlink" title="_finddata_t"></a><code>_finddata_t</code></h2><p>它是存储一个文件相关信息的结构体,查看其定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _USE_32BIT_TIME_T</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _finddata_t     _finddata32_t</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _finddatai64_t  _finddata32i64_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _finddata_t     _finddata64i32_t</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _finddatai64_t  __finddata64_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>我这里是<code>_finddata64i32_t</code>，查看其定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">finddata64i32_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span>    attrib;</span><br><span class="line">    <span class="keyword">__time64_t</span>  time_create;    <span class="comment">// -1 for FAT file systems</span></span><br><span class="line">    <span class="keyword">__time64_t</span>  time_access;    <span class="comment">// -1 for FAT file systems</span></span><br><span class="line">    <span class="keyword">__time64_t</span>  time_write;</span><br><span class="line">    <span class="keyword">_fsize_t</span>    size;</span><br><span class="line">    <span class="keyword">char</span>        name[<span class="number">260</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>attrib</code>是该结构体的一个成员，是attribute（属性）的缩写。</p><p>它代表文件的属性，下边是相应的宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _A_NORMAL 0x00 <span class="comment">// Normal file - No read/write restrictions</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _A_RDONLY 0x01 <span class="comment">// Read only file</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _A_HIDDEN 0x02 <span class="comment">// Hidden file</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _A_SYSTEM 0x04 <span class="comment">// System file</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _A_SUBDIR 0x10 <span class="comment">// Subdirectory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _A_ARCH   0x20 <span class="comment">// Archive file</span></span></span><br></pre></td></tr></table></figure><p>成员<code>name</code>就是文件名字嘛…</p><h2 id="findfirst"><a href="#findfirst" class="headerlink" title="_findfirst"></a><code>_findfirst</code></h2><p>第一个参数是标明文件的字符串，可支持通配符：<code>*.c</code>代表后缀为.c的文件，<code>*</code>就代表所有文件</p><p>第二个参数是<code>_finddata_t</code>类型变量的地址。该变量用来保存文件信息。</p><p><strong>这有坑</strong></p><p>我跟网上有点不同的是，网上我看到的例子定义的<code>hFile</code>都是<code>long</code>型，我用<code>long</code>型打开文件就出问题了。</p><p>其实VS已经警告了<code>warning C4244: “=”: 从“intptr_t”转换到“long”，可能丢失数据</code>。</p><p>我没在意它，后来改掉了类型就成功了。（就冲这一点，VS天下第一！）</p><p>查看<code>_findfirst</code>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _USE_32BIT_TIME_T</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findfirst      _findfirst32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findnext       _findnext32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findfirsti64   _findfirst32i64</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findnexti64     _findnext32i64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findfirst      _findfirst64i32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findnext       _findnext64i32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findfirsti64   _findfirst64</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findnexti64    _findnext64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>我这里用的是<code>_findfirst64i32</code>，查看其定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_ACRTIMP <span class="keyword">intptr_t</span> __cdecl _findfirst64i32(</span><br><span class="line">        _In_z_ <span class="keyword">char</span> <span class="keyword">const</span>*              _FileName,</span><br><span class="line">        _Out_  struct <span class="keyword">_finddata64i32_t</span>* _FindData</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>说明函数返回<code>intptr_t</code></p><p>继续查看<code>intptr_t</code>定义，得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> __int64 <span class="keyword">size_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> __int64          <span class="keyword">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> __int64          <span class="keyword">intptr_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>     <span class="keyword">size_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span>              <span class="keyword">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span>              <span class="keyword">intptr_t</span>;</span><br></pre></td></tr></table></figure><p>所以<code>intptr_t</code>在我电脑上实际是<code>__int64</code>，转换成long可能会丢失数据。</p><h2 id="findnext"><a href="#findnext" class="headerlink" title="_findnext"></a><code>_findnext</code></h2><p>查看其定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _USE_32BIT_TIME_T</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findfirst      _findfirst32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findnext       _findnext32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findfirsti64   _findfirst32i64</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findnexti64     _findnext32i64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findfirst      _findfirst64i32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findnext       _findnext64i32</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findfirsti64   _findfirst64</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _findnexti64    _findnext64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> 我这里是<code>_findnext64i32</code>，查看其定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_ACRTIMP <span class="keyword">int</span> __cdecl _findnext64i32(</span><br><span class="line">     _In_  <span class="keyword">intptr_t</span>                 _FindHandle,</span><br><span class="line">     _Out_ struct <span class="keyword">_finddata64i32_t</span>* _FindData</span><br><span class="line">     );</span><br></pre></td></tr></table></figure><p>没啥讲的，好好看看<code>_findfirst</code>部分就懂这个了。</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p><code>fileinfo.attrib &amp;  _A_SUBDIR</code>，代码中用到了按位与&amp;。在此表示是文件夹（subdirectory）。位运算经常用在表示属性。具体的这次先不讲。</p><p>作者：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io/2018/09/09/如何获取文件夹下所有文件的路径/#more">https://chouxianyu.github.io/2018/09/09/如何获取文件夹下所有文件的路径/#more</a></p><p>欢迎转发和评论</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;&lt;p&gt;&lt;code&gt;getFiles()&lt;/code&gt;函数的作用：&lt;/p&gt;
&lt;p&gt;path是一个文件夹路径，函数在&lt;code&gt;path&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="c/c++" scheme="https://chouxianyu.github.io/tags/c-c/"/>
    
      <category term="文件" scheme="https://chouxianyu.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>指针间的互相赋值</title>
    <link href="https://chouxianyu.github.io/2018/09/01/%E6%8C%87%E9%92%88%E9%97%B4%E7%9A%84%E4%BA%92%E7%9B%B8%E8%B5%8B%E5%80%BC/"/>
    <id>https://chouxianyu.github.io/2018/09/01/指针间的互相赋值/</id>
    <published>2018-09-01T13:40:11.000Z</published>
    <updated>2018-09-01T13:55:07.396Z</updated>
    
    <content type="html"><![CDATA[<p>文章分为三个大的部分</p><p>大标题1提出权限”理念”，大标题2验证赋值规则</p><p>大标题3、4、5是我的个人理解。</p><p>大标题6是最直接的结论。</p><p><strong>提醒</strong></p><p>看懂这篇文章可能需要你知道并理解四种指针的定义，这是基础。当然如果真的不懂，可以直接去文尾记住结论。</p><p>四种指针详解戳这<a href="https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/#more">https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/#more</a></p><h1 id="指针修改指向内容的权限"><a href="#指针修改指向内容的权限" class="headerlink" title="指针修改指向内容的权限"></a>指针修改指向内容的权限</h1><p><strong>普通指针=指针常量&gt;常量指针=四号指针</strong></p><p>这个权限指的是<em>通过该指针</em>是否可以修改内存，情况只有两种：是和否。是的话就有权限，否的话就没有权限，这个大小是0和1，false和true，是有和没有，不是12345678的大和小。</p><p>普通指针很好说，四号指针也是个常量指针嘛，当然不可以修改内存</p><p>这个权限大小关系不难理解，前提是你有理解常指和指常这两个名词吧。</p><p>前边的普指和指常都可以修改内存中的内容，而常指和四号则不可以。</p><h1 id="指针赋值规则"><a href="#指针赋值规则" class="headerlink" title="指针赋值规则"></a>指针赋值规则</h1><p><strong>指针间的赋值</strong>：权限大的可以赋值给权限小的（权限指操作内存即修改内存中的内容的权限）</p><p><strong>权限大的可以赋值给权限小的，同级权限也可以，小赋值给大不行</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">0</span>;<span class="comment">//常量n</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;<span class="comment">//变量m</span></span><br><span class="line"><span class="keyword">int</span>* p1;<span class="comment">//普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p2;<span class="comment">//常量指针与int const* p2相同</span></span><br><span class="line"><span class="comment">//int* const p3=nullptr; //指针常量</span></span><br><span class="line"><span class="comment">//int const * const p4;  //四号指针 既是常指又是指常，即自身不可修改，也不可通过它修改指向的内存</span></span><br><span class="line"></span><br><span class="line">p1 = p2;<span class="comment">//error普指=常指</span></span><br><span class="line">p1 = p3;<span class="comment">//correct普指=指常</span></span><br><span class="line">p1 = p4;<span class="comment">//error普指=四号</span></span><br><span class="line">p1 = &amp;n;<span class="comment">//error普指=常指</span></span><br><span class="line">p1 = &amp;m;<span class="comment">//correct普指=普指</span></span><br><span class="line"></span><br><span class="line">p2 = p1;<span class="comment">//correct常指=普指</span></span><br><span class="line">p2 = p3;<span class="comment">//correct常指=指常</span></span><br><span class="line">p2 = p4;<span class="comment">//correct常指=四号</span></span><br><span class="line">p2 = &amp;n;<span class="comment">//correct常指=常指</span></span><br><span class="line">p2 = &amp;m;<span class="comment">//correct常指=普指</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p3是指常，是常量 赋值当然不行了，更别说权限了，所以上边不定义p3，</span></span><br><span class="line"><span class="comment">//要讨论的是权限，在此定义并初始化以作示例，但定义只能有一个的啊，我在这提醒过了啊</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p3 = p1;<span class="comment">//correct指常=普指</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p3 = p2;<span class="comment">//error指常=常指</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p3 = p4;<span class="comment">//error指常=四号</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;n;<span class="comment">//error指常=常指</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;m;<span class="comment">//correct指常=普指</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p4是四号，是常量，同p3，不赘述</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4 = p1;<span class="comment">//correct四号=普指</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4 = p2;<span class="comment">//correct四号=常指</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4 = p3;<span class="comment">//correct四号=指常</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4 = &amp;n;<span class="comment">//correct四号=常指</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4 = &amp;m;<span class="comment">//correct四号=普指</span></span><br></pre></td></tr></table></figure><p>这个规则是我自己想出来的，可能书上云里雾里的背后就是这么个规律。我之前好像说过存在即合理..实际表述不太对，应该是<strong>存在就有原因</strong>。上边的代码应该囊括了所有“品种”指针的互相赋值，验证也都符合预期。如有错误，欢迎指出。</p><h1 id="赋值规则的过程"><a href="#赋值规则的过程" class="headerlink" title="赋值规则的过程"></a>赋值规则的过程</h1><p><strong>赋值得要满足被赋值方的要求</strong>，就像你想娶我（捂脸），我就需要你一米八，宠我，其他的都不需要，有的话我也一点不碰。但只要你这两点缺一点，我就不要，你是马云爸爸也不行！</p><p>赋值就是那么个意思，我是指常或者普指，我要求有权限修改内存，所以就只有指常和普指能娶我，能给我赋值，因为常指和四号没有那个权限啊！反过来的话，我是常指和四号，我什么都不要，所以谁赋值都行，上面我们也能看到给常指和四号赋值的时候全都correct了。</p><h1 id="赋值规则的必要性"><a href="#赋值规则的必要性" class="headerlink" title="赋值规则的必要性"></a>赋值规则的必要性</h1><h2 id="赋值规则前提是不同指针的权限不同"><a href="#赋值规则前提是不同指针的权限不同" class="headerlink" title="赋值规则前提是不同指针的权限不同"></a>赋值规则前提是不同指针的权限不同</h2><p>我想多种指针是为了程序更好吧，不然只有一种指针能实现所有的功能，岂不是很可怕。给了程序员太大的权利，程序员一跑神犯错，程序就极有可能崩溃。给予指针权限之差就像c++里override吧，也是一种对程序员的友好？这是一方面,这应该能说明赋予指针不同权限的必要。</p><h2 id="然后才有了赋值规则"><a href="#然后才有了赋值规则" class="headerlink" title="然后才有了赋值规则"></a>然后才有了赋值规则</h2><p>我们举个例子，如果没有这个规则，不同类型指针自由互相赋值：你定义一个常量n，然后再定义一个int* p，就是普指，普指按说是有修改内存的权利的，然后p=&amp;n，拿到n的地址，是不是就可以通过p改变n了？（在存在不同权限指针的前提下）。如果没有这个规则，我们可以很随意地改变常量了。干嘛自己造了一座木屋，然后又给它浇上油？</p><h1 id="斗胆扯内存"><a href="#斗胆扯内存" class="headerlink" title="斗胆扯内存"></a>斗胆扯内存</h1><p>不管是指针常量还是常量指针还有普通指针，<strong>它们本身和那块内存都是没有本质关系的</strong>。</p><p>它们（也包括普通类型的指针）只是一个带着镣铐或者没有镣铐的工具，我们可以通过const控制指针的权限以及它本身，同时我们在使用它们时也不能超出它们的权限范围和它们的个人承受力。</p><p>还是说我在做梦！？？！那有人也在做梦的话，联系我可获得<del>王子之吻</del>，开玩笑的啊，我不是gay，也不是变态</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1;<span class="comment">//普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p2;<span class="comment">//常量指针与int const* p2相同</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p3=<span class="literal">nullptr</span>; <span class="comment">//指针常量</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p4;  <span class="comment">//四号指针 既是常指又是指常</span></span><br></pre></td></tr></table></figure><p>p1和p3可以互相赋值；</p><p>p2和p4可以互相赋值；</p><p>p1和p3可以给p2和p4赋值，反之不行；</p><p>p3和p4在程序中只能在定义时被赋值一次，因为它们是const类型的量。</p><p>作者：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io/2018/09/01/指针间的互相赋值/#more">https://chouxianyu.github.io/2018/09/01/指针间的互相赋值/#more</a></p><p>欢迎转发和评论</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章分为三个大的部分&lt;/p&gt;
&lt;p&gt;大标题1提出权限”理念”，大标题2验证赋值规则&lt;/p&gt;
&lt;p&gt;大标题3、4、5是我的个人理解。&lt;/p&gt;
&lt;p&gt;大标题6是最直接的结论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提醒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看懂这篇文章可能需要你知道并理解四
      
    
    </summary>
    
    
      <category term="c/c++" scheme="https://chouxianyu.github.io/tags/c-c/"/>
    
      <category term="指针" scheme="https://chouxianyu.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>物不知其数</title>
    <link href="https://chouxianyu.github.io/2018/09/01/%E7%89%A9%E4%B8%8D%E7%9F%A5%E5%85%B6%E6%95%B0/"/>
    <id>https://chouxianyu.github.io/2018/09/01/物不知其数/</id>
    <published>2018-09-01T04:13:11.000Z</published>
    <updated>2018-09-01T13:26:06.630Z</updated>
    
    <content type="html"><![CDATA[<p>文章分为三个大的部分：</p><p>大标题1是物不知其数问题的引入，大标题2将问题抽象。</p><p>大标题3、4、5是物不知其数问题的三种解法及其代码实现。</p><p>大标题6是提出的一些问题及不太完善的解释。</p><p><strong>提醒</strong>：</p><p>看文章最好先掌握文章整体结构，电脑会比较方便，可以点击标题跳到自己想看的部分。</p><p>看代码发现看不到后边的注释的话，调整网页显示比例（Ctrl+鼠标滚轮）</p><p>另外代码里的注释也是有规律的，单独一行的注释是解释下边的几行的功能的，写在代码右边的注释解释这一行代码功能。</p><h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>秦王暗点兵和韩信乱点兵都是后人对物不知其数问题的一种故事化，有兴趣可以搜索一下。</p><p>物不知其数问题出自《孙子算经》。</p><p>原题为：”今有物不知其数，三三数之二，五五数之三，七七数之二，问物几何？” 这道题的意思是：有一批物品，不知道有几件。如果三件三件地数，就会剩下两件；如果五件五件地数，就会剩下三件；如果七件七件地数，也会剩下两件。</p><p><strong>问：这批物品共有多少件？ 变成一个纯粹的数学问题就是：有一个数，用3除余2，用5除余3，用7除余2。求这个数。</strong></p><p>拿到这个问题，我们可以发现用3和7除余数都是2，自然而然想到3*7=21,21+2=23,23%5=3。所以23就是答案之一，而后边问题中我们求最小值。</p><p>这个问题之所以简单，是由于有被3除和被7除余数相同这个特殊性。</p><h1 id="问题抽象"><a href="#问题抽象" class="headerlink" title="问题抽象"></a>问题抽象</h1><p>去除这个特殊性之后，真正的问题可以是：</p><p><strong>三人一组余两人，五人一组余三人，七人一组余四人。问：这队士兵至少有多少人？</strong></p><p>就是说我们要找到一个最小的数，使其除以3余2，除以5余3，除以7余4</p><p>数据变量化后问题改成：找到一个最小的数，使其除以x余a，除以y余b，除以z余c</p><p>三个条件按顺序分别称为条件1，条件2，条件3。</p><h1 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>定义变量n，在范围内从头到尾递增，循环内判断条件为<code>n%3==2&amp;&amp;n%5==3&amp;&amp;n%7==4</code>，符合条件就break</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到一个最小的数，使其除以x余a，除以y余b，除以z余c</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;<span class="comment">//除数</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;<span class="comment">//余数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d %d"</span>,&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;;n++)<span class="comment">//在这里不设范围</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%x==a&amp;&amp;n%y==b&amp;&amp;n%z==c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h1><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>题目中有三个条件，我们可以将前两个条件合并成条件A，再把条件A与第三个条件合并，最后得出结果。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="条件1和条件2合并成条件A"><a href="#条件1和条件2合并成条件A" class="headerlink" title="条件1和条件2合并成条件A"></a>条件1和条件2合并成条件A</h3><p>已知n除以3余2，可设n=3i+2(i是正整数)，使i从1变大，判断3i+2除以5是否余3。</p><p>我们发现当i=2时，3i+2=8除以5余数为3，即n=8时除以3余2，除以5余3。</p><p>然后前两个条件就被我们合并成了条件A：n=15i+8，</p><p>本质是：<strong>最小的符合前两个条件的数字8加上3和5的最小公倍数15的整数倍</strong></p><p>定理：<strong>若n除以a余b，n加上a的倍数再除以a余数仍然为b</strong>。我们加上的15i即为a的倍数</p><p><strong>注意</strong>：</p><p>是最小公倍数，<strong>不要直接看做是两数乘积</strong>，因为只有在指出三个除数两两互质的情况下，两数乘积即为最小公倍数，在这里提醒一下，不要理解错误。</p><p>如果用的不是最小公倍数，我们下边n增加的单位就变大了，可能会求不到最小值，而题目要求是取得符合要求的<strong>最小值</strong>，如果没有这个要求，也没必要是最小公倍数了。</p><h3 id="条件A和条件3合并成结果"><a href="#条件A和条件3合并成结果" class="headerlink" title="条件A和条件3合并成结果"></a>条件A和条件3合并成结果</h3><p>我们再使条件A和第三个条件合并，n=15i+8(i是正整数)，使i从1变大，判断15i+8除以7的余数是否为4。</p><p>我们发现当i=3时，15i+8=53除以7余4，53即为答案</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>过程中条件合并了两次，让我想到定义一个函数。这个函数要调用两次</p><p>写一个比伪代码还伪的代码： 结果 合并(条件，条件)  </p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//Greatest Common divisior</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">    <span class="comment">//辗转相除法求最大公约数 Greatest Common Divisor</span></span><br><span class="line">    <span class="comment">/* 余数不为0，继续相除，直到余数为0 */</span></span><br><span class="line"><span class="keyword">while</span>(b!=<span class="number">0</span>)   </span><br><span class="line">&#123;</span><br><span class="line">c=a%b;</span><br><span class="line">a=b;</span><br><span class="line">b=c;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//Least Common Multiple </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//最小公倍数等于乘积除以最大公约数</span></span><br><span class="line">    <span class="keyword">return</span> a*b/Gcd(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到一个最小的数，使其除以x余a，除以y余b，除以z余c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y,z;<span class="comment">//除数</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;<span class="comment">//余数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d %d"</span>,&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="comment">//合并条件1和条件2</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((x*i+a)%y!=b)<span class="comment">//循环跳条件为(x*i+a)%y==b</span></span><br><span class="line">    i++;</span><br><span class="line"><span class="comment">//得到条件A</span></span><br><span class="line"><span class="keyword">int</span> d=x*i+a;<span class="comment">//得到条件A</span></span><br><span class="line"><span class="comment">//合并条件A和条件3</span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((Lcm(x,y)*j+d)%z!=c)<span class="comment">//while((Lcm(x,y)*j+d)%z !=c)求得的不一定是最小值</span></span><br><span class="line">    j++;</span><br><span class="line"><span class="comment">//得到结果</span></span><br><span class="line"><span class="keyword">int</span> result=Lcm(x,y)*j+d;<span class="comment">//int result=x*y*j+d求得的不一定是最小值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br></pre></td></tr></table></figure><h1 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h1><h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h2><p>除数分别是3、5、7，用70(5乘7乘2)乘以用3除的余数，用21(3乘7)乘以用5除的余数，用15(3乘5)乘以用7除的余数，然后把这三个乘积相加。加得的结果如果比105(3乘5乘7)大，就除以105，所得的余数就是满足题目要求的最小正整数解。</p><h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><h3 id="除数两两结合得到公倍数"><a href="#除数两两结合得到公倍数" class="headerlink" title="除数两两结合得到公倍数"></a>除数两两结合得到公倍数</h3><p>对所得公倍数的目标(要求)：除以另外一个除数余1</p><p>这一步骤中，不用关注三个条件要求余几，条件中的余几会在下一步体现</p><p><strong>条件一：用3除</strong></p><p>这里是用3除，求<em>另外两个除数</em>的公倍数，并要求用3除余1,5*7=35除以3余2,5乘7乘2=70除以3余1，所以是70</p><p><strong>条件二：用5除</strong></p><p>3*7=21除以5余1，所以是21</p><p><strong>条件三：用7除</strong></p><p>3*5=15除以7余1，所以是15</p><h3 id="公倍数乘以余数相加"><a href="#公倍数乘以余数相加" class="headerlink" title="公倍数乘以余数相加"></a>公倍数乘以余数相加</h3><p><code>70*2+21*3+15*4=263</code></p><p>解读加法：设上式为q+p+r=n。只判断加法会不会影响满足条件1(用3除余2)即可推导出是否满足另外两个条件。</p><p><strong>若n除以a余b，n加上a的倍数再除以a余数仍然为b</strong>，这里n为140，a为3，b为2，加上的p、r之和是3的倍数，所以余数仍为2，仍满足条件1。（发现百度百科这条定理写错了，嘻。我这数学水平也就能折腾折腾小学数学了吧）</p><blockquote><p>【百度】您于2018-08-31提交的百科词条“秦王暗点兵”版本已通过，查看词条内容：（ <a href="http://dwz.cn/s4JsvyGW" target="_blank" rel="noopener">http://dwz.cn/s4JsvyGW</a> ）。感谢您参与编写百度百科，亿万网友因您的贡献受益。</p></blockquote><p>9月1日跑步时收到这条短信，这比兴奋剂还兴奋剂，就想来段加速跑。wuhu~</p><p>同理可得，通过加法之后我们得到了一个同时满足三个条件的数字</p><h3 id="检验是否最小"><a href="#检验是否最小" class="headerlink" title="检验是否最小"></a>检验是否最小</h3><p>用上边得到的数字不断减去三个除数的最小公倍数直至数字小于最小公倍数(其实就是得到的数字除以公倍数取余了)，得到最终答案！</p><p>解读：其实就是上边加粗定理的变式，<strong>若n除以a余b，n减去a的倍数再除以a余数仍然为b</strong>，只是可能说成余数是几不太合理，但要懂那个意思。</p><h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><p>个人感觉过程中的前两步完全可以合成一步，在代码实现中很容易就可以看出来，拆开反而更难理解…(差评)</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到一个最小的数，使其除以x余a，除以y余b，除以z余c</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;<span class="comment">//除数</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;<span class="comment">//余数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d %d"</span>,&amp;x,&amp;y,&amp;z,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="comment">//求第二、三个除数的公倍数</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((Lcm(y,z)*i%x)!=<span class="number">1</span>)</span><br><span class="line">    i++;</span><br><span class="line"><span class="comment">//求第一、三个除数的公倍数</span></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(((Lcm(x,z)*j%y))!=<span class="number">1</span>)</span><br><span class="line">    j++;</span><br><span class="line"><span class="comment">//求第一、二个除数的公倍数</span></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((Lcm(x,y)*k%z)!=<span class="number">1</span>)</span><br><span class="line">    k++;</span><br><span class="line"><span class="comment">//公倍数乘以对应余数后求和</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">sum+=Lcm(x,z)*j*b;</span><br><span class="line">sum+=Lcm(y,z)*i*a;</span><br><span class="line">sum+=Lcm(x,y)*k*c;</span><br><span class="line"><span class="comment">//确认最小值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum%Lcm(Lcm(x,y),z));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*拓展对应的代码~~~~~~~~可以替代5到23行</span></span><br><span class="line"><span class="comment">int sum = 0;</span></span><br><span class="line"><span class="comment">//求第二、三个除数的公倍数同时乘以相应余数求和</span></span><br><span class="line"><span class="comment">int i = 1;</span></span><br><span class="line"><span class="comment">while ((Lcm(y, z)*i%x) != a)</span></span><br><span class="line"><span class="comment">    i++;</span></span><br><span class="line"><span class="comment">sum += Lcm(y, z)*i;</span></span><br><span class="line"><span class="comment">//求第一、三个除数的公倍数同时乘以相应余数求和</span></span><br><span class="line"><span class="comment">int j = 1;</span></span><br><span class="line"><span class="comment">while (((Lcm(x, z)*j%y)) != b)</span></span><br><span class="line"><span class="comment">    j++;</span></span><br><span class="line"><span class="comment">sum += Lcm(x, z)*j;</span></span><br><span class="line"><span class="comment">//求第一、二个除数的公倍数同时乘以相应余数求和</span></span><br><span class="line"><span class="comment">int k = 1;</span></span><br><span class="line"><span class="comment">while ((Lcm(x, y)*k%z) != c)</span></span><br><span class="line"><span class="comment">    k++;</span></span><br><span class="line"><span class="comment">sum += Lcm(x, y)*k;</span></span><br><span class="line"><span class="comment">//确认最小</span></span><br><span class="line"><span class="comment">printf("%d\n", sum % Lcm(Lcm(x, y), z));</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="瑕不掩瑜"><a href="#瑕不掩瑜" class="headerlink" title="瑕不掩瑜"></a>瑕不掩瑜</h1><p>如果输入 3 3 3 1 1 1(可能这有点刁钻啊)</p><p><strong>合并法中</strong>，会发现结果是7，但按照我们给出的题目结果应该是1啊！？</p><p>7的来源是：</p><p>第一次合并为<code>3*1+1=4</code>，除以3余1，符合条件2，所以得到4；</p><p>第二次合并为<code>4*1+1=7</code>，除以3余1，符合条件3，结果为7。</p><p>所以答案是7的原因是因为我们默认i是从1开始增长，它代表我们要求的数一定大于三个除数，算经中的问题其实也隐含了这个条件结果要大于三个除数。</p><p>如果i从0开始增长，最终答案会是1。</p><p><strong>在中国剩余定理中</strong>，我们会发现无法跳出循环<code>while ((Lcm(y, z)*i%x) != a) i++;</code>，</p><p>原因可能就是定理不适用这种情况吧。我没有深入了解中国剩余定理及其使用。因为我是从韩信点兵的题目了解到这些知识的。搜了一下中国剩余定理，发现它是数论里的一个知识，似乎使用也有一些条件，这里不再过多探索。</p><p>emm还是去看了下，中国剩余定理用的时候已经假设了三个除数两两互质。所以输入3 3 3 1 1 1这种就没必要了。但如果能弄懂3 3 3 1 1 1，还是可以让我们对定理有个更好的理解。</p><p>(放过我吧，每次写完东西都会发现bug，让我不爽..再多的抽象，也得加点前提条件呐。哪有那么多适用于所有情况的东西，真理也是少之又少。但简单的东西又没那么值得写，最多算个记录罢了)</p><p>希望有人可以给我提提建议~单机一点不好玩</p><p>作者：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io/2018/09/01/物不知其数/#more">https://chouxianyu.github.io/2018/09/01/物不知其数/#more</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章分为三个大的部分：&lt;/p&gt;
&lt;p&gt;大标题1是物不知其数问题的引入，大标题2将问题抽象。&lt;/p&gt;
&lt;p&gt;大标题3、4、5是物不知其数问题的三种解法及其代码实现。&lt;/p&gt;
&lt;p&gt;大标题6是提出的一些问题及不太完善的解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提醒&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常量指针与指针常量</title>
    <link href="https://chouxianyu.github.io/2018/08/26/%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F/"/>
    <id>https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/</id>
    <published>2018-08-25T19:49:34.000Z</published>
    <updated>2018-09-01T13:55:10.583Z</updated>
    
    <content type="html"><![CDATA[<p>常量指针和指针常量是两个经常出现的概念，今天做个小小总结。</p><p>文章各部分的内容都是很容易理解的，并且附加代码说明，一切的前提是理解<strong>文章2.1和2.2部分</strong>，所以搞好基础再往后看呐。干货在嫌长的直接跳到结论去。</p><h1 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h1><p>最近在看vc，看到书里有提这两个概念，学c的时候也有这两个概念，学c++的时候也有顶层const和底层const（这个我懂是懂，但从理解层次上不是那么懂）。所以就是很常见啦，但似乎很多人很迷惑，或者说理解着不舒服。于是我的“神逻辑”就来了。（希望不要被大佬按在地上摩擦，谢谢合作。欢迎讨论，欢迎留言，欢迎转发。如果你不嫌我菜的话，欢迎提各方面的问题，我可以研究研究）</p><h1 id="我对它们的理解"><a href="#我对它们的理解" class="headerlink" title="我对它们的理解"></a>我对它们的理解</h1><p>常指指常这种名词是英文翻译过来的，所以中文会有点拗口。常量的、指针的，我们生活中是没有这样的词的。</p><p>有的英语变成中文会很生涩。英文里是这样的两个东西:pointer to const, const pointer。const是constant的缩写。</p><p>中文有两种翻译方法：pointer to const, const pointer。constant可以是名词也可以是形容词</p><p>第一种：指向常量的指针（常量指针），指针常量。</p><p>第二种：指向常量的指针（指针常量，有人讲就不应该有指针常量的说法），常量指针。</p><p>说来说去都是中文的文字游戏，那个英文该怎么翻译。英文里很容易能看懂的，换成中文就有两种换法。</p><p>第二种方法确实不该有指针常量这个说法。所以要讨论中文版的话，如果出现指针常量，就应该是第一种方法。</p><p><a href="https://www.thegeekstuff.com/2012/06/c-constant-pointers换成英文就不用玩文字游戏了" target="_blank" rel="noopener">https://www.thegeekstuff.com/2012/06/c-constant-pointers换成英文就不用玩文字游戏了</a></p><p>所以呢，本质上应该用英语去讲。但本篇是讲中文版的一种方法。（去百度也会发现有两种方法）。</p><p>本文用第一种说法，常指是pointer to const，指常是 const pointer。我觉得两种翻译都可以。这里是这种中文说法而已。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>常指指常就是两个词而已，都是四个字。把前边的两个字当做形容词（是用来修饰后边的名词的），后边的名词才是重点。</p><p><strong>指针就是地址嘛，常量就是不可以修改的量</strong>（初始化不算做赋值，不算做修改）。</p><p><strong>注意区分指针本身（的内容）和指向的内存的内容。</strong></p><p>修改指针即改变指针本身的内容，修改内存或者说修改内存内容就是修改指针指向的内存中的内容。这样讲的很清楚了吧……..</p><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><p>常量指针中的常量呢，指的是这个指针的作用是常量性的、不可修改的，即<strong>不可以通过该指针修改内存中的内容</strong>，并不代表指向的内存不修改，注意前边有通过二字。</p><p>这个词也有<strong>指向常量的指针</strong>的叫法，我认为这个中文叫法是不准确的甚至是<strong>错误</strong>的。如果说常量指针是指向常量的指针，我认为这句话最直接的意思是说指针指向的内存是常量，这个意思是错误的，会误导他人，所以我不提倡这样叫它。证明参见<strong>文章3.3部分</strong></p><p>在讨论问题的时候，互相知道对方说的是什么东西非常重要~，比如c++里默认构造，没有构造函数这样的句子，不同人的理解方式不同，这些概念理解也是讨论进行的一个前提。</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><p>这里的指针呢，指的是<strong>这个常量是一个地址</strong>。</p><h2 id="如何根据定义判断类型"><a href="#如何根据定义判断类型" class="headerlink" title="如何根据定义判断类型"></a>如何根据定义判断类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p;<span class="comment">//常量指针</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> * p;<span class="comment">//常量指针 跟上一句等效</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p;<span class="comment">//指针常量</span></span><br></pre></td></tr></table></figure><h3 id="根据const和-的相对位置"><a href="#根据const和-的相对位置" class="headerlink" title="根据const和*的相对位置"></a>根据const和*的相对位置</h3><p>const 在*左边=》常量指针；反之，指针常量。</p><h3 id="根据谁离变量名近"><a href="#根据谁离变量名近" class="headerlink" title="根据谁离变量名近"></a>根据谁离变量名近</h3><p>const近=》指针常量；反之，常量指针。（const就是不变嘛，*就是指针啊，所以理解是很重要的，也就是<strong>2.1</strong>）</p><h1 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h1><h2 id="常量指针-1"><a href="#常量指针-1" class="headerlink" title="常量指针"></a>常量指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="comment">//char ch[] = "HelloWorld!";</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pStr1=ch;<span class="comment">//定义常量指针</span></span><br><span class="line"><span class="comment">//1.常量指针本身的值可以修改</span></span><br><span class="line">pStr1 = <span class="literal">nullptr</span>;<span class="comment">//correct</span></span><br><span class="line"><span class="comment">//2.不能通过常量指针修改它所指向的内存中的内容（注意通过二字，不要误会常量指针）</span></span><br><span class="line">*pStr1 = <span class="string">'h'</span>;<span class="comment">//error</span></span><br><span class="line">*(pStr1 + <span class="number">1</span>) = <span class="string">'E'</span>;<span class="comment">//error</span></span><br><span class="line">pStr1[<span class="number">2</span>] = <span class="string">'L'</span>;<span class="comment">//error</span></span><br></pre></td></tr></table></figure><h2 id="指针常量-1"><a href="#指针常量-1" class="headerlink" title="指针常量"></a>指针常量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码3</span></span><br><span class="line"><span class="comment">//char ch[] = "HelloWorld!";</span></span><br><span class="line"><span class="comment">//指针常量（顶层const）</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> pStr2 = ch;<span class="comment">//定义并初始化</span></span><br><span class="line"><span class="comment">//1.是常量，不可以被赋值（不把初始化叫做赋值）</span></span><br><span class="line">pStr2 = <span class="literal">nullptr</span>;<span class="comment">//error</span></span><br></pre></td></tr></table></figure><h2 id="常量指针容易被误解的地方"><a href="#常量指针容易被误解的地方" class="headerlink" title="常量指针容易被误解的地方"></a>常量指针容易被误解的地方</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码4</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;<span class="comment">//定义变量n</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;n;<span class="comment">//常量指针p1</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;n;<span class="comment">//指针常量p2</span></span><br><span class="line">*p1 = <span class="number">3</span>;<span class="comment">//error 因为不能通过常量指针修改内存中的内容，划重点！：但这不是说指向内存中的内容不可修改</span></span><br><span class="line">n = <span class="number">3</span>;<span class="comment">//correct这是对的，因为n是变量啊</span></span><br><span class="line">*p2 = <span class="number">3</span>;<span class="comment">//correct 指针常量部分的代码就有体现，不多说</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码5</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">0</span>;<span class="comment">//定义变量n</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;n;<span class="comment">//常量指针p1</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;n;<span class="comment">//error 错误的 原因见下-指针间的赋值</span></span><br><span class="line">*p1 = <span class="number">3</span>;<span class="comment">//error 原因是常指不可修改内存</span></span><br><span class="line">n = <span class="number">3</span>;<span class="comment">//error 原因是n是变量</span></span><br></pre></td></tr></table></figure><p>代码4和代码5中的<strong>常量指针p1都不能改变内存中内容，但内存中内容是否可修改是不一定的</strong>。（代码4的第5第6行要好好看）</p><p>原因是：常量指针不可以修改内存是因为不可以<strong>通过常量指针修改内存</strong>所致（你不通过常量指针的话，变量是否可以修改就不一定了），内存是否修改则是根据定义的情况了。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h2 id="常量指针-2"><a href="#常量指针-2" class="headerlink" title="常量指针"></a>常量指针</h2><p>在这里指pointer to const。指针作用是常量性的，不可以通过它修改指向内存（容易被误会成内存一定不可修改）。</p><h2 id="指针常量-2"><a href="#指针常量-2" class="headerlink" title="指针常量"></a>指针常量</h2><p>英文里指const pointer。指针是一个常量，指针本身不可以被修改。</p><p>作者：<a href="https://chouxianyu.github.io/">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/#more">https://chouxianyu.github.io/2018/08/26/常量指针与指针常量/#more</a></p><p>欢迎转发和评论</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常量指针和指针常量是两个经常出现的概念，今天做个小小总结。&lt;/p&gt;
&lt;p&gt;文章各部分的内容都是很容易理解的，并且附加代码说明，一切的前提是理解&lt;strong&gt;文章2.1和2.2部分&lt;/strong&gt;，所以搞好基础再往后看呐。干货在嫌长的直接跳到结论去。&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="c/c++" scheme="https://chouxianyu.github.io/tags/c-c/"/>
    
      <category term="指针" scheme="https://chouxianyu.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>JAI丢包掉帧处理</title>
    <link href="https://chouxianyu.github.io/2018/08/22/JAI%E4%B8%A2%E5%8C%85%E6%8E%89%E5%B8%A7%E5%A4%84%E7%90%86/"/>
    <id>https://chouxianyu.github.io/2018/08/22/JAI丢包掉帧处理/</id>
    <published>2018-08-22T05:34:40.000Z</published>
    <updated>2018-08-23T03:13:13.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题：时间戳停止变化-图像停止更新"><a href="#问题：时间戳停止变化-图像停止更新" class="headerlink" title="问题：时间戳停止变化/图像停止更新"></a>问题：时间戳停止变化/图像停止更新</h1><h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>本小白刚刚接触JAI，有很多不懂的地方。这次遇到问题是请教了YZ大哥（不知道年龄，暂时这么称呼），很感谢YZ大哥的耐心指导。因为我不仅不知道怎么调，连在哪里调也不知道╭(╯^╰)╮。以下是此次问题解决步骤，是YZ大哥跟我说怎么做，然后我照做，过程中又遇到问题，下边也给出了碰到的问题以及相应的解决方法。（8.21更）</p><p>刚刚又看了下JAI SDK Getting Started Guide，发现YZ讲的方法就是文档里那部分我觉得可以先跳过的内容，出现问题应该也是因为我没有按照文档进行配置…..可能我写的这个会有错误、遗漏、表述模糊，具体操作还可参加文档说明（8.22更）</p><p><img src="https://i.loli.net/2018/08/22/5b7ced57146fe.jpg" alt="文档步骤_2018-08-22_10-08-38.jpg"></p><p>4.4=》设置接收缓冲区    4.5=》设置中断调整    4.6=》打开巨型帧    4.7=》计算和设置包延迟</p><h1 id="出现问题原因：图像传输时丢包（掉帧）"><a href="#出现问题原因：图像传输时丢包（掉帧）" class="headerlink" title="出现问题原因：图像传输时丢包（掉帧）"></a>出现问题原因：图像传输时丢包（掉帧）</h1><h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><h2 id="使用-JAI-Control-Tool-采集图像-防止丢包"><a href="#使用-JAI-Control-Tool-采集图像-防止丢包" class="headerlink" title="使用 JAI Control Tool 采集图像 防止丢包"></a>使用 JAI Control Tool 采集图像 防止丢包</h2><h3 id="如何使用JAI-Control-Tool-采集图像"><a href="#如何使用JAI-Control-Tool-采集图像" class="headerlink" title="如何使用JAI Control Tool 采集图像"></a>如何使用JAI Control Tool 采集图像</h3><p><img src="https://i.loli.net/2018/08/22/5b7ced5711c84.png" alt="如何采集图像_2018-08-22_12-17-37.png"></p><h3 id="如何查看是否丢包？"><a href="#如何查看是否丢包？" class="headerlink" title="如何查看是否丢包？"></a>如何查看是否丢包？</h3><p><img src="https://i.loli.net/2018/08/22/5b7ced5713cc5.png" alt="如何查看丢包1_2018-08-22_12-21-47.png"> <img src="https://i.loli.net/2018/08/22/5b7ced57138a1.png" alt="如何查看丢包2_2018-08-22_12-24-36.png"></p><p>除了通过搜索，也可以找到GigE Image Acquisition-Total missing packets<br>其实观察刚开始采集图像时图片是否有撕裂的情况（出现水平黑线）</p><h2 id="如果丢包-设置相机据包为8000左右（我是8196）"><a href="#如果丢包-设置相机据包为8000左右（我是8196）" class="headerlink" title="如果丢包 设置相机据包为8000左右（我是8196）"></a>如果丢包 设置相机据包为8000左右（我是8196）</h2><h3 id="如何设置相机数据包"><a href="#如何设置相机数据包" class="headerlink" title="如何设置相机数据包"></a>如何设置相机数据包</h3><p><img src="https://i.loli.net/2018/08/22/5b7ced571414e.png" alt="设置相机数据包大小_2018-08-22_12-48-27.png"></p><h2 id="设置相机数据包后用JAI-Control-Tool采图时黑屏，查看黑屏是是否有帧率"><a href="#设置相机数据包后用JAI-Control-Tool采图时黑屏，查看黑屏是是否有帧率" class="headerlink" title="设置相机数据包后用JAI Control Tool采图时黑屏，查看黑屏是是否有帧率"></a>设置相机数据包后用JAI Control Tool采图时黑屏，查看黑屏是是否有帧率</h2><h3 id="如何查看帧率"><a href="#如何查看帧率" class="headerlink" title="如何查看帧率"></a>如何查看帧率</h3><p><img src="https://i.loli.net/2018/08/22/5b7cef324a84b.png" alt="如何查看帧率_2018-08-22_12-50-05.png"></p><h2 id="有帧率则调整网卡巨型帧等"><a href="#有帧率则调整网卡巨型帧等" class="headerlink" title="有帧率则调整网卡巨型帧等"></a>有帧率则调整网卡巨型帧等</h2><h3 id="如何找到相机连接的网卡"><a href="#如何找到相机连接的网卡" class="headerlink" title="如何找到相机连接的网卡"></a>如何找到相机连接的网卡</h3><p>网络和共享中心-以太网（就是相机那条网线）-属性-由勾选EBUS设置为不勾选EBUS 同时可以看到连接时使用的网卡</p><p>找到网卡右击-属性-高级-巨型帧（由关闭设为9KB MTU）接收缓冲区设为最大（我的最大只有512，只能这样了）</p><p><img src="https://i.loli.net/2018/08/22/5b7ced57143c1.png" alt="多个网络适配器_2018-08-22_10-27-53.png"></p><p><img src="https://i.loli.net/2018/08/22/5b7cef324c87f.png" alt="连接的哪个网卡_2018-08-22_12-54-08.png"></p><p><img src="https://i.loli.net/2018/08/22/5b7ced571412e.png" alt="进入网卡属性_2018-08-22_10-30-09.png"></p><p><img src="https://i.loli.net/2018/08/22/5b7ced571406f.png" alt="巨型帧_2018-08-22_10-33-07.png"><br><strong>提醒：文档中指出当巨型帧打开的时候，相机数据包大小就可以大于1500bytes，但相机数据包必须小于巨型帧大小。</strong></p><p><img src="https://i.loli.net/2018/08/22/5b7ced57144fc.png" alt="中断调整_2018-08-22_10-33-32.png"></p><p><img src="https://i.loli.net/2018/08/22/5b7ced57144cf.png" alt="接收缓冲区_2018-08-22_10-32-30.png"></p><p><strong>提醒：文档中指出典型的接收缓冲区最大值为2048，标准默认值为256，请结合自己的实际情况</strong></p><p>是不是我的网卡太菜了，众筹给我买个好的可以吗？？？</p><h2 id="如果仍丢包则根据文档设置延时直至成功"><a href="#如果仍丢包则根据文档设置延时直至成功" class="headerlink" title="如果仍丢包则根据文档设置延时直至成功"></a>如果仍丢包则根据文档设置延时直至成功</h2><h3 id="如何设置延时？"><a href="#如何设置延时？" class="headerlink" title="如何设置延时？"></a>如何设置延时？</h3><p>参照文档设置延时（主要是帧率）我的Max Fps是2.00 ，Band Width是90%</p><p><img src="https://i.loli.net/2018/08/22/5b7cf09b8b686.png" alt="设置延迟1_2018-08-22_13-09-13.png"></p><p><img src="https://i.loli.net/2018/08/22/5b7cf09b7f5db.png" alt="设置延迟2_2018-08-22_13-10-54.png"></p><p>修改最大帧率，调整带宽，点击calculate，点击ok。（文档指出当数据包大小或者像素格式改变时，数据包延迟都需要重新计算）</p><p>最后查看是否丢包 如有丢包可以再次调整数据包大小和延迟。<br>另外有一点是，图像的传输是和你整个电脑的运行都有关系的，而不只是网卡和相机设置。</p><p>这是第一次记录bug，图片好像有点多或者说有点乱，下次可以尝试以文字为主！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题：时间戳停止变化-图像停止更新&quot;&gt;&lt;a href=&quot;#问题：时间戳停止变化-图像停止更新&quot; class=&quot;headerlink&quot; title=&quot;问题：时间戳停止变化/图像停止更新&quot;&gt;&lt;/a&gt;问题：时间戳停止变化/图像停止更新&lt;/h1&gt;&lt;h1 id=&quot;描述&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JAI" scheme="https://chouxianyu.github.io/tags/JAI/"/>
    
  </entry>
  
  <entry>
    <title>FirstWriting</title>
    <link href="https://chouxianyu.github.io/2018/08/16/FirstWriting/"/>
    <id>https://chouxianyu.github.io/2018/08/16/FirstWriting/</id>
    <published>2018-08-16T07:53:07.000Z</published>
    <updated>2018-08-16T09:33:27.467Z</updated>
    
    <content type="html"><![CDATA[<p><del>在很久很久以前，你拥有我我拥有你  《外面的世界》</del><br>在很久很久以前我就有搞一个类似博客的东西的想法，不过一直都没有尝试着搞……<br>某天（10号左右吧）刷知乎看到github和hexo可以搭建博客，于是我就来了hhh<br>不过搞的时候也遇到了好多bug，跳了好多坑…<br>博客一是分享，二是记录，三四五还没想起来。</p><p>这是第一次写博客，学习内容是一点点markdown语法，文末有这次学习的链接，之后应该会再好好学学markdown语法。</p><h1 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h1><p><em>斜体1：文字两侧各一个星号</em><br><em>斜体2：文字两侧各一个下划线</em><br><strong>粗体：文字两侧各两个星号</strong><br><strong><em>粗斜体：文字两侧各三个星号</em></strong><br><del>删除线：文字两侧各两个波浪号</del></p><p>那就有个疑问了，如果星号、波浪号、下划线出现在文字中怎么处理…或者说这种情况很少吧，并且对内容没什么影响</p><h1 id="标题怎么用"><a href="#标题怎么用" class="headerlink" title="标题怎么用"></a>标题怎么用</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>行内形式：<a href="https://chouxianyu.github.io/">我的博客</a><br>参考形式：[我的博客][1],[github][2]<br>[1]:<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io/</a><br>[2]:<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>自动链接：我的博客地址<a href="https://chouxianyu.github.io/">https://chouxianyu.github.io/</a></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>无序列表项1</li></ul><ul><li>无序列表项2</li></ul><ul><li>无序列表项3</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>1.有序列表项1<br>2.有序列表项2<br>3.有序列表项3</p><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p><img src="/images/heizi.jpg" alt=""></p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><table><thead><tr><th>表头1</th><th style="text-align:left">表头2</th><th style="text-align:center">表头3</th><th style="text-align:right">表头4</th></tr></thead><tbody><tr><td>默认左对齐</td><td style="text-align:left">显式左对齐</td><td style="text-align:center">居中对齐</td><td style="text-align:right">右对齐</td></tr><tr><td>默认左对齐</td><td style="text-align:left">显式左对齐</td><td style="text-align:center">居中对齐</td><td style="text-align:right">右对齐</td></tr><tr><td>默认左对齐</td><td style="text-align:left">显式左对齐</td><td style="text-align:center">居中对齐</td><td style="text-align:right">右对齐</td></tr><tr><td>默认左对齐</td><td style="text-align:left">显式左对齐</td><td style="text-align:center">居中对齐</td><td style="text-align:right">右对齐</td></tr></tbody></table><h1 id="转载自https-www-jianshu-com-p-56d99a3049a5"><a href="#转载自https-www-jianshu-com-p-56d99a3049a5" class="headerlink" title="转载自https://www.jianshu.com/p/56d99a3049a5"></a>转载自<a href="https://www.jianshu.com/p/56d99a3049a5" target="_blank" rel="noopener">https://www.jianshu.com/p/56d99a3049a5</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;del&gt;在很久很久以前，你拥有我我拥有你  《外面的世界》&lt;/del&gt;&lt;br&gt;在很久很久以前我就有搞一个类似博客的东西的想法，不过一直都没有尝试着搞……&lt;br&gt;某天（10号左右吧）刷知乎看到github和hexo可以搭建博客，于是我就来了hhh&lt;br&gt;不过搞的时候也遇到了
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://chouxianyu.github.io/tags/hexo/"/>
    
      <category term="markdown" scheme="https://chouxianyu.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>MyHelloWorld</title>
    <link href="https://chouxianyu.github.io/2018/08/16/MyHelloWorld/"/>
    <id>https://chouxianyu.github.io/2018/08/16/MyHelloWorld/</id>
    <published>2018-08-16T02:48:13.000Z</published>
    <updated>2018-08-16T02:48:13.230Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://chouxianyu.github.io/2018/08/10/hello-world/"/>
    <id>https://chouxianyu.github.io/2018/08/10/hello-world/</id>
    <published>2018-08-10T12:24:19.691Z</published>
    <updated>2018-08-10T12:24:19.691Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
