<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2019-04-29T14:23:59.512Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浙江理工大学数学建模校赛B题记录</title>
    <link href="https://chouxianyu.github.io/2019/04/29/%E6%B5%99%E6%B1%9F%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A0%A1%E8%B5%9BB%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://chouxianyu.github.io/2019/04/29/浙江理工大学数学建模校赛B题记录/</id>
    <published>2019-04-29T14:21:10.000Z</published>
    <updated>2019-04-29T14:23:59.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">w=[...</span><br><span class="line">    <span class="number">0</span>,   <span class="number">80</span>, <span class="number">150</span>,   <span class="number">90</span>, <span class="number">140</span>, <span class="number">100</span>, <span class="number">120</span>; </span><br><span class="line"><span class="number">120</span>,     <span class="number">0</span>, <span class="number">180</span>, <span class="number">100</span>,   <span class="number">60</span>,   <span class="number">70</span>, <span class="number">110</span>; </span><br><span class="line"><span class="number">100</span>, <span class="number">160</span>,     <span class="number">0</span>,   <span class="number">80</span>,   <span class="number">90</span>,   <span class="number">50</span>,   <span class="number">70</span>;</span><br><span class="line">  inf,   inf,   inf,     <span class="number">0</span>,   <span class="number">40</span>,   <span class="number">70</span>, <span class="number">180</span>; </span><br><span class="line">  inf,   inf,   inf,   <span class="number">30</span>,     <span class="number">0</span>,   <span class="number">80</span>, <span class="number">150</span>; </span><br><span class="line">  inf,   inf,   inf,   <span class="number">80</span>,   <span class="number">90</span>,     <span class="number">0</span>,   <span class="number">50</span>;</span><br><span class="line">  inf,   inf,   inf, <span class="number">130</span>, <span class="number">140</span>,   <span class="number">60</span>,     <span class="number">0</span>; ];</span><br><span class="line"><span class="comment">% 设甲、乙、丙三个矿区为顶点v1，v2，v3，</span></span><br><span class="line"><span class="comment">% A、B、C、D 三个冶炼厂为v4、v5、v6、v7。</span></span><br><span class="line"><span class="comment">% 该矩阵表示7个顶点间的距离</span></span><br><span class="line"><span class="comment">% 由于不是对称矩阵，第一行第二行的元素表示甲到乙还是乙到甲是有区别的。题目不严谨，而老师PPT里是前者。有待区分(TODO)</span></span><br><span class="line"><span class="comment">% <span class="doctag">TODO:</span>graphallshortestpaths函数中的图参数 inf用0表示也可以？</span></span><br><span class="line"><span class="comment">% 该矩阵与题给数据是否完全一样，有待比较(TODO)</span></span><br></pre></td></tr></table></figure><h2 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h2><p>构造有向图，G=(V,E, W)，顶点、边、权重。甲、乙、丙三个矿区为顶点v1，v2，v3，<br>% A、B、C、D 三个冶炼厂为v4、v5、v6、v7。TODO:这部分可以参考骆桦PPT或者相关书籍与论文。</p><p>xij&gt;0，肯定大于0。即负数用表示同样含义的正数表示（TODO：怎么说呢）</p><p>由于可以转运：</p><p><strong>IMPORTANT</strong>：为什么不是用该矩阵中的值作为顶点之间的距离，而是根据此矩阵计算最短路径？（因为题中说可以转运，而最短路径即包括了转运的含义）</p><p>问题中<strong>最优</strong>的定义：</p><p>矿区的矿物产量刚好达到（即等于）冶炼厂矿物需求量（TODO：矿物产量和矿物需求量这两个词是否合适，应参照题目或统一规定用词），这是两个约束条件。</p><p><strong>IMPORTANT</strong>：因为题目是求<strong>矿区到各冶炼厂间</strong>矿石的最优调运方案，所以从最短路径中提取出两个矿区（甲乙）到四个冶炼厂（ABCD）的最短距离</p><p>分别用i =1, 2表示甲乙两个矿区，j =1，2，3，4表示A、B、C、D三个电厂，     cij表示第i个矿区到第j个冶炼厂的最短距离，xij表示第i个矿区到第j个冶炼厂的调运量，ai表示第i个矿区的产量，bj表示第j个冶炼厂的需求量。</p><p>这里是产量和需求平衡的运输问题</p><h2 id="一些假设"><a href="#一些假设" class="headerlink" title="一些假设"></a>一些假设</h2><ul><li>花费与路径长度和运送量相关，所以假设花费=路径长度*运送量。在这一点可以尝试讨论，优化？</li><li>假设调运方案中从矿区到各冶炼厂间调运吨数为整数，试试改成小数？</li></ul><h2 id="matlab程序"><a href="#matlab程序" class="headerlink" title="matlab程序"></a>matlab程序</h2><p>计算出的最短路径矩阵，前三行后四列是我们的结果，如下。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">90</span>   <span class="number">130</span>   <span class="number">100</span>   <span class="number">120</span></span><br><span class="line"><span class="number">90</span>     <span class="number">60</span>     <span class="number">70</span>   <span class="number">110</span></span><br><span class="line"><span class="number">80</span>     <span class="number">90</span>     <span class="number">50</span>     <span class="number">70</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line"></span><br><span class="line">w=[...</span><br><span class="line">    <span class="number">0</span>,   <span class="number">80</span>, <span class="number">150</span>,   <span class="number">90</span>, <span class="number">140</span>, <span class="number">100</span>, <span class="number">120</span>; </span><br><span class="line"><span class="number">120</span>,     <span class="number">0</span>, <span class="number">180</span>, <span class="number">100</span>,   <span class="number">60</span>,   <span class="number">70</span>, <span class="number">110</span>; </span><br><span class="line"><span class="number">100</span>, <span class="number">160</span>,     <span class="number">0</span>,   <span class="number">80</span>,   <span class="number">90</span>,   <span class="number">50</span>,   <span class="number">70</span>;</span><br><span class="line">  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,     <span class="number">0</span>,   <span class="number">40</span>,   <span class="number">70</span>, <span class="number">180</span>; </span><br><span class="line">  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">30</span>,     <span class="number">0</span>,   <span class="number">80</span>, <span class="number">150</span>; </span><br><span class="line">  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">80</span>,   <span class="number">90</span>,     <span class="number">0</span>,   <span class="number">50</span>;</span><br><span class="line">  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>, <span class="number">130</span>, <span class="number">140</span>,   <span class="number">60</span>,     <span class="number">0</span>; ];</span><br><span class="line"></span><br><span class="line">W = sparse(w);</span><br><span class="line">d = graphallshortestpaths(W)</span><br><span class="line">NodeIDs = &#123;<span class="string">'甲'</span>, <span class="string">'乙'</span>,<span class="string">'丙'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>&#125;; <span class="comment">% 节点标签，也就是h.Nodes(i).ID属性值</span></span><br><span class="line">h = view(biograph(w, NodeIDs, <span class="string">'ShowWeights'</span>, <span class="string">'on'</span>))</span><br><span class="line">set(h.Nodes, <span class="string">'shape'</span>, <span class="string">'circle'</span>); <span class="comment">% 顶点画成圆形</span></span><br><span class="line">h.EdgeType = <span class="string">'segmented'</span>; <span class="comment">% 边的连接为线段</span></span><br><span class="line">h.LayoutType = <span class="string">'radial'</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">dolayout(h) <span class="comment">% 刷新图形 会报错，故放在try块中，不影响结果，待深究</span></span><br><span class="line"><span class="keyword">catch</span> exception</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">h2 = view(biograph(d, NodeIDs, <span class="string">'ShowWeights'</span>, <span class="string">'on'</span>));</span><br><span class="line">h2.EdgeType =  <span class="string">'segmented'</span>; <span class="comment">% 边的连接为线段</span></span><br><span class="line">h2.LayoutType = <span class="string">'equilibrium'</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">dolayout(h2) <span class="comment">% 刷新图形 会报错，故放在try块中，不影响结果，待深究</span></span><br><span class="line"><span class="keyword">catch</span> exception</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>TODO:matlab的图不怎么样。修改matlab参数、图论工具箱、网络分析工具箱、NetworkX</p><h2 id="lingo程序"><a href="#lingo程序" class="headerlink" title="lingo程序"></a>lingo程序</h2><p>矩阵x和Objective Value是我们的最终结果：各矿区到各冶炼厂最优调度方案。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">kuang/<span class="number">1.</span><span class="number">.3</span> /:a; !甲乙丙矿区的产量;</span><br><span class="line">chang/<span class="number">1.</span><span class="number">.4</span> /:b; !ABCD四个冶炼厂的矿石用量;</span><br><span class="line">link(kuang,chang):c,x;</span><br><span class="line">endsets</span><br><span class="line">data:</span><br><span class="line">a = <span class="number">700</span> <span class="number">500</span> <span class="number">500</span>;</span><br><span class="line">b = <span class="number">400</span> <span class="number">300</span> <span class="number">400</span> <span class="number">600</span>;</span><br><span class="line">c = <span class="number">90</span>   <span class="number">130</span>   <span class="number">100</span>   <span class="number">120</span></span><br><span class="line"> <span class="number">90</span>     <span class="number">60</span>     <span class="number">70</span>   <span class="number">110</span></span><br><span class="line"> <span class="number">80</span>     <span class="number">90</span>     <span class="number">50</span>     <span class="number">70</span>;</span><br><span class="line">enddata</span><br><span class="line">min = @sum(link: c * x);</span><br><span class="line">@<span class="keyword">for</span>(kuang(<span class="built_in">i</span>):@sum(chang(<span class="built_in">j</span>):x(<span class="built_in">i</span>, <span class="built_in">j</span>)) = a(<span class="built_in">i</span>));</span><br><span class="line">@<span class="keyword">for</span>(chang(<span class="built_in">j</span>):@sum(kuang(<span class="built_in">i</span>):x(<span class="built_in">i</span>, <span class="built_in">j</span>)) = b(<span class="built_in">j</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>TODO：检验答案正确性</p><p>135000.0</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果：三个矿区到四个冶炼厂的调度方案</span><br><span class="line"><span class="number">400</span> <span class="number">0</span>  <span class="number">200</span> <span class="number">100</span></span><br><span class="line"><span class="number">0</span> <span class="number">300</span> <span class="number">200</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">500</span></span><br></pre></td></tr></table></figure><h2 id="待解决主要问题"><a href="#待解决主要问题" class="headerlink" title="待解决主要问题"></a>待解决主要问题</h2><p>图画的不行、论文（建立模型部分、假设部分），可能这只是第一题，不需要花太大精力。</p><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>几乎不用假设和建模，而且老师也给了两个lingo程序。但现在问题是老师给的第二个lingo程序看不太懂，不知道怎么把B题里的数据套进去。</p><p>我借的matlab书上都有直接给代码，但很长。</p><p>最大流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">nodes/s,1,2,3,t/;</span><br><span class="line">arcs(nodes,nodes):c,f;</span><br><span class="line">endsets</span><br><span class="line">data:</span><br><span class="line">c=0;</span><br><span class="line">@text(&apos;fdata.txt&apos;)=f;</span><br><span class="line">enddata</span><br><span class="line">calc:</span><br><span class="line">c(1,2)=20;c(1,3)=16;</span><br><span class="line">c(2,4)=4;c(2,5)=14;</span><br><span class="line">c(3,2)=10;c(3,4)=20;</span><br><span class="line">c(4,5)=8;</span><br><span class="line">endcalc</span><br><span class="line">n=@size(nodes);</span><br><span class="line">max=flow;</span><br><span class="line">@for(nodes(i)|i #ne# 1 #and# i #ne#n:@sum(nodes(j):f(i,j))=@sum(nodes(j):f(j,i)));    </span><br><span class="line">@sum(nodes(i):f(1,i))=flow;</span><br><span class="line">@sum(nodes(i):f(i,n))=flow;</span><br><span class="line">@for(arcs:@bnd(0,f,c));</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>最小费用最大流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">nodes/s,1,2,3,t/:d;</span><br><span class="line">arcs(nodes,nodes):b,c,f;</span><br><span class="line">endsets</span><br><span class="line">data:</span><br><span class="line">d=22 0 0 0 -22;</span><br><span class="line">b=0;c=0;</span><br><span class="line">enddata</span><br><span class="line">calc:</span><br><span class="line">b(1,2)=12;b(1,3)=3;</span><br><span class="line">b(2,4)=18;b(2,5)=3;</span><br><span class="line">b(3,2)=6;b(3,4)=9;</span><br><span class="line">b(4,5)=6;</span><br><span class="line">c(1,2)=20;c(1,3)=16;</span><br><span class="line">c(2,4)=4;c(2,5)=14;</span><br><span class="line">c(3,2)=10;c(3,4)=20;</span><br><span class="line">c(4,5)=8;</span><br><span class="line">endcalc</span><br><span class="line">min=@sum(arcs:b*f);</span><br><span class="line">@for(nodes(i):@sum(nodes(j):f(i,j))-@sum(nodes(j):f(j,i))=d(i));   </span><br><span class="line">@for(arcs:@bnd(0,f,c));</span><br><span class="line">End</span><br></pre></td></tr></table></figure><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><h2 id="可选方法"><a href="#可选方法" class="headerlink" title="可选方法"></a>可选方法</h2><p><code>数学实验13-树算法08</code>PPT里的后三种方法：</p><p>改进的贪心</p><p>模拟退火</p><p>修改过的prim</p><h2 id="英文论文阅读"><a href="#英文论文阅读" class="headerlink" title="英文论文阅读"></a>英文论文阅读</h2><h3 id="s-commentary-the-outstanding-Steiner-tree-papers"><a href="#s-commentary-the-outstanding-Steiner-tree-papers" class="headerlink" title="s commentary the outstanding Steiner tree papers"></a>s commentary the outstanding Steiner tree papers</h3><h4 id="准确解"><a href="#准确解" class="headerlink" title="准确解"></a>准确解</h4><ul><li>暴力法</li></ul><p>直接暴力，890+个可能位置。</p><p>Hanan的一个理论，被三个队伍引用，说只需要考虑和一个已知站x坐标相同并且和另外一个已知站y坐标相同的steiner点。可能的steiner点位置减少到63个。</p><p>在此基础上可以，删除角落里的点，可能的位置减少到31个。</p><ul><li>动态规划</li></ul><p>虽然它还是要计算已知点的所有子集，但它避免测试所有steiner点的子集。</p><p>通过该这样的方法，几个小时可以找到50个可能位置，但似乎没有人这样做。</p><p>电脑芯片设计者通常喜欢近似解，因为网络的长度并不总是操作速度的限制条件。</p><h4 id="近似解"><a href="#近似解" class="headerlink" title="近似解"></a>近似解</h4><p>一个近似算法是不用虚设点，直接使用最小生成树，Hwang证明这个长度不超过steiner树的150%，但这当然不满足题目的要求。</p><p>某队找到一个最好的steiner点，然后把它加进已知站，之后重复这个策略直到加了7个点或者不可能优化了。这个方法找到了一个可能解，但并不是每次都可以这样。</p><p>某队用了多种不同的启发式算法，并且用另外四个样例对他们的方法进行了测试。另外，他们在评估他们的算法时做了一个好的决定。关于最小生成树他们还给了一个优化方案，因为他们通常不能计算准确的steiner树。他们的启发式算法都用了贪心策略。他们想出了一种改进的克鲁斯卡尔算法，模仿克鲁斯卡尔但如果有利的话会使用steiner点。这个启发式算法找到了一种可能解。虽然这个算法在速度上优于上一队，但面对更大规模的问题时它不一定能找到相当好的解。</p><p>某队(也就是下边的这个论文)用了<strong>模拟退火</strong>，模拟退火根据当地重新排列规则随机从某种解移向某种解。移向一个解的概率取决于这两个解的花费和一个叫做温度的控制变量。通过一个合适的冷却速率，这个启发式算法最终停在一个几乎最优解。他们模拟了100次这个程序都得到了最优解。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后简单总结一下，有两种方法：</p><ul><li><p>exact solution</p><p>  求确切的最优解，有两种方法。</p><ul><li><p>暴力枚举法</p><p>  通过减少steiner点可能的位置来节约时间，仍然是在用这种方法。</p></li><li><p>动态规划</p><p>  似乎没有人用这个。</p></li></ul></li><li><p>近似解</p><p>  通过启发式算法，求近似最优解，有几种方法。</p><ul><li><p>单点贪心</p><p>  每次先找到一个最好的steiner点，将其加入已知站，直至N-2或不可能有更好的解了。</p></li><li><p>改进克鲁斯卡尔算法</p><p>  模仿克鲁斯卡尔，但考虑了steiner点。</p></li><li><p><strong>模拟退火</strong>，这是最好的一个方法</p><p>  还未具体去看那篇论文(1991 B Finding optimal Steiner trees)</p></li></ul></li></ul><h3 id="1991-B-Finding-optimal-Steiner-trees"><a href="#1991-B-Finding-optimal-Steiner-trees" class="headerlink" title="1991 B Finding optimal Steiner trees"></a>1991 B Finding optimal Steiner trees</h3><h4 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h4><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>这是一种更有效的寻找所有可行的虚设点和已知点组合的方式。</p><p>我们从一个已给的虚设点和已知点组成的树开始，并且允许模拟退火程序创造一个新的配置。对每一个新配置来说，程序决定了最小生成树并且计算其长度。然后模拟退火程序在冷却计划的基础上决定是使用还是拒绝新配置。修改一个配置和评价这个修改方案都很简单。</p><p>这个方法很有普适性：任何初始配置都可能被使用，并且算法并不直接取决于固定的站点设置。</p><p>和暴力相反，模拟退火并不一定能产生绝对的最优解。然而，我们可以按照我们的希望控制其停在当前最小值（和绝对的最优解不同），同时与暴力相比，计算时间可得到很大的缩减。</p><p>虚设点有31个可能位置作为初始条件。该模拟退火程序的输入是已知点位置、steiner点的可能位置，还有一个初始路径。（我们手动找了一个最优解，并将其作为程序的输入。我们把已知网络按照三点一组的规则进行分组，每组添加一个虚设点使该组最优，然后使各组最优，得到的配置作为模拟退火的最小路径出现了几次。）</p><p>现在配置改变的方式随机从下边选择：</p><ul><li>随机在可能位置添加一个steiner点</li><li>移除一个已加入的虚设点</li><li>将一个已加入的steiner点随机移到一个新的位置</li></ul><p>（通过这三种方式，我们可以尝试所有可能的网络配置。如果是为了这样做，第三种方式并没有必要；但是为了给模拟退火步骤更大的自由性，我们包含了这种方法。）</p><p>使用存储起来的新配置，为了建立最小生成树和评价网络的花费，一个计算程序会被调用。这个花费然后会被程序的模拟退火部分（routine METROP from Press et al.）使用，以决定新的配置是否被保存或拒绝（根据一个意见一致的冷却计划）。</p><p>刚开始的前几次表明一个趋势：增加度为2的虚设点是没用的。虽然虚设点并不花费什么，我们决定在程序中排除这个多余，通过引入较小的虚设点花费，这个花费足够小，并不会影响在必要时加入虚设点，反而最终会处理没有必要的虚设点。</p><p>我们同时也添加了一个模拟退火中不经常出现的特点，借此这个程序可以存储测试出的最优解。（模拟退火一般只返回最终使用的配置）</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>平均迭代9800次退火，1.5min（在25-MHz 386-based PC）</p><p>用不同的种子形成不同的随机数生成器，给了5种不同的最优解，长度为94。</p><p>超过100个回合时，模拟退火总是收敛到5种中的1种，证明它适用于更大范围的steiner树的问题（当暴力是不可能的时候）。</p><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>如果所有站点是有花费的</p><p>如果想用模拟退火，我们可以：</p><ul><li>用一些暴力方法</li><li>模拟退火数量、位置、虚设点的度（嵌套退火）</li><li>修改最小生成树算法，找到花费最小（而不是路径长度最短）的树，并且用前边的模拟退火</li></ul><p>似乎前两种方法太费时间而且效率不高，我们选择第三种。</p><p>虽然模拟退火不一定能给出最优解，但它在100次试验之后，确实给了最优解（暴力检查过）。</p><h1 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h1><ul><li><p>2019.4.4</p><ul><li><p>工作</p><p>  尝试做第一题，写了一些假设，思路和需要注意的点等等。</p></li><li><p>感想</p><p>  平常还是要做好充足的准备，不要等着题发下来了才去详细了解某些知识和算法。比如这次校赛，昨天出的题，B题就是课上讲过的东西，如果当时抽时间具体研究了，现在不是就已经会了吗？（虽然现在刚学习建模不久，而且当时好像没时间……当然是选择原谅自己）</p></li></ul></li><li><p>2019.4.5</p><ul><li><p>工作</p><p>  实现第一题matlab程序，发现作的图好丑，不够清晰。寻求解决办法，了解到网络分析工具箱、NetWorkX等。</p></li><li><p>感想</p><p>  擒贼先擒王。最终目的是写一篇好的论文。现在应该把整个思路给定下来，大体上进行实现。不是能因为这个图花费太多时间，应该在后期优化。</p></li></ul></li><li><p>2019.4.6</p><ul><li><p>工作</p><p>  实现第一题lingo程序，得到答案。重新回顾第一题，整理思路、材料和之后需要做的相关工作。</p><p>  看第二题，最小费用最小流，好像得出答案比较简单。了解steiner树，查阅文献。</p></li><li><p>感想</p><p>  道阻且长，我应该对lingo、matlab极其熟悉吗？</p></li></ul></li><li><p>2019.4.7</p><ul><li><p>工作</p><p>  阅读英文论文点评并总结，着手查看比较好的一篇论文。</p></li><li><p>感想</p><p>  类似的问题，可以直接去看论文。另一方面，更好的是去看论文点评，能够站在顶层往下学习还是很不错的一种体验。</p><p>  问题让求steiner树，我们可能是要先证明每个图中steiner数是一定存在的？</p></li></ul></li><li><p>2019.4.8</p><ul><li><p>工作</p><p>  阅读英文论文模拟退火部分并总结，解决第二题最小费用最大流。</p></li></ul></li><li><p>2019.4.9</p><ul><li><p>工作</p><p>  上完建模课和队友讨论，知道了凸包..…突然发现题目要求很变态的一点，管道必须是平行于x轴或y轴的。这个是求出结果后不证自明，还是过程中就要求判断呢。</p></li></ul></li><li><p>2019.4.10</p><ul><li><p>工作</p><p>  知道凸包是什么了，知道了为什么用L距离，又了解了几种求近似解的方法。着手模拟退火算法</p></li><li><p>感想</p><p>  啊..……不会………..…..…不想说话</p></li></ul></li><li><p>2019.4.11</p><ul><li><p>工作</p><p>  学习模拟退火，学了一半吧</p></li></ul></li><li><p>2019.4.12</p><ul><li><p>工作</p><p>  继续学习模拟退火，学完了，知道是什么，大概知道怎么用。</p><p>  着手将题目与模拟退火结合，设计代码。</p></li></ul></li><li><p>2019.4.13</p><ul><li><p>工作</p><p>  敲代码，整体结构敲出来了，差一个扰动函数</p></li><li><p>感想</p><p>  matlab的基础还是不足，很多东西都需要搜着做</p></li></ul></li><li><p>2019.4.14</p><ul><li><p>工作</p><p>  写扰动函数，尝试调参。难呐..…</p></li></ul></li><li><p>2019.4.17</p><ul><li><p>工作</p><ul><li><p>通过暴力，发现这个题和普通的steiner树不一样，按普通的steiner树求解的话，是不符合题目要求的。</p><p>  它要求边水平或竖直，这样目标函数就应该改成合法性了。</p></li><li><p>设想了目标函数为合法性的算法如何实现。</p></li></ul></li></ul></li><li><p>2019.4.20</p><ul><li><p>工作</p><p>  实现目标函数为合法性的程序，最终可以求得合法的steiner树。但无用的steiner点太多了，需要优化。</p></li></ul></li><li><p>2019.4.21</p><ul><li><p>工作</p><p>  在合法树的基础上进行长度和steiner点个数的优化。</p><p>  遗留了一个问题：自己写的一个函数总是出问题，不符预期。</p></li></ul></li><li><p>2019.4.22</p><ul><li><p>工作</p><p>  解决昨天遗留的问题，写函数优化无用的steiner点。（原因是在for循环中数组变小了，然后就越界了，python中也有这样的东西嘛我记得</p><p>  求得最终答案（不知道强迫症还是什么，总感觉有隐患..…，不过本来的思路就是求近似最优解..）</p><p>  整理代码，完善注释。</p><p>  那个无用的steiner点即使写了优化函数之后还是有，原因是去掉无用点之后，调用最小生成树算法，这个算法导致有多余的steiner点的产生。</p></li></ul></li><li><p>2019.4.23</p><ul><li><p>工作</p><p>  讨论结果和论文思路，分工</p></li></ul></li><li><p>2019.4.24</p><ul><li><p>工作</p><p>  中午下课吃完饭回来就写论文，晚上剪头，吃麻辣烫看了两集BigBang，回来继续写，写到现在11点半了，写了2500+字。主体部分已经写了有四分之三了，一些细节写在了注释里。耶</p></li></ul></li><li><p>2019.4.25</p><ul><li><p>工作</p><p>  上下午第四节都在写论文，算法设计与分析也在写论文..…整体上是写完了，剩下的工作是补充细节。</p></li></ul></li><li><p>2019.4.26</p><ul><li><p>工作</p><p>  快中午的时候开始补充论文细节，一直到晚上，效率挺低的，可能是分工问题，另外是还有一些讨论的工作。</p></li></ul></li><li><p>2019.4.27</p><ul><li><p>工作</p><p>  流程图、公式、标题、字体、程序代码等等都搞定了，差不多结束了，第一题代码太烂就先算了吧，那个不重要。</p></li></ul></li><li><p>2019.4.28</p><ul><li><p>工作</p><p>  搞细节咯，还修改了个流程图。检查了几遍，结束咯~</p></li></ul></li></ul><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;h2 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h2&gt;&lt;f
      
    
    </summary>
    
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-第五章作业</title>
    <link href="https://chouxianyu.github.io/2019/04/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
    <id>https://chouxianyu.github.io/2019/04/25/汇编语言-第五章作业/</id>
    <published>2019-04-25T12:49:43.000Z</published>
    <updated>2019-04-25T12:50:07.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写程序，将一个包含有20个数据的数组M分成两个数组：正数数组P和负数数组N，并分别把这两个数组中的数据个数显示出来。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">flow</span><br><span class="line">start=&gt;start: 开始</span><br><span class="line">getNum=&gt;operation: 取数组下个元素</span><br><span class="line">whetherNegative=&gt;condition: 是负数？</span><br><span class="line">isPositive=&gt;operation: 存入正数数组</span><br><span class="line">isNegative=&gt;operation: 存入负数数组</span><br><span class="line">whetherEnd=&gt;condition: 数组最后一个元素？</span><br><span class="line">showNegative=&gt;operation: 显示偶数个数</span><br><span class="line">showPositive=&gt;operation: 显示奇数个数</span><br><span class="line">end=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">start-&gt;getNum-&gt;whetherNegative</span><br><span class="line">whetherNegative(yes)-&gt;isNegative</span><br><span class="line">whetherNegative(no)-&gt;isPositive</span><br><span class="line">isNegative-&gt;whetherEnd</span><br><span class="line">isPositive-&gt;whetherEnd</span><br><span class="line">whetherEnd(no)-&gt;getNum</span><br><span class="line">whetherEnd(yes)-&gt;showPositive-&gt;showNegative-&gt;end</span><br></pre></td></tr></table></figure><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>初始数组中存放20个数字：<code>1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">separator0 dw &apos;A&apos;; 间隔符，方便查看内存内容</span><br><span class="line">array dw 1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10 ; 存放数组</span><br><span class="line">separator1 dw &apos;A&apos;; 间隔符，方便查看内存内容</span><br><span class="line">P dw 20 dup (?) ; 存放正数</span><br><span class="line">separator2 dw &apos;A&apos;; 间隔符，方便查看内存内容</span><br><span class="line">N dw 20 dup (?) ; 存放负数</span><br><span class="line">separator3 dw &apos;A&apos;; 间隔符，方便查看内存内容</span><br><span class="line">lenOfArray equ 20; 数组长度</span><br><span class="line">lenOfP db 0 ; 存放正数的个数</span><br><span class="line">lenOfN db 0 ; 存放负数的个数</span><br><span class="line">positive db 0dh, 0ah, &apos;the positive number is：&apos;, &apos;$&apos; ; 正数的个数是：</span><br><span class="line">negative db 0dh, 0ah, &apos;the negative number is：&apos;, &apos;$&apos; ; 负数的个数是：</span><br><span class="line">crlf db 0dh, 0ah, &apos;$&apos;;回车换行</span><br><span class="line">data ends</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">code segment</span><br><span class="line">main proc far</span><br><span class="line">assume cs: code, ds: data</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds ; ds入栈</span><br><span class="line">sub ax, ax ; ax置0</span><br><span class="line">push ax ; 0入栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; ds存储数据段地址</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax ; 给ds赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line">mov cx, lenOfArray; 遍历array，cx置为array的长度</span><br><span class="line">lea bx, array; 将array存入bx</span><br><span class="line">lea si, P; 将P存入si</span><br><span class="line">lea di, N; 将N存入di</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">begin1:</span><br><span class="line">mov ax, [bx]; ax指向array数组</span><br><span class="line">cmp ax, 0 ; 判断是否为负数</span><br><span class="line">js isnegative; 结果为负则转移至isnegative</span><br><span class="line">mov [si], ax ; 是正数，存入正数数组</span><br><span class="line">inc lenOfP ; 正数个数+1</span><br><span class="line">add si, 2; si后移</span><br><span class="line">jmp short next; 判断array数组的下一个元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">isnegative:</span><br><span class="line">mov [di], ax ; 是负数，存入负数数组</span><br><span class="line">inc lenOfN ; 负数个数+1</span><br><span class="line">add di, 2; di后移</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">add bx, 2; bx后移</span><br><span class="line">loop begin1; cx为0是跳出循环，运行后边的代码</span><br><span class="line"></span><br><span class="line">lea dx, positive ; 显示正数个数</span><br><span class="line">mov al, lenOfP</span><br><span class="line">call display ; 调显示子程序</span><br><span class="line"></span><br><span class="line">lea dx, negative ; 显示负数个数</span><br><span class="line">mov al, lenOfN</span><br><span class="line">call display ; 调显示子程序</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">display proc near ; 显示子程序</span><br><span class="line">mov ah, 9 ; 调用9号DOS功能，显示一个字符串</span><br><span class="line">int 21h; DOS系统功能调用</span><br><span class="line">aam ; 将(al)中的二进制数转换为二个非压缩bcd码</span><br><span class="line">add ah, ‘0’ ; 变为 0～9 的 ASCII 码</span><br><span class="line">mov dl, ah</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ah, 2 ; 调用2号DOS功能，显示一个字符</span><br><span class="line">int 21h</span><br><span class="line">add al, ‘0’ ; 变为 0～9 的ASCII码</span><br><span class="line">mov dl, al</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ah, 2 ; 调用2号DOS功能，显示一个字符</span><br><span class="line">int 21h</span><br><span class="line">lea dx, crlf ; 显示回车换行</span><br><span class="line">mov ah, 9 ; 调用9号DOS功能，显示一个字符串</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">display endp ; 显示子程序结束</span><br><span class="line">code ends ; 以上定义代码段</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2019/04/25/5cc1ac17759f4.png" alt="数组分正负1.png"></p><p><img src="https://i.loli.net/2019/04/25/5cc1ac17074fd.png" alt="数组分正负2.png"></p><h1 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>试编写一个汇编语言程序，求出首地址为array的100D字数组中的最小偶数，并把它存放在AX中。</p><h2 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">array dw 100 dup(?)</span><br><span class="line">data ends</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">code segment</span><br><span class="line">main proc far</span><br><span class="line">assume cs: code, ds: data</span><br><span class="line">start:</span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds ; ds入栈</span><br><span class="line">sub ax, ax ; ax置0</span><br><span class="line">push ax ; 0入栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; ds存储数据段地址</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax ; 给ds赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compare:</span><br><span class="line">mov ax, data[bx]; 取数组的第一个数</span><br><span class="line">add bx, 2</span><br><span class="line">test ax, 01h ; 是偶数吗？</span><br><span class="line">loopnz compare ; 不是，则比较下一个数</span><br><span class="line">jnz stop ; 没有偶数，退出</span><br><span class="line">jcxz stop ; 最后一个数是偶数，即为最小偶数，退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compare1:</span><br><span class="line">mov dx, data[bx]; 取数组的下一个数</span><br><span class="line">add bx, 2</span><br><span class="line">test dx, 01h ; 是偶数吗？</span><br><span class="line">jnz next ; 不是，比较下一个数</span><br><span class="line">cmp ax, dx ; (ax)&lt;(dx)吗？</span><br><span class="line">jle next</span><br><span class="line">mov ax, dx ; (ax)&lt;(dx)，则置换(ax)为最小偶数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">loop compare1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">code ends ; 以上定义代码段</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="5-12"><a href="#5-12" class="headerlink" title="5.12"></a>5.12</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>有一个首地址为MEM的100D字数组，试编制程序删除数组中所有为0的项，并将后续项向前压缩，最后将数组的剩余部分补上0。</p><h2 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">mem dw 100 dup (?)</span><br><span class="line">data ends</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">code segment</span><br><span class="line">main proc far</span><br><span class="line">assume cs: code, ds: data</span><br><span class="line">start:</span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds ; 设置返回 dos</span><br><span class="line">sub ax, ax</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">; ds指向代码段</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax ; 给ds赋值</span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line">mov si, (100-1)*2 ; (si)指向 mem 的末元素的首地址</span><br><span class="line">mov bx, -2 ; 地址指针的初值</span><br><span class="line">mov cx, 100</span><br><span class="line"></span><br><span class="line">comp: add bx, 2</span><br><span class="line">cmp mem [bx], 0</span><br><span class="line">jz cons</span><br><span class="line">loop comp</span><br><span class="line">jmp finish ; 比较结束，已无0，则结束</span><br><span class="line"></span><br><span class="line">cons:</span><br><span class="line">mov di, bx</span><br><span class="line"></span><br><span class="line">cons1:</span><br><span class="line">cmp di, si ; 到了最后单元吗？</span><br><span class="line">jae nomov</span><br><span class="line">mov ax, mem [di+2] ; 后面的元素向前移位</span><br><span class="line">mov mem [di], ax</span><br><span class="line">add di, 2</span><br><span class="line">jmp cons1</span><br><span class="line"></span><br><span class="line">nomov:</span><br><span class="line">mov word ptr [si], 0; 最后单元补 0</span><br><span class="line">loop comp</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">code ends ; 以上定义代码段</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5-6&quot;&gt;&lt;a href=&quot;#5-6&quot; class=&quot;headerlink&quot; title=&quot;5.6&quot;&gt;&lt;/a&gt;5.6&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火学习</title>
    <link href="https://chouxianyu.github.io/2019/04/25/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/04/25/模拟退火学习/</id>
    <published>2019-04-24T18:01:13.000Z</published>
    <updated>2019-04-24T18:06:58.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="与贪心的区别"><a href="#与贪心的区别" class="headerlink" title="与贪心的区别"></a>与贪心的区别</h1><p>出现较好的解就使用，发现不了就形成解。缺点：跳不出局部最优解</p><p>模拟退火：与贪心类似，但可以以一定的概率跳出局部最优解，通过两个式子实现，Metropolis准则。玻尔兹曼分布</p><h1 id="模拟退火算法和物理退火过程的对应"><a href="#模拟退火算法和物理退火过程的对应" class="headerlink" title="模拟退火算法和物理退火过程的对应"></a>模拟退火算法和物理退火过程的对应</h1><div class="table-container"><table><thead><tr><th style="text-align:center">模拟退火算法</th><th style="text-align:center">物理退火过程</th></tr></thead><tbody><tr><td style="text-align:center">解</td><td style="text-align:center">粒子状态</td></tr><tr><td style="text-align:center">目标函数</td><td style="text-align:center">能量</td></tr><tr><td style="text-align:center">最优解</td><td style="text-align:center">能量最低态</td></tr><tr><td style="text-align:center">设定初温</td><td style="text-align:center">设置加温到几度</td></tr><tr><td style="text-align:center">扰动</td><td style="text-align:center">热涨落</td></tr><tr><td style="text-align:center">metropolis采样过程</td><td style="text-align:center">热平衡，粒子状态满足玻尔兹曼分布</td></tr><tr><td style="text-align:center">控制参数的下降</td><td style="text-align:center">冷却</td></tr></tbody></table></div><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><p>缩进代表层级嵌套关系。</p><ul><li><p>构造一个初始解，令当前解为该解。</p></li><li><p>设置初始温度，初始温度要设得比较高。</p></li><li><p>主要算法，while循环：</p><p>  循环条件可以是温度的阈值或者是解不怎么变化了</p><ul><li><p>for循环</p><p>  平衡过程，在该温度下，使达到平衡（metropolis），恒温下1到$T_L$步</p><ul><li>根据当前解随机生成一个邻解，跟当前解非常接近（扰动，for循环就是多次扰动）</li><li><p>计算邻解的目标函数（花费、路程、大小、钱数等等），减去当前解的目标函数，求得目标函数变化量</p></li><li><p>如果变化量小于0（即优化了），使用该邻近解；如果没有优化，则用metropolis准    则，看是不是要跳出坑，跳出则使用该邻解。</p></li></ul></li><li><p>平衡后设置新温度，即降温。</p></li></ul></li></ul><h1 id="模拟退火算法设计要素"><a href="#模拟退火算法设计要素" class="headerlink" title="模拟退火算法设计要素"></a>模拟退火算法设计要素</h1><h2 id="初始解的生成"><a href="#初始解的生成" class="headerlink" title="初始解的生成"></a>初始解的生成</h2><p>如果初始解比较好的话，收敛得就很快。</p><p>通常以一个随机解作为初始解，并保证理论上能生成解空间中任意的解。（一般要多做几次模拟退火，即试用不同的初始解，再取最优的）</p><p>也可以是一个挑出来的比较好的解。这种情况下，初始温度应当设置得较低。</p><p>初始解不宜“太好”，否则很难从这个解的邻域中跳出。</p><h2 id="邻解生成函数"><a href="#邻解生成函数" class="headerlink" title="邻解生成函数"></a>邻解生成函数</h2><p>应尽可能保证产生的候选解能遍布整个解空间。</p><p>邻域应尽可能的小，能够在少量循环内充分探测，但每次的改变不应该引起太大的变化。</p><h2 id="初始温度如何设定"><a href="#初始温度如何设定" class="headerlink" title="初始温度如何设定"></a>初始温度如何设定</h2><p>初始应该尽可能的高，以确保最终解不受初始解影响，但过高又会增加计算时间。</p><p>均匀抽样一组状态，以各状态目标值的方差为初温。（随机生成一组解）</p><p>等等</p><p>※ 正式开始退火算法前，可进行一个升温过程确定初始温度：逐渐增加温度，直到所有尝试运动都被接受，将此时的温度设置为初始温度。</p><p>等等</p><h2 id="等温步数如何确定"><a href="#等温步数如何确定" class="headerlink" title="等温步数如何确定"></a>等温步数如何确定</h2><p>等温步数即同一个温度下，跑几个循环。</p><p>等温步数也称Metropolis抽样稳定准则，用于决定在各温度下产生候选解的数目，通常取决于解空间和邻域的大小。如果解空间小，步数可以小一点。</p><p>等温过程是为了让系统达到平衡，因此可通过检验目标函数的均值是否稳定（或连续若干步的目标值变化较小，这个可以写一个函数来检测）来确定等温步数。等温步数可以长，也就是多平衡一会而已。</p><p>等温步数受温度的影响。高温时，等温步数可以较小；温度较小时，等温步数要大。随着温度降低，增加等温步数。（因为高温的时候比较混乱， 温度小的时候就在不停地收敛了），可以将等温步数设置成一个温度的函数。</p><p>有时为了考虑方便，也可以直接按一定的步数抽样。不区分高温和低温时的等温步数，大一点就好啦。</p><h2 id="如何降温"><a href="#如何降温" class="headerlink" title="如何降温"></a>如何降温</h2><p>经典模拟退火算法降温方式</p><p>快速模拟退火算法降温方式</p><p>常用的其他降温方式</p><p>后边两种比较常用</p><h2 id="花费函数"><a href="#花费函数" class="headerlink" title="花费函数"></a>花费函数</h2><p>不要太复杂，应该能被快速的计算，花费函数的计算是程序的可能瓶颈。</p><p>一般用目标函数构造花费函数即可。目标函数、目标函数的倒数/相反数经常直接作为花费函数                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p><h2 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h2><p>理论上温度降为0才终止退火算法，因为此时没有概率跳出坑了。但实际温度较低时，尝试的接受概率就几乎为0了。</p><p>设置终止温度的阈值，或设置外循环循环迭代次数。</p><p>算法搜索到的最优值连续若干步保持不变。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>有人说这就是遗传算法+梯度下降。老师说这个算法属于一种蒙特卡洛算法，和蒙特卡洛算法类似。国赛和美赛几乎不会考TSP，太简单了，小比赛才有可能让选手练手。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;与贪心的区别&quot;&gt;&lt;a href=&quot;#与贪心的区别&quot; class=&quot;headerlink&quot; title=&quot;与贪心的区别&quot;&gt;&lt;/a&gt;与贪心的区别&lt;/h1&gt;&lt;p&gt;出现较好的解就使用，发现不了就形成解。缺点：跳不出局部最优解&lt;/p&gt;
&lt;p&gt;模拟退火：与贪心类似，但可以以一
      
    
    </summary>
    
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之继承（一）</title>
    <link href="https://chouxianyu.github.io/2019/04/16/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2019/04/16/C-C-小课之继承（一）/</id>
    <published>2019-04-16T15:18:33.000Z</published>
    <updated>2019-04-24T17:50:40.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h1><p>继承源于生物界，指后代能够传承前代的特征和行为。</p><h2 id="基类和子类"><a href="#基类和子类" class="headerlink" title="基类和子类"></a>基类和子类</h2><p>继承使我们可以通过一个已有的类创建一个新类，新类自然获得已有类的全部功能。在<strong>某个继承关系</strong>中，已有的类在这个继承关系中作为<strong>基类</strong>、<strong>超类</strong>或<strong>父类</strong>，新类称为<strong>派生类</strong>或<strong>子类</strong>。</p><p>具体来讲，子类复制了基类的全体数据成员和成员函数。此外，子类还可以进行扩充、修改和重定义。</p><p>同一个类可以作为多个类的基类，一个子类也可以作为另一个类的基类。</p><p>基类和子类是继承关系中的概念，并不是本质的概念，而是关系上的概念。</p><h2 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h2><p>A作为基类，B作为子类时，我们称：</p><ul><li>B继承A</li><li>A派生B</li></ul><h2 id="单继承和多继承"><a href="#单继承和多继承" class="headerlink" title="单继承和多继承"></a>单继承和多继承</h2><p>只能从一个基类派生的继承称为<strong>单继承</strong>，即一个类一次最多继承一个基类。</p><p>可以从多个基类派生的继承称为<strong>多继承</strong>。</p><p>C++支持单继承和多继承。</p><p>Java只支持单继承，需要“多继承”时使用<strong>接口</strong>实现。（接口是什么，学了Java就知道了）</p><h1 id="类成员访问权限"><a href="#类成员访问权限" class="headerlink" title="类成员访问权限"></a>类成员访问权限</h1><p>C++类成员访问权限默认为<strong>private</strong>。</p><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>语法正确的条件下，访问不受控制，在哪里都可以访问。</p><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>只能在<strong>类内</strong>、<strong>友元函数</strong>访问。</p><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>只能在<strong>类内</strong>、<strong>子类内</strong>、<strong>友元函数</strong>访问。</p><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><p><strong>注意</strong>：继承方式决定的是<strong>子类如何继承基类成员的访问权限</strong>。</p><p>不同继承方式会不同程度地<strong>改变基类成员在派生类中的访问权限</strong>。（个人觉得这句话不好，易让人误解）</p><p>C++中继承方式默认为<code>private</code>。</p><h2 id="public-1"><a href="#public-1" class="headerlink" title="public"></a>public</h2><p>基类成员的访问权限在派生类中保持<strong>不变</strong>。</p><p>基类的<code>private</code>成员、<code>public</code>成员、<code>protected</code>成员在子类中保持他们在基类中相同的访问权限。</p><h2 id="private-1"><a href="#private-1" class="headerlink" title="private"></a>private</h2><p>基类成员的访问权限在派生类中全部变为<code>private</code>。</p><h2 id="protected-1"><a href="#protected-1" class="headerlink" title="protected"></a>protected</h2><p>基类的<code>public</code>成员的访问权限在派生类中变为<code>protected</code>。</p><p><code>private</code>成员和<code>protected</code>成员的访问权限不变。</p><h1 id="派生类对基类的扩展"><a href="#派生类对基类的扩展" class="headerlink" title="派生类对基类的扩展"></a>派生类对基类的扩展</h1><p>派生类<strong>可以</strong>：</p><ul><li><strong>增加</strong>新的数据成员和成员函数</li><li><strong>重载</strong>从基类继承到的成员函数</li><li>覆盖（<strong>重定义</strong>）从基类集成到的成员函数</li><li>改变基类成员在派生类中的访问属性（通过继承方式实现）</li></ul><p>派生类<strong>不能</strong>继承基类的以下内容：</p><ul><li>析构函数</li><li>基类的友元函数</li><li>静态成员<ul><li>静态数据成员</li><li>静态成员函数</li></ul></li></ul><p><strong>注意</strong>：</p><p>静态成员为整个继承体系公有。</p><p>C++11之前，派生类不能继承基类的构造函数，C++11之后可以。</p><h2 id="成员函数的重定义、重载及隐藏"><a href="#成员函数的重定义、重载及隐藏" class="headerlink" title="成员函数的重定义、重载及隐藏"></a>成员函数的重定义、重载及隐藏</h2><p>派生类对继承到的基类成员函数的<strong>重定义</strong>或<strong>重载</strong>都会影响它们在派生类中的可见性。</p><p>派生类对基类函数进行重定义或重载时，由于继承和类作用域的原因，导致了隐藏，解决隐藏有三种方法。</p><p><strong>影响可见性</strong>：</p><p>如果派生类<strong>重定义</strong>或者<strong>重载</strong>了基类中某个函数名为<code>func</code>的函数，则基类中的所有名字为<code>func</code>的函数都会被<strong>隐藏</strong>。（其中<strong>隐藏</strong>指的是在派生类中不能直接看到这个函数。）</p><p><strong>解决</strong>：</p><ol><li><p>通过基类名称访问被派生类<strong>重定义</strong>或<strong>重载</strong>隐藏的函数，</p><p> 如<code>基类::函数名(...)</code>。</p></li><li><p>重载基类的所有同名函数，这些重载函数的代码与基类完全相同。</p></li><li><p>使用<code>using</code>。</p></li></ol><p>前两种方法都很繁琐。</p><p>而C++11提供了<code>using</code>使基类中被隐藏的函数在派生类中可见，具体使用在后边的<code>using</code>部分讲解。</p><h3 id="重定义"><a href="#重定义" class="headerlink" title="重定义"></a>重定义</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><strong>覆盖</strong>也称为<strong>重定义</strong>、<strong>重写</strong>。</p><p>重定义是指派生类定义与基类<strong>具有相同参数列表</strong>的同名成员函数。</p><p>（关于重定义的定义，我个人认为书上P147的说法是错的。）</p><h4 id="隐藏及解决"><a href="#隐藏及解决" class="headerlink" title="隐藏及解决"></a>隐藏及解决</h4><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">()</span><span class="comment">//重定义Base类的void print()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b1;</span><br><span class="line">Derived d1;</span><br><span class="line"></span><br><span class="line">b1.print();<span class="comment">//Base类调用函数正常</span></span><br><span class="line">b1.print(<span class="number">1</span>);<span class="comment">//Base类调用函数正常</span></span><br><span class="line"></span><br><span class="line">d1.print();<span class="comment">//Base类中的print()被隐藏，调用Derived类的print()</span></span><br><span class="line">d1.print(<span class="number">1</span>);<span class="comment">//该行报错，编译不通过。原因是Derived类的int print()重定义了Base类的void print()，导致Base中所有同名函数被隐藏，即print(int)和print()被隐藏。</span></span><br><span class="line"></span><br><span class="line">d1.Base::print();<span class="comment">//调用Base类的print()</span></span><br><span class="line">d1.Base::print(<span class="number">1</span>);<span class="comment">//调用Base类的print(int)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将第34行注释后，输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base::print()</span><br><span class="line">Base::print().....<span class="number">.1</span></span><br><span class="line">Derived::print()</span><br><span class="line">Base::print()</span><br><span class="line">Base::print().....<span class="number">.1</span></span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>重载与重定义不同，重载要求成员函数名称相同，但<strong>具有不同的参数列表</strong>。</p><p>（关于重载的定义，我个人认为书上P147的说法是错的）</p><h4 id="隐藏及解决-1"><a href="#隐藏及解决-1" class="headerlink" title="隐藏及解决"></a>隐藏及解决</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> i)</span><span class="comment">//重载Base类的两个print函数，即print()、print(int i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int print(int i);//这个是重定义Base的void print(int i)，而非重载</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b1;</span><br><span class="line">Derived d1;</span><br><span class="line"></span><br><span class="line">b1.print();<span class="comment">//Base类调用函数正常</span></span><br><span class="line">b1.print(<span class="number">1</span>);<span class="comment">//Base类调用函数正常</span></span><br><span class="line"></span><br><span class="line">d1.print();<span class="comment">//该行报错，因为Derived的print(char i)重载了Base类的两个print函数，它们在Derived类中被隐藏了</span></span><br><span class="line">d1.print(<span class="string">'A'</span>);<span class="comment">//调用Derived类的print(char i)</span></span><br><span class="line"></span><br><span class="line">d1.Base::print();<span class="comment">//调用Base类的print()</span></span><br><span class="line">d1.Base::print(<span class="number">1</span>);<span class="comment">//调用Base类的print(int)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将第33行注释后，输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base::print()</span><br><span class="line">Base::print().....<span class="number">.1</span></span><br><span class="line">Derived::print()......A</span><br><span class="line">Base::print()</span><br><span class="line">Base::print().....<span class="number">.1</span></span><br></pre></td></tr></table></figure><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><p>using有两个用途：</p><ul><li>使隐藏的函数重现</li><li>改变基类成员在派生类中的访问权限</li></ul><h3 id="使隐藏函数重现"><a href="#使隐藏函数重现" class="headerlink" title="使隐藏函数重现"></a>使隐藏函数重现</h3><p><strong>方法</strong>：在派生类中用<code>using 基类::函数名;</code>声明基类的函数名，不需提供函数参数。</p><p>一条<code>using</code>可以把<strong>指定函数名</strong>的所有版本添加到派生类作用域中，它们的访问权限与using语句所在区域的访问权限相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> i)</span><span class="comment">//重载Base类的两个print函数，即print()、print(int i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Base::print;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Derived d1;</span><br><span class="line"></span><br><span class="line">d1.print();<span class="comment">//不加using的话该行报错</span></span><br><span class="line">d1.print(<span class="string">'A'</span>);<span class="comment">//调用Derived类的print(char i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改变基类成员在派生类中的访问权限"><a href="#改变基类成员在派生类中的访问权限" class="headerlink" title="改变基类成员在派生类中的访问权限"></a>改变基类成员在派生类中的访问权限</h3><p>在派生类的<code>public</code>、<code>protected</code>或<code>private</code>权限区域内，使用<code>using</code>再次声明基类的非<code>private</code>成员，就可以重新设置它们在派生类中的权限为<code>using</code>语句所在区域的权限。</p><h2 id="继承和类作用域"><a href="#继承和类作用域" class="headerlink" title="继承和类作用域"></a>继承和类作用域</h2><p>在存在继承关系时，派生类的作用域嵌套在基类作用域的内层。</p><p>因此，在解析类成员名称时，如果在本类的作用域内没有找到，编译器会接着在外层的基类作用域内继续寻找该成员名称的定义。</p><p>在这个寻找的过程中，一旦在某个作用域找到了，就停止查找，即使外层作用域内还有同名成员，也不找了。</p><p>形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    Derived &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码验证</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::print()......"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> :</span><span class="keyword">public</span> Derived1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived2 d;</span><br><span class="line">d.print(<span class="number">1</span>);<span class="comment">//该行代码报错，因为在Derived1中找到同名函数void print()，不会再向外层找，又因为参数列表不匹配，所以报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;继承的概念&quot;&gt;&lt;a href=&quot;#继承的概念&quot; class=&quot;headerlink&quot; title=&quot;继承的概念&quot;&gt;&lt;/a&gt;继承的概念&lt;/h1&gt;&lt;p&gt;继承源于生物界，指后代能够传承前代的特征和行为。&lt;/p&gt;
&lt;h2 id=&quot;基类和子类&quot;&gt;&lt;a href=&quot;#基类和子
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="继承" scheme="https://chouxianyu.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="https://chouxianyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>项目开发记录</title>
    <link href="https://chouxianyu.github.io/2019/04/12/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://chouxianyu.github.io/2019/04/12/项目开发记录/</id>
    <published>2019-04-12T14:17:25.000Z</published>
    <updated>2019-04-24T17:52:17.067Z</updated>
    
    <content type="html"><![CDATA[<p>一段旅程算是结尾了吧，以下为本学期开发记录：</p><ul><li>2.26 晚上</li></ul><p>整理项目里的代码和注释</p><ul><li>2.27 中午至下午</li></ul><p>解决先登录问题</p><ul><li>2.28 下午</li></ul><p>解决先登录问题</p><ul><li>3.1   中午至下午</li></ul><p>解决先登录后续问题：控制台warning，路由重复</p><p>尝试数据持久化，redux-persist</p><ul><li>3.2   下午</li></ul><p>数据持久化 redux-persist。combineReducer？ persistCombineReducer?</p><ul><li>3.3   </li></ul><p>循环injectedReducers，发现有个root，还有动态的数据持久化配置不好实现，改用localStoreage</p><ul><li>3.11  晚上</li></ul><p>给后端分任务：规定用户名和密码格式要求，并检测其合法性，新的页面要显示什么内容，前后端交互</p><ul><li>3.19 下午</li></ul><p>总结项目，明确各自的任务</p><ul><li>3.23 下午</li></ul><p>和hyk讨论前后端合作。</p><ul><li>3.25 下午</li></ul><p>开发编辑/显示标准基本信息界面，定义与后端交互的接口内容</p><ul><li>3.27 早上、晚上</li></ul><p>开发修改密码页面，补充标准基本信息界面提交功能</p><ul><li>3.30 上午</li></ul><p>前后端交互测试成功。向老师汇报情况</p><ul><li>3.31</li></ul><p>项目上传至coding</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一段旅程算是结尾了吧，以下为本学期开发记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.26 晚上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整理项目里的代码和注释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.27 中午至下午&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决先登录问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.28 下午&lt;
      
    
    </summary>
    
    
      <category term="React" scheme="https://chouxianyu.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-实验（二）常用网络指令</title>
    <link href="https://chouxianyu.github.io/2019/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/"/>
    <id>https://chouxianyu.github.io/2019/04/10/计算机网络-实验（二）常用网络指令/</id>
    <published>2019-04-10T12:34:44.000Z</published>
    <updated>2019-04-13T08:27:32.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>学会并掌握常用网络命令。</li><li>学会分析在不同参数下显示的数据。</li></ol><h1 id="实验仪器"><a href="#实验仪器" class="headerlink" title="实验仪器"></a>实验仪器</h1><p>PC机、局域网</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h2><p><strong>知识点扫盲</strong>：地址解析协议，即<em>ARP</em>（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</p><p><strong>功能</strong>：显示和修改IP地址与物理地址之间的转换表</p><h3 id="a"><a href="#a" class="headerlink" title="-a"></a>-a</h3><p><strong>功能</strong>：（Windows下）显示当前的ARP信息，可以指定网络地址。</p><p>Linux系统中，使用<code>-g</code>。</p><p><strong>代码</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a<span class="comment"># 显示当前所有的ARP信息</span></span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Internet Address</th><th style="text-align:center">Physical Address</th><th style="text-align:center">Type</th></tr></thead><tbody><tr><td style="text-align:center">192.168.1.178</td><td style="text-align:center">00-16-ec-a0-42-fa</td><td style="text-align:center">dynamic</td></tr><tr><td style="text-align:center">..…</td><td style="text-align:center">..…</td><td style="text-align:center">..…</td></tr></tbody></table></div><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a 192.168.1.178# 显示指定IP(即192.168.1.178)的ARP信息</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Internet Address</th><th style="text-align:center">Physical Address</th><th style="text-align:center">Type</th></tr></thead><tbody><tr><td style="text-align:center">192.168.1.178</td><td style="text-align:center">00-16-ec-a0-42-fa</td><td style="text-align:center">dynamic</td></tr></tbody></table></div><h3 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h3><p><strong>功能</strong>：添加主机，并将网络地址跟物理地址相对应，这一项是永久生效的。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arp -s 157.55.85.212 00-aa-00-62-c6-09 # 在IP和物理地址转换表中添加一项</span><br><span class="line">arp -a 157.55.85.212# 显示指定IP(即157.55.85.212)的ARP信息</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Internet Address</th><th style="text-align:center">Physical Address</th><th style="text-align:center">Type</th></tr></thead><tbody><tr><td style="text-align:center">157.55.85.212</td><td style="text-align:center">00-aa-00-62-c6-09</td><td style="text-align:center"><strong>static</strong></td></tr></tbody></table></div><p><strong>注意</strong>：这里添加的一个<code>Type</code>为<code>static</code>的。</p><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p><strong>功能</strong>：删除指定的主机，可以使用* 来删除所有主机。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arp -d 157.55.85.212# 删除指定IP(即157.55.85.212)</span><br><span class="line">arp -a 157.55.85.212# 显示指定IP(即157.55.85.212)的ARP信息</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO ARP Entries Found</span><br></pre></td></tr></table></figure><h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p><strong>知识点扫盲</strong>：文件传输协议，即FTP(File Transfer Protocol)。是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议。</p><p>ftp也是一种服务。一旦启动，将创建在其中可以使用ftp命令的子环境，通过键入 <code>quit</code>子命令可以从子环境返回到Windows命令提示符。当 ftp 子环境运行时，它由ftp命令提示符代表。</p><p>下边的指令除了ftp是在Windows命令提示符，其他都是在ftp的子环境里。</p><p><strong>功能</strong>：控制文件的双向传输（老师说的..…）。</p><h3 id="ftp-1"><a href="#ftp-1" class="headerlink" title="ftp"></a>ftp</h3><p><strong>功能</strong>：启动ftp服务。</p><p>在命令提示符下，直接输入<code>ftp</code>即可。</p><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open 192.168.1.171# 连接指定的ftp服务器（这里是老师的电脑）</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connected to 192.168.1.171.</span><br><span class="line">220-Microsoft FTP Service</span><br><span class="line">220 张芳之家</span><br><span class="line">User (192.168.1.171:(none)): zf</span><br><span class="line">331 Password required for zf.</span><br><span class="line">Password:</span><br><span class="line">230-欢迎进入“张芳之家”</span><br><span class="line">230 User zf logged in.</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上边的第6行需要输入<strong>密码</strong>。我们输的时候，屏幕上并不会显示出来。</p><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p><strong>功能</strong>：查看本目录下的内容，目录可以理解成文件夹的意思。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir# 查看当前目录内容</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">200 PORT command successful.# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for /bin/ls.# ASCII传输方式连接/bin/ls</span><br><span class="line">04-26-1308:22AM&lt;DIR&gt;654# 有个文件夹，名字是654</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 44 字节，用时 0.00 Seconds 44000.00Kbyte/sec.</span><br></pre></td></tr></table></figure><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p><strong>功能</strong>：更换<strong>远程</strong>目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 654# 进入文件夹654</span><br><span class="line">dir# 查看当前目录内容</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">200 PORT command successful.# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for /bin/ls.# ASCII传输方式连接/bin/ls</span><br><span class="line">04-26-1308:22AM70qqq.txt# 有个文件，名字是qqq.txt</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 48 字节，用时 0.00 Seconds 44000.00Kbyte/sec.</span><br></pre></td></tr></table></figure><h3 id="lcd"><a href="#lcd" class="headerlink" title="lcd"></a>lcd</h3><p><strong>功能</strong>：更换<strong>本地</strong>目录，若无参数，将显示当前目录。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd e:\</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local directory now E:\.</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><strong>功能</strong>：将远程文件复制到本地计算机。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get qqq.txt</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">200 PORT command successful.# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for qqq.txt(70 bytes)# ASCII传输方式连接/bin/ls</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 70 字节，用时 0.00 Seconds 70000.00Kbyte/sec.</span><br></pre></td></tr></table></figure><h3 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h3><p><strong>功能</strong>：退出ftp服务。ftp子环境下输入<code>quit</code>即可。</p><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">221 再见！欢迎下次“张芳之家”</span><br></pre></td></tr></table></figure><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p><strong>功能</strong>：显示当前的TCP/IP配置的设置值。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows IP Configuration</span><br><span class="line"></span><br><span class="line">Ethernet adapter 本地连接:</span><br><span class="line">        Connection-specific DNS Suffix  . :</span><br><span class="line">        IP Address. . . . . . . . . . . . : 192.168.1.95# IP地址</span><br><span class="line">        Subnet Mask . . . . . . . . . . . : 255.255.255.0# 子网掩码</span><br><span class="line">        Default Gateway . . . . . . . . . : 192.168.1.3# 缺省网关</span><br></pre></td></tr></table></figure><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p><strong>知识点扫盲</strong>：Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。</p><p><strong>功能</strong>：远程连接另一台计算机</p><h3 id="telnet-1"><a href="#telnet-1" class="headerlink" title="telnet"></a>telnet</h3><p><strong>功能</strong>：启动telnet。</p><p>在命令提示符下，直接输入<code>telnet</code>即可。</p><h3 id="open-1"><a href="#open-1" class="headerlink" title="open"></a>open</h3><p><strong>功能</strong>：连接指定计算机。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open 192.168.1.94# 连接我同桌..</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正在连接到192.168.1.94... </span><br><span class="line">您将要发送密码信息到 Internet 区域中的远程计算机。这可能不安全。是否还要发送(y/n</span><br><span class="line">): n</span><br><span class="line">login:ligong</span><br><span class="line">password:</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：第四行和第五行输入账号和密码，密码并不会显示出来。</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>功能</strong>：复制文件到自己电脑上</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy qqq.txt c:\# 复制其e盘qqq.txt到其c盘，前提是此时已在E盘，使用cd e:\实现</span><br></pre></td></tr></table></figure><h3 id="quit-1"><a href="#quit-1" class="headerlink" title="quit"></a>quit</h3><p>退出，直接输入<code>quit</code>即可。</p><h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p><strong>知识点扫盲</strong>：它包含了管理网络环境、服务、用户、登陆等Windows 98/NT/2000 中大部分重要的管理功能。</p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p><strong>功能</strong>：将消息发送到网络上的其他用户、计算机或消息名。必须运行信使服务以接收邮件。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net send * 123# 给所有人发123</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息已经送到域 2HJF</span><br></pre></td></tr></table></figure><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net send s14 hello# 给s14机器发hello</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息已经送到 S14</span><br></pre></td></tr></table></figure><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;学会并掌握常用网络命令。&lt;/li&gt;
&lt;li&gt;学会分析在不同参数下显示的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-实验（一）</title>
    <link href="https://chouxianyu.github.io/2019/04/08/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2019/04/08/汇编语言-实验（一）/</id>
    <published>2019-04-08T03:18:40.000Z</published>
    <updated>2019-04-10T12:36:54.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在数据段DATA中有两个字数据X和Y, 假设X=1122H, Y=3344H, 编程求两个字的和,结果存放到Z单元中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;*********************************************************************</span><br><span class="line">data segment; 定义数据段</span><br><span class="line">x dw <span class="number">1122</span>h; 字 X</span><br><span class="line">y dw <span class="number">3344</span>h; 字 Y</span><br><span class="line">z dw ?; 字 Z</span><br><span class="line">data ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">code segment; 定义代码段</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">main proc far; 程序的主部分</span><br><span class="line">start:</span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds; ds压栈</span><br><span class="line">xor ax,ax; (ax) &lt;- data</span><br><span class="line">push ax; ax压栈</span><br><span class="line"></span><br><span class="line">; ds设为data</span><br><span class="line">mov ax,data; (ax) &lt;- data</span><br><span class="line">mov ds,ax; (ds) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; z=x+y</span><br><span class="line">mov ax,x; (al) &lt;- x</span><br><span class="line">add ax,y; (al) &lt;- (al)+y</span><br><span class="line">mov z,ax; (z) &lt;- (al)</span><br><span class="line"></span><br><span class="line">; 返回DOS环境</span><br><span class="line">ret; 返回DOS环境</span><br><span class="line">main  endp</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">code  ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串传送到DEST_BUFFER开始的单元中。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">;*********************************************************************</span><br><span class="line">data segment; 定义数据段</span><br><span class="line">source_buffer db <span class="number">20</span> dup(<span class="string">'A'</span>); 串source_buffer，占<span class="number">20</span>个字节，内容是<span class="number">20</span>个字母A</span><br><span class="line">data ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">extra segment; 定义附加段</span><br><span class="line">dest_buffer db <span class="number">20</span> dup(?); 串dest_buffer，占<span class="number">20</span>个字节，内容未确定</span><br><span class="line">extra ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">code segment; 定义代码段</span><br><span class="line">assume cs:code,ds:data,es:extra</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">main proc far; 程序的主部分</span><br><span class="line">start: </span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds; ds压栈</span><br><span class="line">xor ax,ax; (ax) &lt;- data</span><br><span class="line">push ax; ax压栈</span><br><span class="line"></span><br><span class="line">; ds设为data</span><br><span class="line">mov ax,data; (ax) &lt;- data</span><br><span class="line">mov ds,ax; (ds) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; es设为extra</span><br><span class="line">mov ax,extra; (ax) &lt;- extra</span><br><span class="line">mov es,ax; (es) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; 准备工作</span><br><span class="line">lea si,source_buffer; 存储源串首地址</span><br><span class="line">lea di,dest_buffer; 存储目的串首地址</span><br><span class="line">cld; 建立方向标志</span><br><span class="line">mov cx,<span class="number">20</span>; <span class="number">20</span>个字符</span><br><span class="line">; 移动串</span><br><span class="line">rep movsb; 移动串至CX为<span class="number">0</span>，即移动整个串</span><br><span class="line"></span><br><span class="line">; 返回DOS环境</span><br><span class="line">ret; 返回DOS环境</span><br><span class="line">main  endp</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">code  ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h1><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串向下移10个单元。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">;*********************************************************************</span><br><span class="line">extra segment; 定义附加段</span><br><span class="line">source_buffer db <span class="number">20</span> dup(<span class="string">'A'</span>); 串source_buffer，占<span class="number">20</span>个字节，内容是<span class="number">20</span>个字母A</span><br><span class="line">dest_buffer=source_buffer+<span class="number">10</span>; 串dest_buffer，结果串的首地址</span><br><span class="line">extra ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">code segment; 定义代码段</span><br><span class="line">assume cs:code,es:extra</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">main proc far; 程序的主部分</span><br><span class="line">start: </span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds; ds压栈</span><br><span class="line">xor ax,ax; (ax) &lt;- <span class="number">0</span></span><br><span class="line">push ax; ax压栈</span><br><span class="line"></span><br><span class="line">; es设为extra</span><br><span class="line">mov ax,extra; (ax) &lt;- extra</span><br><span class="line">mov es,ax; (es) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; 准备工作</span><br><span class="line">lea si,source_buffer+<span class="number">19</span>; 存储源串末地址</span><br><span class="line">lea di,dest_buffer+<span class="number">19</span>; 存储目的串末地址</span><br><span class="line"><span class="built_in">std</span>; 建立方向标志</span><br><span class="line">mov cx,<span class="number">20</span>; <span class="number">20</span>个字符</span><br><span class="line">; 移动串</span><br><span class="line">rep movs es:byte ptr[di],es:[di]; 移动串至CX为<span class="number">0</span>，即移动整个串</span><br><span class="line"></span><br><span class="line">; 返回DOS环境</span><br><span class="line">ret; 返回DOS环境</span><br><span class="line">main  endp</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">code  ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><p>不小心，上边代码写错了,<code>rep movs ds:byte ptr[di],ds:[di]</code>，源地址和目标地址不小心都用了di。</p><p>按说这样不能进行后移，但却得到了正确的结果。</p><p>经过调试，发现可能是编译环境自行将我的错误代码改成了正确代码，进行了优化。</p><p>同时也发现：<code>rep movs ds:byte ptr[si],ds:[di]</code>，这个代码也是错的，但也得到了正确的结果。</p><p>正确的代码应该是这样：<code>rep movs ds:byte ptr[di],ds:[si]</code>。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目一&quot;&gt;&lt;a href=&quot;#题目一&quot; class=&quot;headerlink&quot; title=&quot;题目一&quot;&gt;&lt;/a&gt;题目一&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://chouxianyu.github.io/tags/Bug/"/>
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之指针悬挂</title>
    <link href="https://chouxianyu.github.io/2019/03/28/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E6%8C%87%E9%92%88%E6%82%AC%E6%8C%82/"/>
    <id>https://chouxianyu.github.io/2019/03/28/C-C-小课之指针悬挂/</id>
    <published>2019-03-28T15:44:06.000Z</published>
    <updated>2019-03-28T15:58:33.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是指针悬挂"><a href="#什么是指针悬挂" class="headerlink" title="什么是指针悬挂"></a>什么是指针悬挂</h1><p><strong>指向非法内存的指针，也叫野指针。</strong></p><p>非法内存即不能使用的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="number">12345</span>;</span><br><span class="line"><span class="comment">//int* p;//p未初始化，p的值随机，一般都会指向非法内存</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p;<span class="comment">//运行这行代码会出错</span></span><br></pre></td></tr></table></figure><p>随便让p指向一块内存（一般指向非法内存）。</p><p><strong>运行时使用非法内存，会报错。</strong></p><h1 id="一些指针悬挂的情况"><a href="#一些指针悬挂的情况" class="headerlink" title="一些指针悬挂的情况"></a>一些指针悬挂的情况</h1><p>课本中有两处提到指针悬挂，分别是：<strong>合成拷贝构造函数</strong>和<strong>合成赋值运算符函数</strong>。</p><p>如果类中有指针，这两个函数<strong>可能</strong>造成指针悬挂。（看完之后想想为什么只是可能？）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面给出这两种函数造成指针悬挂的代码及注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">MyClass()&#123;p = <span class="keyword">new</span> <span class="keyword">int</span>;&#125;</span><br><span class="line">~MyClass()&#123;<span class="keyword">delete</span> p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass a;</span><br><span class="line"><span class="function">MyClass <span class="title">b</span><span class="params">(a)</span></span>;<span class="comment">//调用合成拷贝函数</span></span><br><span class="line"><span class="comment">//MyClass b = a;//调用合成赋值运算符</span></span><br><span class="line">a.print();</span><br><span class="line">b.print();<span class="comment">//据两行输出可知，两个指针指向同一块内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后，B会先析构，然后A析构。</span></span><br><span class="line"><span class="comment">//B析构会释放p指向的内存，同时这块内存变为非法内存，</span></span><br><span class="line"><span class="comment">//此时A的指针p指向非法内存，造成指针悬挂。</span></span><br><span class="line"><span class="comment">//A析构时delete p,使用了非法内存，这时出错</span></span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>如果这两个函数造成指针悬挂，应显式提供这两个函数，并将这两个合成函数的<strong>浅拷贝改为深拷贝</strong>。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是指针悬挂&quot;&gt;&lt;a href=&quot;#什么是指针悬挂&quot; class=&quot;headerlink&quot; title=&quot;什么是指针悬挂&quot;&gt;&lt;/a&gt;什么是指针悬挂&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;指向非法内存的指针，也叫野指针。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非法内存即不能使用
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="指针" scheme="https://chouxianyu.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>插值和线性回归</title>
    <link href="https://chouxianyu.github.io/2019/03/28/%E6%8F%92%E5%80%BC%E5%92%8C%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>https://chouxianyu.github.io/2019/03/28/插值和线性回归/</id>
    <published>2019-03-28T11:26:40.000Z</published>
    <updated>2019-03-28T11:29:20.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>根据现有数据，插的值一定在曲线上。</p><p><code>interpl</code>，一维插值函数。</p><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p><code>regress</code></p><p>$Y=b_0+b_1x_1+b_2x_2+\cdots+b_kx_k$</p><p>拟合$x_1\ x_2\ \cdots\ x_k$与$Y$的关系</p><p><code>[B, Bint, R, Rint, Status]=regress(Y, X)</code></p><p><code>B</code>：回归得到的自变量系数</p><p><code>Bint</code>：B的95%的置信区间矩阵</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插值&quot;&gt;&lt;a href=&quot;#插值&quot; class=&quot;headerlink&quot; title=&quot;插值&quot;&gt;&lt;/a&gt;插值&lt;/h1&gt;&lt;p&gt;根据现有数据，插的值一定在曲线上。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;interpl&lt;/code&gt;，一维插值函数。&lt;/p&gt;
&lt;h1 id=&quot;线性回归
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="插值" scheme="https://chouxianyu.github.io/tags/%E6%8F%92%E5%80%BC/"/>
    
      <category term="线性回归" scheme="https://chouxianyu.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>传染病模型</title>
    <link href="https://chouxianyu.github.io/2019/03/28/%E4%BC%A0%E6%9F%93%E7%97%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://chouxianyu.github.io/2019/03/28/传染病模型/</id>
    <published>2019-03-28T11:26:20.000Z</published>
    <updated>2019-03-28T11:28:31.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>该模型在数学建模中可以解决很多问题。</p><p>该模型由三个微分方程构成。</p><h1 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>假设系统中有三种人：</p><ul><li><p>易感染的人</p><p>  数量用$S$表示，刚开始所有人都是易感染的人</p></li><li><p>感染的人</p><p>  数量用$I$表示</p></li><li><p>康复的人</p><p>  数量用$R$表示（假设该传染病不致命）</p></li></ul><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><p>$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              \frac{dS}{dt}=-\beta SI\\<br>              \frac{dI}{dt}=\beta SI-\gamma I\\<br>              \frac{dR}{dt}=\gamma I\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><p>其中$\beta$是接触率，$\gamma$是康复率。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="函数odesir"><a href="#函数odesir" class="headerlink" title="函数odesir"></a>函数odesir</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dy</span> = <span class="title">odesir</span><span class="params">(t, y, beta, gamma)</span></span></span><br><span class="line"><span class="comment">% 根据传染病模型者中的y和t求出dy/dt</span></span><br><span class="line"><span class="comment">% y=[S; I; R]</span></span><br><span class="line">dy =</span><br><span class="line">[</span><br><span class="line">-beta*y(<span class="number">1</span>)*y(<span class="number">2</span>); % dS/dt</span><br><span class="line">beta*y(<span class="number">1</span>)*y(<span class="number">2</span>) - gamma*y(<span class="number">2</span>); % dS/dt</span><br><span class="line">gamma*y(<span class="number">2</span>); % dR/dt</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.01</span>;</span><br><span class="line"><span class="built_in">gamma</span> = <span class="number">0.1</span>;</span><br><span class="line">tspan = [<span class="number">0</span>,<span class="number">50</span>];</span><br><span class="line">y0 = [<span class="number">99</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">[t y] = ode45(@odesir, tspan, y0, [], bata, <span class="built_in">gamma</span>);</span><br><span class="line">plot(t,y);</span><br><span class="line">xlabel(<span class="string">'time'</span>);</span><br><span class="line">ylabel(<span class="string">'population'</span>);</span><br><span class="line">legend(<span class="string">'S'</span>, <span class="string">'I'</span>, <span class="string">'R'</span>);</span><br></pre></td></tr></table></figure><p><code>ode23</code>和<code>ode45</code>的区别：精度不一样，<code>ode45</code>精度高。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><a href="https://i.loli.net/2019/03/28/5c9cae1f0f6be.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/28/5c9cae1f0f6be.png" alt="传染病.png"></a></p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;该模型在数学建模中可以解决很多问题。&lt;/p&gt;
&lt;p&gt;该模型由三个微分方程构成。&lt;/p&gt;
&lt;h1 id=&quot;建立模型&quot;&gt;&lt;a href=&quot;#建立
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="微分方程" scheme="https://chouxianyu.github.io/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Runge-Kutta法解微分方程</title>
    <link href="https://chouxianyu.github.io/2019/03/28/Runge-Kutta%E6%B3%95%E8%A7%A3%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    <id>https://chouxianyu.github.io/2019/03/28/Runge-Kutta法解微分方程/</id>
    <published>2019-03-28T11:25:59.000Z</published>
    <updated>2019-03-28T11:27:48.381Z</updated>
    
    <content type="html"><![CDATA[<p>连续问题，微分方程或偏微分方程一定能表示。比如疾病传染、新闻传播等。</p><p>离散问题，可以用差分方程或者类似于差分的算法。</p><h1 id="一阶微分方程求解"><a href="#一阶微分方程求解" class="headerlink" title="一阶微分方程求解"></a>一阶微分方程求解</h1><h2 id="方程"><a href="#方程" class="headerlink" title="方程"></a>方程</h2><p>$y’=cos\ t$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clear,clc;</span><br><span class="line"></span><br><span class="line">f = @(t,y) <span class="built_in">cos</span>(t);<span class="comment">% 定义函数 f(t,y) = cos(t) 表示的就是dy/dt=cos(t)</span></span><br><span class="line">tspan = [<span class="number">0</span>,<span class="number">2</span>*pi];<span class="comment">% 时间t范围</span></span><br><span class="line">y0 = <span class="number">2</span>;   <span class="comment">% y的初值，用来处理积分得到的C</span></span><br><span class="line">[t,y] = ode23(f,tspan,y0); <span class="comment">% 注意调用格式</span></span><br><span class="line">plot(t,y);</span><br><span class="line">xlabel(<span class="string">'t'</span>);</span><br><span class="line">ylabel(<span class="string">'y'</span>);</span><br></pre></td></tr></table></figure><p><code>@</code>表示句柄，当把一个函数作为参数传给另外一个函数，这时候必须要用句柄。这里是把函数<code>f</code>传给函数<code>ode23</code>。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><a href="https://i.loli.net/2019/03/28/5c9c9a965cc43.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/28/5c9c9a965cc43.png" alt="一阶微分方程.png"></a></p><h1 id="高阶微分方程求解"><a href="#高阶微分方程求解" class="headerlink" title="高阶微分方程求解"></a>高阶微分方程求解</h1><h2 id="方程-1"><a href="#方程-1" class="headerlink" title="方程"></a>方程</h2><p>$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              y’’=-sin\ y+sin\ 5t\\<br>              y(0)=1\\<br>              y’(0)=0\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><p>可以将该高阶微分方程转化为两个一阶的微分方程：$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              y_1=y\\<br>              y_2=y’\\<br>              y’_1=y_2\\<br>              y’_2=-sin\ y_1+sin\ 5t\\<br>              y_1(0)=1\\<br>              y_2(0)=0\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clear,clc;</span><br><span class="line"></span><br><span class="line">f = @(t, y) [ y(<span class="number">2</span>); -sin( y(<span class="number">1</span>) ) + sin( <span class="number">5</span>*t ) ]; <span class="comment">% 两个参数分别是y1和y2的导数</span></span><br><span class="line">tspan = [ <span class="number">0</span>, <span class="number">20</span> ]; <span class="comment">% 时间t范围</span></span><br><span class="line">y0 = [ <span class="number">1</span>; <span class="number">0</span> ]; <span class="comment">% 初值，分别对应y1，y2的初值</span></span><br><span class="line">[t, y] = ode23(f, tspan, y0); <span class="comment">% 注意调用格式</span></span><br><span class="line">plot(t,y);</span><br><span class="line">xlabel(<span class="string">'t'</span>);</span><br><span class="line">ylabel(<span class="string">'y'</span>);</span><br><span class="line">legend(<span class="string">'y1'</span>,<span class="string">'y2'</span>);</span><br></pre></td></tr></table></figure><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><a href="https://i.loli.net/2019/03/28/5c9c9a9662d63.png" target="_blank" rel="noopener">​<img src="https://i.loli.net/2019/03/28/5c9c9a9662d63.png" alt="高阶微分方程.png"></a></p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;连续问题，微分方程或偏微分方程一定能表示。比如疾病传染、新闻传播等。&lt;/p&gt;
&lt;p&gt;离散问题，可以用差分方程或者类似于差分的算法。&lt;/p&gt;
&lt;h1 id=&quot;一阶微分方程求解&quot;&gt;&lt;a href=&quot;#一阶微分方程求解&quot; class=&quot;headerlink&quot; title=&quot;一阶微
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="微分方程" scheme="https://chouxianyu.github.io/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之类和对象</title>
    <link href="https://chouxianyu.github.io/2019/03/27/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>https://chouxianyu.github.io/2019/03/27/C-C-小课之类和对象/</id>
    <published>2019-03-27T08:38:04.000Z</published>
    <updated>2019-04-16T15:19:01.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>如何理解类和对象？</p><p>类是一种自定义数据类型，用<strong>类</strong>定义出来的变量就是<strong>对象</strong>。</p><p>格式：</p><ul><li><code>数据类型 数据;</code></li><li><code>int a;</code></li><li><code>A a();</code></li></ul><p>这一章的主要问题就是如何<strong>设计</strong>、<strong>实现</strong>和<strong>使用</strong>类。</p><p>设计和实现分别对应类的抽象和封装；使用即最后一步，用类实现功能。</p><p><strong>简单地说</strong>：面向对象就是将事物定义（包括抽象和封装）成类并使用。</p><h1 id="类的抽象和封装"><a href="#类的抽象和封装" class="headerlink" title="类的抽象和封装"></a>类的抽象和封装</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>计算机软件开发采用的抽象方法主要有两种：</p><ul><li><p>过程抽象</p><p>  结果给出了函数的名称、接收的参数和能够提供的功能。</p></li><li><p><strong>数据抽象</strong></p><p>  数据抽象是面向对象程序设计方法，<strong>以数据为中心</strong>。</p><p>  结果形成某事物的类，其中包括<strong>成员变量</strong>和<strong>成员函数</strong>。</p></li></ul><p>简单来说，就是找出一个类有哪些<strong>变量</strong>和<strong>功能</strong>，但不用<strong>封装</strong>。</p><p>比如这是一个点餐系统。</p><p><a href="https://i.loli.net/2019/03/27/5c9b35ca001e9.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/27/5c9b35ca001e9.png" alt="点餐系统类图.png"></a></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>分为两部分：</p><ul><li><p>接口</p><p>  使用者看到的东西</p></li><li><p>实现</p><p>  实现抽象出的类，写<code>.cpp</code>代码</p></li></ul><p>简单地说，就是写代码。</p><p>比如：对老师来说，课代表就是接口，课代表怎么收作业就是实现。</p><h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cxy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">growTaller</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"drinkMilk"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        height+=<span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cxy cbh;</span><br><span class="line">    cbh.growtaller();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请找出代码里的类、对象、抽象、封装。</p><h1 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h1><h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>C++中，为了禁止成员函数修改数据成员的值，可以使用常量成员函数。</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">f</span><span class="params">(T1, T1, ...)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>只有类的成员函数才能定义为常量函数，普通函数不能。</li><li>常量成员函数与const参数没有关系</li></ul><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul><li>每个对象的数据成员都有自己独立的存储空间。就像int变量一样。</li><li><strong>注意</strong>：一个类的成员函数只有一份，所有对象共用。</li><li><strong>注意</strong>：类的static成员只有一份，它并不算对象的数据成员。</li></ul><h1 id="构造函数设计"><a href="#构造函数设计" class="headerlink" title="构造函数设计"></a>构造函数设计</h1><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>书上P97下边给的定义是最准确的。</p><p>想想之前讲的默认的含义。</p><p>简单来说：如果用类定义对象时，我们没有给参数的话，调用的就是默认构造函数。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>默认构造函数有两种：</p><ul><li><p>不带参数的构造函数</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A();</span><br></pre></td></tr></table></figure><p>  可以是我们自己定义的，也可以是编译器合成的。</p></li><li><p>所有形参都提供了默认值的构造函数</p><p>  这个当然是我们自己定义的。</p></li></ul><h2 id="构造函数与初始化列表"><a href="#构造函数与初始化列表" class="headerlink" title="构造函数与初始化列表"></a>构造函数与初始化列表</h2><h3 id="初始化列表次序"><a href="#初始化列表次序" class="headerlink" title="初始化列表次序"></a>初始化列表次序</h3><p>初始化列表中的成员初始化次序与他们在类中的声明次序相同，与初始化列表中的次序无关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    A(<span class="keyword">int</span> aa,<span class="keyword">int</span> bb,<span class="keyword">int</span> cc):b(aa),a(bb),c(cc)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a handsome constructor yo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提问：初始化次序是什么？</p><h3 id="初始化列表执行时间"><a href="#初始化列表执行时间" class="headerlink" title="初始化列表执行时间"></a>初始化列表执行时间</h3><p>类内初始值$\rightarrow$构造函数初始化列表$\rightarrow$构造函数体</p><h2 id="what必须采用初始化列表？"><a href="#what必须采用初始化列表？" class="headerlink" title="what必须采用初始化列表？"></a>what必须采用初始化列表？</h2><h3 id="C-11之前"><a href="#C-11之前" class="headerlink" title="C++11之前"></a>C++11之前</h3><p>一个类的</p><ul><li>常量成员</li><li>引用成员</li><li>类对象成员</li><li>子类构造函数对基类构造函数的调用</li><li>等等</li></ul><p>必须通过初始化列表进行初始化。</p><h3 id="C-11之后"><a href="#C-11之后" class="headerlink" title="C++11之后"></a>C++11之后</h3><p>除了初始化列表，可以用类内初始值yo。</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>若有几个对象同时结束生存期，析构函数调用顺序与构造函数顺序相反。</p><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><p>关键字：<code>static</code>。</p><p>静态成员可以是变量，也可以是函数。</p><p><strong>注意</strong>：静态成员函数不可以访问非静态成员。think why？</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>表示这个成员是属于整个类的。</p><h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> boyNum;<span class="comment">//男孩的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Boy::boyNum；<span class="comment">//未初始化</span></span><br><span class="line"><span class="comment">//static int Boy::boyNum = 0；//初始化</span></span><br></pre></td></tr></table></figure><p>在类内<code>static int number；</code>，仅仅是<strong>声明</strong>，</p><p>原则上，<strong>定义</strong>必须写在类外：<code>static int Boy::boyNum;</code>，值默认为0，也可以进行初始化。</p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>两种方式：</p><ul><li><p>通过类名访问（<strong>非静态成员不能以这种这样访问</strong>）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; Boy::boyNum &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过对象访问</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Boy <span class="title">cbh</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cbhboyNum &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><p>看看下边的this？</p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>this用来标识一个对象，是该对象的地址，类型是<code>Boy* const</code>，隐含在非静态成员函数的参数里。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>静态成员函数没有this指针，所以不可以访问非静态成员。</p><p>常量成员函数的this，类型是<code>const Boy *</code>。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;如何理解类和对象？&lt;/p&gt;
&lt;p&gt;类是一种自定义数据类型，用&lt;strong&gt;类&lt;/strong&gt;定义出来的变量就是&lt;strong&gt;对象&lt;/s
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="面向对象" scheme="https://chouxianyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>美国人口指数增长模型拟合</title>
    <link href="https://chouxianyu.github.io/2019/03/27/%E7%BE%8E%E5%9B%BD%E4%BA%BA%E5%8F%A3%E6%8C%87%E6%95%B0%E5%A2%9E%E9%95%BF%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88/"/>
    <id>https://chouxianyu.github.io/2019/03/27/美国人口指数增长模型拟合/</id>
    <published>2019-03-27T00:50:23.000Z</published>
    <updated>2019-03-27T06:11:25.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h1><p>美国人口数满足指数增长模型$x(t)=x_0e^{rt}$，其中$x(t)$表示第$t$年的人口数，$x_0$表示第0年的人口数，即人口数初值。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>$ x(t) = x_0e^{rt} \ \Rightarrow \ ln \,x(t)=rt+ln\,x_0 \,\Rightarrow Y=ln \,x(t)a_1t+a_2$ ，</p><p>其中$Y=ln\,x(t)$，$a_1=r$，$a_2=ln\,x_0$。</p><p>如上，将指数函数转化为线性函数，利用线性函数进行拟合，再将线性函数转化为指数函数。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">t  = <span class="number">1790</span> : <span class="number">10</span> : <span class="number">1900</span>; <span class="comment">% 时间</span></span><br><span class="line">p = [<span class="number">3.9</span>   <span class="number">5.3</span>    <span class="number">7.2</span>    <span class="number">9.6</span> ...</span><br><span class="line">      <span class="number">12.9</span> <span class="number">17.1</span>  <span class="number">23.2</span>  <span class="number">31.4</span> ...</span><br><span class="line">      <span class="number">38.6</span>  <span class="number">50.2</span> <span class="number">62.9</span>  <span class="number">76.0</span>];  <span class="comment">% 人口数</span></span><br><span class="line"></span><br><span class="line">  Y = <span class="built_in">log</span>(p); <span class="comment">% 转换为线性</span></span><br><span class="line">  X = t; <span class="comment">% 不用X直接用t也可以</span></span><br><span class="line">  a = polyfit(X, Y, <span class="number">1</span>); <span class="comment">% X,Y线性拟合</span></span><br><span class="line">  x0 = <span class="built_in">exp</span>(a(<span class="number">2</span>)); <span class="comment">%</span></span><br><span class="line">  r = a(<span class="number">1</span>);</span><br><span class="line">  ti = <span class="number">1790</span>:<span class="number">1900</span>; <span class="comment">% 曲线的横坐标</span></span><br><span class="line">  pti = x0*<span class="built_in">exp</span>(r*ti); <span class="comment">% 曲线纵坐标，即拟合结果</span></span><br><span class="line">  plot(t, p, <span class="string">'o'</span>, ti, pti, <span class="string">'m'</span>); <span class="comment">% 原数据与拟合结果对比</span></span><br><span class="line">  xlabel(<span class="string">'Year'</span>);</span><br><span class="line">  ylabel(<span class="string">'Population'</span>);</span><br></pre></td></tr></table></figure><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><a href="https://i.loli.net/2019/03/27/5c9ac6c55118e.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/27/5c9ac6c55118e.png" alt="美国人口指数增长模型拟合.png"></a></p><p>可以看到，前期拟合结果较好，但是1890年到1900年曲线与原数据相比偏高。</p><p>原因是人口数并不完全符合指数增长模型，人口并不能完全地按照“J”型曲线增长，而应该是“S”型曲线。物种竞争嘛，所以刚开始的假设是不合理的，可以再进行优化。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;假设&quot;&gt;&lt;a href=&quot;#假设&quot; class=&quot;headerlink&quot; title=&quot;假设&quot;&gt;&lt;/a&gt;假设&lt;/h1&gt;&lt;p&gt;美国人口数满足指数增长模型$x(t)=x_0e^{rt}$，其中$x(t)$表示第$t$年的人口数，$x_0$表示第0年的人口数，即人口数初
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="拟合" scheme="https://chouxianyu.github.io/tags/%E6%8B%9F%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>线性方程组求解</title>
    <link href="https://chouxianyu.github.io/2019/03/26/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/"/>
    <id>https://chouxianyu.github.io/2019/03/26/线性方程组求解/</id>
    <published>2019-03-26T01:03:41.000Z</published>
    <updated>2019-03-27T05:59:24.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定解方程组"><a href="#定解方程组" class="headerlink" title="定解方程组"></a>定解方程组</h1><p>有一组解。</p><p>$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              2x+3y+1z = 4\\<br>              4x+2y+3z=17\\<br>              7x+1y-1z=1\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% A*X=B</span></span><br><span class="line">A = [<span class="number">2</span> <span class="number">3</span> <span class="number">1</span>; <span class="number">4</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">7</span> <span class="number">1</span> <span class="number">-1</span>];</span><br><span class="line">B = [<span class="number">4</span> <span class="number">17</span> <span class="number">1</span>]';</span><br><span class="line">X= A\B <span class="comment">% 求得X</span></span><br></pre></td></tr></table></figure><h1 id="不定方程组"><a href="#不定方程组" class="headerlink" title="不定方程组"></a>不定方程组</h1><p>有无数组解。</p><p>$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              4x+5y+1z=3\\<br>              1x+2y+4z=15\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% A*X=B</span></span><br><span class="line">A = [<span class="number">4</span> <span class="number">5</span> <span class="number">1</span>; <span class="number">1</span> <span class="number">2</span> <span class="number">4</span>];</span><br><span class="line">B = [<span class="number">3</span> <span class="number">15</span>]';</span><br><span class="line">X= A\B <span class="comment">% 得无数解中的一种</span></span><br></pre></td></tr></table></figure><h1 id="超定方程组"><a href="#超定方程组" class="headerlink" title="超定方程组"></a>超定方程组</h1><p>无解。</p><p>$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              4x+5y = 3\\<br>              1x+2y = 15\\<br>              3x+1y = 12\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% A*X=B</span></span><br><span class="line">A = [<span class="number">4</span> <span class="number">5</span>; <span class="number">1</span> <span class="number">2</span>; <span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">B = [<span class="number">3</span> <span class="number">15</span> <span class="number">12</span>]';</span><br><span class="line">X= A\B <span class="comment">% 本来是无解的，按最小二乘法得到最接近的解</span></span><br></pre></td></tr></table></figure><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定解方程组&quot;&gt;&lt;a href=&quot;#定解方程组&quot; class=&quot;headerlink&quot; title=&quot;定解方程组&quot;&gt;&lt;/a&gt;定解方程组&lt;/h1&gt;&lt;p&gt;有一组解。&lt;/p&gt;
&lt;p&gt;$\begin{equation}&lt;br&gt;    \left\{&lt;br&gt;         
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="线性方程组求解" scheme="https://chouxianyu.github.io/tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>线性和非线性拟合</title>
    <link href="https://chouxianyu.github.io/2019/03/25/%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%8B%9F%E5%90%88/"/>
    <id>https://chouxianyu.github.io/2019/03/25/线性和非线性拟合/</id>
    <published>2019-03-25T14:50:59.000Z</published>
    <updated>2019-03-27T05:59:28.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性拟合"><a href="#线性拟合" class="headerlink" title="线性拟合"></a>线性拟合</h1><p>一阶拟合：$y=a_1x+a_2$，这就是线性拟合了。</p><p>二阶拟合：$y=a_1x^2+a_2x+a_3​$，这就不是线性拟合了。</p><h2 id="polyfit"><a href="#polyfit" class="headerlink" title="polyfit"></a>polyfit</h2><p><code>a=polyfit(x,y,n)</code></p><ul><li>最小二乘法计算拟合多项式系数</li><li>x,y为拟合数据向量</li><li>n为拟合多项式次数</li><li>通过a保存多项式系数，从最高次向最低次排列</li></ul><h2 id="polyval"><a href="#polyval" class="headerlink" title="polyval"></a>polyval</h2><p><code>y=polyval(a,x)</code></p><ul><li>计算多项式的函数值</li><li>返回在x处多项式的值</li><li>a为多项式系数，元素按多项式降幂排序</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 求拟合多项式系数，即a</span></span><br><span class="line">x = [<span class="number">1.0</span> <span class="number">1.5</span> <span class="number">2.0</span> <span class="number">2.5</span> <span class="number">3.0</span>]';</span><br><span class="line">y = [<span class="number">0.9</span> <span class="number">1.7</span> <span class="number">2.2</span> <span class="number">2.6</span> <span class="number">3.0</span>]';</span><br><span class="line">a = polyfit(x,y,<span class="number">1</span>) <span class="comment">% 1指一阶拟合，也就是指多项式次数</span></span><br><span class="line"><span class="comment">% 求拟合结果</span></span><br><span class="line">xi = <span class="number">1</span> : <span class="number">0.1</span> : <span class="number">3</span>;</span><br><span class="line">yi = polyval(a, xi); <span class="comment">% 求多项式的函数值</span></span><br><span class="line">plot(x,y,<span class="string">'o'</span>,xi,yi); <span class="comment">% 作图对比原数据和拟合结果</span></span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><a href="https://i.loli.net/2019/03/25/5c98ea25b3240.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/25/5c98ea25b3240.png" alt="线性拟合.png"></a></p><p>图中点是原始数据，线是拟合结果，线有点点弯。</p><h1 id="指定形式拟合"><a href="#指定形式拟合" class="headerlink" title="指定形式拟合"></a>指定形式拟合</h1><h2 id="fittype"><a href="#fittype" class="headerlink" title="fittype"></a>fittype</h2><p>定义拟合形式</p><h2 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h2><p>根据数据向量，按照某种拟合形式拟合。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1.0</span> <span class="number">1.5</span> <span class="number">2.0</span> <span class="number">2.5</span> <span class="number">3.0</span>]';</span><br><span class="line">y = [<span class="number">0.9</span> <span class="number">1.7</span> <span class="number">2.2</span> <span class="number">2.6</span> <span class="number">3.0</span>]';</span><br><span class="line">p = fittype(<span class="string">'a*x+b*sin(x)+c'</span>); <span class="comment">% 定义拟合形式</span></span><br><span class="line">f = fit(x,y,p) <span class="comment">% 向量x,y按照p的形式拟合</span></span><br><span class="line">plot(f,x,y); <span class="comment">% 作图对比拟合结果</span></span><br></pre></td></tr></table></figure><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><a href="https://i.loli.net/2019/03/25/5c98ea2708385.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/25/5c98ea2708385.png" alt="指定形式拟合.png"></a></p><p>图中代码没有定义<code>x</code>,<code>y</code>也可以运行，是因为工作区中已经有这两个变量了。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性拟合&quot;&gt;&lt;a href=&quot;#线性拟合&quot; class=&quot;headerlink&quot; title=&quot;线性拟合&quot;&gt;&lt;/a&gt;线性拟合&lt;/h1&gt;&lt;p&gt;一阶拟合：$y=a_1x+a_2$，这就是线性拟合了。&lt;/p&gt;
&lt;p&gt;二阶拟合：$y=a_1x^2+a_2x+a_3​$，这
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="拟合" scheme="https://chouxianyu.github.io/tags/%E6%8B%9F%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Matlab作图</title>
    <link href="https://chouxianyu.github.io/2019/03/24/Matlab%E4%BD%9C%E5%9B%BE/"/>
    <id>https://chouxianyu.github.io/2019/03/24/Matlab作图/</id>
    <published>2019-03-24T14:45:05.000Z</published>
    <updated>2019-03-27T06:00:05.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维作图"><a href="#二维作图" class="headerlink" title="二维作图"></a>二维作图</h1><h2 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h2><p><a href="https://i.loli.net/2019/03/24/5c97966b8cef3.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/24/5c97966b8cef3.png" alt="plot.png"></a></p><h2 id="简单控制语句"><a href="#简单控制语句" class="headerlink" title="简单控制语句"></a>简单控制语句</h2><p><a href="https://i.loli.net/2019/03/24/5c97966b6d271.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/24/5c97966b6d271.png" alt="简单控制语句.png"></a></p><h2 id="sin-x-amp-cos-x"><a href="#sin-x-amp-cos-x" class="headerlink" title="sin(x) &amp; cos(x)"></a>sin(x) &amp; cos(x)</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-2</span> * <span class="built_in">pi</span> : <span class="number">0.1</span> : <span class="number">2</span>*<span class="built_in">pi</span>; <span class="comment">% 切片</span></span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="built_in">cos</span>(x);</span><br><span class="line">plot(x, y1,<span class="string">'-b'</span>); <span class="comment">% - 实线 b 蓝色</span></span><br><span class="line">hold on <span class="comment">% 保持当前画的图形不被覆盖掉</span></span><br><span class="line">plot(x, y2, <span class="string">'-r'</span>); <span class="comment">% - 实线 r 红色</span></span><br><span class="line">xlabel(<span class="string">'x'</span>); <span class="comment">%  x轴上加标签</span></span><br><span class="line">ylabel(<span class="string">'y'</span>); <span class="comment">%  y轴上加标签</span></span><br><span class="line">text(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'(0,0)'</span>); <span class="comment">% 在(0,0)加文本</span></span><br><span class="line">legend(<span class="string">'sin x'</span>, <span class="string">'cos x'</span>); <span class="comment">% 图例</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/03/24/5c97966acaa8f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/24/5c97966acaa8f.png" alt="sinx&amp;cosx.png"></a></p><h2 id="two-hearts"><a href="#two-hearts" class="headerlink" title="two hearts"></a>two hearts</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span> : <span class="built_in">pi</span>/<span class="number">180</span> : <span class="number">4</span>*<span class="built_in">pi</span>; <span class="comment">%  切片</span></span><br><span class="line">x = <span class="number">16</span>*<span class="built_in">sin</span>(t).^<span class="number">3</span>; <span class="comment">% x,y用参数为t的方程表示</span></span><br><span class="line">y = <span class="number">13</span>*<span class="built_in">cos</span>(t) - <span class="number">5</span>*<span class="built_in">cos</span>(<span class="number">2</span>*t)... <span class="comment">% 本行未结束</span></span><br><span class="line"><span class="number">-2</span>*<span class="built_in">cos</span>(<span class="number">3</span>*t) - <span class="built_in">cos</span>(<span class="number">4</span>*t);</span><br><span class="line">plot(x<span class="number">-3</span>, y, <span class="string">'-r'</span>, x+<span class="number">3</span>, y, <span class="string">'-b'</span>);</span><br><span class="line">xlabel(<span class="string">'x'</span>); <span class="comment">%  x轴上加标签</span></span><br><span class="line">ylabel(<span class="string">'y'</span>); <span class="comment">%  y轴上加标签</span></span><br><span class="line">axis([<span class="number">-20</span>, <span class="number">20</span>, <span class="number">-20</span>, <span class="number">15</span>]); <span class="comment">% 坐标范围：x [-20,20] y [-20,15]</span></span><br><span class="line">title(<span class="string">'Two Hearts'</span>); <span class="comment">% 标题</span></span><br><span class="line">legend(<span class="string">'U'</span>, <span class="string">'I'</span>); <span class="comment">% 图例</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/03/24/5c97966ac39fd.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/24/5c97966ac39fd.png" alt="twoHearts.png"></a></p><h2 id="对数坐标"><a href="#对数坐标" class="headerlink" title="对数坐标"></a>对数坐标</h2><p><code>loglog</code>，双对数坐标。</p><p><code>semilogx</code>，只有x是对数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>*<span class="number">2.</span>^[<span class="number">0</span>:<span class="number">6</span>];</span><br><span class="line">y = [<span class="number">100</span> <span class="number">150</span> <span class="number">225</span> <span class="number">340</span> ...</span><br><span class="line"> <span class="number">510</span> <span class="number">765</span> <span class="number">1150</span>];</span><br><span class="line">loglog(x, y, <span class="string">'.-r'</span>); <span class="comment">% 点实线 红色</span></span><br><span class="line">xlim([<span class="number">0.5e1</span>, <span class="number">0.8e3</span>]); <span class="comment">% x坐标范围</span></span><br><span class="line">ylim([<span class="number">0.8e2</span>, <span class="number">1.4e3</span>]); <span class="comment">% y坐标范围</span></span><br><span class="line">xlabel(<span class="string">'x'</span>);</span><br><span class="line">ylabel(<span class="string">'y'</span>);</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/03/24/5c97966ad56f0.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/24/5c97966ad56f0.png" alt="对数坐标.png"></a></p><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><p><code>polar</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theta = <span class="number">0</span> : <span class="built_in">pi</span>/<span class="number">180</span> : <span class="number">4</span>*<span class="built_in">pi</span>; <span class="comment">% 角度</span></span><br><span class="line">r = <span class="number">1</span>- <span class="built_in">sin</span>(theta); <span class="comment">% 长度</span></span><br><span class="line">polar(theta, r, <span class="string">'-r'</span>); <span class="comment">% 实线 红色</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/03/24/5c97966b0e806.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/24/5c97966b0e806.png" alt="极坐标.png"></a></p><h1 id="三维作图"><a href="#三维作图" class="headerlink" title="三维作图"></a>三维作图</h1><h2 id="plot3"><a href="#plot3" class="headerlink" title="plot3"></a>plot3</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">0</span> : <span class="built_in">pi</span>/<span class="number">50</span> : <span class="number">10</span>*<span class="built_in">pi</span>; <span class="comment">% 2pi是一圈 10pi转5圈 </span></span><br><span class="line">x = <span class="built_in">sin</span>(t);</span><br><span class="line">y = <span class="built_in">cos</span>(t);</span><br><span class="line">z = t;</span><br><span class="line">plot3(x, y, z); <span class="comment">% 3维</span></span><br><span class="line">title(<span class="string">'Helix'</span>);</span><br><span class="line">xlabel(<span class="string">'sin t'</span>);</span><br><span class="line">ylabel(<span class="string">'cos t'</span>);</span><br><span class="line">zlabel(<span class="string">'t'</span>);</span><br><span class="line">grid on <span class="comment">% 打开网格</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/03/24/5c97966ad4b4b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/24/5c97966ad4b4b.png" alt="Helix.png"></a></p><h2 id="三维曲面"><a href="#三维曲面" class="headerlink" title="三维曲面"></a>三维曲面</h2><p><code>meshgrid</code>，生成绘制3D图形所需的网格数据。</p><p><code>[x, y]=meshgrid(1:3, 1:3)</code></p><p><code>mesh</code>，<code>surf</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = <span class="built_in">meshgrid</span>(-<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>); <span class="comment">% 生成数据</span></span><br><span class="line">z = <span class="built_in">sin</span>(x) .* <span class="built_in">cos</span>(y);</span><br><span class="line">mesh(x, y, z); <span class="comment">% 作图</span></span><br><span class="line">surf(x, y, z); <span class="comment">% 使有颜色</span></span><br><span class="line">xlabel(<span class="string">'x'</span>); </span><br><span class="line">ylabel(<span class="string">'y'</span>);</span><br><span class="line">zlabel(<span class="string">'z'</span>);</span><br><span class="line">title(<span class="string">'sin x sin y'</span>);</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/03/24/5c97966b6e115.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/24/5c97966b6e115.png" alt="三维曲面.png"></a></p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二维作图&quot;&gt;&lt;a href=&quot;#二维作图&quot; class=&quot;headerlink&quot; title=&quot;二维作图&quot;&gt;&lt;/a&gt;二维作图&lt;/h1&gt;&lt;h2 id=&quot;plot&quot;&gt;&lt;a href=&quot;#plot&quot; class=&quot;headerlink&quot; title=&quot;plot&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="可视化" scheme="https://chouxianyu.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Matlab基础</title>
    <link href="https://chouxianyu.github.io/2019/03/24/Matlab%E5%9F%BA%E7%A1%80/"/>
    <id>https://chouxianyu.github.io/2019/03/24/Matlab基础/</id>
    <published>2019-03-24T14:44:52.000Z</published>
    <updated>2019-03-25T14:13:38.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本命令和语句"><a href="#基本命令和语句" class="headerlink" title="基本命令和语句"></a>基本命令和语句</h1><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><ul><li><p><code>clear y</code></p><p>  删除y变量</p></li><li><p><code>clear</code></p><p>  删除所有变量</p></li></ul><h2 id="clc"><a href="#clc" class="headerlink" title="clc"></a>clc</h2><p>清空屏幕输出</p><h2 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h2><p>matlab文件命名规则和C语言变量命名规则类似。</p><h2 id="help"><a href="#help" class="headerlink" title="help"></a>help</h2><p>帮助文档，<code>help functionname</code>。</p><h2 id="lookfor"><a href="#lookfor" class="headerlink" title="lookfor"></a>lookfor</h2><p>寻找含关键字的函数，<code>lookfor keyword</code>。</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>一行中的元素可以用逗号或者空格隔开。</p><p>分号表示一行向量的结束。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>起点：步长：终点，步长可以省略，默认为1</p><h2 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h2><p><code>A&#39;</code> </p><h2 id="linespace"><a href="#linespace" class="headerlink" title="linespace"></a>linespace</h2><p>类似切片，均匀生成几个数字，得到行向量。</p><h1 id="常用矩阵"><a href="#常用矩阵" class="headerlink" title="常用矩阵"></a>常用矩阵</h1><h2 id="zeros"><a href="#zeros" class="headerlink" title="zeros"></a>zeros</h2><p>零矩阵，参数是行数和列数或者方阵行数。</p><h2 id="ones"><a href="#ones" class="headerlink" title="ones"></a>ones</h2><p>1矩阵，参数同zeros。</p><h2 id="eye"><a href="#eye" class="headerlink" title="eye"></a>eye</h2><p>单位矩阵</p><h2 id="固定变量"><a href="#固定变量" class="headerlink" title="固定变量"></a>固定变量</h2><h3 id="pi"><a href="#pi" class="headerlink" title="pi"></a>pi</h3><p>π</p><h3 id="i"><a href="#i" class="headerlink" title="i"></a>i</h3><p>虚数，$\sqrt{-1}​$。</p><h3 id="Inf"><a href="#Inf" class="headerlink" title="Inf"></a>Inf</h3><p>无穷大</p><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>不是一个数字，not a number。</p><h1 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h1><p>矩阵指2维向量，向量指1维向量。</p><h2 id="矩阵加法"><a href="#矩阵加法" class="headerlink" title="矩阵加法"></a>矩阵加法</h2><p>同型矩阵同位置元素相加。</p><p>若矩阵+向量，每行/列都会加该向量。</p><h2 id="矩阵减法"><a href="#矩阵减法" class="headerlink" title="矩阵减法"></a>矩阵减法</h2><p>类似于矩阵加法。</p><h2 id="矩阵乘法-除法"><a href="#矩阵乘法-除法" class="headerlink" title="矩阵乘法/除法"></a>矩阵乘法/除法</h2><h3 id="点乘点除"><a href="#点乘点除" class="headerlink" title="点乘点除"></a>点乘点除</h3><p><code>A.*B</code>，对应位相乘。</p><h3 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h3><p><code>A^2</code></p><h3 id="点次方"><a href="#点次方" class="headerlink" title="点次方"></a>点次方</h3><p><code>A.^2</code>，每一位都次方。</p><h1 id="矩阵取值"><a href="#矩阵取值" class="headerlink" title="矩阵取值"></a>矩阵取值</h1><h2 id="双索引"><a href="#双索引" class="headerlink" title="双索引"></a>双索引</h2><p>A(1,3)`，第一行第三列元素。 </p><h2 id="单索引"><a href="#单索引" class="headerlink" title="单索引"></a>单索引</h2><p>matlab是竖着数的。</p><p>若A是三行三列的矩阵，则<code>A(1,2)==A(4)</code>。</p><h2 id="取行-列向量"><a href="#取行-列向量" class="headerlink" title="取行/列向量"></a>取行/列向量</h2><p><code>A(2,:)</code>，取A的第二行所有列，即第二行。</p><h1 id="比较和逻辑运算"><a href="#比较和逻辑运算" class="headerlink" title="比较和逻辑运算"></a>比较和逻辑运算</h1><p>同位置元素进行比较，<code>&gt;</code>、<code>&lt;</code>、<code>&amp;</code>、<code>|</code>、<code>==</code>、异或<code>xor(x&gt;5,y&lt;7)</code>。比如<code>A==B</code>。</p><p><code>x(x&lt;0)=0</code>，将x中小于0的赋值为0</p><p><code>y(y(:,1)&lt;0,:)=0</code>，如果某行第一列小于0，整行赋值为0</p><h1 id="矩阵操作函数"><a href="#矩阵操作函数" class="headerlink" title="矩阵操作函数"></a>矩阵操作函数</h1><p>设A是矩阵，B是行向量，C是列向量。</p><h2 id="flipud"><a href="#flipud" class="headerlink" title="flipud"></a>flipud</h2><p>上下旋转</p><h2 id="fliplr"><a href="#fliplr" class="headerlink" title="fliplr"></a>fliplr</h2><p>左右旋转</p><h2 id="rot90"><a href="#rot90" class="headerlink" title="rot90"></a>rot90</h2><p>沿副对角线旋转，与转置不同。</p><h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p>求和。</p><ul><li><p>sum(B)</p><p>  求该行的和</p></li><li><p>sum(A)</p><p>  每列求和，得到一个行向量</p></li><li><p>sum(A，1)</p><p>  等价于sum(A)，1代表维度，列是第一个维度。</p></li><li><p>sum(A，2)</p><p>  每行求和，得到一个列向量。</p></li><li><p>sum(A(:))</p><p>  整个矩阵求和。<code>A(:)</code>将矩阵<code>A</code>拉成一个列向量。</p></li></ul><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><ul><li><p>max(B)</p><p>  求一行的最大值。</p></li><li><p>max(B,2)</p><p>  每个元素与2比较，得最大值；若小于2，则结果为2；若大于2，则结果为该元素。</p></li><li><p>max(A)</p><p>  与<code>sum</code>类似，每列求最大值，等价于<code>max(A,[],1)</code>。</p></li><li><p><code>max(A,[],2)</code></p><p>  每行求最大值。</p></li></ul><h1 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h1><h2 id="ceil"><a href="#ceil" class="headerlink" title="ceil"></a>ceil</h2><p>向上取整</p><h2 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h2><p>靠近0取整</p><h2 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h2><p>向下取整</p><h2 id="round"><a href="#round" class="headerlink" title="round"></a>round</h2><p>四舍五入取整</p><h2 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h2><p><code>mod(i,2)</code>，取i/2的余数。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本命令和语句&quot;&gt;&lt;a href=&quot;#基本命令和语句&quot; class=&quot;headerlink&quot; title=&quot;基本命令和语句&quot;&gt;&lt;/a&gt;基本命令和语句&lt;/h1&gt;&lt;h2 id=&quot;clear&quot;&gt;&lt;a href=&quot;#clear&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之引用</title>
    <link href="https://chouxianyu.github.io/2019/03/24/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E5%BC%95%E7%94%A8/"/>
    <id>https://chouxianyu.github.io/2019/03/24/C-C-小课之引用/</id>
    <published>2019-03-24T08:07:48.000Z</published>
    <updated>2019-03-24T08:08:52.302Z</updated>
    
    <content type="html"><![CDATA[<p>关于引用，讲一个同学问的题目。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//域限定符</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;<span class="comment">//域限定符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> b = <span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//定义函数，为了规范，应该在main前边写函数声明，main后定义函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//a是main函数中j的引用</span></span><br><span class="line">a = a * b;<span class="comment">//j = j * b</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;m = f(j);<span class="comment">//函数f返回引用a，即j的引用，所以m是j的引用</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;m;<span class="comment">//p指向j</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//200</span></span><br><span class="line">m = <span class="number">20</span>;<span class="comment">//m是j的引用，j = 20</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//20</span></span><br><span class="line">f(j, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//100</span></span><br><span class="line">*p = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用分为左值引用和右值引用。</p><p>左值引用是某个变量的别名，作用类似于指针，提高效率。</p><p>右值引用是绑定到右值上的引用，只能绑定到即将销毁的对象上。</p><h2 id="域限定符"><a href="#域限定符" class="headerlink" title="域限定符"></a>域限定符</h2><p>命名空间是为了解决全局命名空间污染问题。</p><p>通过限定符可以使用对应命名空间内的对象（变量、函数、类型、类等）。</p><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>默认参数又叫做缺省参数。如何理解？</p><ul><li><p>默认</p><p>  小明：小红，你在干嘛?</p><p>  小明：小红，你刚才在干嘛？</p></li><li><p>缺省</p><p>  可以缺少、省略。</p></li></ul><p>所有默认参数都必须出现在无默认参数的最右边。</p><p>也就是说实参从左向右给形参赋值，默认参数从右向左给形参赋值。</p><h2 id="函数位置"><a href="#函数位置" class="headerlink" title="函数位置"></a>函数位置</h2><p>函数应该写在代码的哪里？</p><p>如果使用C语言，比较好的方式是将函数声明和函数定义分开放，即在main函数前声明函数，在main函数后定义函数。</p><p>如果使用C++，最好面向对象，使用头文件和源文件。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h3><p>谈到这个，相关的名词有两个：</p><ul><li><p>堆</p><p>  <code>new</code>出来的内存就在堆里</p></li><li><p>（堆）栈</p><p>  如果在main函数中定义一个<code>int</code>，它就存储在栈里。</p></li></ul><p>在学数据结构时，会学到栈和堆，它们是两种数据结构。</p><h3 id="栈和函数"><a href="#栈和函数" class="headerlink" title="栈和函数"></a>栈和函数</h3><p>栈有一个应用就是处理函数的<strong>嵌套</strong>，比较典型的就是递归。</p><p>比如上边代码中的main运行到f函数时，先要保存现在main函数的状态（变量、代码执行到的位置等），将其压栈（PUSH）；然后再进入f函数，栈顶即为f函数的内容，f函数执行完后，出栈（POP）；然后继续执行main函数。</p><p>在调试时就可以看到函数调用栈。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于引用，讲一个同学问的题目。&lt;/p&gt;
&lt;h1 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="引用" scheme="https://chouxianyu.github.io/tags/%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之课程介绍</title>
    <link href="https://chouxianyu.github.io/2019/03/24/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://chouxianyu.github.io/2019/03/24/C-C-小课之课程介绍/</id>
    <published>2019-03-24T07:59:55.000Z</published>
    <updated>2019-03-24T14:55:05.764Z</updated>
    
    <content type="html"><![CDATA[<p>应要求，周六晚上开了一个课，教C/C++，把课件放在这里。</p><h1 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h1><ul><li><p>关于我</p><p>  班级，性别，年龄。</p><p>  第一次教课，希望大家及时对课堂给予一定建议与<strong>反馈</strong>。</p></li><li><p>上课时间</p><p>  周六晚上六点半，时长根据上课内容的多少和难度确定。</p></li><li><p>需求</p><p>  大家的需求是什么？C/C++?（<strong>我需要讲得广一点吗</strong>？）</p><p>  具体希望了解哪个方面呢？</p><p>  这可能跟你的年级、所上课程有关，也有可能你们也不知道。</p></li><li><p><strong>课程定位</strong></p><ul><li><p>该课程主要起<strong>辅助</strong>作用</p><p>  学习的主要战场应在个人课下的学习和学院老师的课堂上，这个课并不是冲刺课。</p><p>  由于能力和精力有限，我不能保证谁上了这个课就一定可以考高分或者不挂科。</p><p>  如果合作愉快，大家一定会有收获。</p></li><li><p>我的作用是帮助大家</p><p>  毕竟大二了，与大部分大一的同学相比，写代码的经验和知识面会足一些，我会尽可能把我的知识、思路和方法讲给大家。</p></li></ul></li></ul><h1 id="课程要求"><a href="#课程要求" class="headerlink" title="课程要求"></a>课程要求</h1><ul><li><p>课堂纪律</p><p>  合乎公共礼仪即可，好好听课，该请假的要跟我请假。每次课要点名的。</p><p>  希望大家能做到不懂就问。</p></li><li><p><strong>每周作业：每人提一个问题给我</strong></p><p>  这个是为了更好地了解大家的学习上遇到的困难，大家给出问题后，我可以在课堂上有针对性地进行讲解。大家的问题可能会是课堂的主要内容。</p></li></ul><h1 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h1><ul><li><p>大家解决编程中遇到的问题的能力有一定提升，能够多思考为什么</p></li><li><p>更了解C/C++，扩展知识面</p></li><li><p>课堂之外给大家帮助</p><p>  课余也可以</p></li></ul><h1 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h1><ul><li><p>C/C++课程重难点</p><p>  面向正在上C++、C语言课程的同学，讲解一些重点。</p></li><li><p><strong>大家的作业：提出的问题</strong></p><p>  可以是找到的题，可以是写作业遇到的问题，都可以。</p><p>  这是使这门课最大程度地为大家服务的一个方式，可以提高这门课的效用。</p></li><li><p>我遇到的有意思的问题</p><p>  大概想想有数组名，指针（包括指针赋值），面向对象，抽象，C++类的互相引用等等吧。</p></li></ul><p>大家有什么问题吗？</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应要求，周六晚上开了一个课，教C/C++，把课件放在这里。&lt;/p&gt;
&lt;h1 id=&quot;课程简介&quot;&gt;&lt;a href=&quot;#课程简介&quot; class=&quot;headerlink&quot; title=&quot;课程简介&quot;&gt;&lt;/a&gt;课程简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;关于我&lt;/p&gt;
&lt;p&gt;  班级，
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之数组名</title>
    <link href="https://chouxianyu.github.io/2019/03/24/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E6%95%B0%E7%BB%84%E5%90%8D/"/>
    <id>https://chouxianyu.github.io/2019/03/24/C-C-小课之数组名/</id>
    <published>2019-03-24T07:59:18.000Z</published>
    <updated>2019-03-24T08:10:05.435Z</updated>
    
    <content type="html"><![CDATA[<p>我们今天讨论数组名是什么东西，理解它有助于我们进一步理解和使用指针。</p><p>因为它涉及到了内存地址。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>数组名是什么？含义是什么？</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>一个值+1之后的变化可以反映出它的意义/含义。</p><h2 id="前提的证明"><a href="#前提的证明" class="headerlink" title="前提的证明"></a>前提的证明</h2><p>其实不证自明，计算机中就是这样的。</p><ul><li><p>生活中</p><p>  一个苹果+1，结果是两个，增加了一个苹果。</p><p>  一箱苹果+1，结果是两箱，个数是2*每箱苹果数，增加了一箱苹果。</p></li><li><p>计算机中</p><p>  int型变量的地址+1，增加了一个int的大小。</p><p>  double型变量的地址+1，增加了一个double的大小。</p></li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>根据前提，通过将数组名或数组名相关的值+1来判断它的含义。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>编程中要了解一个东西，大多时候我们可以通过输出它来了解它。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注释指出array代表什么</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"    &amp;array[0] =  %p\n"</span>, &amp;<span class="built_in">array</span>[<span class="number">0</span>]);<span class="comment">//首元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"        array =  %p\n"</span>, <span class="built_in">array</span>);<span class="comment">//数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"      array+1 =  %p\n"</span>, <span class="built_in">array</span> + <span class="number">1</span>);<span class="comment">//数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  &amp;array[0]+1 =  %p\n"</span>, &amp;<span class="built_in">array</span>[<span class="number">0</span>] + <span class="number">1</span>);<span class="comment">//首元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"       &amp;array =  %p\n"</span>, &amp;<span class="built_in">array</span>);    <span class="comment">//数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"     &amp;array+1 =  %p\n"</span>, &amp;<span class="built_in">array</span> + <span class="number">1</span>);<span class="comment">//数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(array) =  %zd\n"</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));<span class="comment">//数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么用printf不是cout？用cout其实也行，printf更方便。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &amp;<span class="built_in">array</span>[<span class="number">0</span>] =  <span class="number">0000002</span>A433FF628</span><br><span class="line">        <span class="built_in">array</span> =  <span class="number">0000002</span>A433FF628</span><br><span class="line">      <span class="built_in">array</span>+<span class="number">1</span> =  <span class="number">0000002</span>A433FF62C</span><br><span class="line">  &amp;<span class="built_in">array</span>[<span class="number">0</span>]+<span class="number">1</span> =  <span class="number">0000002</span>A433FF62C</span><br><span class="line">       &amp;<span class="built_in">array</span> =  <span class="number">0000002</span>A433FF628</span><br><span class="line">     &amp;<span class="built_in">array</span>+<span class="number">1</span> =  <span class="number">0000002</span>A433FF63C</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">array</span>) =  <span class="number">20</span></span><br></pre></td></tr></table></figure><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h2 id="数组名是什么，有什么含义"><a href="#数组名是什么，有什么含义" class="headerlink" title="数组名是什么，有什么含义"></a>数组名是什么，有什么含义</h2><p><del>数组名是一个常量（所以不能被赋值），是一个地址。</del>（<code>&amp;array</code>中array并不是地址，因为地址是一个值，我们并不能取一个值的地址吧）</p><p>在不同情况下，有着不同的含义。</p><ul><li><p>代表整个数组</p><p>  碰到<code>&amp;</code>、<code>sizeof</code>时，数组名代表整个数组，作用像是一个变量。</p></li><li><p>代表数组首元素</p><p>  数组名单独出现或碰到<code>[]</code>、<code>*</code>时，数组名代表数组第一个元素，是一个地址。（这个下次会讲）</p></li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="IDE、编译器、编辑器"><a href="#IDE、编译器、编辑器" class="headerlink" title="IDE、编译器、编辑器"></a>IDE、编译器、编辑器</h2><ul><li><p>编辑器</p><p>  文本编辑器，比如notepad++，sublime。</p></li><li><p>编译器</p><p>  处理我们写的代码。</p><p>  C/C++的比如有：gcc，mingw。</p><p>  计算机语言可以分为两种：编译语言和解释语言。</p></li><li><p>IDE</p><p>  Integrated Development Environment，集成开发环境。</p><p>  集合了编辑器和编译器的功能，还有一些辅助开发的功能。</p></li></ul><h2 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h2><ul><li><p>解决方案</p></li><li><p>项目</p></li><li><p>调试</p></li><li><p>查看源码</p><p>  比如看<code>sizeof</code>、<code>iostream</code>，<code>Ctrl+左键</code></p></li><li><p>查看类图</p><p>  右击(项目)-查看-查看类图</p></li></ul><h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p><a href="https://tool.lu/hexconvert/" target="_blank" rel="noopener">https://tool.lu/hexconvert/</a></p><h2 id="地址-1"><a href="#地址-1" class="headerlink" title="地址+1"></a>地址+1</h2><p>核心在于单位。==见下篇==</p><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>占用的字节数。基本数据类型、结构体（会字节对齐）。</p><ul><li><p>不同环境下（32位、64位等）某种类型的变量占用字节数可能是不同的</p><p>  比如指针，32位下是4个字节，64位下是8个字节，</p><p>  正好是对应计算机的字长。（后边有讲计算机字长是什么）</p></li><li><p><code>%zd</code>、<code>size_t</code></p></li></ul><p>==后边还有一篇==</p><h2 id="p-x"><a href="#p-x" class="headerlink" title="%p %x"></a>%p %x</h2><p>两者有细微差别。</p><h2 id="重视warning"><a href="#重视warning" class="headerlink" title="重视warning"></a>重视warning</h2><p>VS的warning还是比较全的，其他IDE的waring不一定全。</p><p>如果写代码出了问题却找不到原因，有可能是warning给出的潜在问题没有处理。</p><p>写代码时遇到waring一定要处理，不然很容易出问题。</p><h2 id="混合编程"><a href="#混合编程" class="headerlink" title="混合编程"></a>混合编程</h2><p>C和C++还是不一样的。特别是函数的使用，如果要动态申请一个类对象的内存，可别用malloc，它和new还是不一样的。</p><h2 id="一些重要名词"><a href="#一些重要名词" class="headerlink" title="一些重要名词"></a>一些重要名词</h2><h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><p>生活、编程中出现的数字、字符串、字符等等，都是值。</p><p>比如1,2,3，我爱你等等。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量算是对值的一个<strong>替代</strong>（或者说抽象）吧，提高复用性。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>地址是个值。</p><p>计算机有存储空间。我们将其一个个地编号，也就是给了它一个地址。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针是个变量。</p><p>跟普通变量其实没什么本质区别，只不过它<strong>被用来存储地址</strong>而已。</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><code>*</code> <code>[]</code> <code>&amp;</code>的优先级？</p><h2 id="计算机字长"><a href="#计算机字长" class="headerlink" title="计算机字长"></a>计算机字长</h2><p>字长：字的长度（位数）。</p><p>计算机中有字节这个单位。1个字节等于8位。</p><p>多个<strong>字节</strong>组成<strong>字</strong>。</p><p>我们平常说的电脑32位，64位指的就是字长。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们今天讨论数组名是什么东西，理解它有助于我们进一步理解和使用指针。&lt;/p&gt;
&lt;p&gt;因为它涉及到了内存地址。&lt;/p&gt;
&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;数组名是什么？含
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="数组" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
