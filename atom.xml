<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2019-06-29T11:59:30.699Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理-课程设计</title>
    <link href="https://chouxianyu.github.io/2019/06/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>https://chouxianyu.github.io/2019/06/29/计算机组成原理-课程设计/</id>
    <published>2019-06-29T11:58:10.000Z</published>
    <updated>2019-06-29T11:59:30.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的与要求"><a href="#目的与要求" class="headerlink" title="目的与要求"></a>目的与要求</h1><p>​    深入了解计算机各种指令的执行过程，以及控制器的组成，指令系统微程序设计的具体知识，进一步理解和掌握动态微程序设计的概念；完成微程序控制的特定功能计算机的指令系统设计和调试。</p><p>​    要进行这项大型实验，必须清楚地懂得：</p><ol><li>TEC-2机的功能部件及其连接关系；</li><li>TEC-2机每个功能部件的功能与具体组成；</li><li>TEC-2机支持的指令格式；</li><li>TEC-2机的微指令格式，AM2910芯片的用法；</li><li>已实现的典型指令的执行实例，即相应的微指令与其执行次序的安排与衔接；</li><li>要实现的新指令的格式与功能。</li></ol><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>$TEC-2$模拟机</p><h1 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h1><p>请选定指令格式、操作码，按照要求，设计三条指令。</p><h2 id="指令一"><a href="#指令一" class="headerlink" title="指令一"></a>指令一</h2><ul><li><p><strong>说明</strong></p><p>  把用绝对地址表示的内存单元<code>ADDR1</code>中的内容与内存单元<code>ADDR2</code>中的内容相减，结果存于内存单元<code>ADDR1</code>中。</p><p>  三字指令（控存入口<code>110H</code>）。</p></li><li><p><strong>格式</strong></p><p>  <code>D8××,ADDR1,ADDR2</code></p></li><li><p><strong>功能</strong></p><p>  <code>[ADDR1]=[ADDR1]-[ADDR2]</code></p></li></ul><h3 id="微程序设计与实现"><a href="#微程序设计与实现" class="headerlink" title="微程序设计与实现"></a>微程序设计与实现</h3><div class="table-container"><table><thead><tr><th style="text-align:center">执行顺序</th><th style="text-align:center">微指令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$PC\to AR,PC+1 \to PC$</td><td style="text-align:center">为读取第1个操作数的地址做准备</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$MEM \to R6$</td><td style="text-align:center">读取第1个操作数的地址送入$R_6$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$PC \to AR,PC+1 \to PC$</td><td style="text-align:center">为读取第2个操作数的地址做准备</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">$MEM \to AR$</td><td style="text-align:center">读取第2个操作数的地址送入$AR$</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">$R6 \to AR,MEM \to R6$</td><td style="text-align:center">第1个操作数地址送$AR$，读取第2个操作数送入$R_6$</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">$MEM-R6\to R6$</td><td style="text-align:center">第1个操作数-第2个操作数送入$R_6$</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">$R6 \to MEM$</td><td style="text-align:center">$R_6$送第1个操作数所在存储单元</td></tr></tbody></table></div><ol><li>$PC\to AR,PC+1 \to PC$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> A0B5 <span class="number">5402</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbba492b14679.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbba492b14679.png" alt="微指令11.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  不需要读写存储器或输入输出设备，所以为<code>10X</code></p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口，运算器Y输出$A$口</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$B$口和0,（选$A$口和0也可以，因为$A$口和$B$口是同一个寄存器）</p></li><li><p>$A$口</p><p>  选$PC$，即$R_5$</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  选$PC$，即$R_5$</p></li><li><p>$SCI$</p><p>  最低位进位设置为1</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  选微指令中的$A$口、$B$口地址</p></li><li><p>$DC1$</p><p>  因为$AR$只能接收来自运算器的结果输出信号，所以$DC1$可以任意</p></li><li><p>$DC2$</p><p>  运算器输出送$AR$</p></li></ul></li></ul><ol><li>$MEM \to R6$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> <span class="number">30F</span>0 <span class="number">6000</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc13dbd27187.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc13dbd27187.png" alt="微指令12.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口，运算器Y输出运算结果（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和0</p></li><li><p>$A$口</p><p>  任意</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  选$R6$</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  $A$口任意，因为不使用$A$口；选择微指令中的$B$口地址</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><ol><li>$PC \to AR,PC+1 \to PC$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> A0B5 <span class="number">5402</span></span><br></pre></td></tr></table></figure><p>这条微指令和本机器指令的第一条微指令完全一样，不再做解释说明</p><ol><li>$MEM \to AR$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> <span class="number">10F</span>0 <span class="number">0002</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc11e9d48798.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc11e9d48798.png" alt="微指令14.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果不送寄存器，运算器Y输出运算结果送$AR$</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和0</p></li><li><p>$A$口</p><p>  任意</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  任意</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  都任意，因为不使用$A$口和$B$口</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  运算器输出送$AR$</p></li></ul></li></ul><ol><li>$R6 \to AR,MEM \to R6$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> <span class="number">20F</span>6 <span class="number">6002</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc1435171281.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc1435171281.png" alt="微指令15.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时并非真正的运算，并且第6条微指令才是真正的运算，所以这3位任意即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口，运算器Y输出$A$口</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和0</p></li><li><p>$A$口</p><p>  $R_6$</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  $R_6$</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$A$口和$B$口</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  运算器输出送$AR$</p></li></ul></li></ul><ol><li>$MEM-R6\to R6$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E01</span> <span class="number">22</span>D6 <span class="number">6000</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc13ed899415.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc13ed899415.png" alt="微指令16.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意取值即可</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行时不需要条件测试，不需要使用$\bar{CC}$，所以这4位任意取值</p></li><li><p>$SST$</p><p>  此时是真正的运算，设置标志位</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口；运算器Y输出$A$口（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择减法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和$A$口</p></li><li><p>$A$口</p><p>  $R_6$</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  $R_6$</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$A$口和$B$口</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><ol><li>$R6 \to MEM$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0029</span> <span class="number">0300</span> <span class="number">1046</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbc142d818038.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbc142d818038.png" alt="微指令17.png"></a></p><ul><li><p>七</p><p>  这是最后一条微指令，下一条微指令是<code>A4H</code>。</p></li><li><p>六</p><p>  $AM2910$命令码为3，即3号指令，条件转移</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  $\bar{CC}$设为0，进行转移</p></li><li><p>$SST$</p><p>  此时并不是运算，所以标志位不变</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  写存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果不送寄存器；运算器Y输出​$A$口</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择0和$A$口</p></li><li><p>$A$口</p><p>  $R_6$</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  任意</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$A$口；$B$口任意</p></li><li><p>$DC1$</p><p>  运算器输出送$IB$</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><h3 id="指令测试"><a href="#指令测试" class="headerlink" title="指令测试"></a>指令测试</h3><p>如下图所示，<code>[A00H]</code>存储单元（$ADDR1$）存储了<code>0045H</code>，<code>[A01H]</code>存储单元（$ADDR2$）存储了<code>0023H</code>，最终指令运行后<code>[A00H]</code>为<code>0022H</code>，实现<code>[ADDR1]=[ADDR1]-[ADDR2]</code>。</p><p><a href="https://i.loli.net/2019/06/22/5d0d96d08694544002.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d08694544002.png" alt="指令测试11.png"></a></p><p><a href="https://i.loli.net/2019/06/22/5d0d96ccdb05229094.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96ccdb05229094.png" alt="指令测试12.png"></a></p><h2 id="指令二"><a href="#指令二" class="headerlink" title="指令二"></a>指令二</h2><ul><li><p><strong>说明</strong></p><p>  将一通用寄存器内容加上某内存单元内容，结果放在另一寄存器中。</p><p>  双字指令（控存入口<code>130H</code>），$SR$和$DR$分别为源、目的寄存器（各4位）。</p></li><li><p><strong>格式</strong></p><p>  <code>E0 DR SR,ADDR</code></p></li><li><p><strong>功能</strong></p><p>  <code>DR=SR+ [ADDR]</code> </p></li></ul><h3 id="微程序设计与实现-1"><a href="#微程序设计与实现-1" class="headerlink" title="微程序设计与实现"></a>微程序设计与实现</h3><div class="table-container"><table><thead><tr><th style="text-align:center">执行顺序</th><th style="text-align:center">微指令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$PC\to AR,PC+1 \to PC$</td><td style="text-align:center">为读取操作数的地址做准备</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$MEM \to AR$</td><td style="text-align:center">操作数的地址送入$AR$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$SR+MEM \to DR$</td><td style="text-align:center">计算$SR$与操作数的和存入$DR$</td></tr></tbody></table></div><ol><li>$PC\to AR,PC+1 \to PC$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> A0B5 <span class="number">5402</span></span><br></pre></td></tr></table></figure><p>这条微指令和第一条机器指令的第一条微指令完全一样，不再做解释说明</p><ol><li>$MEM \to AR$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E00</span> <span class="number">10F</span>0 <span class="number">0002</span></span><br></pre></td></tr></table></figure><p>这条微指令和第一条机器指令的第四条微指令完全一样，不再做解释说明</p><ol><li>$SR+MEM \to DR$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0029</span> <span class="number">0301</span> <span class="number">30</span>D0 <span class="number">0088</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cddbbb584732965.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cddbbb584732965.png" alt="微指令23.png"></a></p><ul><li><p>七</p><p>  这是最后一条微指令，下一条微指令是<code>A4H</code>。</p></li><li><p>六</p><p>  $AM2910$命令码为3，即3号指令，条件转移</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  $\bar{CC}$设为0，进行转移</p></li><li><p>$SST$</p><p>  此时进行了运算，需要对标志位进行设置</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口；运算器Y输出​运算结果（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和$A$口</p></li><li><p>$A$口</p><p>  使用机器指令中设置的$SR$，微指令中不需要给$A$口地址</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  使用机器指令中设置的$DR$，微指令中不需要给$B$口地址</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用机器指令中的$SR、DR$</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><h3 id="指令测试-1"><a href="#指令测试-1" class="headerlink" title="指令测试"></a>指令测试</h3><p>如图示，$R_0$（$SR$）为<code>0023H</code>，<code>A00H</code>（$ADDR$）存储<code>0023H</code>，程序运行后$R_1$（$DR$）为<code>0046H</code>，实现<code>DR=SR+ [ADDR]</code> 。</p><p><a href="https://i.loli.net/2019/06/22/5d0d96d27564178096.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d27564178096.png" alt="指令测试21.png"></a></p><p><a href="https://i.loli.net/2019/06/22/5d0d96cc0eda569856.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96cc0eda569856.png" alt="指令测试22.png"></a></p><h2 id="指令三"><a href="#指令三" class="headerlink" title="指令三"></a>指令三</h2><ul><li><p><strong>说明</strong></p><ul><li><p>转移指令</p><p>  判断两个通用寄存器内容是否相等，若相等则转移到指定绝对地址，否则顺序执行。</p></li><li><p>双字指令（控存入口<code>140H</code>），<code>SR</code>和<code>DR</code>分别为源、目的寄存器（各4位），<code>ADDR</code>为绝对地址。</p></li><li><p>提示</p><p>  利用指令的<code>CND</code>字段，即$IR_{10-8}$，令$IR_{10-8}=101$，即$\bar{CC}=Z$。</p><p>  当<code>DR==SR​</code>时<code>Z=1</code>，微程序不跳转，接着执行$MEM \to PC$（即$ADDR\to PC$）；</p><p>  而当<code>DR!=SR​</code>时<code>Z=0​</code>，微程序跳转至<code>A4H</code>。</p></li></ul></li><li><p><strong>格式</strong></p><p>  <code>E5 DR SR,ADDR</code></p></li><li><p><strong>功能</strong></p><p>  <code>if DR==SR goto ADDR</code> <code>else　顺序执行</code></p></li></ul><h3 id="微程序设计与实现-2"><a href="#微程序设计与实现-2" class="headerlink" title="微程序设计与实现"></a>微程序设计与实现</h3><div class="table-container"><table><thead><tr><th style="text-align:center">执行顺序</th><th style="text-align:center">微指令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">$SR-DR$</td><td style="text-align:center">测试$SR$与$DR$是否相等</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">$PC \to AR,PC+1 \to PC，\ $如果$Z=0，$则微程序跳转到$A4H$</td><td style="text-align:center">为读取转移地址做准备</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">$MEM \to PC$</td><td style="text-align:center">程序转移到指定地址</td></tr></tbody></table></div><ol><li>$SR-DR$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0E01</span> <span class="number">9210</span> <span class="number">0088</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cdeeba4c4559040.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cdeeba4c4559040.png" alt="微指令31.png"></a></p><ul><li><p>七</p><p>  顺序执行，下址字段任意</p></li><li><p>六</p><p>  $AM2910$命令码为14，即14号指令，顺序执行</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  顺序执行，不需要条件测试</p></li><li><p>$SST$</p><p>  此时进行了运算，需要对标志位进行设置，来判断$SR$和$DR$是否相等</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  不进行存储器或IO操作</p></li><li><p>$MI_{8-6}$</p><p>  运算结果不送寄存器；运算器Y输出​运算结果（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择减法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$A$口和$B$口</p></li><li><p>$A$口</p><p>  使用机器指令中设置的$SR$，微指令中不需要给$A$口地址</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  使用机器指令中设置的$DR$，微指令中不需要给$B$口地址</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用机器指令中的$SR、DR$</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><ol><li>$PC \to AR,PC+1 \to PC$，如果$Z=0$，则微程序跳转到$A4H$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0029</span> <span class="number">03E0</span> A045 <span class="number">5412</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cdeebbf81988317.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cdeebbf81988317.png" alt="微指令32.png"></a></p><ul><li><p>七</p><p>  微程序转移，下址字段为<code>A4H</code></p></li><li><p>六</p><p>  $AM2910$命令码为3，即3号指令，条件转移</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  测试条件设置为$IR_{10-8}$，指令中将$IR_{10-8}$设为5，即$\bar{CC}=Z$</p></li><li><p>$SST$</p><p>  此时并不是计算，状态位保持即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  不进行存储器或IO操作</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口；运算器Y输出$A$口</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$A$口和0</p></li><li><p>$A$口</p><p>  $A$口设置为$PC$，即$R_5$。</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  $B$口设置为$PC$，即$R_5$。</p></li><li><p>$SCI$</p><p>  最低位进位设置为1</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$A$口和$B$口地址</p></li><li><p>$DC1$</p><p>  由于是写$AR$，这里把运算器输出送$IB$。经过前两条机器指令的试验，实际上$DC1$可以任意。</p></li><li><p>$DC2$</p><p>  写$AR$</p></li></ul></li></ul><ol><li>$MEM \to PC$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0029</span> <span class="number">0300</span> <span class="number">30F</span>0 <span class="number">5000</span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2019/06/21/5d0cdeec78a4046521.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/21/5d0cdeec78a4046521.png" alt="微指令33.png"></a></p><ul><li><p>七</p><p>  微程序转移，下址字段为<code>A4H</code></p></li><li><p>六</p><p>  $AM2910$命令码为3，即3号指令，条件转移</p></li><li><p>五</p><ul><li><p>$SCC、SC$</p><p>  测试条件设置为0，一定转移</p></li><li><p>$SST$</p><p>  此时并不是计算，状态位保持即可</p></li></ul></li><li><p>四、三</p><ul><li><p>$\bar{MIO}、REQ、\bar{WE}$</p><p>  读存储器</p></li><li><p>$MI_{8-6}$</p><p>  运算结果送$B$口；运算器Y输出运算结果（并没有使用）</p></li><li><p>$MI_{5-3}$</p><p>  选择加法运算</p></li><li><p>$MI_{2-0}$</p><p>  运算数选择$D$和0</p></li><li><p>$A$口</p><p>  $A$口任意，并不使用。</p></li></ul></li><li><p>二</p><ul><li><p>$B$口</p><p>  $B$口设置为$PC$，即$R_5$。</p></li><li><p>$SCI$</p><p>  最低位进位设置为0</p></li><li><p>$SSH$</p><p>  不移位</p></li></ul></li><li><p>一</p><ul><li><p>$SA、SB$</p><p>  使用微指令中的$B$口地址，$A$口任意（因为不使用$A$口）。</p></li><li><p>$DC1$</p><p>  任意</p></li><li><p>$DC2$</p><p>  不控制</p></li></ul></li></ul><h3 id="指令测试-2"><a href="#指令测试-2" class="headerlink" title="指令测试"></a>指令测试</h3><p>当$R_1$（$SR$）存储<code>0023H</code>、$R_2$（$DR$）存储<code>0026H</code>时，即$DR \neq SR$时，程序顺序执行，运行了<code>MOV R1,0026</code>，所以程序运行后$R_1$为<code>0026H</code>。</p><p>当$R_1$（$SR$）存储<code>0023H</code>、$R_2$（$DR$）存储<code>0023H</code>时，即$DR = SR$时，程序跳转至<code>828H</code>（$ADDR$），所以未运行<code>MOV R1,0026</code>，所以程序运行后$R_1$仍为<code>0023H</code>。</p><ul><li>$DR \neq SR$时</li></ul><p><a href="https://i.loli.net/2019/06/22/5d0d96d48c64257612.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d48c64257612.png" alt="指令测试31_1.png"></a></p><p><a href="https://i.loli.net/2019/06/22/5d0d96d0d65a585568.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d0d65a585568.png" alt="指令测试31_2.png"></a></p><ul><li>$DR = SR$时</li></ul><p><a href="https://i.loli.net/2019/06/22/5d0d96d491b2e57530.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d491b2e57530.png" alt="指令测试32_1.png"></a></p><p><a href="https://i.loli.net/2019/06/22/5d0d96d07a6d178706.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/22/5d0d96d07a6d178706.png" alt="指令测试32_2.png"></a></p><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><ol><li>磨刀不误砍柴工。在设计微程序前，我把实验书看了一遍，有些地方不是很懂；之后着手去设计微程序，然后再去看书，理解到的更多了；最终微程序设计完之后，我又把书看了一遍，又发现了很多之前理解不到位的地方，正所谓温故而知新。我想这最能说明实践和理论的关系吧，多动手多动脑，才能巩固对知识的理解。</li><li>通过本次对微指令码一位位的设计，我对于计算机的底层实现有了更深的理解，更进一步地了解了计算机的工作原理，特别是运算器、控制器、内存、寄存器等部件之间的协作。本学期也学了汇编语言，它几乎是最靠近计算机硬件的编程语言了，在本次课程设计中，自主设计硬件间的协作，又算是直接接触了硬件，巩固了汇编和计组两门学科的知识与其联系。</li><li>通过本次课程设计，我巩固了微程序设计的方法与思想，比如微指令、微操作、微命令、水平型微指令、微控存等基本概念，了解了微程序层次上程序员所看到的的计算机系统结构，加深了对程序员一词的理解。不同层次的程序员由于工作的“机器”不同，所以面对的问题以及其实现往往也是极为不同的。</li></ol><h1 id="附加材料"><a href="#附加材料" class="headerlink" title="附加材料"></a>附加材料</h1><p><strong>以下为$TEC-2$部分知识点总结。</strong></p><h2 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h2><p>$TEC-2$机字长为16位，运算器、主存、数据与地址总线均为16位。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>$TEC-2$机指令有6位操作码，故支持64条指令，其中53条已实现，用于写出该机的监控程序。</p><p>$IR$：指令寄存器，存储当前正在执行的指令。</p><p>指令最高6位（$IR_{15-10}$）是操作码，之后两位$IR_{9-8}$是条件码，把它用作条件转移指令的判断条件，因此可以认为这两位是指令的扩展操作码。除条件转移指令之外，其余指令不使用这两位。</p><h2 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h2><p>主存支持$64K$字，$4K\times8$的$ROM(2732)$存放监控程序，$2K\times8$的$RAM(2716)$存放用户数据及数据。</p><h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2><p>运算器主要由4片$AM2901$级联而成，可实现8种运算功能，16个双端口（$A$、$B$）读出、单端口（$B$）写入的通用寄存器（$R_{0-15}$，其中$R_{4-6}$作为$SP$、$PC$、$IP$），另配有1片$AM2902$实现快速进位。</p><ul><li><p>$IP$</p><p>  保存当前正在运行的指令的地址，<strong>用于转移变址的目的</strong>。</p><p>  所以在课设第一条指令中可以使用$R_6$暂存数据，因为此时不需要转移变址，用不到$IP$。</p></li><li><p>$I_{8-6}$</p><p>  进行寄存器结果选择和Y输出选择</p></li><li><p>$I_{5-3}$</p><p>  进行运算功能选择</p></li><li><p>$I_{2-0}$</p><p>  进行数据来源选择</p></li></ul><h3 id="引脚信号"><a href="#引脚信号" class="headerlink" title="引脚信号"></a>引脚信号</h3><ul><li><p>$D_{3-0}$</p><p>  外部送给$AM2901$的数据信号，比如从内存读出来的数据</p></li><li><p>$Y_{3-0}$</p><p>  $AM2901$向外送出的数据，受​$\bar{OE}$控制。但在​$TEC-2$中，​$\bar{OE}$已接地</p></li><li><p>$A、B$</p><p>  选择寄存器组中的源与目的寄存器。</p><p>  当$A$、$B$同值时，被选中的同一个寄存器的内容将被同时送到$A$、$B$两个数据输出端口</p></li></ul><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><ul><li>控制器主要由一片$AM2910$、7片$6116(RAM,2K\times8)$（微控存）、16位的指令寄存器$IR$和2片$2716$（存储用于实现53条机器指令的微程序，加电后读取送入微控存）等组成。</li><li>程序计数器$PC$用运算器中的通用寄存器$R_5$代替，保存下一条指令的地址。</li><li>指令地址寄存器$IP$由运算器中的$R_6$代替。</li><li>控存字长56位，已实现的53条指令的微程序存放在2片单独的8位$ROM$中，加电的过程自动调入控存（装入微码）。</li><li>地址总线的输入信号仅有一组，即地址寄存器（$AR$），而<strong>AR只能接收来自运算器的结果输出信号</strong>。</li></ul><h3 id="AM2910"><a href="#AM2910" class="headerlink" title="$AM2910$"></a>$AM2910$</h3><p>$AM2910$，微程序定序器，<strong>作用：形成下一条微指令的地址</strong>。</p><h4 id="三个输出使能信号"><a href="#三个输出使能信号" class="headerlink" title="三个输出使能信号"></a>三个输出使能信号</h4><p><strong>作用：决定直接输入D的来源</strong></p><ul><li><p>$\bar{MAP}$</p><p>  当其有效时，$D$来源于$MAPROM$，用于实现从机器指令到相应的微程序段的转移。</p></li><li><p>$\bar{VECT}$</p><p>  当其有效时，原意为$D$来源于中断向量，现用于接收手拨微地址。</p></li><li><p>$\bar{PL}$</p><p>  当其有效时，$D$来源于微指令的下地址字段，用于实现微程序转移。</p></li></ul><h4 id="引脚定义"><a href="#引脚定义" class="headerlink" title="引脚定义"></a>引脚定义</h4><ul><li><p>$\bar{CC}$</p><p>  条件测试，当其为低电平时，测试成功，转移（使用下址字段）；否则，顺序执行。</p></li><li><p>$\bar{OE}$</p><p>  Y输出允许信号，低电平有效，已接地</p></li><li><p>$\bar{CCEN}$</p><p>  $\bar{CC}$允许信号，已接地</p></li></ul><h4 id="16条命令"><a href="#16条命令" class="headerlink" title="16条命令"></a>16条命令</h4><ul><li><p>2号命令</p><p>  指令功能分支，无条件转$MAP$</p></li><li><p>3号命令</p><p>  条件转移，条件测试$\bar{CC}$为1时顺序执行，否则按下地址$D$转移。</p></li><li><p>14号命令</p><p>  顺序执行下一条微指令</p></li></ul><h2 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h2><h3 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h3><p>每位的用处已在EXCEL表格中说明。</p><ul><li><p>$DC1$和$DC2$</p><p>  关于这两个控制位我还有两个问题</p><ul><li><p>$DC2$为​$2$时</p><p>  写$AR$时应把$DC2$设为2，即$AR$接收来自$IB$的数据；但$DC1$课本上都是设为0，即微型开关送$IB$。</p><p>  这样不就是把微型开关送到了$AR$嘛？这不太对啊！？以下是我的猜测：</p><p>  我猜在这里$DC1$应该是任意的。因为$AR$只能接收运算器的输出，所以当$DC2$设置为写$AR$时，就忽略$DC1$的设置，硬件应该可以实现。</p></li><li><p>$DC2$为​$0$时</p><p>  此时代表$NC$，即无寄存器接收$IB$的数据，所以此时$DC1$应该也是任意，书上写的是0。</p></li></ul></li><li><p>$SSH$</p></li></ul><h3 id="常用微指令"><a href="#常用微指令" class="headerlink" title="常用微指令"></a>常用微指令</h3><ul><li><p>19H</p><p>  取指令，$PC$增量。</p><p>  该条微指令公用于所有指令。</p></li><li><p>1AH</p><p>  按新取来的指令的操作码找到该条指令本身的微程序段的入口地址。</p><p>  19H之后一定是1AH。</p></li><li><p>A4H</p><p>  根据有无中断请求，决定是进入中断处理过程，还是顺序执行。</p><p>  任何一条机器指令执行完都要去A4H检测中断</p></li></ul><h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><p>以第一条指令为例</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol><li><p>$S_2S_1S_0$</p><p> 设为<code>100</code></p></li><li><p>$FS_1FS_2FS_3FS_4$</p><p> 设为<code>1010</code></p></li><li><p>$STEP/CONT$</p><p> 设为<code>CONT</code></p></li></ol><h3 id="输入并查看微码"><a href="#输入并查看微码" class="headerlink" title="输入并查看微码"></a>输入并查看微码</h3><ol><li><p><code>E900</code></p><p> 将微码输入到<code>900H</code>开始的内存单元中</p></li><li><p><code>D900</code></p><p> 查看内存</p></li></ol><h3 id="将微码加载到微控存"><a href="#将微码加载到微控存" class="headerlink" title="将微码加载到微控存"></a>将微码加载到微控存</h3><ol><li><p><code>A800</code></p><p> 输入加载微码的程序</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0800: MOV R1,900; 900是微码在内存中地址</span><br><span class="line">0802: MOV R2,7; 共7条微指令</span><br><span class="line">0804: MOV R3,110; 微码在微控存中的首地址</span><br><span class="line">0806: LDMC;加载微码</span><br><span class="line">0807: RET</span><br></pre></td></tr></table></figure></li><li><p><code>G800</code></p><p> 运行上边的代码，把微码装入微控存<code>110H</code>开始的单元中</p></li></ol><h3 id="测试指令"><a href="#测试指令" class="headerlink" title="测试指令"></a>测试指令</h3><ol><li><p><code>A820</code></p><p> 输入测试指令的程序到<code>820H</code>开始的内存单元中</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0820: MOV R0,0045</span><br><span class="line">0822: MOV [A00],R0; [A00]单元存储45H</span><br><span class="line">0824: MOV R1,0023</span><br><span class="line">0826: MOV [A01],R1; [A01]单元存储23H</span><br><span class="line">0828: NOP; 占一个字</span><br><span class="line">0829: NOP</span><br><span class="line">082A: NOP</span><br><span class="line">082B: RET</span><br></pre></td></tr></table></figure></li><li><p><code>E826</code></p><p> 把新指令写到<code>826H</code>开始的内存单元</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0828    0000:D800  0000:0A00  0000:0A01</span><br></pre></td></tr></table></figure></li><li><p><code>U820</code></p><p> 反汇编，查看我们输入的测试指令的程序</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0820: 2C00 0045  MOV    R0,     0045</span><br><span class="line">0822: 3400 0A00  MOV    [0A00], R0</span><br><span class="line">0824: 2C10 0023  MOV    R1,     0023</span><br><span class="line">0826: 3401 0A01  MOV    [0A01], R1</span><br><span class="line">0828: D800       DW     D800</span><br><span class="line">0829: 0A00       ADC    R0,     R0; 高8位为000010XX，对应指令为ADC，实际上是我们自己设计的指令</span><br><span class="line">082A: 0A01       ADC    R0,     R1</span><br><span class="line">082B: AC00       RET</span><br></pre></td></tr></table></figure></li><li><p><code>G820</code></p><p> 运行从<code>820H</code>开始的程序</p></li></ol><h3 id="观察运算结果"><a href="#观察运算结果" class="headerlink" title="观察运算结果"></a>观察运算结果</h3><p><code>DA00</code></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目的与要求&quot;&gt;&lt;a href=&quot;#目的与要求&quot; class=&quot;headerlink&quot; title=&quot;目的与要求&quot;&gt;&lt;/a&gt;目的与要求&lt;/h1&gt;&lt;p&gt;​    深入了解计算机各种指令的执行过程，以及控制器的组成，指令系统微程序设计的具体知识，进一步理解和掌握动态微程
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第七章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第七章复习/</id>
    <published>2019-06-28T13:38:07.000Z</published>
    <updated>2019-06-28T13:39:39.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三层次存储系统"><a href="#三层次存储系统" class="headerlink" title="三层次存储系统"></a>三层次存储系统</h1><p>三层次存储系统指<strong>CACHE-主存-辅存</strong>存储系统。</p><p>目的：解决<strong>高速度、大容量和低成本</strong>间的矛盾。</p><h2 id="主存-辅存层次"><a href="#主存-辅存层次" class="headerlink" title="主存-辅存层次"></a>主存-辅存层次</h2><p>解决<strong>容量和成本</strong>间的矛盾。</p><h2 id="CACHE-主存层次"><a href="#CACHE-主存层次" class="headerlink" title="CACHE-主存层次"></a>CACHE-主存层次</h2><p>解决<strong>速度和成本</strong>间的矛盾。</p><h1 id="CACHE工作原理"><a href="#CACHE工作原理" class="headerlink" title="CACHE工作原理"></a>CACHE工作原理</h1><p>工作原理也就是层次存储系统能发挥效用的原因，如下：</p><p>根据程序访问的局部性，如果当前正在执行的程序和数据存放在CACHE中，当程序运行时，不必从主存储器取指令和数据，访问CACHE即可。</p><p><strong>程序访问的局部性</strong>：</p><p>在一个较短的时间间隔内，程序访问的地址（程序、指令的地址和数据的地址）往往集中制存储器逻辑地址空间的很小范围内。</p><h1 id="三种地址映像方式"><a href="#三种地址映像方式" class="headerlink" title="三种地址映像方式"></a>三种地址映像方式</h1><p>地址映像：主存地址映像到Cache</p><h2 id="直接映像"><a href="#直接映像" class="headerlink" title="直接映像"></a>直接映像</h2><ul><li><p><strong>优点</strong></p><p>  实现简单，只需利用主存地址按某些字段直接判断，即可确定所需字块是否已在cache中</p></li><li><p><strong>缺点</strong></p><p>  不够灵活，不能用替换算法</p></li></ul><h2 id="全相联映像"><a href="#全相联映像" class="headerlink" title="全相联映像"></a>全相联映像</h2><ul><li><p><strong>优点</strong></p><p>  最灵活，可以使用任何替换算法，理论上命中率高</p></li><li><p><strong>缺点</strong></p><p>  成本最高，每个Cache块都要用一个运算器</p></li></ul><h2 id="组相联映像"><a href="#组相联映像" class="headerlink" title="组相联映像"></a>组相联映像</h2><p><strong>组间直接映像，组内全相联映像</strong>。</p><ul><li><p><strong>优缺点</strong></p><p>  是直接映像和全相联映像的折衷方案，性能处于前两种之间。</p></li></ul><h1 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h1><h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>把最先调入cache的字块替换出去</p><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>把近期最少使用的字块替换出去。</p><p>这需要一张表来记录cache中各字块的使用情况，把最近使用的字块放到表的最上边，其他的向下顺移。</p><h1 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h1><p>虚拟存储器拥有辅存的容量，接近主存的速度和辅存的单位成本。</p><h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><p>利用程序的模块化形状，把主存按段分配</p><ul><li>优点<ul><li>段的分界和程序的自然分界相对应</li><li>段的逻辑独立性使它易于编译、管理、修改和保护，也易于重复调用。</li></ul></li><li>缺点<ul><li>容易在段间留下许多零碎的存储空间，造成空间浪费。</li></ul></li></ul><h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>主存物理空间被划分为<strong>等长</strong>的页</p><ul><li><p>优点</p><p>  与段式管理相比，空间浪费要小得多</p></li><li><p>缺点</p><p>  处理、保护和共享都不如段式来得方便</p></li></ul><h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><p>程序按模块分段，<strong>段内再分页</strong>，<strong>出入内存仍以页为单位</strong>，用段表和页表进行两级管理（每段一个页表）</p><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><p>虚地址高位字段为虚页号，低位字段为页内字地址。</p><p>假设页表保存在内存中，那么访问存储器时首先要查页表（需要访问主存），得到实地址后，再次访问主存才能完成读写操作，这样相当于<strong>主存速度降低了一半</strong>。</p><p><strong>解决办法</strong>：使用快慢表，快表是慢表（主存中的页表）的小小的副本。</p><p>查表时，用虚页号同时去查快表和慢表，如果在快表中找到，就将对应的实页号送入实主存地址寄存器，并使慢表的查找作废；找不到时，就要花费一个访问主存时间查慢表，从中查到实页号送入实存地址寄存器，并将此虚页号和对应的实页号送入快表，替换快表中某一行内容（这也使用替换算法）。</p><h2 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h2><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三层次存储系统&quot;&gt;&lt;a href=&quot;#三层次存储系统&quot; class=&quot;headerlink&quot; title=&quot;三层次存储系统&quot;&gt;&lt;/a&gt;三层次存储系统&lt;/h1&gt;&lt;p&gt;三层次存储系统指&lt;strong&gt;CACHE-主存-辅存&lt;/strong&gt;存储系统。&lt;/p&gt;
&lt;p&gt;目
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第六章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第六章复习/</id>
    <published>2019-06-28T13:38:01.000Z</published>
    <updated>2019-06-28T13:39:31.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="控制器作用"><a href="#控制器作用" class="headerlink" title="控制器作用"></a>控制器作用</h1><ul><li><p>控制程序的执行</p><p>  即协调并控制计算机各部件执行程序的指令序列。</p></li></ul><h1 id="控制器功能"><a href="#控制器功能" class="headerlink" title="控制器功能"></a>控制器功能</h1><ul><li><p><strong>取指令</strong></p></li><li><p><strong>分析指令</strong></p><p>  又叫指令译码。</p></li><li><p><strong>执行指令</strong></p></li><li><p>控制程序和数据的输入与结果输出</p></li><li><p>对异常情况和某些请求的处理</p></li></ul><h1 id="控制器组成"><a href="#控制器组成" class="headerlink" title="控制器组成"></a>控制器组成</h1><h2 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h2><p>程序计数器/指令地址寄存器，存放当前指令或下一条指令的地址（TEC-2中PC存储下一条指令的地址）。</p><ul><li><p>在一条无条件跳转指令的指令周期内，PC的值被修改<strong>2</strong>次。</p><p>  取指令周期结束后，PC值自动加1；执行周期中，PC值修改为要跳转到的地址，故在这个指令周期内，PC值被修改两次。</p></li><li><p>程序计数器（PC）的位数取决于<strong>主存的容量</strong>。</p><p>  程序计数器的内容为指令在主存中的地址，所以程序计数器的位数与主存地址的位数相等，而主存地址位数取决于主存的容量。</p></li><li><p>指令周期、间址周期</p></li></ul><h2 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h2><p>指令寄存器，存放当前正在执行的指令</p><ul><li><p>指令寄存器（IR）的位数取决于指令字长</p><p>  指令寄存器的内容为正在执行的指令，所以位数取决于指令字长。</p></li><li><p>CPU中的通用寄存器不能替代指令寄存器（IR）</p><p>  指令寄存器是专门用于存放指令的专用寄存器，不能由通用寄存器替代。</p></li></ul><h2 id="指令译码器"><a href="#指令译码器" class="headerlink" title="指令译码器"></a>指令译码器</h2><p>又叫操作码译码器，对指令寄存器中的操作码进行分析解释。</p><h2 id="脉冲源及启停电路"><a href="#脉冲源及启停电路" class="headerlink" title="脉冲源及启停电路"></a>脉冲源及启停电路</h2><ul><li><p>脉冲源</p><p>  产生一定频率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号；</p><p>  另外在开机时产生<code>reset</code>信号</p></li><li><p>启停电路</p><p>  保证可靠地送出或封锁完整的时钟脉冲，控制时序信号的发生和停止</p></li></ul><h2 id="时序控制信号形成部件"><a href="#时序控制信号形成部件" class="headerlink" title="时序控制信号形成部件"></a>时序控制信号形成部件</h2><p>形成并调整时序。</p><p>产生控制信号一般有两种方法：</p><h3 id="微程序控制方式"><a href="#微程序控制方式" class="headerlink" title="微程序控制方式"></a>微程序控制方式</h3><h3 id="硬布线控制方式"><a href="#硬布线控制方式" class="headerlink" title="硬布线控制方式"></a>硬布线控制方式</h3><h1 id="几个周期"><a href="#几个周期" class="headerlink" title="几个周期"></a>几个周期</h1><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p><strong>从取指令开始到其执行完成所经过的时间</strong>。</p><p>一个指令周期包含若干个时钟周期。</p><h2 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h2><p>通常称为节拍脉冲或T周期。</p><p><strong>时钟周期</strong>是计算机中最基本的、<strong>最小的时间单位</strong>。</p><h1 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h1><p>结合课后习题6.1食用。</p><ul><li><p>MAR主存地址寄存器；MDR主存数据寄存器；AC累加寄存器，简称累加器。</p></li><li><p>主存与CPU之间的连线有地址总线和数据总线。</p></li><li><p>地址总线的信息仅从CPU传送到主存MAR，数据总线则允许双向传送（CPU和MDR）。</p></li><li><p>指令从主存取出到产生控制信号的数据通路</p><p>  指令地址从PC经地址总线送到MAR，数据从主存经数据总线送到IR。</p></li><li><p>数据在运算器和主存直接进行读/写的数据通路</p><p>  读写地址由IR中指令的地址字段经地址总线送主存MAR；读时数据从主存经数据总线送到MDR，然后送ALU，然后送AC；写时数据从AC送MDR，再送主存。</p></li></ul><h1 id="微程序控制的基本概念"><a href="#微程序控制的基本概念" class="headerlink" title="微程序控制的基本概念"></a>微程序控制的基本概念</h1><p>把机器指令拆分成微指令，再把微指令拆分成微操作。</p><h2 id="微指令"><a href="#微指令" class="headerlink" title="微指令"></a>微指令</h2><p>把机器指令拆分成微指令。</p><p>机器指令与微指令的关系：用微指令解释机器指令</p><p>微指令长度一般要比机器指令长得多。</p><h2 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h2><p><strong>一个微指令中</strong>，由<strong>同时发出的控制信号</strong>所执行的各个操作称为<strong>微操作</strong>。</p><h2 id="微命令"><a href="#微命令" class="headerlink" title="微命令"></a>微命令</h2><p>微命令和微操作一一对应。</p><p>微命令是微操作的控制信号，微操作是微命令的执行过程。</p><h2 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h2><p>微指令序列。</p><h2 id="控制存储器"><a href="#控制存储器" class="headerlink" title="控制存储器"></a>控制存储器</h2><p>用来存放微程序，其<strong>容量取决于实现指令系统所需的微程序长度</strong>（或者说<strong>其容量取决于微指令的条数</strong>）。</p><h1 id="AM2910"><a href="#AM2910" class="headerlink" title="$AM2910$"></a>$AM2910$</h1><p>微程序定序器</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><strong>形成下一条微指令的地址</strong></p><h2 id="三个输出使能信号"><a href="#三个输出使能信号" class="headerlink" title="三个输出使能信号"></a>三个输出使能信号</h2><p><strong>作用：决定直接输入D的来源</strong></p><ul><li><p>$\bar{MAP}$</p><p>  当其有效时，$D$来源于$MAPROM$，用于实现从机器指令到相应的微程序段的转移。</p></li><li><p>$\bar{VECT}$</p><p>  当其有效时，原意为$D$来源于中断向量，现用于接收手拨微地址。</p></li><li><p>$\bar{PL}$</p><p>  当其有效时，$D$来源于微指令的下地址字段，用于实现微程序转移。</p></li></ul><h4 id="16条命令"><a href="#16条命令" class="headerlink" title="16条命令"></a>16条命令</h4><ul><li><p>2号命令</p><p>  指令功能分支，无条件转$MAP$，此时$\bar{MAP}为0$，根据指令的操作码形成用来解释执行该机器指令的微程序的入口地址</p></li><li><p>3号命令</p><p>  条件转移，条件测试$\bar{CC}$为1时顺序执行，否则按下地址$D$转移。</p></li><li><p>14号命令</p><p>  顺序执行下一条微指令</p></li></ul><h1 id="CPU如何区分指令和数据"><a href="#CPU如何区分指令和数据" class="headerlink" title="CPU如何区分指令和数据"></a>CPU如何区分指令和数据</h1><p>可以从时间和空间上来区分</p><p>取指令周期中从内存中读出的信息流是指令流，它流向控制器；</p><p>执行指令周期中从内存读出或送入内存的信息流是数据流，它由内存流向运算器或由运算器流向内存。</p><h1 id="微程序控制的基本工作原理"><a href="#微程序控制的基本工作原理" class="headerlink" title="微程序控制的基本工作原理"></a>微程序控制的基本工作原理</h1><p>机器指令取入<code>IR</code>后，对操作码进行译码，得到相应指令的第一条微指令的地址。</p><ul><li><p><code>MAPROM</code></p><p>  指令译码器可用只读存储器组成，将操作码作为<code>MAPROM</code>的地址输入，该单元的内容即相应指令第一条微指令的地址，之后由微指令的下址字段指出下一条微指令的地址。</p><p>  根据微指令地址从控制存储器中取出微指令，并将它存放在微指令寄存器中。控制字段各位直接与受控门相连，由此生成控制信号。</p></li></ul><h1 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h1><h2 id="水平型微指令"><a href="#水平型微指令" class="headerlink" title="水平型微指令"></a>水平型微指令</h2><p>在一条微指令中定义并执行多个<strong>并行</strong>微命令，所以速度比垂直型微指令快。</p><p>直接控制法、字段编译法经常应用在同一条水平型微指令中。</p><h2 id="垂直型微指令"><a href="#垂直型微指令" class="headerlink" title="垂直型微指令"></a>垂直型微指令</h2><p>在微指令中设置有微操作码字段，由其规定微指令的功能。</p><p>不强调微指令的并行控制功能</p><h2 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h2><p>从实现原理和性能两个方面比较。</p><ol><li>水平型微指令并行操作能力强，效率高，灵活性强</li><li>水平型微指令实现一条机器指令的执行时间短</li><li>水平型微指令字长较长，但微程序短</li><li>水平型微指令用户难以掌握</li></ol><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;控制器作用&quot;&gt;&lt;a href=&quot;#控制器作用&quot; class=&quot;headerlink&quot; title=&quot;控制器作用&quot;&gt;&lt;/a&gt;控制器作用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;控制程序的执行&lt;/p&gt;
&lt;p&gt;  即协调并控制计算机各部件执行程序的指令序列。&lt;/p&gt;
&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第四章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第四章复习/</id>
    <published>2019-06-28T13:37:54.000Z</published>
    <updated>2019-06-28T13:39:23.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h1><h2 id="按在计算机中的作用（层次）分类"><a href="#按在计算机中的作用（层次）分类" class="headerlink" title="按在计算机中的作用（层次）分类"></a>按在计算机中的作用（层次）分类</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>简称主存，又称内存储器（内存）。</p><p>CPU可直接随机对其进行访问，也可以和Cache交换数据。</p><p>特点：容量较小、存取速度较快、单位价格较高。</p><h3 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h3><p>简称辅存，又称外存储器（外存）。</p><p><strong>不能</strong>与CPU直接交换信息。</p><p>特点：容量极大、存取速度较慢、单位成本低。</p><h3 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h3><p>简称Cache，位于主存和CPU之间。</p><p>特点：存储容量小、价格高。</p><h2 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h2><h3 id="磁表面存储器"><a href="#磁表面存储器" class="headerlink" title="磁表面存储器"></a>磁表面存储器</h3><p>比如磁盘、磁带。</p><h3 id="磁心存储器"><a href="#磁心存储器" class="headerlink" title="磁心存储器"></a>磁心存储器</h3><h3 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h3><h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>集成度低，功耗高，速度快</p><h4 id="MOS"><a href="#MOS" class="headerlink" title="MOS"></a>MOS</h4><p>集成度高，功耗低，速度慢。</p><p>所以现在内存主要用的MOS型存储器。</p><h3 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h3><p>比如光盘。</p><h2 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h2><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>随机读写存储器。存取时间与存储单元物理地址无关。</p><p>优点：读写方便、使用灵活，断电后内容丢失。</p><p>主要用作主存或Cache。</p><h4 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h4><p>以触发器原理寄存信息。</p><h4 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h4><p>以电容充电原理寄存信息。</p><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>只读存储器。（Read Only）</p><p>只能<strong>随机读出</strong>而不能写入，断电后内容不会丢失。</p><p>可与RAM共同作为主存的一部分。</p><h3 id="串行访问存储器"><a href="#串行访问存储器" class="headerlink" title="串行访问存储器"></a>串行访问存储器</h3><p>读写时，需按其物理位置的先后顺序寻址。</p><h4 id="顺序存取存储器"><a href="#顺序存取存储器" class="headerlink" title="顺序存取存储器"></a>顺序存取存储器</h4><p>如磁带。</p><p>特点：只能按某种顺序存取，存取速度慢。</p><h4 id="直接存取存储器"><a href="#直接存取存储器" class="headerlink" title="直接存取存储器"></a>直接存取存储器</h4><p>如磁盘。</p><p>存取方式介于RAM和顺序存取存储器，通常先寻找整个存储器中的某个区域（如磁盘上的磁道），再在小区域内顺序查找。</p><h2 id="按信息可保存性分类"><a href="#按信息可保存性分类" class="headerlink" title="按信息可保存性分类"></a>按信息可保存性分类</h2><h3 id="易失性存储器"><a href="#易失性存储器" class="headerlink" title="易失性存储器"></a>易失性存储器</h3><p>断电内容丢失，如RAM。</p><h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><p>断电内容不丢失，如ROM、磁表面存储器和光存储器。</p><p>又可分为</p><p>E代表可擦写（Erase），P代表可编程（Programming）</p><ul><li>$ROM$</li><li>$PROM$</li><li>$EPROM$</li><li>$E^2PROM$，多出来的这个E代表电（Electric）</li><li>$Flash\ Memory$</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><p>CD-ROM是只读型<strong>光盘</strong>存储器。</p></li><li><p>磁盘是<strong>直接存取存储器</strong>。</p></li><li><p>相联存储器是按<strong>内容指定方式</strong>和<strong>地址指定方式</strong>相结合进行寻址的寄存器。</p><p>  相联存储器的基本原理：把存储单元的一部分内容作为检索项去检索存储器，并将存储器中与该检索项符合的存储单元内容进行读或写。</p></li><li><p>若OS在硬盘上，则内存储器应用RAM和ROM。</p><p>  需将外存中的OS（部分）引导进内存，而引导程序通常用ROM存放。</p><p>  另外ROM还经常存放操作系统等需要频繁使用，尤其是停电后不允许丢失的程序或数据。</p></li></ul><h1 id="RAM-1"><a href="#RAM-1" class="headerlink" title="RAM"></a>RAM</h1><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><p>6管结构。TTL</p><p>读出时，根据两条位线中哪一条有负脉冲来判断触发器的状态。</p><p>写入时，根据两条位线电平来写入1或0。</p><h2 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h2><p>MOS电容</p><ul><li><p>DRAM采用地址复用策略（地址时分复用）。</p><p>  目的：使DRAM芯片的地址管脚减少一半，从而减小器件尺寸。</p></li></ul><h3 id="刷新（再生）"><a href="#刷新（再生）" class="headerlink" title="刷新（再生）"></a>刷新（再生）</h3><p>DRAM通过读出方式实现再生，读出放大器作为一个再生放大器。</p><p>DRAM刷新的单位是行，每列都有自己的读放。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li><p>破坏性读出：某个存储单元被读出时，原存储信息被破坏。</p><p>  破坏性读出的存储器，每次读出后，必须紧接一个再生的操作，以恢复被破坏的信息。</p></li><li><p>另外由于电容漏电阻的存在，也需要进行再生。</p></li></ul><h4 id="常见方式"><a href="#常见方式" class="headerlink" title="常见方式"></a>常见方式</h4><ul><li><p>集中刷新</p><p>  在一个刷新周期内，利用一段固定时，依次对存储器所有行进行刷新，在此期间停止对存储器的读写操作，成为访存“<strong>死区</strong>”。</p></li><li><p>分散刷新</p><p>  把对每行的刷新分散到各个工作周期内，增加了存储周期，但没有死区。</p></li><li><p>分布式刷新（异步刷新）</p><p>  介于集中刷新和分散刷新。</p></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>六个方面：集成度、速度、功耗、价格、容量、原理、刷新</p><ul><li>DRAM价格便宜（因此一般容量大，用作内存；而SRAM则用作Cache），集成度高，功耗低；但速度慢，还需要时间和电路进行再生（刷新）。</li><li>SRAM利用触发器保存信息，DRAM利用电容存储电荷保存信息。</li><li>DRAM需要刷新，SRAM不用刷新。</li><li>DRAM采用地址复用策略，SRAM不采用。</li></ul><h1 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h1><p>主要有3个性能指标，三者相互制约。</p><p>目标：大容量、低成本和高速度。</p><h2 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h2><p>存储字数$\times$字长，如1M$\times$8位。</p><h2 id="单位成本"><a href="#单位成本" class="headerlink" title="单位成本"></a>单位成本</h2><p>总成本/总容量。</p><h2 id="存储速度"><a href="#存储速度" class="headerlink" title="存储速度"></a>存储速度</h2><h3 id="存取时间"><a href="#存取时间" class="headerlink" title="存取时间"></a>存取时间</h3><p>完成一次存储器操作的时间，分为读取时间和写入时间。</p><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><p>又称读写周期或访问周期。连续两次操作存储器之间的最小时间间隔。</p><p>通常存取周期大于存取时间，因为它多了个复原时间。</p><p>复原时间：</p><ul><li><p>SRAM</p><p>  存取信息的稳定时间。</p></li><li><p>DRAM</p><p>  刷新的又一次存取时间，刷新是通过读出实现的。</p></li></ul><p>对于破坏性读出的存储器，存取周期往往比存取时间大得多。</p><h3 id="主存带宽"><a href="#主存带宽" class="headerlink" title="主存带宽"></a>主存带宽</h3><p>又称数据传输率，每秒从主存进出信息的最大数量。</p><h1 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h1><p>读写控制线可以是一根（$\bar{WE}$），也可以是两根（$\bar{WE}$和$\bar{RD}$）。</p><p>字扩展、位扩展和字位扩展是重点（两种操作，如何画图），看PPT上作业及答案。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><div class="table-container"><table><thead><tr><th style="text-align:center">顺序</th><th style="text-align:center">位扩展</th><th style="text-align:center">字扩展</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">地址线与各芯片并联，CPU$\bar{WE}$与各芯片$\bar{WE}$并联</td><td style="text-align:center">低位地址线与各芯片并联，CPU$\bar{WE}$与各芯片$\bar{WE}$并联</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">各芯片$\bar{CS}$并联接地</td><td style="text-align:center">高位地址经译码器各输出分别连接各芯片$\bar{CS}$</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">各芯片数据引到数据线（算是串行）</td><td style="text-align:center">各芯片数据引到数据线（算是并行）</td></tr></tbody></table></div><p>四个要素：$\bar{WE}$、$\bar{CS}$、地址线、数据线</p><h1 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h1><ul><li><p>解决的主要问题是<strong>提高主存储器的数据传输率</strong></p></li><li><p>采用低位交叉编址方式</p><p>  低位地址选择不同的存储模块，高位地址指向相应的模块内部的存储字。因此，连续的地址分部在相邻的不同模块中。</p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储器分类&quot;&gt;&lt;a href=&quot;#存储器分类&quot; class=&quot;headerlink&quot; title=&quot;存储器分类&quot;&gt;&lt;/a&gt;存储器分类&lt;/h1&gt;&lt;h2 id=&quot;按在计算机中的作用（层次）分类&quot;&gt;&lt;a href=&quot;#按在计算机中的作用（层次）分类&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第三章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第三章复习/</id>
    <published>2019-06-28T13:37:48.000Z</published>
    <updated>2019-06-28T13:39:12.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h2 id="2进制转8进制"><a href="#2进制转8进制" class="headerlink" title="2进制转8进制"></a>2进制转8进制</h2><p>从小数点开始向左向右，3个一组换算成8进制，缺位补0。</p><p>如例3.4</p><h2 id="8进制转2进制"><a href="#8进制转2进制" class="headerlink" title="8进制转2进制"></a>8进制转2进制</h2><p>将一位8进制数换算成3位2进制数。</p><p>如例3.6</p><h2 id="2进制转16进制"><a href="#2进制转16进制" class="headerlink" title="2进制转16进制"></a>2进制转16进制</h2><p>从小数点开始向左向右，4个一组换算成16进制，缺位补0。</p><h2 id="16进制转2进制"><a href="#16进制转2进制" class="headerlink" title="16进制转2进制"></a>16进制转2进制</h2><p>将一位16进制数换算成4位2进制数。</p><h2 id="8进制转16进制-拓展"><a href="#8进制转16进制-拓展" class="headerlink" title="8进制转16进制(拓展)"></a>8进制转16进制(拓展)</h2><p>从小数点开始向左向右，<strong>2</strong>个一组换算成16进制，缺位补0。可以先变成2进制，再变成16进制。</p><p>如表3.1</p><h2 id="2进制转10进制"><a href="#2进制转10进制" class="headerlink" title="2进制转10进制"></a>2进制转10进制</h2><p>每位2进制数乘以它的权重，再求和。8421</p><p>如例3.1</p><h2 id="10进制转2进制"><a href="#10进制转2进制" class="headerlink" title="10进制转2进制"></a>10进制转2进制</h2><h3 id="整数部分"><a href="#整数部分" class="headerlink" title="整数部分"></a>整数部分</h3><p><strong>除2取余至商为0</strong>，先求出来的余数靠近小数点（低位）。</p><p>如例3.7</p><h3 id="小数部分"><a href="#小数部分" class="headerlink" title="小数部分"></a>小数部分</h3><p><strong>小数部分</strong> <strong>乘2取整至小数部分为0</strong>或满足精度要求，先求出来的整数靠近小数点（高位）。</p><p>如例3.8</p><h1 id="机器数的表示"><a href="#机器数的表示" class="headerlink" title="机器数的表示"></a>机器数的表示</h1><ul><li>机器数有三种表示方式：原码、反码和补码。</li></ul><p>我们先假设机器数为小数，符号为放在最左边，小数点置于符号位和数值之间。</p><h2 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h2><ul><li>即<code>±绝对值</code>，用$X$表示，正号有时可省略。</li></ul><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><ul><li>最高位为符号位，0表示正数，1表示负数，绝对值跟随其后。</li><li>小数点的位置默认在符号位之后，书写时可以将小数点保留或省略。</li></ul><p>0的原码有两种表示形式：</p><ul><li>$[+0]_原=00000=0.0000$</li><li>$[-0]_原=10000=1.0000$</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><ul><li>正数的补码与其原码一样</li><li>补码零的表示形式唯一：$[+0]_补=[-0]_补=00000=0.0000$</li></ul><h3 id="负数原码补码互求"><a href="#负数原码补码互求" class="headerlink" title="负数原码补码互求"></a>负数原码补码互求</h3><ol><li>符号位不变</li><li>数据位按位取反</li><li>末位+1</li></ol><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>若加法运算不超过机器范围时：</p><ul><li><p>加法结果仍为补码</p></li><li><p>$[X+Y]_补=[X]_补+[Y]_补$</p><p>  $[X-Y]_补=[X]_补+[-Y]_补$</p></li><li><p><strong>符号位也参与运算</strong></p></li></ul><h3 id="由-Y-补-求-Y-补"><a href="#由-Y-补-求-Y-补" class="headerlink" title="由$[Y]_补$求$[-Y]_补$"></a>由$[Y]_补$求$[-Y]_补$</h3><ol><li>$[Y]_补$<strong>所有位</strong>取反</li><li>末位+1</li></ol><h3 id="证明-X-Y-补-X-补-Y-补"><a href="#证明-X-Y-补-X-补-Y-补" class="headerlink" title="证明$[X+Y]_补=[X]_补+[Y]_补$"></a>证明$[X+Y]_补=[X]_补+[Y]_补$</h3><p>补码定义：</p><script type="math/tex; mode=display">[X]_补=\begin{cases}         X,0\leq X<1\\2+X,-1\leq X<0\end{cases}</script><ol><li><p>$X&gt;0,Y&gt;0$</p><p>可知$X+Y&gt;0$，所以$[X+Y]_补=X+Y=X_补+Y_补$。</p></li><li><p>$X&gt;0,Y&lt;0$</p><p> $[X]_补=X$</p><p> $[Y]_补=2+Y$</p><p> $[X+Y]_补=X+Y=X_补+Y_补$</p></li><li><p>==待续==</p></li></ol><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><ul><li>正数的反码与其原码一样</li></ul><h3 id="负数原码反码互求"><a href="#负数原码反码互求" class="headerlink" title="负数原码反码互求"></a>负数原码反码互求</h3><ol><li>符号位不变</li><li>数据位按位取反</li></ol><h1 id="加减法运算的溢出判断"><a href="#加减法运算的溢出判断" class="headerlink" title="加减法运算的溢出判断"></a>加减法运算的溢出判断</h1><p>有进位$\neq$溢出</p><p>只有两个同号数相加或两个异号数相减，才有可能溢出。</p><p>定点运算器中，无论双符号位还是单符号位，必须有<strong>溢出判断电路</strong>，它一般由<strong>异或门</strong>来实现。</p><p>以下为三种方法（双符号位法较重要）：</p><ul><li><p>当符号相同的两数相加时，结果的符号与加数或被加数不相同，则为溢出。</p></li><li><p>当任意符号两数相加时，如果$C\neq C_f$，则为溢出，即溢出条件为$C\bigoplus C_f$，其中$C$为数值最高位的进位，$C_f$为符号位的进位。</p></li><li><p>采用<strong>双符号位</strong>$f_{S2}f_{S1}$，正数双符号位为00，负数双符号位为11。</p><p>  两个符号位都参与运算，如果结果$f_{S1}\neq f_{S2}$，则为溢出，即溢出条件为$f_{S1}\bigoplus f_{S2}$。</p><p>  若采用双符号位，运算结果的符号位为高符号位$f_{S2}$。</p></li></ul><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p>浮点数指小数点位置可浮动的数据，通常以下式表示：</p><script type="math/tex; mode=display">N=M\times R^E</script><ul><li><p>$N$</p><p>  浮点数</p></li><li><p>$M$</p><p>  尾数，mantissa</p></li><li><p>$E$</p><p>  阶码，exponent（幂）</p></li><li><p>$R$</p><p>  阶的基数，radix（进制、基数），$R$为一常数，在一台计算机中，所有数据的$R$都是相同的，不需要在每个数据中表示出来。</p></li></ul><p>浮点数的机内表示一般采用以下形式</p><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">$M_S$</th><th style="text-align:center">$E$</th><th style="text-align:center">$M$</th></tr></thead><tbody><tr><td style="text-align:center">位数</td><td style="text-align:center">1</td><td style="text-align:center">$n+1$</td><td style="text-align:center">$m$</td></tr><tr><td style="text-align:center">说明</td><td style="text-align:center">尾数的符号位</td><td style="text-align:center">阶码，<strong>其中最高位为符号位</strong>，表示正阶或负阶</td><td style="text-align:center">尾数</td></tr></tbody></table></div><h2 id="尾数规格化"><a href="#尾数规格化" class="headerlink" title="尾数规格化"></a>尾数规格化</h2><ul><li><p>定义</p><p>  <strong>为了保证（极高）数据精度</strong>，尾数通常用规格化形式表示：当$R=2$，且尾数值不为0时，尾数绝对值应$\geq(0.5)_{10}$。</p></li><li><p>方法</p><p>  对非规格化浮点数，通过将尾数左移或右移，并修改阶码值使之满足规格化要求。</p><p>  尾数左移几位，阶码也减少几；尾数右移几，阶码就增加几。</p></li><li><p>机器零</p><p>  当一个浮点数的尾数为0或阶码的值比在机器中表示的最小值还小时，计算机都把该浮点数看成零值，称为<strong>机器零</strong>。</p></li></ul><p>在多数通用机中，浮点数的<strong>尾数</strong>用<strong>原码或补码</strong>表示，<strong>阶码</strong>用<strong>补码</strong>或<strong>移码</strong>表示。</p><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><ul><li>$[X]_补$符号位取反后即为$[X]_移$。</li><li>计算机中，<strong>移码</strong>（阶码）只进行<strong>加减法运算</strong>，且需要对得到的结果进行修正，即<strong>对结果的符号位求反</strong>。</li><li>数据零有惟一的编码，$[+0]_移=[-0]_移=1000\dots0$。当数据小于计算机能表示的最小值时，称为<strong>机器零</strong>，将阶码（移码）置为$0000\dots0$，且不管尾数值是多少，都按浮点数下溢处理。</li></ul><h2 id="数值范围和精度"><a href="#数值范围和精度" class="headerlink" title="数值范围和精度"></a>数值范围和精度</h2><ul><li><p>定义</p><ul><li><p>数值范围</p><p>  机器所能表示的一个数的最大值和最小值之间的范围</p></li><li><p>数据精度</p><p>  一个数的有效位数</p></li></ul></li><li><p>常用浮点数（IEEE754国际标准）</p><p>  基数$R$为2，阶码采用移码（也称增码），尾数采用原码。因为规格化原码尾数的最高位恒为1，所以不再尾数中表示出来，计算时在尾数前边自动添上1。</p><p>  |        浮点数类型        |   阶码   |         尾数          |<br>  | :———————————: | :———: | :—————————-: |<br>  | 单精度浮点数（<strong>32</strong>位） | <strong>8位</strong>  | 24位（内含1位符号位） |<br>  | 双精度浮点数（<strong>64</strong>位） | <strong>11位</strong> | 53位（内含1位符号位） |</p></li></ul><h1 id="浮点数的加减法运算"><a href="#浮点数的加减法运算" class="headerlink" title="浮点数的加减法运算"></a>浮点数的加减法运算</h1><p>有5步操作，如下：</p><ol><li><p><strong>对阶</strong></p><p>阶码较小的浮点数尾数右移$\Delta E$位，其阶码值加上$\Delta E$。</p><p>若<strong>尾数</strong>是<strong>原码</strong>表示的，是<strong>无符号移位</strong>；</p><p>若<strong>尾数</strong>是<strong>补码</strong>表示的，是<strong>带符号移位</strong>。（上边也讲了补码的符号位参与运算嘛）</p></li><li><p><strong>尾数的加减运算</strong></p><p>两尾数进行加减运算，得到两尾数之和/差。</p></li><li><p><strong>规格化操作</strong></p></li></ol><ul><li><p><strong>左规</strong></p><p>  如果结果两符号位值相同，则尾数加减结果<strong>未溢出</strong>。</p><p>  但若最高数值位与符号位相同，此时尾数连续左移，直至<strong>最高数值位</strong>与<strong>符号位</strong>的值不同为止，同时从阶码中减去移位的位数。</p></li><li><p><strong>右规</strong></p><p>  如果结果两符号位值不同，则尾数加减结果<strong>溢出</strong>。此时将尾数结果右移1位，阶码+1。</p></li></ul><ol><li><p><strong>舍入</strong></p><p>作用：处理尾数右移（右规或对阶）时丢失的低位。</p><p>当<strong>丢失的最高位</strong>为1时，在尾数末位+1，如果加1使尾数溢出，就再进行一次右规。</p></li><li><p><strong>检查阶码是否溢出</strong></p><p>阶码溢出表示浮点数溢出。</p><p>若阶码下溢，则置运算结果为机器零（通常尾数和阶码全部置0）；若上溢，则置溢出标志。</p></li></ol><h1 id="定点原码一位乘法"><a href="#定点原码一位乘法" class="headerlink" title="定点原码一位乘法"></a>定点原码一位乘法</h1><h1 id="定点补码一位乘法"><a href="#定点补码一位乘法" class="headerlink" title="定点补码一位乘法"></a>定点补码一位乘法</h1><h1 id="定点原码一位除法"><a href="#定点原码一位除法" class="headerlink" title="定点原码一位除法"></a>定点原码一位除法</h1><h1 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>码距</strong>：根据任意两个合法码之间至少有几个二进制位确定，若仅有1位不同，则称其码距为1。</p><p>使码距由1增加到2。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>为1个字节（8位）补充1位到高位</strong>，称为<strong>校验位</strong>；低8位为<strong>数据位</strong>。</p><p>添加校验位，使<strong>1的个数</strong>为<strong>奇数</strong>时，这种方法称为<strong>奇校验</strong>；使<strong>1的个数</strong>为<strong>偶数</strong>时，称为<strong>偶校验</strong>。</p><ul><li><p>奇校验</p><p>  若数据位中有奇数个1，校验位为0；若有偶数个1，校验位为1。</p></li><li><p>偶校验</p><p>  若数据位中有奇数个1，校验位为1；若有偶数个1，校验位为0。</p></li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><strong>发现1位或奇数个位错</strong>。</li><li>不能确定哪一位错，也不能发现偶数个位错。</li></ul><p>记住第一句话即可，它的功能只有第一句话，所以第二句可有可无。</p><h1 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>海明校验码基于<strong>偶校验</strong>。</p><p>在数据中加入$r$个校验位，并把数据的每一个二进制位（共$k$个数据位）分配在几个奇偶校验组中，即<strong>一个数据位由多个校验位校验</strong>。</p><script type="math/tex; mode=display">2^r-1-r\geq k</script><ul><li>$2^r$：$r$个校验码可以表示$2^r$个信息。</li><li>$-1$：用1个信息表示没有错误。</li><li>$-r$：错误也可能发生在$r$个校验位。</li></ul><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>$k$为数据位个数，$r$为校验位个数，$m=r+k$，即海明码的位数。</p><p>海明码（Hamming Code）为$H_mH_{m-1}…H_2H_1$。</p><ul><li>$H_i$为第$i$个海明码位。</li><li>$P_i$为第$i$个校验位（Parity Bit）。</li><li>$D_i$为第$i$个数据位（Data Bit）。</li></ul><h3 id="确定校验位的位置"><a href="#确定校验位的位置" class="headerlink" title="确定校验位的位置"></a>确定校验位的位置</h3><p>每位海明码由多个校验位校验，规律如下式：</p><script type="math/tex; mode=display">每位海明码的位号=检验该位海明码的各校验位位号之和</script><p>由上式可知，第$i$个校验位$P_i$的海明码位号为$2^{i-1}$或最高位，海明码的其他位为数据位。</p><h3 id="确定校验位的表达式-P-i"><a href="#确定校验位的表达式-P-i" class="headerlink" title="确定校验位的表达式$P_i$"></a>确定校验位的表达式$P_i$</h3><p>根据偶校验原理可得：</p><script type="math/tex; mode=display">P_i=该校验位校验的各数据位的异或</script><h3 id="确定校验和表达式-S-i"><a href="#确定校验和表达式-S-i" class="headerlink" title="确定校验和表达式$S_i$"></a>确定校验和表达式$S_i$</h3><script type="math/tex; mode=display">校验和的个数=校验位的个数=偶校验组的个数</script><script type="math/tex; mode=display">S_i​=每组偶校验组各位的异或</script><p><strong>若某校验和的值为0，说明该组没有错。若所有校验和值为0，则海明码没有出错</strong>。</p><h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h3><p>根据所有校验和的值及其表达式，是可以判断出哪一位出了错的。</p><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><p><strong>发现一位错并纠正。</strong></p><p>若想发现两位错，则应再增加一个校验位$S’$，即书上例子里的$S_5$，用来判断是奇数还是偶数个出错。</p><p>若$S’$为0，则说明偶数个出错；若为1，则奇数个出错。</p><p>偶数个出错时，若$S_i$都为0，即$S$的值都为0时，则没有出错。</p><h1 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h1><h2 id="模2运算"><a href="#模2运算" class="headerlink" title="模2运算"></a>模2运算</h2><h3 id="模2加减"><a href="#模2加减" class="headerlink" title="模2加减"></a>模2加减</h3><p>即异或。</p><h3 id="模2乘"><a href="#模2乘" class="headerlink" title="模2乘"></a>模2乘</h3><p>按模2加求部分积之和。</p><h3 id="模2除"><a href="#模2除" class="headerlink" title="模2除"></a>模2除</h3><p>按模2减求部分余数。</p><p>每求一位商应使部分余数减少一位（即不要最高的一位），并在低位补0。</p><p>当部分余数首位为1时，商取1，减数取除数；</p><p>当部分余数首位为0时，商取0，减数取0。</p><h2 id="编码方法"><a href="#编码方法" class="headerlink" title="编码方法"></a>编码方法</h2><h3 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h3><p>$(n,k)码$，其中高$k$位是数据位；<strong>后$r$位是校验位</strong>（与奇偶校验不同）；$n=k+r$为CRC码的长度。</p><p>令$M$为数据位；$G$为生成多项式（Generator Polynomial），它有$r+1$位。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>$M$左移$r$位得$M’$，$M’$模2除以$G$。</p><p>设所得余数（Remainder）为$R$，$r$位；商（Quotient）为$Q$。</p><p>$M’$加上$R$即得CRC码。</p><h2 id="纠错方法"><a href="#纠错方法" class="headerlink" title="纠错方法"></a>纠错方法</h2><h3 id="判断错误"><a href="#判断错误" class="headerlink" title="判断错误"></a>判断错误</h3><p>CRC码模2除以$G$是可以除尽的。</p><p>若余数为0，则无误；</p><p>若余数不为0，则某一位出错，且不同位出错，余数不同。</p><p>余数与出错位对应关系不变，只与码制和生成多项式有关。</p><h3 id="纠错-1"><a href="#纠错-1" class="headerlink" title="纠错"></a>纠错</h3><p>得到一个不为0的余数后：</p><p>在其右侧补0，继续除下去（余数的变化是规律的），每除一次的同时将CRC码循环左移。</p><p>循环该操作至余数为101（$G$为1011时），此时出错位在最高位。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h1&gt;&lt;h2 id=&quot;2进制转8进制&quot;&gt;&lt;a href=&quot;#2进制转8进制&quot; class=&quot;headerlink&quot; title=&quot;2进制
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第二章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第二章复习/</id>
    <published>2019-06-28T13:37:42.000Z</published>
    <updated>2019-06-28T13:39:04.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两种电路"><a href="#两种电路" class="headerlink" title="两种电路"></a>两种电路</h1><h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><p>输出只和当前输入有关</p><h2 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h2><p>输出不仅和当前输入有关，还和原来状态有关。</p><h1 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h1><p>$n$位输入，最多$2^n$个输出。</p><p>给定$n$位输入后，输出中仅有对应的那一个为1（或0），其他都为0（或1）。</p><h1 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h1><p>从多个输入中选择某一个作为输出。</p><h1 id="181和182"><a href="#181和182" class="headerlink" title="181和182"></a>181和182</h1><ul><li>181实现了<strong>位间快速进位</strong>。（4位，AM2901也是）</li><li>182实现了<strong>组间快速进位</strong>。（4组，AM2902也是）</li></ul><p>例题：</p><p>如果实现64位快速运算，需要多少个181和多少个182？</p><ul><li><p>181</p><p>  $\frac{64}{4}=16$</p></li><li><p>182</p><p>  $\frac{16}{4}=4，\frac{4}{4}=1$</p><p>  $4+1=5$</p></li></ul><p>如果是128位呢</p><ul><li><p>181</p><p>  $\frac{128}{4}=32$</p></li><li><p>182</p><p>  $\frac{32}{4}=8，\frac{8}{4}=2，\frac{2}{4}=1$</p><p>  $8+2+1=11$</p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;两种电路&quot;&gt;&lt;a href=&quot;#两种电路&quot; class=&quot;headerlink&quot; title=&quot;两种电路&quot;&gt;&lt;/a&gt;两种电路&lt;/h1&gt;&lt;h2 id=&quot;组合逻辑电路&quot;&gt;&lt;a href=&quot;#组合逻辑电路&quot; class=&quot;headerlink&quot; title=&quot;组合逻辑电
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-第一章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机组成原理-第一章复习/</id>
    <published>2019-06-28T13:37:32.000Z</published>
    <updated>2019-06-28T13:38:57.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冯诺依曼型计算机特点"><a href="#冯诺依曼型计算机特点" class="headerlink" title="冯诺依曼型计算机特点"></a>冯诺依曼型计算机特点</h1><h2 id="存储程序-核心特点"><a href="#存储程序-核心特点" class="headerlink" title="存储程序(核心特点)"></a>存储程序(核心特点)</h2><ul><li>采用<strong>存储程序</strong>方式，程序和数据放在同一个存储器中，以二进制表示。</li></ul><h2 id="五部分组成"><a href="#五部分组成" class="headerlink" title="五部分组成"></a>五部分组成</h2><p>各部分通过<strong>数据总线、地址总线、控制总线</strong>传递信息，进行联系。</p><ul><li><p>运算器</p><p>  对数据进行运算</p></li><li><p>控制器</p><p>  实现程序的自动执行</p></li><li><p>存储器</p><p>  存放程序和数据</p></li><li><p>输入设备</p><p>  输入原始数据和处理这些数据的程序</p></li><li><p>输出设备</p><p>  输出计算机的处理结果</p></li></ul><h2 id="指令的组成"><a href="#指令的组成" class="headerlink" title="指令的组成"></a>指令的组成</h2><ul><li>由<strong>操作码</strong>和<strong>地址码</strong>组成</li></ul><h2 id="运算器为中心"><a href="#运算器为中心" class="headerlink" title="运算器为中心"></a>运算器为中心</h2><ul><li>输入输出设备与存储器间的数据传送都通过运算器</li></ul><h2 id="指令的存放和执行"><a href="#指令的存放和执行" class="headerlink" title="指令的存放和执行"></a>指令的存放和执行</h2><ul><li>指令在存储器中<strong>按执行顺序存放</strong></li></ul><h1 id="电子计算机的发展"><a href="#电子计算机的发展" class="headerlink" title="电子计算机的发展"></a>电子计算机的发展</h1><ol><li>电子管计算机</li><li>晶体管计算机</li><li>集成电路计算机</li><li>大规模集成电路计算机</li><li>超大规模集成电路计算机</li></ol><h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><h2 id="软件系统"><a href="#软件系统" class="headerlink" title="软件系统"></a>软件系统</h2><h2 id="硬件系统"><a href="#硬件系统" class="headerlink" title="硬件系统"></a>硬件系统</h2><h1 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h1><p>==字长==</p><p>==容量==</p><p>==CIP==</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冯诺依曼型计算机特点&quot;&gt;&lt;a href=&quot;#冯诺依曼型计算机特点&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼型计算机特点&quot;&gt;&lt;/a&gt;冯诺依曼型计算机特点&lt;/h1&gt;&lt;h2 id=&quot;存储程序-核心特点&quot;&gt;&lt;a href=&quot;#存储程序-核心特点&quot; c
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-域名系统DNS</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9FDNS/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机网络-域名系统DNS/</id>
    <published>2019-06-28T13:34:24.000Z</published>
    <updated>2019-06-28T13:36:28.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>把互连网上的主机名转换为IP地址</p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>当某一个应用进程需要把主机名解析为IP地址时，该应用进程就调用<strong>解析程序</strong>，并成为DNS的一个<strong>客户</strong>。</p><p>把待解析的域名放在<strong>DNS请求报文</strong>中，以<strong>UDP用户数据报</strong>方式发给<strong>本地域名服务器</strong>。</p><p>本地域名服务器在查找域名后，把对应的IP地址放在<strong>回答报文</strong>中返回，应用进程获得目的主机的IP地址。</p><p>若本地域名服务器不能回答该请求，则此域名服务器暂时成为DNS的另一个<strong>客户</strong>（递归查询），并向其他域名服务器发出查询请求（一般迭代查询），直至找到能够回答该请求的域名服务器。</p><h1 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h1><p>采用<strong>层次树状结构</strong>的命名方法。</p><p><strong>域</strong>：名字空间中一个可被管理的划分，域还可以划分为子域，子域还可以划分为子域，形成顶级域、二级域、三级域等等。</p><p>DNS不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。</p><p>域名是从右往左看的，越往右等级越高。</p><h1 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h1><p>DNS服务器的管辖范围是<strong>以区为单位</strong>，区可能等于或小于域，但一定不能大于域，即区是域的子集。</p><p>一个服务器所负责管辖（或有权限的）的范围叫做<strong>区</strong>。</p><p>一个区中的所有节点必须是能够连通的。</p><p><strong>每个区</strong>设置响应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的域名到IP地址的映射。</p><h2 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h2><p>根域名服务器是最高层次的域名服务器。</p><p>所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。</p><h2 id="顶级域名服务器"><a href="#顶级域名服务器" class="headerlink" title="顶级域名服务器"></a>顶级域名服务器</h2><p>负责管理在该顶级域名下注册的所有二级域名。</p><h2 id="权限域名服务器"><a href="#权限域名服务器" class="headerlink" title="权限域名服务器"></a>权限域名服务器</h2><p>负责一个区的域名服务器。</p><h2 id="本地域名服务器"><a href="#本地域名服务器" class="headerlink" title="本地域名服务器"></a>本地域名服务器</h2><p><strong>当一台主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。</strong></p><p>不管哪一个<strong>本地域名服务器</strong>，若要对一个域名进行解析，<strong>只要自己无法解析，就首先要求助于根域名服务器</strong>。</p><h1 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h1><h2 id="主机向本地域名服务器查询"><a href="#主机向本地域名服务器查询" class="headerlink" title="主机向本地域名服务器查询"></a>主机向本地域名服务器查询</h2><p>一般采用<strong>递归查询</strong>。</p><p>如果本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器会以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即<strong>替主机继续查询</strong>）。</p><p>递归查询的结果：</p><ul><li>查到的IP地址</li><li>报错，表示无法查询到所需的IP地址</li></ul><h2 id="本地域名服务器向根域名服务器查询"><a href="#本地域名服务器向根域名服务器查询" class="headerlink" title="本地域名服务器向根域名服务器查询"></a>本地域名服务器向根域名服务器查询</h2><p>一般采用<strong>迭代查询</strong>。</p><p>根域名服务器收到本地域名服务器发出的迭代查询请求报文时，本地域名服务器收到的查询结果有两种：</p><ul><li>查到的IP地址</li><li>下一步向哪个域名服务器查询</li></ul><p>顶级域名服务器在收到本机域名服务器的查询请求后，收到的结果有两种：</p><ul><li>查到的IP地址</li><li>下一步向哪个权限域名服务器查询</li></ul><p>就这样，本地域名服务器就这样进行迭代查询，最终把得到的结果返回给发起查询的主机。</p><h1 id="高速缓存域名服务器"><a href="#高速缓存域名服务器" class="headerlink" title="高速缓存域名服务器"></a>高速缓存域名服务器</h1><p>功能：用来存放<strong>最近查询过的域名</strong>以及<strong>从何处获得域名映射信息</strong>的记录。</p><p>好处：<strong>提高DNS查询效率</strong>，<strong>减轻根域名服务器的负荷</strong>和<strong>减少互联网上的DNS查询报文数量</strong>。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h1&gt;&lt;p&gt;把互连网上的主机名转换为IP地址&lt;/p&gt;
&lt;h1 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-运输层复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机网络-运输层复习/</id>
    <published>2019-06-28T13:34:11.000Z</published>
    <updated>2019-06-28T13:36:06.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>实现两台主机中<strong>进程之间</strong>的通信。</p><ul><li><p>复用和分用</p><ul><li><p>复用</p><p>  多个应用层进程可使用同一运输层服务</p></li><li><p>分用</p><p>  运输层把收到的信息分别交付上面应用层的相应进程</p></li></ul></li><li><p>提供可靠性</p></li></ul><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul><li>面向连接</li><li><strong>面向字节流</strong></li><li>提供可靠性</li><li>不提供广播或多播服务</li><li>协议数据单元是<strong>TCP报文段</strong></li><li>有拥塞控制</li></ul><p>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。</p><p><strong>套接字</strong>：IP地址+端口号</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><ul><li>无连接</li><li>面向报文（给什么数据，传什么数据）</li><li>尽最大努力交付</li><li>可以一对多、多对一、多对多</li><li>协议数据单元是<strong>UDP用户数据报</strong></li><li>没有拥塞控制</li></ul><h1 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h1><ul><li><p><strong>无差错情况</strong>：停止等待</p><p>  每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。</p></li><li><p><strong>出现差错</strong>：超时重传</p><p>  每发送完一个分组时设置一个超时计数器。</p><p>  如果超时还未收到确认，就重传分组；在超时前收到确认则撤销该超时计数器。</p><ul><li><p>A发送完一个分组后<strong>必须暂时保留已发送到分组的副本</strong>，在收到响应确认后才能清除这个副本。</p></li><li><p>分组和确认分组必须进行<strong>编号</strong>，这样才能明确发送出去的分组是哪一个收到了确认，哪一个没有收到确认。</p><p>  可以处理确认迟到的情况。</p></li><li><p>超时计数器设置的<strong>重传时间应当比数据在分组传输的平均往返时间长一些</strong>。如果设定得很长，通信效率就会降低；如果设定得太短，会导致不必要的重传，浪费了网络资源。</p></li></ul></li><li><p><strong>确认丢失</strong></p><p>  确认丢失时，发送方进行超时重传，而<strong>接收方丢弃这个重复的分组</strong>，<strong>向发送方发送确认</strong>。</p></li><li><p><strong>确认迟到</strong></p><p>  确认迟到了，发送方进行超时重传，而<strong>接收方丢弃这个重复的分组</strong>，<strong>向发送方发送确认</strong>。</p><p>  发送方收到迟到的确认什么也不做。</p></li></ul><h1 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h1><p>TCP进行拥塞控制的一种算法。</p><p>拥塞是运输层的概念。</p><p>发送方维持一个变量：<strong>拥塞窗口</strong>，让自己的<strong>发送窗口等于拥塞窗口</strong>，<strong>拥塞窗口的大小取决于网络的拥塞程度</strong>。</p><p><strong>判断网络拥塞的依据就是出现了超时</strong>。网络拥塞时就把拥塞窗口减小一些。</p><p>慢开始：<strong>由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值</strong>。</p><p>发送方每收到一个对新报文段的确认就使发送方的拥塞窗口+1。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h1&gt;&lt;p&gt;实现两台主机中&lt;strong&gt;进程之间&lt;/strong&gt;的通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;复用和分用&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-网络层复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机网络-网络层复习/</id>
    <published>2019-06-28T13:34:01.000Z</published>
    <updated>2019-06-28T13:35:59.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主要解决的问题"><a href="#主要解决的问题" class="headerlink" title="主要解决的问题"></a>主要解决的问题</h1><p>网络层讨论的问题是多个网络互连的问题，即分组如何从一个网络传送到另一个网络。</p><h1 id="协议数据单元"><a href="#协议数据单元" class="headerlink" title="协议数据单元"></a>协议数据单元</h1><p>网络层协议数据单元就是IP数据报，又称为<strong>数据报</strong>、<strong>分组</strong>或<strong>包</strong>。</p><h1 id="网络层的两种服务"><a href="#网络层的两种服务" class="headerlink" title="网络层的两种服务"></a>网络层的两种服务</h1><p>网络层的两种服务指的是向运输层提供<strong>无连接</strong>或<strong>面向连接</strong>的服务。</p><p>选用哪一种服务的实质是：在计算机通信中，可靠交付应当由谁来负责。是网络（网络层）还是端系统（网络层的上几层）？</p><p><strong>可靠</strong>：<strong>分组无差错按序到达终点，不丢失，不重复</strong></p><p>互联网的设计思路：<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</strong>。<strong>分组不进行编号</strong>。</p><h1 id="虚电路和数据报网络对比"><a href="#虚电路和数据报网络对比" class="headerlink" title="虚电路和数据报网络对比"></a>虚电路和数据报网络对比</h1><p>7个方面</p><div class="table-container"><table><thead><tr><th style="text-align:center">对比的方面</th><th style="text-align:center">虚电路服务</th><th style="text-align:center">数据报服务</th></tr></thead><tbody><tr><td style="text-align:center">可靠性由谁保证</td><td style="text-align:center">可靠由网络来保证</td><td style="text-align:center">可靠由用户主机来保证</td></tr><tr><td style="text-align:center">是否面向连接</td><td style="text-align:center">面向连接</td><td style="text-align:center">无连接</td></tr><tr><td style="text-align:center">是否有终点地址</td><td style="text-align:center">仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组转发方式</td><td style="text-align:center">属于同一虚电路的分组按同一路由转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">结点故障对网络的影响</td><td style="text-align:center">所有通过故障结点的虚电路均不能工作</td><td style="text-align:center">出故障的结点可能会丢失分组，一些路由可能发生变化</td></tr><tr><td style="text-align:center">分组到达终点顺序</td><td style="text-align:center">按发送顺序到达</td><td style="text-align:center">不一定按发送顺序到达</td></tr><tr><td style="text-align:center">端到端的差错处理和流量控制</td><td style="text-align:center">可以由网络负责，也可以由用户主机负责</td><td style="text-align:center">用户主机负责</td></tr></tbody></table></div><p><strong>互联网的IP协议提供不可靠的无连接的服务</strong>。</p><h1 id="中间设备"><a href="#中间设备" class="headerlink" title="中间设备"></a>中间设备</h1><div class="table-container"><table><thead><tr><th style="text-align:center">工作层次</th><th style="text-align:center">中间设备</th></tr></thead><tbody><tr><td style="text-align:center">物理层</td><td style="text-align:center">转发器</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:center">网桥/桥接器</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">路由器</td></tr><tr><td style="text-align:center">网络层以上</td><td style="text-align:center">网关</td></tr></tbody></table></div><h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>以32位IP地址为例，A、B、C类地址都是单播地址，都由两个固定长度的字段组成，第一个字段是<strong>网络号</strong>，第二个字段是<strong>主机号</strong>。一个网络号在整个互联网范围内是唯一的，一个主机号在其网络内必须是唯一的。</p><p>一个IP只能对应一个主机；一个主机可以有多个IP，比如路由器。</p><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>A、B、C类地址的网络号字段分别是1个、2个和3个字节长，其网络号字段前几位是<strong>类别号</strong>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">IP地址类型</th><th style="text-align:center">类别号</th><th style="text-align:center">可指派网络号</th></tr></thead><tbody><tr><td style="text-align:center">A类</td><td style="text-align:center">0</td><td style="text-align:center">1-126</td></tr><tr><td style="text-align:center">B类</td><td style="text-align:center">10</td><td style="text-align:center">128.1-191.255</td></tr><tr><td style="text-align:center">C类</td><td style="text-align:center">110</td><td style="text-align:center">192.0.1-233.255.255</td></tr></tbody></table></div><p>网络号127被保留作为<strong>本地环回测试</strong>，全0被保留表示<strong>本网络</strong>。</p><h2 id="既然有了MAC地址，为什么要用IP地址？"><a href="#既然有了MAC地址，为什么要用IP地址？" class="headerlink" title="既然有了MAC地址，为什么要用IP地址？"></a>既然有了MAC地址，为什么要用IP地址？</h2><p>全世界存在<strong>各式各样的网络</strong>，它们使用<strong>不同的硬件地址</strong>。要使这些<strong>异构网络</strong>能够互相通信就必须进行<strong>非常复杂的硬件地址转换工作</strong>，因此由用户主机来完成这项工作几乎是不可能的事。但IP编址把这个复杂问题解决了。</p><h1 id="分组转发"><a href="#分组转发" class="headerlink" title="分组转发"></a>分组转发</h1><p>路由表指出<strong>到某个网络应该如何转发</strong>，每行对应于一个网络。</p><p>在互联网上转发分组时，是<strong>从一个路由器转发到下一个路由器</strong>。</p><p>每条路由主要信息：<strong>（目的网络地址，下一跳地址）</strong>。下一跳地址是路由器端口的IP地址。</p><ul><li>使用子网时分组的转发</li></ul><p>使用子网划分后，每条路由主要信息：<strong>（目的网络地址，子网掩码，下一跳地址）</strong>。</p><p><strong>主机</strong></p><p>要发数据包时先<strong>判断是直接交付还是间接交付</strong>：即发送的这个分组是在本子网上进行直接交付还是要通过本子网的路由器进行间接交付：将与本子网的子网掩码和目的IP地址相与求得目的网络地址与该子网地址比较，得出是否直接交付。</p><p><strong>路由器</strong></p><ol><li>拿到目的IP地址后<strong>对路由器直接相连的网络逐个进行检查</strong>（直接相连的网络可以直接写在路由表的最前边），将各网络的子网掩码和目的IP地址<strong>相与求得目的网络地址</strong>，判断该网络地址是否和对应的目的网络地址匹配。若匹配则直接交付，转发任务结束；否则就是间接交付，进行下一步。</li><li>若有<strong>特定主机路由</strong>，则把数据传送给路由表中指明的下一跳，否则执行下一步。</li><li>用<strong>路由表每一行</strong>中的子网掩码和目的IP地址相与，若结果与该行目的网络地址匹配，则把数据传送给该行指明的下一跳路由器；否则执行下一步</li><li>若路由表中有一个<strong>默认路由</strong>，则把数据报传送给路由表指定的默认路由器；否则，执行下一步</li><li><strong>报告转发分组出错</strong>。</li></ol><h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>功能：从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。</p><p>操作：去ARP高速缓存里找，找不到就广播ARP请求分组获得目的硬件地址（可以是路由器或主机的）并记录在ARP高速缓存中。</p><h2 id="ARP消息类型"><a href="#ARP消息类型" class="headerlink" title="ARP消息类型"></a>ARP消息类型</h2><ul><li>ARP request<ul><li>ARP请求分组（1），用于请求某IP主机的硬件地址。</li><li><strong>广播</strong>。</li><li>主要内容：我的IP是xxx，我的硬件地址是xxx，我想知道IP地址是xxx的地址。</li></ul></li><li>ARP response<ul><li>ARP响应分组（2），用于指出某IP主机的硬件地址。</li><li><strong>单播</strong>。</li><li>主要内容：我的IP是xxx，我的硬件地址是xxx</li></ul></li></ul><p>假设主机A发送ARP请求分组请求主机B的物理地址，不久之后很有可能B也要向A发送数据报。所以ARP请求分组包含了源IP，B收到ARP请求分组时会把A的IP地址和物理地址记录在其ARP高速缓存中。</p><h2 id="ARP高速缓存"><a href="#ARP高速缓存" class="headerlink" title="ARP高速缓存"></a>ARP高速缓存</h2><p>如果没有ARP高速缓存，任何一台主机每次进行通信时都必须在网络上广播ARP请求分组，使网络上的通信量大大增加。</p><h2 id="生存时间"><a href="#生存时间" class="headerlink" title="生存时间"></a>生存时间</h2><ul><li>ARP对保存在ARP高速缓存中的每一个映射地址项目都设置生存时间，凡超过生存时间的项目就从高速缓存中删除掉。这样可以及时更新各主机与其物理地址的映射关系，处理主机网络适配器故障或更新等情况。</li><li>生存时间设置得太长会使映射关系发生变化的主机迟迟无法通信，设置得太短会使ARP请求和响应分组的通信太频繁。</li></ul><h2 id="ARP属于网络层"><a href="#ARP属于网络层" class="headerlink" title="ARP属于网络层"></a>ARP属于网络层</h2><p>不能说“ARP向网络层提供了服务”，因为ARP本身是网络层的一部分。数据链路层使用硬件地址而不使用IP地址，因此ARP不在数据链路层。</p><h2 id="不需要发送ARP请求分组的情况"><a href="#不需要发送ARP请求分组的情况" class="headerlink" title="不需要发送ARP请求分组的情况"></a>不需要发送ARP请求分组的情况</h2><ul><li>源主机的ARP高速缓存中已有目的IP地址的项目</li><li>源主机发送广播分组</li><li>源主机和目的主机使用点对点链路</li></ul><h1 id="IP子网"><a href="#IP子网" class="headerlink" title="IP子网"></a>IP子网</h1><p>IP地址与子网掩码相与</p><p>同样的IP地址和不同的子网掩码可以得出相同的网络地址。但是不同的掩码效果是不同的：可划分的子网数和每一个子网中的最大主机数都是不一样的。</p><p>知道A和B的IP，想让他们在一个子网内，应如何给它们分配子网掩码？</p><p>计算子网号个数时要去除全0和全1的情况，即减2。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主要解决的问题&quot;&gt;&lt;a href=&quot;#主要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;主要解决的问题&quot;&gt;&lt;/a&gt;主要解决的问题&lt;/h1&gt;&lt;p&gt;网络层讨论的问题是多个网络互连的问题，即分组如何从一个网络传送到另一个网络。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-数据链路层复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机网络-数据链路层复习/</id>
    <published>2019-06-28T13:33:54.000Z</published>
    <updated>2019-06-28T13:35:48.594Z</updated>
    
    <content type="html"><![CDATA[<p>网桥在数据链路层进行互连。</p><h1 id="数据链路层研究的问题"><a href="#数据链路层研究的问题" class="headerlink" title="数据链路层研究的问题"></a>数据链路层研究的问题</h1><p>在同一个局域网中，<strong>分组</strong>怎么从一台主机传送到另一台主机上（不经过路由器转发）。</p><p><strong>分组是网络层的协议数据单元</strong>，数据链路层的协议数据单元是<strong>帧</strong>。</p><h1 id="链路和数据链路"><a href="#链路和数据链路" class="headerlink" title="链路和数据链路"></a>链路和数据链路</h1><h2 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h2><p>也叫物理链路。</p><p>一个结点到相邻结点的一段<strong>物理线路</strong>，而没有其他的交换结点。</p><h2 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h2><p>也叫逻辑链路。</p><p><strong>链路</strong>加上实现协议的<strong>硬件</strong>和<strong>软件</strong>形成数据链路。</p><p>常用方法：</p><p>网络适配器，即网卡，既有软件，又包括硬件，其一般包括物理层和数据链路层两层的功能。</p><h2 id="链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？"><a href="#链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？" class="headerlink" title="链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？"></a>链路和数据链路有什么区别？“电路接通了”和“数据链路接通了”的区别在哪？</h2><p>所谓<strong>链路就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点</strong>。在进行数据通信时，两个计算机之间的通信路径往往要经过许多段这样的链路。可见链路只是一条路径的组成部分。</p><p>数据链路则是另外一个概念。这是因为<strong>当需要在一条线路上传输数据时，除了必须有一条物理线路外，还必须有一些必要的通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路</strong>。现在最常用的方法是使用网络适配器（如拨号上网使用拨号适配器，以及通过以太网上网使用局域网适配器）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p><p>也可以把链路分为物理链路和逻辑链路。物理链路就是上面说的链路，而逻辑链路就是上面的数据链路，是物理链路加上必要的通信协议。</p><p><strong>“电路接通了”表明物理连接已经能够传输比特流了</strong>。</p><p><strong>而“数据链路接通了”是指在物理连通的基础上，建立数据链路，实现封装成帧、透明传输、差错检测等功能</strong>。</p><h1 id="帧"><a href="#帧" class="headerlink" title="帧"></a>帧</h1><p>数据链路层的<strong>协议数据单元</strong>。</p><h1 id="数据链路层三个基本问题"><a href="#数据链路层三个基本问题" class="headerlink" title="数据链路层三个基本问题"></a>数据链路层三个基本问题</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>数据链路层在网络层交下来的IP数据报（即分组）前后分别添加<strong>首部</strong>和<strong>尾部</strong>形成<strong>帧</strong>。（OSI的数据链路层把传输的比特流划分成帧。）</p><p><strong>只有数据链路层会添加尾部，除物理层外，即应用层、传输层、网络层、数据链路层都会为上边传下来的数据添加首部</strong>。</p><p>首部和尾部包括许多必要的控制信息（如同步信息、地址信息、差错控制等），</p><h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>为使接收端能从收到的比特流中准确地找到帧的开始和结束位置。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>首部和尾部的一个重要作用就是<strong>帧定界</strong>（即确定帧的界限）：</p><p>SOH（Start Of Header），放在帧的最前边，表示帧的开始。</p><p>EOT（End Of Transmission），放在帧的最后边，表示帧的结束。</p><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><h3 id="问题来源-1"><a href="#问题来源-1" class="headerlink" title="问题来源"></a>问题来源</h3><p>由于帧开始和结束的标记使用专门指明的控制字符，所传输的数据中不能出现8比特的组合和用作帧定界的控制字符的比特编码一样，否则会出现<strong>帧定界错误</strong>。</p><h3 id="解决问题-1"><a href="#解决问题-1" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>解决方法：<strong>字节填充</strong></li></ul><p>发送端的数据链路层在<strong>数据中控制字符和转义字符</strong>的前边插入一个<strong>转义字符</strong>ESC；</p><p>接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符ESC。</p><p>简单来说，（要注意：添加和删除ESC是对于<strong>数据中的</strong>ESC、SOH、EOT来说的）</p><p><strong>发送端的数据链路层在数据中的ESC、SOH、EOT前添加ESC</strong>，</p><p><strong>接收端的数据链路层把数据中ESC、SOH、EOT前的ESC去掉</strong></p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h3 id="问题来源-2"><a href="#问题来源-2" class="headerlink" title="问题来源"></a>问题来源</h3><ul><li><strong>比特差错</strong></li></ul><p>现实的通信链路不是理想的，传输过程中可能出现<strong>比特差错</strong>（1变成0，或0变成1）。</p><p><strong>比特差错并不是传输差错</strong>。</p><p>为保证数据传输的可靠性，必须进行差错检测。</p><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p>数据链路层广泛使用了<strong>循环冗余校验码CRC</strong>的检错技术。</p><p>若数据链路层<strong>仅仅</strong>使用CRC，则只能实现<strong>无差错接受</strong>、<strong>无比特差错</strong>的传输，这并不是<strong>可靠传输</strong>。</p><p>==CRC可参考计组复习笔记，超链接==</p><ul><li>CRC和FCS不同</li></ul><p><strong>帧检验序列FCS</strong>，是数据后边的<strong>冗余码</strong>；而CRC是一种检错方法。</p><ul><li>编码方法</li></ul><p>数据左移几位（P的位数-1）后模2除以生成多项式P，则得应在数据后添加的余数</p><ul><li>检错方法</li></ul><p>拿到的数据加冗余码，模2除生成多项式P，求得余数</p><p>若余数为0，则无误，接受；</p><p>若不为0，则有误，就<strong>丢弃</strong>。</p><h2 id="为什么三个问题必须加以解决"><a href="#为什么三个问题必须加以解决" class="headerlink" title="为什么三个问题必须加以解决"></a>为什么三个问题必须加以解决</h2><p><strong>封装成帧就是在一段数据的前后分别添加首部和尾部</strong>（在首部和尾部里面有许多必要的控制信息），这样就构成了一个帧。接收端在收到物理层上交的比特流，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<strong>首部和尾部的一个重要作用就是帧定界，如果不进行封装成帧，那么数据链路层在收到一些数据时，就无法知道对方传输的数据中哪些是数据，哪些是控制信息，甚至数据中有没有差错也不知道，也无法知道数据传送结束了没有，因此不知道应该在什么时候把收到的数据给上一层。</strong></p><p><strong>上层交下来的数据，不管是什么形式的比特组合，都必须能够正确传送</strong>。由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何比特组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。<strong>数据链路层不应对传送的数据提出限制，即不应当规定某种形式的比特组合不能够传送。如果没有透明传输，就可能会出现帧定界错误</strong>。</p><p>如果数据链路层没有<strong>差错检测</strong>，那么当目的主机收到其他主机发送来的数据时，在交给高层后，<strong>如果应用程序要求收到的数据必须正确无误</strong>，那么目的主机的高层软件可以对收到的数据进行差错检测。如果发现数据中有差错，就可以请求源主机<strong>重传</strong>这些数据。这样做就可以达到正确接收数据的目的。但这种工作方式有一个很大的缺点，就是<strong>一些在传输过程中出现了错误的数据（这些已经是没有用处的数据）还会继续在网络中传送，这样就浪费了网络的资源</strong>。</p><h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><p>PPP协议<strong>面向连接</strong>。</p><p>PPP控制字符：<code>0x7E</code></p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><p>简单</p><h2 id="字节填充"><a href="#字节填充" class="headerlink" title="字节填充"></a>字节填充</h2><p>PPP使用异步传输时，转义符定义为<code>0x7D</code>，使用字节填充</p><div class="table-container"><table><thead><tr><th style="text-align:center">处理情况</th><th style="text-align:center">填充前</th><th style="text-align:center">填充后</th></tr></thead><tbody><tr><td style="text-align:center">控制字符</td><td style="text-align:center">0x7E</td><td style="text-align:center">(0x7D,0x5E)</td></tr><tr><td style="text-align:center">转义字符</td><td style="text-align:center">0x7D</td><td style="text-align:center">(0x7D,0x5D)</td></tr><tr><td style="text-align:center">ASCII码控制字符(小于0x20)</td><td style="text-align:center">0x03</td><td style="text-align:center">(0x7D,0x23)</td></tr></tbody></table></div><h2 id="零比特填充"><a href="#零比特填充" class="headerlink" title="零比特填充"></a>零比特填充</h2><p>PPP使用同步传输时</p><p>保证<strong>信息字段中</strong>不会出现连续6个1，方法如下</p><ul><li><p>发送端</p><p>  扫描<strong>信息字段</strong>，发现<strong>连续5个1</strong>，在其后边添1个0</p></li><li><p>接收端</p><p>  扫描<strong>信息字段</strong>，发现<strong>连续5个1</strong>，则删除其后边的1个0</p></li></ul><h1 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h1><p><strong>局域网的协议结构一般不包括网络层</strong>。</p><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网是典型的局域网，几乎成了局域网的同义词。</p><p>为了通信的简便，以太网采取了以下两种措施：</p><ul><li><strong>无连接、不可靠</strong></li><li>以太网发送的数据都使用<strong>曼彻斯特编码</strong></li></ul><h2 id="截断二进制指数退避算法"><a href="#截断二进制指数退避算法" class="headerlink" title="截断二进制指数退避算法"></a>截断二进制指数退避算法</h2><p>以太网使用截断二进制指数退避算法来确定碰撞后重传的时机。</p><p>设碰撞次数为$k$，则$k=Min[重传次数，10]$，重传时间为$0$到$2^k-1$个时间片</p><h2 id="局域网主要特点"><a href="#局域网主要特点" class="headerlink" title="局域网主要特点"></a>局域网主要特点</h2><ul><li>网络为一个单位所拥有</li><li>地理范围和站点数目均有限</li></ul><h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><h3 id="星形网"><a href="#星形网" class="headerlink" title="星形网"></a>星形网</h3><p>现在主要用这个，</p><p><strong>集线器星型拓扑</strong>：</p><ul><li>易维护，物理上是星形，逻辑上是总线型</li><li><strong>集线器工作在物理层</strong></li></ul><h3 id="环形网"><a href="#环形网" class="headerlink" title="环形网"></a>环形网</h3><p>一个电脑出问题，会影响整个局域网。</p><h3 id="总线网"><a href="#总线网" class="headerlink" title="总线网"></a>总线网</h3><p>所有的主机都连在一根总线上。</p><ul><li><p>广播</p><p>  一台计算机发送数据，总线上所有计算机都能检测到这个数据</p></li><li><p>一对一</p><p>  给每个适配器一个独一无二的MAC地址，在发送数据帧时，在帧的首部写明接收站的地址。</p><p>  当数据帧中的目的地址与适配器ROM中存放的MAC地址一致时，该适配器才接受这个数据帧，否则丢弃。</p></li></ul><h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h2><p>载波监听多路访问/碰撞检测，协议的实质是载波监听和碰撞检测。</p><h1 id="以太网扩展"><a href="#以太网扩展" class="headerlink" title="以太网扩展"></a>以太网扩展</h1><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网桥在数据链路层进行互连。&lt;/p&gt;
&lt;h1 id=&quot;数据链路层研究的问题&quot;&gt;&lt;a href=&quot;#数据链路层研究的问题&quot; class=&quot;headerlink&quot; title=&quot;数据链路层研究的问题&quot;&gt;&lt;/a&gt;数据链路层研究的问题&lt;/h1&gt;&lt;p&gt;在同一个局域网中，&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-物理层复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机网络-物理层复习/</id>
    <published>2019-06-28T13:33:46.000Z</published>
    <updated>2019-06-28T13:35:30.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="物理层主要解决的问题"><a href="#物理层主要解决的问题" class="headerlink" title="物理层主要解决的问题"></a>物理层主要解决的问题</h1><p>进行<strong>信号和比特流的转换</strong>，实现<strong>透明传输比特流</strong>，尽量使数据链路层感觉不到传输媒体之间的差异。</p><h1 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h1><h2 id="机械特性"><a href="#机械特性" class="headerlink" title="机械特性"></a>机械特性</h2><p>接插件的形状、尺寸、引脚数目和排列等<strong>规格</strong></p><h2 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h2><p><strong>电压范围</strong></p><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><p>某电平<strong>电压的意义</strong></p><h2 id="过程特性"><a href="#过程特性" class="headerlink" title="过程特性"></a>过程特性</h2><p>不同功能的各种可能<strong>事件的出现顺序</strong>。</p><h1 id="协议数据单元"><a href="#协议数据单元" class="headerlink" title="协议数据单元"></a>协议数据单元</h1><p>物理层上所传数据的单位是<strong>比特</strong>。</p><h1 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h1><h2 id="源系统"><a href="#源系统" class="headerlink" title="源系统"></a>源系统</h2><h3 id="源点"><a href="#源点" class="headerlink" title="源点"></a>源点</h3><p>又称信源，源站。</p><p>产生要传输的数据（比特流）。</p><h3 id="发送器"><a href="#发送器" class="headerlink" title="发送器"></a>发送器</h3><p>对源点生成的比特流进行编码，然后在传输系统中进行传输。</p><h2 id="传输系统"><a href="#传输系统" class="headerlink" title="传输系统"></a>传输系统</h2><p>可以是简单的传输线，也可以是复杂的网络系统。</p><h2 id="目的系统"><a href="#目的系统" class="headerlink" title="目的系统"></a>目的系统</h2><h3 id="接收器"><a href="#接收器" class="headerlink" title="接收器"></a>接收器</h3><p>接收信号，转换为终点可以处理的信息。</p><p>比如解调器，把模拟信号还原为比特流。</p><h3 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h3><p>又称目的站、信宿。</p><p>获取接收器传来的比特流。</p><h1 id="通信常用术语"><a href="#通信常用术语" class="headerlink" title="通信常用术语"></a>通信常用术语</h1><p>通信的目的是传送消息。</p><h2 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h2><p>消息是<strong>本质</strong>。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据是运送消息的<strong>实体</strong>。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是数据的<strong>电气或电磁表现</strong>。</p><h1 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h1><p>根据信号中代表消息的参数的取值方式分类</p><h2 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号"></a>模拟信号</h2><p>代表消息的参数取值是<strong>连续</strong>的。</p><h2 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h2><p>代表消息的参数取值是<strong>离散</strong>的。</p><p><strong>码元</strong>：承载信息的基本信号单位。</p><p>有两个要素：码元的取值个数$M$（$M$进制码元）和码元携带的信息量（即码元的位数）$n$。</p><p>$n\geq log_2^M$</p><p><a href="https://zhidao.baidu.com/question/680218902599074452.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/680218902599074452.html</a></p><h1 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h1><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">基带信号</th><th style="text-align:center">带通信号</th></tr></thead><tbody><tr><td style="text-align:center">频率</td><td style="text-align:center">低，甚至有直流成分</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">传播距离</td><td style="text-align:center">短</td><td style="text-align:center">远</td></tr></tbody></table></div><p>许多信道并不能传输低频分量或直流分量。为解决这个问题，必须对基带信号进行<strong>调制</strong>。</p><h2 id="基带调制"><a href="#基带调制" class="headerlink" title="基带调制"></a>基带调制</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>又称<strong>编码</strong>。</p><p>仅对基带信号的<strong>波形进行变换</strong>，使其与信道特性相适应。</p><p>变换后的信号仍为<strong>基带信号</strong>。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>不归零制</li><li>归零制</li><li><strong>曼彻斯特编码</strong></li><li>差分曼彻斯特编码</li></ul><h2 id="载波调制"><a href="#载波调制" class="headerlink" title="载波调制"></a>载波调制</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>使用<strong>载波</strong>，把基带信号的<strong>频率范围搬移到较高的频段</strong>，并转换为模拟信号。</p><p>经过载波调制后的信号称为<strong>带通信号</strong>，带通指仅在一段频率范围内能够通过信道。</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul><li>调幅</li><li>调频</li><li>调相</li></ul><h1 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h1><p>信道指向某一个方向传送信息的媒体。</p><p>一条通信线路往往包含一条发送信道和一条接收信道。</p><h1 id="三种通信基本方式"><a href="#三种通信基本方式" class="headerlink" title="三种通信基本方式"></a>三种通信基本方式</h1><p>从通信的双方信息交换的方式来看</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">单工通信</th><th style="text-align:center">半双工通信</th><th style="text-align:center">全双工通信</th></tr></thead><tbody><tr><td style="text-align:center">通信方向</td><td style="text-align:center">通信只能有一个方向</td><td style="text-align:center">双向交替通信</td><td style="text-align:center">双向同时通信</td></tr><tr><td style="text-align:center">信道数</td><td style="text-align:center">一条</td><td style="text-align:center">两条</td><td style="text-align:center">两条</td></tr></tbody></table></div><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p>信号在信道上传输会失真。</p><p>从概念上讲，限制码元在信道上的传输速率的因素有两个：</p><h2 id="信道能够通过的频率范围"><a href="#信道能够通过的频率范围" class="headerlink" title="信道能够通过的频率范围"></a>信道能够通过的频率范围</h2><p><strong>码间串扰</strong>：接收端收到的信号波形失去了码元之间的清晰界限。</p><p><strong>奈氏准则</strong>：指出在假定的理想条件下，为避免码间串扰，码元的传输速率的上限值。</p><p><strong>在任何信道中，码元的传输速率是有上限的，超过上限，就会出现严重的码间串扰问题。</strong></p><p><strong>波特</strong>：Baud，码元传输速率的单位。1 Baud即每秒传送1个码元。</p><h2 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h2><p><strong>信噪比</strong>就是信号平均功率$S$和噪声平均功率$N$之比，常记为$S/N$，并用分贝$dB$作为度量单位。</p><script type="math/tex; mode=display">信噪比(dB)=10log_{10}^{S/N}(dB)</script><p><strong>香农公式</strong>指出，信道的<strong>极限信息传输速率</strong>$C$是：</p><script type="math/tex; mode=display">C=W\ log_2^{1+S/N}(bit/s)</script><p>式中，$W$为信道的带宽，单位为$Hz$。</p><p>香农公式表明：<strong>信道的带宽或信噪比越大，信道的极限传输速率就越大。</strong></p><h2 id="其他因素"><a href="#其他因素" class="headerlink" title="其他因素"></a>其他因素</h2><p>对于频带宽度、信噪比和码元传输速率已确定的信道，我们可以通过<strong>让每一个码元携带更多的信息量</strong>提高信息的传输速率。</p><p><strong>码元个数不是越多越好。</strong></p><p>如果每个码元携带的信息量$n$越大，即码元取值的数量越多，则在接收端进行调解时<strong>要正确识别每一个码元就越困难</strong>，导致出错率增加。</p><h1 id="奈氏准则和香农公式的主要区别"><a href="#奈氏准则和香农公式的主要区别" class="headerlink" title="奈氏准则和香农公式的主要区别"></a>奈氏准则和香农公式的主要区别</h1><ul><li><p>奈氏准则指出了，<strong>码元传输速率</strong>是受限的，不能任意提高，否则在接收端就无法正确判定码元是1还是0（因为有码元之间的相互干扰）。</p><p>  奈氏准则是在理想条件下推导出的。在实际条件下，最高码元传输速率要比理想条件下得出的数值还要小些。电信工程技术人员的任务就是要在实际条件下，寻找出较好的传输码元波形，将比特转换为较为合适的传输信号。</p><p>  需要注意的是，<strong>奈氏准则并没有对信息传输速率给出限制</strong>。<strong>要提高信息传输速率就必须使每一个传输的码元能够代表许多个比特的信息</strong>。这就需要很好的编码技术。</p></li><li><p>香农公式给出了<strong>信息传输速率</strong>的极限，即对于一定的传输带宽（以赫兹为单位）和一定的信噪比，信息传输速率的上限就确定了。这个极限是不能够突破的。<strong>要想提高信息的传输速率，或者必须设法提高传输线路的带宽，或者必须设法提高所传信号的信噪比，此外没有其他任何办法</strong>。</p><p>  香农公式告诉我们，若要得到无限大的信息传输速率，只有两个办法：要么使用无限大的传输带宽，要么使信号的信噪比无限大（即采用没有噪声的传输信道或使用无限大的发送功率）。当然这都是不可能的。</p></li></ul><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p>物理层的“连接”不一定是使用导线的“连接”，比如无线连接就不是使用导线的“连接”。</p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p><strong>复用</strong>：允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><h2 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h2><p>所有用户在<strong>同一时间</strong>占用<strong>不同的带宽资源</strong>。</p><p>用户在分配到一定的频带后，在通信过程中<strong>自始至终都占用</strong>这个频带。</p><ul><li><strong>波分复用</strong></li></ul><p>就是光的频分复用。</p><h2 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h2><p>又称同步时分复用。考过图2-15。</p><p>所用用户在<strong>不同时间</strong>内用<strong>同样的频度带宽</strong>。</p><p>由于计算机数据的突发性质，时分复用时一个用户对已经分配到的子信道的利用率一般是不高的。</p><ul><li><strong>统计时分复用</strong></li></ul><p>与同步时分复用相比，它按需动态分配时间。</p><h2 id="频分复用和时分复用的优缺点"><a href="#频分复用和时分复用的优缺点" class="headerlink" title="频分复用和时分复用的优缺点"></a>频分复用和时分复用的优缺点</h2><ul><li><p>优点</p><p>  技术比较成熟</p></li><li><p>缺点</p><p>  不够灵活</p></li></ul><h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>又称码分多址。</p><p>各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p><p>每个用户<strong>可以</strong>在<strong>同样的时间</strong>使用<strong>同样的频带</strong>进行通信。</p><h3 id="码片定义"><a href="#码片定义" class="headerlink" title="码片定义"></a>码片定义</h3><p>每一个比特用m个比特表示，这m个比特称为<strong>码片</strong>。</p><p>每个用户发送的是码片（代表1）、码片反码（代表0）或不发送。</p><p>接收方用想接收的发送方的码片与收到的信号进行规格化內积。</p><p>若规格化內积为1，则发送方发送了码片，即1；若为-1，则发送方发送了码片反码，即0。</p><h3 id="码片特点"><a href="#码片特点" class="headerlink" title="码片特点"></a>码片特点</h3><p>內积：同位相乘之和</p><p>规格化內积：內积除以位数</p><p>正交：內积为0</p><ul><li>分配给每个用户的码片必须各不相同，并且相互正交。</li><li>某用户码片与其他用户码片（或码片的反码）內积为0。</li><li>码片与自身规格化內积为1。</li><li>码片与自身反码规格化內积为-1。</li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;物理层主要解决的问题&quot;&gt;&lt;a href=&quot;#物理层主要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;物理层主要解决的问题&quot;&gt;&lt;/a&gt;物理层主要解决的问题&lt;/h1&gt;&lt;p&gt;进行&lt;strong&gt;信号和比特流的转换&lt;/strong&gt;，实现&lt;strong
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-第一章复习</title>
    <link href="https://chouxianyu.github.io/2019/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/06/28/计算机网络-第一章复习/</id>
    <published>2019-06-28T13:33:39.000Z</published>
    <updated>2019-06-28T13:35:19.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Internet如何翻译"><a href="#Internet如何翻译" class="headerlink" title="Internet如何翻译"></a>Internet如何翻译</h1><p>有两种翻译方式：</p><h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><p>国家推荐</p><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><p>现实中大多使用这个词。</p><h1 id="互联网的重要特点"><a href="#互联网的重要特点" class="headerlink" title="互联网的重要特点"></a>互联网的重要特点</h1><h2 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h2><p>世界各地的用户都可以交换信息，好像彼此之间直接连通一样。</p><h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>即资源共享，如信息、软件、硬件共享等。</p><h1 id="两个认识互联网的角度"><a href="#两个认识互联网的角度" class="headerlink" title="两个认识互联网的角度"></a>两个认识互联网的角度</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>课本是从这个角度来讲解的，我们从这个角度来学习。</p><h1 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h1><p>定义：计算机网络由若干<strong>结点</strong>（node）和连接这些结点的<strong>链路</strong>（link）组成。</p><h2 id="结点"><a href="#结点" class="headerlink" title="结点"></a>结点</h2><p>可以是计算机、集线器、路由器、交换机等。</p><h2 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h2><h1 id="互连网与互联网"><a href="#互连网与互联网" class="headerlink" title="互连网与互联网"></a>互连网与互联网</h1><h2 id="互连网"><a href="#互连网" class="headerlink" title="互连网"></a>互连网</h2><p>internet</p><ul><li><p>定义</p><p>  通用名词，泛指通过路由器将网络连起来形成的网络。</p></li><li><p>其中网络间的通信协议可以是<strong>任意</strong>的。</p></li><li><p>互连不仅是物理上，还要通过软件连接。</p></li></ul><h2 id="互联网-1"><a href="#互联网-1" class="headerlink" title="互联网"></a>互联网</h2><p>Internet</p><ul><li><p>定义</p><p>  互联网是全球最大的、开放的、由众多网络相互连接而成的特定互连网。</p></li><li><p>采用<strong>TCP/IP协议族</strong>作为通信规则。</p></li><li><p>前身是美国的ARPANET。</p></li></ul><h1 id="三层ISP结构"><a href="#三层ISP结构" class="headerlink" title="三层ISP结构"></a>三层ISP结构</h1><p>ISP，互联网服务提供者。</p><p>互联网现在采用三层ISP结构。</p><h2 id="本地ISP"><a href="#本地ISP" class="headerlink" title="本地ISP"></a>本地ISP</h2><h2 id="地区ISP"><a href="#地区ISP" class="headerlink" title="地区ISP"></a>地区ISP</h2><h2 id="主干ISP"><a href="#主干ISP" class="headerlink" title="主干ISP"></a>主干ISP</h2><h1 id="IXP"><a href="#IXP" class="headerlink" title="IXP"></a>IXP</h1><p>允许两个网络直接相连并交换信息。</p><h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><h2 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h2><p>与网络相连的计算机常称为主机。</p><ul><li><p>定义</p><p>  连接在互联网上的所有主机。</p></li><li><p>由用户（个人、公司）控制。</p></li><li><p><strong>进行通信和资源共享</strong>。</p></li></ul><h3 id="主机通信方式"><a href="#主机通信方式" class="headerlink" title="主机通信方式"></a>主机通信方式</h3><ul><li><p>对象</p><p>  计算机通信的对象是应用层中的<strong>进程</strong>。</p></li></ul><h4 id="客户-服务器方式"><a href="#客户-服务器方式" class="headerlink" title="客户/服务器方式"></a>客户/服务器方式</h4><p>即C/S方式。</p><ul><li><p>客户和服务器指通信中所涉及的两个应用<strong>进程</strong>。</p></li><li><p>客户/服务器模式描述的是进程之间服务和被服务的<strong>关系</strong>。</p><p>  客户是服务请求方，服务器是服务提供方。</p></li><li><p>客户和服务器都要使用互联网核心部分提供的服务。</p></li><li><p><strong>客户必须知道服务器程序的地址，服务器不需要知道客户程序的地址。</strong></p></li></ul><h4 id="对等连接方式"><a href="#对等连接方式" class="headerlink" title="对等连接方式"></a>对等连接方式</h4><p>对等连接（peer to peer），P2P。</p><ul><li><p>定义</p><p>  两台主机在通信时并不区分谁是客户或服务器。</p></li><li><p>本质上还是C/S方式。</p></li></ul><h2 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h2><ul><li><p>定义</p><p>  由大量<strong>网络</strong>和连接这些网络的<strong>路由器</strong>组成。</p></li><li><p>由ISP控制。</p></li><li><p>为边缘部分提供服务。</p></li></ul><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><p>核心部分的工作方式就是路由器的工作方式。</p><ul><li>存储转发</li><li>路由器间不断交换路由信息</li></ul><h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><ul><li>严格来讲，分组交换也是可以面向连接的</li><li>现在用的是分组交换</li></ul><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><ul><li><p>并不是真正意义上的交换</p></li><li><p>主要特点：<strong>面向连接</strong></p><ul><li>建立连接、通信、释放连接</li><li><strong>在通信的全部时间内，通信的两个用户始终占用端到端的通信资源。</strong></li></ul></li><li><p>优点</p><p>  静态分配传输带宽，只要建立了连接，网络发生拥塞也不会影响通信质量。</p></li><li><p>缺点</p><ul><li>计算机通信时，数据具有突发性，线路上真正用来传送数据的时间往往不到10%，造成通信线路资源的浪费。</li><li>如果通信链路是由多段链路组成的，只要有一段链路出现故障，就不能通信。</li></ul></li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><ul><li><p>主要特点：采用<strong>存储转发</strong>技术</p><ul><li>将报文拆分成多个分组，<strong>加上头部</strong></li><li>通过路由器以分组为单位进行存储转发</li><li>在接收端将分组组装成报文</li></ul></li><li><p>优点</p><ul><li><p>高效</p><p>  动态分配传输带宽，<strong>逐段占用通信链路</strong>。</p></li><li><p>灵活</p><p>  为每一个分组独立地选择最合适的转发路由。</p></li><li><p>迅速</p><p>  <strong>不需要建立连接就可以向其他主机发送分组</strong>。</p></li><li><p>可靠</p><ol><li><strong>保证可靠性的网络协议、分布式多路由的分组交换网</strong>使网络有很好的生存性。</li><li>某个结点或者链路出现故障时，<strong>分组传送的路由可以自适应地动态改变</strong>。</li></ol></li></ul></li><li><p>缺点</p><ul><li>存储转发时需排队，造成一定<strong>时延</strong>。当网络拥塞非常严重时，整个网络也可能会瘫痪。</li><li>分组的首部造成一定<strong>开销</strong>。</li></ul></li></ul><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><ul><li>主要特点：<ul><li>采用存储转发技术，但报文不分组</li><li><strong>适用于间歇式轻负载</strong></li></ul></li></ul><p>与分组交换相比：</p><ul><li>优点<ul><li>省去了划分分组的步骤</li><li>省去了接收端组装分组的步骤</li></ul></li><li>缺点<ul><li>灵活性不如分组交换</li></ul></li></ul><h2 id="哪个交换方式最好？"><a href="#哪个交换方式最好？" class="headerlink" title="哪个交换方式最好？"></a>哪个交换方式最好？</h2><p>不能说哪个方式一定好或坏</p><ul><li>若需<strong>连续传送大量数据</strong>，且其<strong>发送时间远大于连接建立时间</strong>，则电路交换的传输速率较快。</li><li>报文交换和分组交换不需要预先分配传输带宽，在传送突发数据时可提高整个网络的<strong>信道利用率</strong>。</li><li>由于一个分组的长度远远小于整个报文的长度，因此分组交换比报文交换的时延小；同时也具有更好的灵活性。</li></ul><h1 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><ul><li><p>也称为数据率（data rate）或比特率（bit rate）。</p></li><li><p>定义</p><p>  连接在计算机网络上的<strong>主机</strong>在数字<strong>信道</strong>上<strong>传输数据</strong>的速率。</p></li><li><p>单位是b/s，kb/s，Mb/s，Gb/s</p></li></ul><p>==信道：一个发送端，一个接收端==</p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><ul><li><p>定义</p><p>  数字信道所能传输的<strong>最高</strong>速率。</p></li><li><p>毫无疑问，带宽单位和速率一样。</p></li></ul><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><ul><li><p>定义</p><p>  <strong>单位时间内</strong>通过某个网络（或信道、接口）的<strong>实际的数据量</strong>。</p></li><li><p>单位是b，Mb等。</p></li></ul><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>$总时延=发送时延+传播时延+处理时延+排队时延$</p><ul><li><p>一般来说，小时延的网络优于大时延的网络</p><p>  一个低速率、小时延的网络可以优于一个高速率、大时延的网络。</p></li><li><p>在总时延中，哪一种时延占主导地位，必须具体分析。</p></li></ul><h3 id="发送时延"><a href="#发送时延" class="headerlink" title="发送时延"></a>发送时延</h3><p>又叫传输时延，发送速率又叫传输速率。</p><p>$发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}$</p><p>可见发送时延并非固定不变。</p><p>对于高速网络链路，我们提高的仅仅是数据的发送速率，而不是比特在链路上的传播速率。</p><h3 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h3><p>$传播时延=\frac{信道长度(m)}{电磁波在信道上的传播速率(m/s)}$</p><p><strong>光纤与铜线相比降低了发送时延，光纤的传播速度反而不如铜线传播速度快</strong>。</p><h3 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h3><p>主机或路由器在收到分组时要花费一定时间进行处理。</p><h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h3><p>分组在路由器中可能要排队。</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积又称为以比特为单位的链路长度。</p><p>$时延带宽积=传播时延\times带宽$</p><p>时延带宽积反映传输时线路上数据的多少，即<strong>线路上的比特数</strong>。</p><p>传播时延决定线路的长度</p><p>带宽决定每位的长度</p><h2 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h2><p>定义：双向交互一次所需的时间。</p><p>从发送方发送数据开始，到发送方收到接收方的确认。</p><p><code>ping www.baidu.com</code></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ul><li><p><strong>信道利用率并非越高越好</strong></p><p>  信道或网络的<strong>利用率</strong>过高会产生非常大的<strong>时延</strong>。</p></li></ul><p>令$D_0$表示网络空闲时的时延，$D$表示网络当前的时延，$U$为网络利用率，</p><p>则$D=\frac{D_0}{1-U}$。</p><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>$信道利用率=\frac{有数据通过时间}{总时间}$</p><h3 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h3><p>定义：信道利用率加权平均值</p><h1 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h1><h2 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h2><ul><li><p>相互通信的两个计算机系统必须高度协调，而这种协调是十分复杂的。</p><p>  分层可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</p></li></ul><h2 id="三种分层方法"><a href="#三种分层方法" class="headerlink" title="三种分层方法"></a>三种分层方法</h2><p>OSI是法律上的国际标准，TCP/IP是事实上的国际标准。</p><p><a href="https://i.loli.net/2019/06/17/5d06f3764b59848351.jpg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/06/17/5d06f3764b59848351.jpg" alt="计算机网络体系结构.jpg"></a></p><ul><li><p>七层协议：OSI</p><p>  <strong>概念清楚</strong>，理论较为完整。</p><p>  但既复杂又不实用。</p></li><li><p>四层协议：TCP/IP </p><p>  简洁，<strong>得到广泛应用</strong>。</p><p>  实质内容只有上三层，网络接口层并没有什么具体内容。</p></li><li><p>五层协议</p><p>  综合七层协议和四层协议的优点：既简洁又能将概念阐述清楚。</p></li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>5个</p><ul><li><p>各层间是独立的</p><p>  <strong>每一层只实现一种相对独立的功能</strong>，上层仅知道下层的接口，而不需知道其如何实现。</p></li><li><p>灵活性好</p><p>  只要层间接口关系保持不变，可以对各层进行修改。</p></li><li><p>结构上可分割开</p><p>  各层都可以采用最<strong>合适</strong>的技术实现</p></li><li><p>易于实现和维护</p><p>  整个系统被分解为若干个<strong>相对独立的子系统</strong>，每个子系统都易于实现和维护</p></li><li><p>能促进标准化工作</p><p>  每一层的功能及其所提供的服务都已有了<strong>精确的说明</strong></p></li></ul><h2 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h2><p>分层应使每一层的<strong>功能非常明确</strong>，所以层次的划分并不容易。</p><p>层数太少，会使每一层的协议太复杂；</p><p>层数太多，会使各层在功能上有重叠，造成额外开销。</p><h2 id="对等层"><a href="#对等层" class="headerlink" title="对等层"></a>对等层</h2><p>在OSI参考模型中，位于同一水平行（同一层）上的系统构成了OSI的对等层。</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p><strong>定义</strong>：<strong>在ISO/OSI参考模型中，同层对等实体间信息交换时必须遵守的规则。</strong></p><p>每层都有协议，有的层只能有一个协议，有的层可以有多个协议。</p><p>网络协议主要由以下<strong>三个要素</strong>构成：</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>数据与控制信息的<strong>结构和格式</strong></p><h2 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h2><p>需要发出<strong>何种</strong>控制信息，完成<strong>何种</strong>动作以及做出<strong>何种</strong>响应</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p><strong>事件实现顺序</strong>的详细说明</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Internet如何翻译&quot;&gt;&lt;a href=&quot;#Internet如何翻译&quot; class=&quot;headerlink&quot; title=&quot;Internet如何翻译&quot;&gt;&lt;/a&gt;Internet如何翻译&lt;/h1&gt;&lt;p&gt;有两种翻译方式：&lt;/p&gt;
&lt;h2 id=&quot;因特网&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="https://chouxianyu.github.io/2019/06/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>https://chouxianyu.github.io/2019/06/25/计算机网络概述/</id>
    <published>2019-06-25T12:28:43.000Z</published>
    <updated>2019-06-25T12:29:48.945Z</updated>
    
    <content type="html"><![CDATA[<p>之前看韩利辉计网视频的笔记。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>覆盖范围小 自己花钱买设备 带宽固定 自己维护</p><p>比如学院的局域网：</p><p>机房的汇聚层交换机连接各教室的交换机，教室的接入层交换机连接各电脑。</p><p>两两之间的网线不超过100米，10M 100M 1000M</p><p>接入层交换机带宽为百兆，每个口都是百兆。汇聚层交换机带宽要比接入层交换机大。</p><p>规范的局域网应该是分层的</p><h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>超过100米，比如电话线拨号上网，带宽不固定，花钱买带宽、维护等服务</p><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p>由众多ISP组成，ISP是Internet Service Provider，因特网服务提供商。</p><p>各提供商都有自己的机房，对网民提供Internet连接。</p><p>各提供商之间最多有一根线相连，所以我用移动的网访问电信的服务器可能会很慢。</p><p>有的网站会在各运营商的机房都买一个服务器，或者双线机房（机房里有两种运营商）。</p><h1 id="IP和MAC"><a href="#IP和MAC" class="headerlink" title="IP和MAC"></a>IP和MAC</h1><p>计算机有一个IP地址。</p><p>网段。</p><p>子网掩码，告诉计算机哪儿是网络部分，哪儿是主机部分。</p><p>路由器作用：负责在不同网段转发数据</p><p>路由器的端口也有MAC地址</p><p>路由器的端口相当于计算机的一个网卡，也有地址</p><p>网关：告诉计算机去哪个网段，==指向路由器==。</p><p>网卡：MAC地址（物理地址，唯一），出厂已经固定在网卡里，48位二进制。</p><p>MAC和IP分别是物理和逻辑上的概念</p><p>计算机上发数据包给DNS服务器（计算机配的有），DNS将域名解析成IP，返给计算机</p><h1 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h1><p>数据、源IP、目标IP</p><p>就像一封信</p><p>计算机数据包最大1500字节。</p><p>数据一次传不完的话，数据帧是有编号的。</p><h1 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h1><p>数据包加上源MAC、目标MAC，就是数据帧。</p><p>想把数据包传给目标IP，需要路由器，用MAC找到路由器。</p><p>然后路由器根据目标IP更新源MAC和目标MAC，最短路径。</p><p>数据帧传给交换机，交换机传给路由器，路由器给路由器，最后给交换机，交换机给计算机。</p><p>客户机：给我数据</p><p>服务器：好的，给你</p><p>客户机：已接收，给我下一个数据</p><p>服务器：好的，给你</p><p>服务器不知道客户机的MAC地址，可以知道客户机的IP。</p><p>为什么不能只用MAC标识电脑？</p><p>如果全球计算机都是用交换机连接的，不需要路由器，就可以只用MAC标识电脑。但这不可能。</p><p>网卡有缓存，发送缓存，接收缓存。</p><h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>7层，国际标准化组织分析计算机通讯得出的。</p><p>好处：</p><p>不同厂商生产设备可以一起用</p><p>各层较为独立，每一个模块有变化，不会影响另一个模块。这并不代表各层之间没有关系。</p><p>k层为k+1层提供服务。</p><p>分层的思想是使用网络的指导原则。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>所有能产生网络流量的程序，记事本就不是，QQ就是。</p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>在传输之前进行的东西。</p><p>比如在切割成数据包传输之前是否进行压缩、加密处理、编码</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>session，规定哪个服务器和客户机哪个窗口交互。</p><p>cmd中输入<code>netstat -n</code> 可以查看会话。</p><p>只要和其他计算机有数据传输，就会建立会话。我们就可以查到它。</p><p>通过查看会话 可以查木马。木马和病毒不一样。</p><p>输入<code>netstat -nb</code>可以会话是谁建立的。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>实现可靠传输、流量控制、不可靠传输。</p><p>可靠传输：超时重传 </p><p>流量控制：客户机给服务器一个数据包说慢点</p><p>不可靠传输：比如向DNS通过域名查IP，双方一个数据包就可以解决问题，这种通讯不需要建立会话，不需要给数据包编号。就不用超时重传，再来一次就好了。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>选择最佳路径、规划IP地址。</p><p>人工指定路径：通过静态路由</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>定义帧的开始和结束、透明传输、差错校验。</p><p>用特殊位表示开始和结束，看到开始标志就接收 看到结束标志就结束</p><p>启动密码子 终止密码子</p><p>透明传输：一部分数据和结束位一样，会在数据那里插入一个特殊的位，表明这不是真正的结束。接收端接收以后再把插入的位去掉。</p><p>差错检验：查出错误，但不会纠正错误，纠正是传输层做的</p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>定义网络设备接口标准、电气标准、如何在物理链路上传输得更快</p><p>接口标准：不同公司生产的网线、网卡都能使用</p><p>电气标准：比如用几伏电压代表1。</p><h1 id="OSI和网络排错"><a href="#OSI和网络排错" class="headerlink" title="OSI和网络排错"></a>OSI和网络排错</h1><p>应该从最底层开始查找。</p><h2 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h2><p>查看连接状态、查看发送和接受到的数据包大小。</p><h2 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>MAC地址冲突、ADSL欠费、网速没办法协商、计算机连接到错误的VLAN</p><h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2><p>配置了错误的IP地址、子网掩码、网关</p><p>路由器上没有到达目标网络的路由</p><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p>应用层在这儿指网络层之上的</p><p>应用程序配置错误</p><h1 id="OSI和网络安全"><a href="#OSI和网络安全" class="headerlink" title="OSI和网络安全"></a>OSI和网络安全</h1><h2 id="物理层-2"><a href="#物理层-2" class="headerlink" title="物理层"></a>物理层</h2><p>交换机不用的口 把网线拔掉</p><h2 id="数据链路层-2"><a href="#数据链路层-2" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>ADSL账号密码、无线AP、VLAN、交换机端口绑定MAC地址</p><h2 id="网络层-2"><a href="#网络层-2" class="headerlink" title="网络层"></a>网络层</h2><p>在路由器上使用ACL控制数据包流量、Windows高级防火墙</p><h2 id="应用层-2"><a href="#应用层-2" class="headerlink" title="应用层"></a>应用层</h2><p>应用层在这儿指网络层之上的。</p><p>开发的应用程序没漏洞</p><p>SQL注入</p><h1 id="OSI和TCP-IP协议"><a href="#OSI和TCP-IP协议" class="headerlink" title="OSI和TCP/IP协议"></a>OSI和TCP/IP协议</h1><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前看韩利辉计网视频的笔记。&lt;/p&gt;
&lt;h1 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h1&gt;&lt;h2 id=&quot;局域网&quot;&gt;&lt;a href=&quot;#局域网&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>相对论基础</title>
    <link href="https://chouxianyu.github.io/2019/06/22/%E7%9B%B8%E5%AF%B9%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://chouxianyu.github.io/2019/06/22/相对论基础/</id>
    <published>2019-06-22T06:22:09.000Z</published>
    <updated>2019-06-22T06:22:33.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="狭义相对论两条基本原理"><a href="#狭义相对论两条基本原理" class="headerlink" title="狭义相对论两条基本原理"></a>狭义相对论两条基本原理</h1><p>狭义相对论基于惯性参考系</p><h2 id="相对性原理"><a href="#相对性原理" class="headerlink" title="相对性原理"></a>相对性原理</h2><p>物理定律在一切惯性参考系中都具有相同的数学表达形式，也就是所有<strong>惯性系</strong>对于描述物理现象都是等价的。</p><ul><li>狭义相对论原理是伽利略力学相对性原理的推广</li><li>光的传播不需要介质</li></ul><h2 id="光速不变原理"><a href="#光速不变原理" class="headerlink" title="光速不变原理"></a>光速不变原理</h2><p>在彼此相对做匀速直线运动的任一<strong>惯性参考系</strong>中，所测得的光在真空中的传播速度都是相等的。</p><ul><li>真空中的光速是个恒量</li><li>物体的速度不能超过真空中的光速</li></ul><h1 id="相对论速度变换公式"><a href="#相对论速度变换公式" class="headerlink" title="相对论速度变换公式"></a>相对论速度变换公式</h1><script type="math/tex; mode=display">v=\frac{v'+u}{1+\frac{v'u}{c^2}}</script><ul><li>$v’$：$K’$系中的速度</li><li>$v$：$K$系中的速度</li><li>$u$：两坐标系的速度差</li><li>$\beta=\frac{u}{c}$</li></ul><h1 id="狭义相对论的时空观"><a href="#狭义相对论的时空观" class="headerlink" title="狭义相对论的时空观"></a>狭义相对论的时空观</h1><h2 id="“同时”的相对性"><a href="#“同时”的相对性" class="headerlink" title="“同时”的相对性"></a>“同时”的相对性</h2><p>在某个惯性系中同时发生的两个事件，在另一相对它运动的惯性系中，并<strong>不一定同时发生</strong>，这一结论叫做<strong>同时的相对性</strong>。</p><script type="math/tex; mode=display">t_2'-t_1'=\frac{\frac{u}{c^2}(x_1-x_2)}{\sqrt{1-\beta^2}}</script><p><strong>只有当两个事件发生在同一地点时，“同时”才有绝对意义。</strong></p><h2 id="时间延缓"><a href="#时间延缓" class="headerlink" title="时间延缓"></a>时间延缓</h2><p>又叫时间膨胀或时钟变慢</p><script type="math/tex; mode=display">t=\frac{t_0}{\sqrt{1-\beta^2}}</script><ul><li>$t_0$：固有时，相对于过程发生的地点为<strong>静止的参考系</strong>中测得的时间间隔。</li><li>$t$：运动时，大于固有时。</li></ul><h2 id="长度收缩"><a href="#长度收缩" class="headerlink" title="长度收缩"></a>长度收缩</h2><script type="math/tex; mode=display">l=l_0\sqrt{1-\beta^2}</script><ul><li>$l_0$：固有长度，观察者相对于物体静止时测得的物体长度。</li><li>$l$：运动长度，小于固有长度</li></ul><h2 id="相对性和绝对性"><a href="#相对性和绝对性" class="headerlink" title="相对性和绝对性"></a>相对性和绝对性</h2><p>在相对论时空中，运动的描述、时空的量度都是<strong>相对</strong>的，但因果关系是<strong>绝对</strong>的。</p><h1 id="狭义相对论动力学基础"><a href="#狭义相对论动力学基础" class="headerlink" title="狭义相对论动力学基础"></a>狭义相对论动力学基础</h1><h2 id="质速关系式"><a href="#质速关系式" class="headerlink" title="质速关系式"></a>质速关系式</h2><script type="math/tex; mode=display">m=\frac{m_0}{\sqrt{1-(\frac{v}{c})^2}}</script><ul><li>$m_0$：静质量</li><li>$m$：动质量</li></ul><p>光子的静质量为$0$，速度为$c$</p><p>质速关系式反映了物体与运动的不可分割性</p><h2 id="质能关系式"><a href="#质能关系式" class="headerlink" title="质能关系式"></a>质能关系式</h2><script type="math/tex; mode=display">E_0=m_0c^2</script><script type="math/tex; mode=display">E=mc^2</script><script type="math/tex; mode=display">E_k=E-E_0</script><ul><li>$E_0$：静能</li><li>$E$：运动时的总能量（静能和动能之和）</li><li>$E_k$：相对论动能</li></ul><h2 id="动量能量关系式"><a href="#动量能量关系式" class="headerlink" title="动量能量关系式"></a>动量能量关系式</h2><script type="math/tex; mode=display">E^2=c^2p^2+{E_0}^2</script><h1 id="光速"><a href="#光速" class="headerlink" title="光速"></a>光速</h1><script type="math/tex; mode=display">3\times10^8\ m/s</script><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;狭义相对论两条基本原理&quot;&gt;&lt;a href=&quot;#狭义相对论两条基本原理&quot; class=&quot;headerlink&quot; title=&quot;狭义相对论两条基本原理&quot;&gt;&lt;/a&gt;狭义相对论两条基本原理&lt;/h1&gt;&lt;p&gt;狭义相对论基于惯性参考系&lt;/p&gt;
&lt;h2 id=&quot;相对性原理&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="物理" scheme="https://chouxianyu.github.io/tags/%E7%89%A9%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-标志位设置</title>
    <link href="https://chouxianyu.github.io/2019/06/22/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E6%A0%87%E5%BF%97%E4%BD%8D%E8%AE%BE%E7%BD%AE/"/>
    <id>https://chouxianyu.github.io/2019/06/22/汇编语言-标志位设置/</id>
    <published>2019-06-22T06:11:04.000Z</published>
    <updated>2019-06-22T06:11:26.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="所有标志位"><a href="#所有标志位" class="headerlink" title="所有标志位"></a>所有标志位</h1><p><code>MOV</code>、<code>PUSH</code>、<code>POP</code>、<code>NOT</code>、<code>条件转移指令</code>、<code>非条件转移指令</code>、<code>类型转换指令</code>不影响标志位</p><h1 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h1><ul><li><p><code>INC</code>、<code>DEC</code>不影响<code>CF</code></p></li><li><p><code>ADD</code></p><p>  若最高有效位向高位有进位，<code>CF=1</code>；否则<code>CF=0</code></p></li><li><p><code>SUB</code></p><p>  作为无符号数运算时，若减数大于被减数，有借位，<code>CF=1</code>；否则<code>CF=0</code></p></li><li><p>移位指令</p><p>  根据各指令移位特性，设置<code>CF</code></p></li><li><p><code>NEG</code></p><p>  操作数为0，则<code>CF=0</code>；否则<code>CF=1</code></p></li><li><p><code>NOT</code>以外的逻辑运算指令</p><p>  使<code>CF=0</code></p></li></ul><h1 id="OF"><a href="#OF" class="headerlink" title="OF"></a>OF</h1><ul><li><p><code>ADD</code></p><p>  若两数同号，而结果与操作数符号相反，则<code>OF=1</code>；否则<code>OF=0</code></p></li><li><p><code>SUB</code></p><p>  若两数符号相反，结果与减数符号相同，则<code>OF=1</code>；否则<code>OF=0</code></p></li><li><p><code>NOT</code>以外的逻辑运算指令</p><p>  使<code>OF=0</code></p></li></ul><h1 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h1><ul><li>在指令影响<code>SF</code>的情况下，结果（二进制）最高位为0，则<code>SF=0</code>；否则<code>SF=1</code></li><li>移位指令可影响<code>SF</code></li></ul><h1 id="ZF"><a href="#ZF" class="headerlink" title="ZF"></a>ZF</h1><ul><li>移位指令可影响<code>ZF</code></li><li>结果是0，<code>ZF=1</code>；否则，<code>ZF=0</code></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;所有标志位&quot;&gt;&lt;a href=&quot;#所有标志位&quot; class=&quot;headerlink&quot; title=&quot;所有标志位&quot;&gt;&lt;/a&gt;所有标志位&lt;/h1&gt;&lt;p&gt;&lt;code&gt;MOV&lt;/code&gt;、&lt;code&gt;PUSH&lt;/code&gt;、&lt;code&gt;POP&lt;/code&gt;、&lt;code&gt;
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-中断</title>
    <link href="https://chouxianyu.github.io/2019/06/22/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%B8%AD%E6%96%AD/"/>
    <id>https://chouxianyu.github.io/2019/06/22/汇编语言-中断/</id>
    <published>2019-06-22T06:05:29.000Z</published>
    <updated>2019-06-22T06:16:16.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据传送方式"><a href="#数据传送方式" class="headerlink" title="数据传送方式"></a>数据传送方式</h1><h2 id="程序控制方式"><a href="#程序控制方式" class="headerlink" title="程序控制方式"></a>程序控制方式</h2><h2 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h2><h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><h1 id="中断传送方式"><a href="#中断传送方式" class="headerlink" title="中断传送方式"></a>中断传送方式</h1><p>避免因反复查询外部设备的状态而浪费时间，从而提高CPU的效率。</p><h2 id="非屏蔽中断"><a href="#非屏蔽中断" class="headerlink" title="非屏蔽中断"></a>非屏蔽中断</h2><p>非屏蔽中断不受中断允许标志<code>IF</code>的屏蔽，系统中只能有一个非屏蔽中断，其中断类型号为2。</p><h2 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h2><ol><li><p><code>PUSH (FLAGS)</code></p></li><li><p><code>IF&lt;-0</code></p><p> <code>TF&lt;-0</code></p><p> <code>AC&lt;-0</code></p></li><li><p><code>PUSH (CS)</code></p><p> <code>PUSH (IP)</code></p></li><li><p><code>(IP)&lt;-(N*4)</code></p><p> <code>(CS)&lt;-(N*4+2)</code></p></li></ol><h2 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h2><p><code>INT</code>，不给中断号的话，默认是3号中断</p><p><code>STI</code>，设置中断允许位（<code>IF=1</code>）</p><p><code>CLI</code>，清除中断允许位（<code>IF=0</code>）</p><h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p>各类型中断处理程序的入口地址表，其存放在内存低位处，每项占用4个字节，低位是<code>(IP)</code>，高位是<code>(CS)</code>。</p><p>每类中断向量的偏移地址可由中断类型号N乘以4计算出来。</p><h2 id="子程序与中断的区别"><a href="#子程序与中断的区别" class="headerlink" title="子程序与中断的区别"></a>子程序与中断的区别</h2><p><strong>两者实现机制不同</strong></p><ul><li><p>中断程序是固定的(如果操作系统允许，程序员可以修改)；</p><p>  而子程序是程序员动态编写的。</p></li><li><p><code>call func</code>，根据<code>func</code>直接找到子程序入口，根据需求修改<code>(IP)</code>和<code>(CS)</code>；</p><p>  而<code>int 21h</code>需要计算地址，通过中断向量表找到中断处理程序入口地址。</p></li></ul><h1 id="BIOS、DOS中断"><a href="#BIOS、DOS中断" class="headerlink" title="BIOS、DOS中断"></a>BIOS、DOS中断</h1><p>BIOS中断和DOS中断是两种特殊的中断。</p><p>BIOS比DOS更靠近硬件。</p><p>在某些情况下，既可选择DOS中断又可选择BIOS中断实现相应功能；某些情况下，必须使用BIOS才能实现相应的功能。</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol><li>将调用参数装入指定寄存器中</li><li>如需功能号，将其装入<code>AH</code></li><li>如需子功能号，将其装入<code>AL</code></li><li>按中断号调用DOS或BIOS中断，<code>INT 21H</code></li></ol><h1 id="DOS常用功能"><a href="#DOS常用功能" class="headerlink" title="DOS常用功能"></a>DOS常用功能</h1><h2 id="1号功能"><a href="#1号功能" class="headerlink" title="1号功能"></a>1号功能</h2><ul><li><p>功能号</p><p>  <code>(AH)=1</code></p></li><li><p>功能</p><p>  从键盘输入一个字符并回显在屏幕上</p></li><li><p>返回参数</p><p>  <strong><code>(AL)=字符</code></strong></p></li></ul><h2 id="2号功能"><a href="#2号功能" class="headerlink" title="2号功能"></a>2号功能</h2><ul><li><p>功能号</p><p>  <code>(AH)=2</code></p></li><li><p>功能</p><p>  显示一个字符（检验Ctrl_Break），光标随字符移动</p></li><li><p>调用参数</p><p>  <strong><code>(DL)=字符</code></strong></p></li></ul><h2 id="9号功能"><a href="#9号功能" class="headerlink" title="9号功能"></a>9号功能</h2><ul><li><p>功能号</p><p>  <code>(AH)=9</code></p></li><li><p>功能</p><p>  显示字符串，光标跟随字符移动</p></li><li><p>调用参数</p><p>  <strong><code>(DS):(DX)</code>为串地址，串必须以<code>$</code>结束</strong></p></li></ul><h2 id="0A号功能"><a href="#0A号功能" class="headerlink" title="0A号功能"></a>0A号功能</h2><ul><li><p>功能号</p><p>  <code>(AH)=0AH</code></p></li><li><p>功能</p><p>  输入字符到缓冲区，缓冲区第一个字节保存最大字符数，第二个字节保存实际输入的字符数</p></li><li><p>返回参数</p><p>  <strong><code>(DS):(DX)为缓冲区首址</code></strong></p></li></ul><h1 id="常用ASCII码"><a href="#常用ASCII码" class="headerlink" title="常用ASCII码"></a>常用ASCII码</h1><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">十六进制ASCII码</th></tr></thead><tbody><tr><td style="text-align:center">空格</td><td style="text-align:center"><code>20H</code></td></tr><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center"><code>30H</code></td></tr><tr><td style="text-align:center"><code>A</code></td><td style="text-align:center"><code>41H</code></td></tr><tr><td style="text-align:center"><code>a</code></td><td style="text-align:center"><code>61H</code></td></tr><tr><td style="text-align:center">换行</td><td style="text-align:center"><code>0AH</code></td></tr><tr><td style="text-align:center">回车(归位)</td><td style="text-align:center"><code>0DH</code></td></tr></tbody></table></div><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据传送方式&quot;&gt;&lt;a href=&quot;#数据传送方式&quot; class=&quot;headerlink&quot; title=&quot;数据传送方式&quot;&gt;&lt;/a&gt;数据传送方式&lt;/h1&gt;&lt;h2 id=&quot;程序控制方式&quot;&gt;&lt;a href=&quot;#程序控制方式&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-汇编语言程序格式</title>
    <link href="https://chouxianyu.github.io/2019/06/22/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E6%A0%BC%E5%BC%8F/"/>
    <id>https://chouxianyu.github.io/2019/06/22/汇编语言-汇编语言程序格式/</id>
    <published>2019-06-22T06:05:20.000Z</published>
    <updated>2019-06-22T06:16:31.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上机过程"><a href="#上机过程" class="headerlink" title="上机过程"></a>上机过程</h1><ol><li>编辑汇编源程序：<code>test.asm</code></li><li>编译：<code>masm test</code></li><li>链接：<code>link test</code></li><li>调试：<code>debug test.exe</code></li><li>运行：<code>test</code></li></ol><h1 id="汇编源程序组成"><a href="#汇编源程序组成" class="headerlink" title="汇编源程序组成"></a>汇编源程序组成</h1><ul><li>指令</li><li>伪操作</li><li>宏指令</li></ul><h1 id="段定义、assume、字符串定义"><a href="#段定义、assume、字符串定义" class="headerlink" title="段定义、assume、字符串定义"></a>段定义、assume、字符串定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">buffer dw &quot;HELLO&quot; </span><br><span class="line">buffer db &quot;HELLO&quot;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">main proc far</span><br><span class="line">assume ds:data,cs:code</span><br><span class="line">push ds</span><br><span class="line">    mov ax,0</span><br><span class="line">    push ax</span><br><span class="line"></span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">main endp</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h1 id="LABEL、DUP"><a href="#LABEL、DUP" class="headerlink" title="LABEL、DUP"></a>LABEL、DUP</h1><p>同一块内存可以具有<strong>不同的类型</strong>属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BYTE_ARRAY LABEL BYTE</span><br><span class="line">WORD_ARRAY DW 50 DUP(?)</span><br></pre></td></tr></table></figure><h1 id="EQU、"><a href="#EQU、" class="headerlink" title="EQU、="></a>EQU、=</h1><p>表达式赋值伪操作，给表达式赋一个名字，这个名字不占用内存，不允许重复定义</p><p>=也是赋值，但允许重复定义。</p><h1 id="地址计数器"><a href="#地址计数器" class="headerlink" title="地址计数器$"></a>地址计数器$</h1><p>当前正在汇编指令的偏移地址</p><h1 id="ORG"><a href="#ORG" class="headerlink" title="ORG"></a>ORG</h1><p>设置当前地址计数器的值</p><h1 id="数值回送操作符"><a href="#数值回送操作符" class="headerlink" title="数值回送操作符"></a>数值回送操作符</h1><h2 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h2><p>以字节数表示的类型</p><p>表达式是变量时</p><ul><li><code>DB</code>：1</li><li><code>DW</code>：2</li><li><code>DD</code>：4</li><li><code>DF</code>：6</li></ul><p>表达式是标号时</p><ul><li><code>NEAR</code>：-1</li><li><code>FAR</code>：-2</li></ul><p>表达式为常数时</p><ul><li>0</li></ul><h2 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH"></a>LENGTH</h2><p>使用DUP时，回送该变量的单元数</p><p>其他情况，回送1</p><h2 id="SIZE"><a href="#SIZE" class="headerlink" title="SIZE"></a>SIZE</h2><p>回送分配给该变量的字节数，<code>SIZE=LENGTH*TYPE</code></p><h2 id="OFFSET"><a href="#OFFSET" class="headerlink" title="OFFSET"></a>OFFSET</h2><p>回送变量或标号的偏移地址</p><h2 id="SEG"><a href="#SEG" class="headerlink" title="SEG"></a>SEG</h2><p>回送变量或标号的段地址</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;上机过程&quot;&gt;&lt;a href=&quot;#上机过程&quot; class=&quot;headerlink&quot; title=&quot;上机过程&quot;&gt;&lt;/a&gt;上机过程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;编辑汇编源程序：&lt;code&gt;test.asm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译：&lt;code&gt;masm tes
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-宏汇编</title>
    <link href="https://chouxianyu.github.io/2019/06/22/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%8F%E6%B1%87%E7%BC%96/"/>
    <id>https://chouxianyu.github.io/2019/06/22/汇编语言-宏汇编/</id>
    <published>2019-06-22T06:05:07.000Z</published>
    <updated>2019-06-22T06:16:25.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="与子程序比较"><a href="#与子程序比较" class="headerlink" title="与子程序比较"></a>与子程序比较</h1><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">子程序</td><td style="text-align:center">模块化，省内存，程序只占用一份存储空间</td><td style="text-align:center">保存及恢复寄存器、参数传递增加额外开销</td></tr><tr><td style="text-align:center">宏汇编</td><td style="text-align:center">参数传送简单</td><td style="text-align:center">每调用一次就展开一次，内存消耗大</td></tr></tbody></table></div><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">macroname macro [dummy parameter list]</span><br><span class="line">...</span><br><span class="line">endm</span><br></pre></td></tr></table></figure><h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>宏展开时，合并前后两个符号形成一个符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEAP MACRO COND,LAB</span><br><span class="line">J&amp;COND LAB</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="%"></a>%</h2><p>把跟在%之后的表达式的值转换成当前基数下的数。</p><h1 id="LOCAL伪操作"><a href="#LOCAL伪操作" class="headerlink" title="LOCAL伪操作"></a>LOCAL伪操作</h1><p>宏定义体内使用标号需要使用<code>LOCAL</code>伪操作，其必须是<code>MACRO</code>伪操作后的第一个语句，两者之间不允许有注释和分号标志。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;与子程序比较&quot;&gt;&lt;a href=&quot;#与子程序比较&quot; class=&quot;headerlink&quot; title=&quot;与子程序比较&quot;&gt;&lt;/a&gt;与子程序比较&lt;/h1&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th st
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>标志位设置</title>
    <link href="https://chouxianyu.github.io/2019/06/22/%E6%A0%87%E5%BF%97%E4%BD%8D%E8%AE%BE%E7%BD%AE/"/>
    <id>https://chouxianyu.github.io/2019/06/22/标志位设置/</id>
    <published>2019-06-22T06:04:47.000Z</published>
    <updated>2019-06-22T06:04:47.516Z</updated>
    
    <content type="html"><![CDATA[<hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://github.com/chouxianyu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@臭咸鱼&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://chouxianyu.github
      
    
    </summary>
    
    
  </entry>
  
</feed>
