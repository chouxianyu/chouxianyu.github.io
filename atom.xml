<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2019-06-05T11:42:12.632Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络-实验（三）ARP欺骗</title>
    <link href="https://chouxianyu.github.io/2019/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%89%EF%BC%89ARP%E6%AC%BA%E9%AA%97/"/>
    <id>https://chouxianyu.github.io/2019/06/05/计算机网络-实验（三）ARP欺骗/</id>
    <published>2019-06-05T11:41:40.000Z</published>
    <updated>2019-06-05T11:42:12.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>掌握常见ARP欺骗类型和手段</li><li>掌握ARP协议工作原理和格式</li><li>掌握防范ARP地址欺骗的方法和措施</li><li>掌握Sniffer Pro软件的使用</li></ol><h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ul><li><p>硬件</p><p>  交换机1 台、路由器1台、计算机数台</p></li><li><p>软件</p><p>  <code>Sinffer pro</code></p></li></ul><h1 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h1><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>ARP(Address Resolve Protocol)</code>，地址解析协议。</p><p><strong>用途</strong>：用于寻找和IP 地址相对应的MAC地址。</p><p><strong>ARP消息类型</strong>：</p><ul><li><p>ARP request</p><p>  即ARP请求分组，用于请求某IP主机的硬件地址。</p><p>  <strong>广播</strong>。</p></li><li><p>ARP response</p><p>  即ARP响应分组，用于指出某IP主机的硬件地址。</p><p>  单播。</p></li></ul><h3 id="ARP报文中各字段的意义"><a href="#ARP报文中各字段的意义" class="headerlink" title="ARP报文中各字段的意义"></a>ARP报文中各字段的意义</h3><ul><li><p>硬件类型</p><p>  以太网接口类型为1。</p></li><li><p>协议类型</p><p>  IP协议类型为080016。</p></li><li><p>操作</p><p>  ARP请求分组为1，ARP响应分组为2。</p></li><li><p>硬件地址长度</p><p>  MAC地址长度为6BH。</p></li><li><p>协议地址长度</p><p>  IP地址长度为4BH。</p></li><li><p><strong>源MAC地址</strong></p><p>  发送方的MAC地址。</p></li><li><p><strong>源IP地址</strong></p><p>  发送方的IP地址。</p></li><li><p><strong>目的MAC 地址</strong></p><p>  ARP 请求分组中该字段没有意义；ARP 响应分组中为接收方的MAC地址。</p></li><li><p><strong>目的IP 地址</strong></p><p>  ARP 请求分组中为请求解析的IP 地址；ARP 响应分组中为接收方的IP地址。</p></li></ul><h2 id="ARP欺骗原理"><a href="#ARP欺骗原理" class="headerlink" title="ARP欺骗原理"></a>ARP欺骗原理</h2><p><strong>ARP请求分组</strong>以<strong>广播</strong>形式发送，网络上的主机可以自主发送ARP应答消息；</p><p>当其他主机收到<strong>ARP响应分组</strong>时，不会检测该报文的真实性，直接将其记录在本地的MAC地址转换表。</p><p>就可以发送伪ARP响应分组，从而篡改本地的MAC地址表。</p><p>举例：</p><p>攻击者<strong>甲</strong>通过冒充某IP主机<strong>丙</strong>，给出错误的物理地址，并向另一主机<strong>乙</strong>单播一个ARP响应分组，这样<strong>乙</strong>接收到这个错误的IP与物理地址的映射，更新了ARP缓存表。</p><p>之后，主机<strong>乙</strong>使用ARP缓存表中该项时，则会出现错误。</p><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="设置账户"><a href="#设置账户" class="headerlink" title="设置账户"></a>设置账户</h2><p>控制面板——用户账户——设置用户名为<code>ligong</code>，并设置密码。</p><h2 id="设置FTP站点"><a href="#设置FTP站点" class="headerlink" title="设置FTP站点"></a>设置FTP站点</h2><p>控制面板——Internet信息服务——FTP站点——硬件——安全账户——浏览——高级——选中<code>ligong</code>——允许匿名——应用、确定。</p><h2 id="禁止网络保护"><a href="#禁止网络保护" class="headerlink" title="禁止网络保护"></a>禁止网络保护</h2><p>右击屏幕右下角盾牌，取消<code>Enable Auto Protection</code>。</p><h2 id="所用主机说明"><a href="#所用主机说明" class="headerlink" title="所用主机说明"></a>所用主机说明</h2><p>我们需要三台主机，分别为甲、乙、丙。</p><p><strong>甲</strong>为监听并攻击者，<strong>乙</strong>为<code>Ping</code>命令/<code>FTP</code>命令操作者，<strong>丙</strong>为IP地址提供者。</p><p><strong>甲</strong>实现ARP欺骗后，<strong>乙</strong>无法<code>Ping</code>或无法通过<code>FTP</code>连接<strong>丙</strong>。</p><h2 id="进行ARP欺骗"><a href="#进行ARP欺骗" class="headerlink" title="进行ARP欺骗"></a>进行ARP欺骗</h2><p>在<strong>甲</strong>主机上进行操作。</p><ol><li><p>打开<code>Sniffer Pro</code>，选中本机的网卡，并选中<code>Log Off</code>，点击确定。</p></li><li><p>点击菜单栏中<code>File</code>中的<code>Log On</code>，登录网卡。</p></li><li><p>打开菜单栏中<code>display</code>中的<code>Define Filter</code>；</p><p> 选中<code>Address</code>选项卡，将<code>Station1</code>和<code>Station2</code>设置为<code>Any</code>（这样将监听网络上的所有消息，个人觉得可以只监听乙和丙）；</p><p> 选中<code>Advanced</code>选项卡，选中<code>ARP</code>、<code>IP</code>、<code>IP ARP</code>、<code>TCP</code>、<code>UDP</code>和<code>FTP</code>。</p></li><li><p>打开菜单栏中<code>Capture</code>中的<code>Start</code>，开始监听。</p></li><li><p>点击左侧<code>Connection</code>，点击下侧的<code>Objects</code>选项。</p></li><li><p>在右侧找到<strong>乙</strong>对<strong>丙</strong>的<code>ARP</code>信息包，双击，再选择<code>Decode</code>选项，可以看到<code>ARP</code>分组的结构，我们对<strong>丙</strong>的MAC地址进行修改（右击——<code>Edit</code>）。</p></li><li><p>打开菜单栏中<code>Tools</code>中的<code>Trace Route</code>，实现ARP欺骗。</p></li></ol><h2 id="结果检验"><a href="#结果检验" class="headerlink" title="结果检验"></a>结果检验</h2><p><strong>甲</strong>实现ARP欺骗后，<strong>乙</strong><code>Ping</code>或通过<code>ftp</code>连接<strong>丙</strong>则会失败。</p><p>因为<strong>甲</strong>通过广播发出了错误的<strong>丙</strong>的物理地址，而<strong>乙</strong>接收到了这个错误的信息，在连接<strong>丙</strong>时则会使用这个错误的物理地址，造成无法连接。</p><h1 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h1><p>ARP是建立在网络中各个主机互相信任的基础上的。</p><p>ARP欺骗可以导致计算机通信失败，更严重的是可以导致通信重定向，攻击者可以窃取被攻击者通信的数据，存在极大的安全隐患。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;掌握常见ARP欺骗类型和手段&lt;/li&gt;
&lt;li&gt;掌握ARP协议工作原理和格式&lt;/li&gt;
&lt;li&gt;掌握防范ARP地
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>80x86寄存器组</title>
    <link href="https://chouxianyu.github.io/2019/05/31/80x86%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84/"/>
    <id>https://chouxianyu.github.io/2019/05/31/80x86寄存器组/</id>
    <published>2019-05-31T08:23:12.000Z</published>
    <updated>2019-05-31T08:23:36.465Z</updated>
    
    <content type="html"><![CDATA[<p>寄存器可以分为<strong>程序可见的寄存器</strong>和<strong>程序不可见的寄存器</strong>两大类。</p><p>程序可见的寄存器可以分为以下三类：</p><ul><li>通用寄存器</li><li>专用寄存器</li><li>段寄存器</li></ul><h1 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h1><h2 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h2><p>AX、BX、CX、DX可称为数据寄存器，用来暂时存放计算过程中所用到的操作数。它们是16位，但也可以按字节访问，比如AH（高位字节）和AL（低位字节）。</p><h3 id="AX"><a href="#AX" class="headerlink" title="AX"></a>AX</h3><p>（accumulator），作为累加器用，所以是算术运算的主要寄存器。</p><h3 id="BX"><a href="#BX" class="headerlink" title="BX"></a>BX</h3><p>（base），在计算存储器地址时，常用作基址寄存器。</p><h3 id="CX"><a href="#CX" class="headerlink" title="CX"></a>CX</h3><p>（count），常用来保存计数值，如在移位指令、循环指令和串处理指令中用作隐含的计数器。</p><h3 id="DX"><a href="#DX" class="headerlink" title="DX"></a>DX</h3><p>（data），一般在作双字长运算时把DX和AX组合在一起存放一个双字长数，DX用来存放高位字。</p><h2 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h2><p>可以存放操作数，但<strong>只能以字为单位</strong>使用。</p><h3 id="SP"><a href="#SP" class="headerlink" title="SP"></a>SP</h3><p>（stack pointer），堆栈指针寄存器。</p><h3 id="BP"><a href="#BP" class="headerlink" title="BP"></a>BP</h3><p>（base pointer），基址指针寄存器。可以和堆栈段寄存器SS联用来确定堆栈段中的某一存储单元的地址。</p><h3 id="SI"><a href="#SI" class="headerlink" title="SI"></a>SI</h3><p>（source index），源变址寄存器，一般与数据段寄存器DS联用，用来确定数据段中某一存储单元的地址。</p><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>（destination index），目的变址寄存器，一般与数据段寄存器DS联用，用来确定数据段中某一存储单元的地址。</p><p>※SI和DI有自动增量和自动减量的功能。</p><p>在<strong>串处理指令</strong>中，SI和DI作为隐含的源变址和目的变址寄存器，此时SI和DS联用，DI和附加段寄存器ES联用，分别达到在数据段和附加段中寻址的目的。</p><h1 id="专用寄存器"><a href="#专用寄存器" class="headerlink" title="专用寄存器"></a>专用寄存器</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>（instruction pointer），指令指针寄存器，它用来存放代码段中的偏移地址。</p><p>在程序运行的过程中，它<strong>始终指向下一条指令</strong>的首地址，它<strong>与段寄存器CS联用</strong>确定下一条指令的物理地址。</p><h2 id="SP-1"><a href="#SP-1" class="headerlink" title="SP"></a>SP</h2><p>（stack pointer），堆栈指针寄存器，存放<strong>栈顶的偏移地址</strong>，<strong>与堆栈段寄存器SS联用</strong>来确定堆栈段中栈顶的地址。</p><h2 id="FLAGS"><a href="#FLAGS" class="headerlink" title="FLAGS"></a>FLAGS</h2><p>标志寄存器，又称为<strong>程序状态寄存器</strong>（program status word，PSW）。</p><h3 id="条件标志"><a href="#条件标志" class="headerlink" title="条件标志"></a>条件标志</h3><ul><li><p>溢出标志</p><p>  （overflow flag，OF），运算溢出时为1，否则为0。</p></li><li><p>符号标志</p><p>  （sign flag，SF），运算结果为负时为1，否则为0。</p></li><li><p>零标志</p><p>  （zero flag，ZF），运算结果为0时为1，否则为0。</p></li><li><p>进位标志</p><p>  （carry flag，CF），记录运算时从最高有效位产生的进位值。有进位时为1，否则为0。</p></li><li><p>辅助进位标志</p><p>  （auxiliary carry flag，AF），..…</p></li><li><p>奇偶标志</p><p>  （parity flag，PF），结果操作数中<strong>1的个数为偶数时为1</strong>，<strong>否则置0</strong>。</p></li></ul><h3 id="控制标志"><a href="#控制标志" class="headerlink" title="控制标志"></a>控制标志</h3><p><strong>方向标志</strong>（direction flag），在串处理指令中控制处理信息的方向用。</p><p>DF为1时，高地址到低地址，即倒着来。</p><p>DF为0时，低地址到高地址，即正着来。</p><h3 id="系统标志"><a href="#系统标志" class="headerlink" title="系统标志"></a>系统标志</h3><ul><li><p>陷阱标志</p><p>  （trap flag，TF），用于<strong>调试</strong>时的<strong>单步</strong>方式操作。</p><p>  TF为1时，产生陷阱；否则不产生。</p></li><li><p>中断标志</p><p>  （interrupt flag，IF），当其为1时，允许CPU响应中断；否则不允许。</p></li></ul><h1 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h1><p>段寄存器也是一种专用寄存器，<strong>专用于存储器寻址</strong>，用来直接或间接<strong>存放段地址</strong>。</p><ul><li><p>代码段</p><p>  （code segment，CS），存放当前正在运行的程序。</p></li><li><p>数据段</p><p>  （data segment，DS），存放当前运行程序所用的数据。</p><p>  如果程序使用了串处理指令，则其源操作数也存放在数据段里。</p></li><li><p>堆栈段</p><p>  （stack segment，SS）</p></li><li><p>附加段</p><p>  （extra segment，ES），附加的数据段，作为辅助的数据区，也是串处理指令的目的操作数存放区。</p></li></ul><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;寄存器可以分为&lt;strong&gt;程序可见的寄存器&lt;/strong&gt;和&lt;strong&gt;程序不可见的寄存器&lt;/strong&gt;两大类。&lt;/p&gt;
&lt;p&gt;程序可见的寄存器可以分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器&lt;/li&gt;
&lt;li&gt;专用寄存器&lt;/li&gt;
&lt;li&gt;段寄存器&lt;
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>请不要到处糊弄</title>
    <link href="https://chouxianyu.github.io/2019/05/31/%E8%AF%B7%E4%B8%8D%E8%A6%81%E5%88%B0%E5%A4%84%E7%B3%8A%E5%BC%84/"/>
    <id>https://chouxianyu.github.io/2019/05/31/请不要到处糊弄/</id>
    <published>2019-05-30T20:47:51.000Z</published>
    <updated>2019-05-30T21:01:05.128Z</updated>
    
    <content type="html"><![CDATA[<p>现在是凌晨三点，我并不想熬夜的，但我<strong>真的睡不着</strong>。</p><p>提交成果后，我觉得在这道题的参赛者中我是很有希望拿第一的。因为我花了很大的精力，从正确性、效率和适用性这三个层面上来看，做得很不错了，几乎完美。这并不是傲慢，仅仅是基于现实情况对自己能力和成果的肯定。</p><p>后来成绩出了，结果和想象中有点差距，我<strong>有些失望</strong>，第一反应是想知道各组的成绩，这样可以看到差距有多大和自己是差在哪里，问了问，无果。</p><p>今天，知道了另外一件事，<strong>更加失望</strong>，想象中是第一，然而现实却是这样。</p><p>我做得这么差吗？那以后好好努力吧。加油..…</p><p>凌晨一点左右，结合老师的评价，我看了名次好的同学的成果，嗯..….，结果稍微不太一样哈，嗯，再看看，看看结果的图片吧，这不是一样吗？</p><p>奥奥，他算出来某神秘物体S的个数是3，我算的是6啊（这个数字是少一点比较好的）。诶，我验证过3是不可能的啊，嗯，再看看..…</p><p>emm？那几个怎么没算上？他也是6啊。而且用他自己的理论都能把他说倒，这几个是S，另外几个怎么就不是S呢？</p><p>我再去查查资料吧。嗯嗯，果然是当时我遇到的一个问题：是否使用L距离。这个问题只是表象，计算方法而已，并非实质，但它影响了S的定义，进而影响了3或6这个数字。如果按资料里的假设，这篇论文还可以，就是没明确写出来假设，S的定义也没有明确指出，所以刚才那个问题还是存在的。</p><p>在我的假设下，使用欧式距离，S也有明确定义，结果也是正确的，跟他们相比差别就在L距离了，书上都是说假设用L距离，而非一定是L距离，L距离并不是该类问题的固定假设，严格来讲，我这个并不是个所谓的问题。</p><hr><p>看下来，好像评委也没认真研究这个题目吧？都没看出来两种方法的区别吧？</p><p>这就让我<strong>很震惊、很气愤</strong>了。（或许是我真的菜吧，没真的懂这个问题？）</p><p>作为学习、研究学问的人，老师和学生都糊弄？这样糊弄哪来学问。</p><hr><p>以下才算是正文。我就想这么写，写一堆一堆的废话。</p><p>这个比赛糊弄，其他的比赛也有糊弄的，昨天得知我刚树立好的目标也在糊弄，emmm真的多..…</p><p>我知道比赛是有评委的嘛，评委没有多少时间看，你得知道他想看什么，你要做得让他舒服。</p><p>这我当然不否认，各种各样的合作是需要让别人舒服，但我想讨论的是糊弄。</p><p>比赛之外，再算上其他时候遇见的糊弄..…..…啊，wsl，这也是我为什么睡不着了。</p><p><strong>我们都懒，偶尔懒一懒、跑跑神还是可以的啊，但也别啥都糊弄</strong></p><p>上课不听，玩游戏刷微博看小说，上课下课了自豪地说：我啥都没听懂，这老师讲得真烂；他讲的我听不懂，所以我才玩儿的；我书跟新买的一样干净哈哈哈。</p><p>上课你去得早，上课前你在玩游戏等着上课，上课你又不听，反正还是打游戏，那你刚才等啥呢？</p><p>上实验课前边10分钟老师在讲，你坐那儿玩手机，到做实验了你就开始活跃了，我们要干嘛？怎么做？带带我？</p><p>作业什么的有个问题问你，你是做出来了，但是问你你就不知道，在背答案呢还是做作业打工呢..…..…</p><p>让给你讲东西，给你讲了你说别扯了，你听不懂，不想听。</p><p>遇到的那些问题，随便想想办法都可以自己解决的。上边说的都是糊弄学习什么的，我是比较喜欢思考和科学的，有人说他不喜欢学习，当然可以啊。</p><p>emm那你问过你自己喜欢什么吗？你真的喜欢它吗？你了解它吗？为什么？这样可以吗？不喜欢学是不是你不想学的借口啊？自己现在过得充实有意义吗？</p><p>要是你说，人生的每一次选择都是最好的，人生怎么样过都可以，那也行，你有这样的乐观、自信和准备就好。</p><p><strong>如果你能跟自己说说话</strong>，多上一层思考，多想想自己的内核逻辑，换点思考内容，事情多问几个真的吗？是吗？为什么？怎么弄的？我的原因？他的原因？谁的原因？我做得还可以吗？他说的对嘛？他为什么这样想？我为什么这样想？我应该怎么想？这样做是否符合社会主义核心价值观？这样是最有效的方式吗？我在想什么？哈哈哈哈哈哈</p><p>以上内容个人觉得口吻过于讽刺，不要对号入座，<strong>看看就好，别天天糊弄着过就好了</strong>。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是凌晨三点，我并不想熬夜的，但我&lt;strong&gt;真的睡不着&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;提交成果后，我觉得在这道题的参赛者中我是很有希望拿第一的。因为我花了很大的精力，从正确性、效率和适用性这三个层面上来看，做得很不错了，几乎完美。这并不是傲慢，仅仅是基于现实情况
      
    
    </summary>
    
    
      <category term="生活" scheme="https://chouxianyu.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-实验（三）</title>
    <link href="https://chouxianyu.github.io/2019/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2019/05/27/汇编语言-实验（三）/</id>
    <published>2019-05-27T07:31:54.000Z</published>
    <updated>2019-05-31T08:23:46.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>掌握程序设计中的3种基本结构(顺序结构、选择程序、循环程序)。</li><li><p>熟练使用汇编语言的指令：数据传送类指令、数据运算类指令、逻辑判断类指令与转移指令、循环指令等。</p></li><li><p>初步了解系统功能调用的使用方法，尝试使用01H号功能调用进行字符输入的方法及使用02H号功能调用进行字符输出（显示）的方法。</p></li></ol><h1 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h1><ol><li><p>编写十进制到十六进制转换程序。要求从键盘取得一个十进制数，然后把该数以十六进制形式在屏幕上显示出来</p></li><li><p>已知从BUF开始存放了10个16进制字数据，编程求出这10个数中的最大数，（将最大数存入MAX字节单元），并将其以10进制数的形式在屏幕上显示出来。（提示：以上两题都要求采用子程序的方法）</p></li><li><p>从键盘上输入一行字符，如果这行字符比前一次输入的一行字符长度长，则保存该行字符，然后继续输入另一行字符;如果它比前一次输入的行短，则不保存这行字符。按下‘$’输入结束，最后将最长的一行字符显示出来。（选作）</p></li></ol><h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>如下图所示，首先调用子程序getinput获取用户输入的十进制数字，然后调用子程序htoa以十六进制显示用户输入的数据。</p><p><a href="https://i.loli.net/2019/05/27/5ceb94bfd01e517970.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5ceb94bfd01e517970.png" alt="dtoh.png"></a></p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>如下图所示，首先调用子程序getmax获取buf中的最大值，同时存储进max和(ax)，最后调用子程序display显示(ax)。</p><p><a href="https://i.loli.net/2019/05/27/5ceb94bfd008631514.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5ceb94bfd008631514.png" alt="max.png"></a></p><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>​    首先子程序getstr获取用户输入的字符串，每收到一个字符串之后，根据长度判断是否更新string，然后用户输入一个字符判断输入是否结束；</p><p>​    然后子程序display显示字符串string。</p><p><a href="https://i.loli.net/2019/05/27/5ceb94bf9bc6e32835.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5ceb94bf9bc6e32835.png" alt="getstr.png"></a></p><h1 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h1><h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">stack segment; 数据段</span><br><span class="line">dw 128 dup(?); 堆栈大小为128个字</span><br><span class="line">tos label word; 栈底地址为tos</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment; 代码段</span><br><span class="line">assume ss:stack,cs:code</span><br><span class="line">main proc far</span><br><span class="line">; 初始化ss、sp寄存器</span><br><span class="line">mov ax,stack</span><br><span class="line">mov ss,ax; (ss)&lt;-stack</span><br><span class="line">lea sp,tos; (sp)&lt;-tos，sp存储栈顶地址，当前栈顶即为栈底</span><br><span class="line"></span><br><span class="line">; 为返回DOS作准备</span><br><span class="line">push ds</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">; 获取用户输入的十进制数</span><br><span class="line">call getinput</span><br><span class="line"></span><br><span class="line">; 调用子程序，在DOS中以十六进制输出(ax)</span><br><span class="line">call htoa</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">getinput proc near</span><br><span class="line">mov bx,0; bx存储用户输入</span><br><span class="line">mov cl,10; 乘法用</span><br><span class="line"></span><br><span class="line">input:</span><br><span class="line">; 判断用户输入是否合法</span><br><span class="line">mov ah,1; 调用1号功能，获取用户输入，保存至(al)</span><br><span class="line">int 21h; 调用DOS</span><br><span class="line">sub al,30h; ASCII码转二进制</span><br><span class="line">cmp al,0; </span><br><span class="line">jl exit; (al)&lt;0，则说明输入结束</span><br><span class="line">cmp al,9</span><br><span class="line">jg exit; (al)&gt;9，则说明输入结束</span><br><span class="line"></span><br><span class="line">; (bx)&lt;-(bx)*10+(al)</span><br><span class="line">push ax; 暂存(ax)</span><br><span class="line">mov al,bl; (al)&lt;-(bl)</span><br><span class="line">mul cl; (ax)&lt;-(al)*(cl)</span><br><span class="line">mov bx,ax; (bx)&lt;-(ax)==(bx)*10</span><br><span class="line">pop ax; 恢复(ax)，(al)为用户输入的数字</span><br><span class="line">and ax,00ffh; (ax)高位设为0</span><br><span class="line">add bx,ax; (bx)&lt;-(bx)+(al)</span><br><span class="line"></span><br><span class="line">jmp input; 继续获取用户输入</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">mov ax,bx; (ax)&lt;-用户输入</span><br><span class="line">ret; 返回</span><br><span class="line">getinput endp</span><br><span class="line"></span><br><span class="line">htoa proc near </span><br><span class="line">cmp ax,15; 和15比较</span><br><span class="line">jle blow; 若(ax)小于等于15，则跳转至blow</span><br><span class="line"></span><br><span class="line">; (ax)低4位（大小是一个字）进栈后，右移4位</span><br><span class="line">push ax; (ax)大于15，暂存ax</span><br><span class="line">push bp; 暂存bp</span><br><span class="line">mov bp,sp</span><br><span class="line">mov bx,[bp+2]; (bx)&lt;-(ax)，(bp)、(ax)都占一个字，栈底与栈顶相比为高地址</span><br><span class="line">and bx,000fh; 只保留低4位</span><br><span class="line">mov [bp+2],bx; 存入栈中</span><br><span class="line">pop bp; 恢复bp</span><br><span class="line">mov cl,4</span><br><span class="line">shr ax,cl; 逻辑右移4位</span><br><span class="line">call htoa; 递归调用子程序htoa</span><br><span class="line">pop ax; 获取之前存入栈中的低4位</span><br><span class="line">blow:</span><br><span class="line">add al,30h; (al)转换为ASCII码</span><br><span class="line">cmp al,3ah; </span><br><span class="line">jl printit; 若(ax)小于10，则跳转至printit</span><br><span class="line">add al,7h; (al)大于等于10，加7进位到高位</span><br><span class="line"></span><br><span class="line">printit:</span><br><span class="line">mov dl,al; </span><br><span class="line">mov ah,2; 调用2号功能，DOS输出(dl)</span><br><span class="line">int 21h; 调用DOS</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">htoa endp</span><br><span class="line"> </span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">buf dw 5,9,6,8,7,0,4,3,2,1; 定义10个字数据</span><br><span class="line">max dw ?; 存储最大值</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">assume ds:data,cs:code</span><br><span class="line">main proc far</span><br><span class="line"></span><br><span class="line">; 为返回DOS作准备</span><br><span class="line">push ds</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">; 将(ds)设为data</span><br><span class="line">mov ax,data; (ax) &lt;- data</span><br><span class="line">mov ds,ax; (ds) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; max记录buf中的最大值</span><br><span class="line">call getmax</span><br><span class="line"></span><br><span class="line">; (ax)&lt;-max</span><br><span class="line">mov ax,max</span><br><span class="line"></span><br><span class="line">; 十进制输出(ax)</span><br><span class="line">call display</span><br><span class="line"></span><br><span class="line">; 返回DOS</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">getmax proc near</span><br><span class="line">; 保存寄存器</span><br><span class="line">push ax</span><br><span class="line">push cx</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">; 数据初始化</span><br><span class="line">mov ax,[buf]</span><br><span class="line">mov max,ax; 假设第0个元素为最大值</span><br><span class="line">mov cx,9; buf还剩9个元素</span><br><span class="line">mov si,2; 下标指向第一个元素，因为是字数据，所以为2</span><br><span class="line">compare:</span><br><span class="line">mov ax,buf[si]</span><br><span class="line">cmp max,ax</span><br><span class="line">jge loop1</span><br><span class="line"></span><br><span class="line">mov ax,buf[si]</span><br><span class="line">mov max,ax; 更新最大值</span><br><span class="line">loop1:</span><br><span class="line">add si,2; 下标+1</span><br><span class="line">loop compare; 继续比较</span><br><span class="line"></span><br><span class="line">; 恢复寄存器</span><br><span class="line">pop si</span><br><span class="line">pop cx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">; 返回</span><br><span class="line">ret</span><br><span class="line">getmax endp</span><br><span class="line"></span><br><span class="line">display proc near ; 将(ax)以十进制形式输出</span><br><span class="line"></span><br><span class="line">; 保存寄存器</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">; 初始化</span><br><span class="line">mov si,0; 数字的位数</span><br><span class="line">mov bl,10; 数字之后除以bx,即10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 数字每位倒序压栈</span><br><span class="line">prepare:</span><br><span class="line">div bl; 被除数默认为(ax)，除以10。</span><br><span class="line">add ah,30h; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h</span><br><span class="line">push ax; 存储最后一位</span><br><span class="line">and ax,00ffh; (ah)&lt;-0</span><br><span class="line">mov cx,ax; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环</span><br><span class="line">inc si; 更新数字位数</span><br><span class="line">inc cx; 如果为0，加一之后为1。loop判断前会将cx减一。</span><br><span class="line">loop prepare; </span><br><span class="line"></span><br><span class="line">; 弹栈，并用十进制显示</span><br><span class="line">mov cx,si; si为数字位数，即循环运行次数</span><br><span class="line">show:</span><br><span class="line">pop ax; 获取要显示的数据</span><br><span class="line">mov dl,ah; 要显示的数据放在dl里</span><br><span class="line">mov ah,2; 2号功能</span><br><span class="line">int 21h; 调用DOS</span><br><span class="line">loop show</span><br><span class="line"></span><br><span class="line">; 恢复寄存器</span><br><span class="line">pop si</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">; 返回</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">display endp ; display子程序结束</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h2 id="题目三-1"><a href="#题目三-1" class="headerlink" title="题目三"></a>题目三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">string db 0; 存放字符的个数</span><br><span class="line">db 80 dup(0),0dh,0ah,&apos;$&apos;; 存放前一次输入的字符串，兼作显示缓冲区。0ah换行、0dh回车（归位）</span><br><span class="line">buffer db 80; 输入字符串的缓冲区，最多输入80个字符</span><br><span class="line">db 0; 存放字符的个数</span><br><span class="line">db 80 dup(0); 存放当前输入的字符串，20h为空格</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">assume cs:code,ds:data,es:data</span><br><span class="line">main proc far</span><br><span class="line"></span><br><span class="line">; 为返回dos作准备</span><br><span class="line">push ds</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">; (ds)&lt;-(ax) (es)&lt;-(ax)</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">; 调用子程序，获取用户输入的串，判断是否更新，最终输出</span><br><span class="line">call getstr</span><br><span class="line"></span><br><span class="line">; 显示最终串</span><br><span class="line">call display</span><br><span class="line"></span><br><span class="line">; 程序返回</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line"></span><br><span class="line">getstr proc near</span><br><span class="line"></span><br><span class="line">; 保存寄存器</span><br><span class="line">push ax</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push di</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">; 获取用户输入的字符串存入buffer</span><br><span class="line">input:</span><br><span class="line">leadx,buffer; dx存缓冲区首址</span><br><span class="line">movah,0ah; DOS调用0A号功能，输入字符到缓冲区DS:DX</span><br><span class="line">int21h; DOS调用</span><br><span class="line"></span><br><span class="line">; DOS光标换行（处理多组输入，因为按下Enter仅能使光标回车）</span><br><span class="line">mov ah,2</span><br><span class="line">mov dl,0ah</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">; 比较字符串长度</span><br><span class="line">leasi,buffer+1; buffer+1是当前串长度的地址</span><br><span class="line">leadi,string; (string)存入di，(string+2)存入es，源操作数只能用存储器寻址方式，目的寄存器不允许使用段寄存器</span><br><span class="line">moval,[si]; 当前串长度存入al</span><br><span class="line">cmpal,[di]; 与之前的串长度进行比较</span><br><span class="line">jbenext; 如果当前串更短，跳转到next，接收下一个字符串</span><br><span class="line"></span><br><span class="line">; 更新之前串string</span><br><span class="line">movcx,80+1; 当前串比之前串长，更新串</span><br><span class="line">cld; 正向处理字符串</span><br><span class="line">repmovsb; 重复串操作，di为目的串，si为源串</span><br><span class="line"></span><br><span class="line">; 处理$失效问题</span><br><span class="line">mov ah,0</span><br><span class="line">mov si,ax</span><br><span class="line">mov [string+si+1],&apos;$&apos;</span><br><span class="line"></span><br><span class="line">; 获取下一个串</span><br><span class="line">next:</span><br><span class="line">movah,1; 获取用户输入</span><br><span class="line">int21h; DOS调用</span><br><span class="line">cmpal,&apos;$&apos; ; 是结束符吗？</span><br><span class="line">jneinput; 不是则继续输入</span><br><span class="line"></span><br><span class="line">; 恢复寄存器</span><br><span class="line">pop si</span><br><span class="line">pop di</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">; 子程序返回</span><br><span class="line">ret</span><br><span class="line">getstr endp</span><br><span class="line"></span><br><span class="line">display proc near</span><br><span class="line">; 保护寄存器</span><br><span class="line">push dx</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">; DOS光标换行，处理用$结束输入后没有换行的问题</span><br><span class="line">mov ah,2</span><br><span class="line">mov dl,0ah</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">; 显示最终串</span><br><span class="line">leadx,string+1; 串地址存入dx</span><br><span class="line">movah, 9; dos调用9号功能，显示串</span><br><span class="line">int21h; 调用DOS</span><br><span class="line"></span><br><span class="line">; 恢复寄存器</span><br><span class="line">pop ax</span><br><span class="line">pop dx</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">display endp</span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>前两题略</p><h2 id="题目三-2"><a href="#题目三-2" class="headerlink" title="题目三"></a>题目三</h2><p><strong>遇到的问题及解决方法如下：</strong></p><ol><li>获取用户输入的字符串时，按下Enter之后，光标回车，由于题目是多个输入（用户只输入一个字符串时，也要用<code>$</code>作为一次输入，所以也算多个输入），所以要增加换行操作。</li><li><p>输出结果时string后边的<script type="math/tex">`并没有起到作用，只能自己在更新string之后手动存储`</script>。</p></li><li><p>出现吞字问题：除了第一次输入，之后的输入第一个字符都会被当做判断输入结束的字符而不是字符串的内容…所以会吞字。</p></li></ol><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;掌握程序设计中的3种基本结构(顺序结构、选择程序、循环程序)。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;熟练使用汇编语言的指令：
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-实验（二）</title>
    <link href="https://chouxianyu.github.io/2019/05/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2019/05/05/汇编语言-实验（二）/</id>
    <published>2019-05-05T02:57:58.000Z</published>
    <updated>2019-05-05T12:15:36.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>掌握程序设计中的3种基本结构(顺序结构、选择程序、循环程序)。</li><li>熟练使用汇编语言的指令：数据传送类指令、数据运算类指令、逻辑判断类指令与转移指令、循环指令等。</li><li>初步了解系统功能调用的使用方法，尝试使用<code>01H</code>号功能调用进行字符输入的方法及使用<code>02H</code>号功能调用进行字符输出（显示）的方法。</li></ol><h1 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h1><ol><li>计算1+2+3+…+10，将结果显示在屏幕上。</li><li>利用<code>01H</code>号功能调用输入10个一位数字，并将其由ASCII码转换为二进制数，依此保存到变量<code>BUF</code>的10个字节中，变量<code>BUF</code>的形式为<code>BUF  DB  10  DUP（？）</code>。编程求出这10个数中的最大数和最小数，将最大数存入<code>MAX</code>单元、最小数存入<code>MIN</code>单元，并将其在屏幕上显示出来。</li></ol><h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>如下图所示，首先通过循环求出1+2+…+10，然后调用子程序<code>display</code>显示<code>sum</code>。</p><p><a href="https://i.loli.net/2019/05/05/5cce505e3f5cb.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/05/5cce505e3f5cb.png" alt="sum.png"></a></p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>如下图所示，首先调用子程序<code>getinput</code>获取用户输入，同时存储进数组，并更新<code>max</code>和<code>min</code>，最后调用两次子程序<code>display</code>显示<code>max</code>和<code>min</code>。</p><p><a href="https://i.loli.net/2019/05/05/5cce505e3a87c.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/05/5cce505e3a87c.png" alt="maxmin.png"></a></p><h1 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h1><h2 id="题目一-1"><a href="#题目一-1" class="headerlink" title="题目一"></a>题目一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">;*********************************************************************</span><br><span class="line"></span><br><span class="line">data segment; 定义数据段</span><br><span class="line">sum dw 0; 存储和</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;*********************************************************************</span><br><span class="line"></span><br><span class="line">code segment; 定义代码段</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">main proc far; 程序的主部分</span><br><span class="line">start:</span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds; ds压栈</span><br><span class="line">xor ax,ax; (ax) &lt;- data</span><br><span class="line">push ax; ax压栈</span><br><span class="line"></span><br><span class="line">; ds设为data</span><br><span class="line">mov ax,data; (ax) &lt;- data</span><br><span class="line">mov ds,ax; (ds) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">mov cx,10; 从10加到1</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">add sum,cx; sum &lt;- sum+(cx)</span><br><span class="line">loop next; (cx) &lt;- (cx)-1</span><br><span class="line"></span><br><span class="line">mov ax,sum; (ax) &lt;- sum</span><br><span class="line">call display; 调用子程序以十进制显示(ax)</span><br><span class="line"></span><br><span class="line">; 返回DOS环境</span><br><span class="line">ret; 返回DOS环境</span><br><span class="line">main  endp</span><br><span class="line"></span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">display proc near ; 将(ax)以十进制形式输出</span><br><span class="line"></span><br><span class="line">; 保存寄存器</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">; 初始化</span><br><span class="line">mov si,0; 数字的位数</span><br><span class="line">mov bl,10; 数字之后除以bx,即10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 数字每位倒序压栈</span><br><span class="line">prepare:</span><br><span class="line">div bl; 被除数默认为(ax)，除以10。</span><br><span class="line">add ah,30h; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h</span><br><span class="line">push ax; 存储最后一位</span><br><span class="line">and ax,00ffh; (ah)&lt;-0</span><br><span class="line">mov cx,ax; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环</span><br><span class="line">inc si; 更新数字位数</span><br><span class="line">inc cx; 如果为0，加一之后为1。loop判断前会将cx减一。</span><br><span class="line">loop prepare; </span><br><span class="line"></span><br><span class="line">; 弹栈，并用十进制显示</span><br><span class="line">mov cx,si; si为数字位数，即循环运行次数</span><br><span class="line">show:</span><br><span class="line">pop ax; 获取要显示的数据</span><br><span class="line">mov dl,ah; 要显示的数据放在dl里</span><br><span class="line">mov ah,2; 2号功能</span><br><span class="line">int 21h; 调用DOS</span><br><span class="line">loop show</span><br><span class="line"></span><br><span class="line">; 恢复寄存器</span><br><span class="line">pop si</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">; 返回</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">display endp ; display子程序结束</span><br><span class="line"></span><br><span class="line">code  ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="题目二-1"><a href="#题目二-1" class="headerlink" title="题目二"></a>题目二</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">;*********************************************************************</span><br><span class="line"></span><br><span class="line">data segment; 定义数据段</span><br><span class="line">buf db 10 dup(-1); 存储10个输进来的数字</span><br><span class="line">max db 0; 最大值，输入的数字一定大于等于0</span><br><span class="line">min db 9; 最小值，输入的数字一定小于等于9</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">;*********************************************************************</span><br><span class="line"></span><br><span class="line">code segment; 定义代码段</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">main proc far; 程序的主部分</span><br><span class="line">start:</span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds; ds压栈</span><br><span class="line">xor ax,ax; (ax) &lt;- data</span><br><span class="line">push ax; ax压栈</span><br><span class="line"></span><br><span class="line">; ds设为data</span><br><span class="line">mov ax,data; (ax) &lt;- data</span><br><span class="line">mov ds,ax; (ds) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; 获取用户输入并进行存储，记录最大值最小值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call getinput; 数字存入al，显示一下</span><br><span class="line"></span><br><span class="line">; 显示最大值</span><br><span class="line">mov al,max; 显示最大值</span><br><span class="line">and ax,00ffh; (ah)&lt;-0 </span><br><span class="line">call display; 调用子程序以十进制显示(ax)</span><br><span class="line"></span><br><span class="line">; 显示最小值</span><br><span class="line">mov al,min; 显示最小值</span><br><span class="line">and ax,00ffh; (ah)&lt;-0</span><br><span class="line">call display; 调用子程序</span><br><span class="line"></span><br><span class="line">; 返回DOS环境</span><br><span class="line">ret; 返回DOS环境</span><br><span class="line">main  endp</span><br><span class="line"></span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">getinput proc near; 获取用户输入并进行存储，记录最大值最小值</span><br><span class="line">; 保存寄存器</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line"></span><br><span class="line">; 初始化</span><br><span class="line">mov cx,10; 10个输入</span><br><span class="line">lea bx,buf; 存储数组地址，用来遍历数组</span><br><span class="line"></span><br><span class="line">; 获取用户输入</span><br><span class="line">savetoarray:</span><br><span class="line">mov ah,1; 1号功能，获取用户输入，保存至al</span><br><span class="line">int 21h; 调用DOS</span><br><span class="line"></span><br><span class="line">; 存入数组</span><br><span class="line">sub al,30h; (al)减去30h由ASCII码转为十进制数，在计算机内自动用二进制表示</span><br><span class="line">mov [bx],al; 存入数组，相对寻址方式</span><br><span class="line">inc bx; 数组地址加一</span><br><span class="line"></span><br><span class="line">; 判断是否更新最大值</span><br><span class="line">updatemax:</span><br><span class="line">cmp al,max; (ax)&lt;-max</span><br><span class="line">jl updatemin; (ax)&lt;max，则不用更新</span><br><span class="line">mov max,al; 更新最大值</span><br><span class="line"></span><br><span class="line">; 判断是否更新最小值</span><br><span class="line">updatemin:</span><br><span class="line">cmp al,min; (ax)&lt;-min</span><br><span class="line">jg loopp; (ax)&gt;min，则不用更新</span><br><span class="line">mov min,al; 更新最小值</span><br><span class="line"></span><br><span class="line">; 循环savetoarray</span><br><span class="line">loopp:</span><br><span class="line">loop savetoarray; cx减一，循环至cx为0</span><br><span class="line"></span><br><span class="line">; 恢复寄存器</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">; 返回</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">getinput endp ; getinput子程序结束</span><br><span class="line"></span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">display proc near ; 将(ax)以十进制形式输出</span><br><span class="line"></span><br><span class="line">; 保存寄存器</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">; 初始化</span><br><span class="line">mov si,0; 数字的位数</span><br><span class="line">mov bl,10; 数字之后除以bx,即10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 数字每位倒序压栈</span><br><span class="line">prepare:</span><br><span class="line">div bl; 被除数默认为(ax)，除以10。</span><br><span class="line">add ah,30h; (ah)为默认的余数寄存器，转换为ASCII码，字符0的ASCII码为48，即30h</span><br><span class="line">push ax; 存储最后一位</span><br><span class="line">and ax,00ffh; (ah)&lt;-0</span><br><span class="line">mov cx,ax; al为默认的商寄存器。ax=ah+al。当商为0时则跳出循环</span><br><span class="line">inc si; 更新数字位数</span><br><span class="line">inc cx; 如果为0，加一之后为1。loop判断前会将cx减一。</span><br><span class="line">loop prepare; </span><br><span class="line"></span><br><span class="line">; 弹栈，并用十进制显示</span><br><span class="line">mov cx,si; si为数字位数，即循环运行次数</span><br><span class="line">show:</span><br><span class="line">pop ax; 获取要显示的数据</span><br><span class="line">mov dl,ah; 要显示的数据放在dl里</span><br><span class="line">mov ah,2; 2号功能</span><br><span class="line">int 21h; 调用DOS</span><br><span class="line">loop show</span><br><span class="line"></span><br><span class="line">; 恢复寄存器</span><br><span class="line">pop si</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">; 返回</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">display endp ; display子程序结束</span><br><span class="line">code  ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h1><h2 id="设计的程序包含了几个段"><a href="#设计的程序包含了几个段" class="headerlink" title="设计的程序包含了几个段"></a>设计的程序包含了几个段</h2><p>题目一和题目二的程序各设计了两个段：数据段和代码段。</p><h2 id="你的代码经过编译和链接之后，总共占用多少个字节"><a href="#你的代码经过编译和链接之后，总共占用多少个字节" class="headerlink" title="你的代码经过编译和链接之后，总共占用多少个字节"></a>你的代码经过编译和链接之后，总共占用多少个字节</h2><p>题目一和题目二程序编译链接后大小均为1KB。</p><h2 id="调用DEBUG进行反汇编，查看程序的第一条指令的地址码是多少？最后一条指令的地址码是多少？"><a href="#调用DEBUG进行反汇编，查看程序的第一条指令的地址码是多少？最后一条指令的地址码是多少？" class="headerlink" title="调用DEBUG进行反汇编，查看程序的第一条指令的地址码是多少？最后一条指令的地址码是多少？"></a>调用DEBUG进行反汇编，查看程序的第一条指令的地址码是多少？最后一条指令的地址码是多少？</h2><ol><li>题目一第一条指令的地址码为<code>076B:0000</code>，最后一条指令的地址码为<code>076B:0018</code>。因为使用了一个子程序，所以主程序较短。</li><li>题目二第一条指令的地址码为<code>076B:0000</code>，最后一条指令的地址码为<code>076B:001E</code>。因为使用了两个子程序，所以主程序较短。</li></ol><h2 id="对于第2题，怎样修改程序可以同时实现将10个数字的累加功能"><a href="#对于第2题，怎样修改程序可以同时实现将10个数字的累加功能" class="headerlink" title="对于第2题，怎样修改程序可以同时实现将10个数字的累加功能"></a>对于第2题，怎样修改程序可以同时实现将10个数字的累加功能</h2><ol><li>首先在数据段中定义变量，代码如：<code>sum db 0</code>；</li><li>然后在<code>getinput</code>子程序中<code>savetoarray</code>中<code>sub al,30h</code>后添加代码<code>add sum,al</code>。</li></ol><h2 id="对于第2题，若要求输入的是两位数，又该怎么办？"><a href="#对于第2题，若要求输入的是两位数，又该怎么办？" class="headerlink" title="对于第2题，若要求输入的是两位数，又该怎么办？"></a>对于第2题，若要求输入的是两位数，又该怎么办？</h2><ol><li>首先<code>(cx)</code>改为20；</li><li>然后每两个数字一组：其中先得到的数字转换为十进制数字<code>A</code>暂存，后得到的数字转换成十进制数字<code>B</code>暂存；</li><li>可知我们要操作的数字为<code>A*10+B</code>（可以通过乘法和加法实现）；</li><li>其他程序不变。</li></ol><h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><h2 id="题目一-2"><a href="#题目一-2" class="headerlink" title="题目一"></a>题目一</h2><p>运行程序，可见输出了1+2+…+10=55。</p><h2 id="题目二-2"><a href="#题目二-2" class="headerlink" title="题目二"></a>题目二</h2><p>运行程序，输入9876543210共10个数字，可见输出了最大值9和最小值0。</p><p>查看数据段<code>dds:0</code>，结果如下，可知数字均已存入<code>buf</code>数组。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;掌握程序设计中的3种基本结构(顺序结构、选择程序、循环程序)。&lt;/li&gt;
&lt;li&gt;熟练使用汇编语言的指令：数据传
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理课程介绍</title>
    <link href="https://chouxianyu.github.io/2019/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://chouxianyu.github.io/2019/05/02/计算机组成原理课程介绍/</id>
    <published>2019-05-02T08:26:42.000Z</published>
    <updated>2019-05-02T08:29:19.176Z</updated>
    
    <content type="html"><![CDATA[<p>之前看哈工大计组视频时的笔记。</p><h1 id="课程名称解释"><a href="#课程名称解释" class="headerlink" title="课程名称解释"></a>课程名称解释</h1><h2 id="计算机：数字电子计算机"><a href="#计算机：数字电子计算机" class="headerlink" title="计算机：数字电子计算机"></a>计算机：数字电子计算机</h2><h2 id="组成：计算机硬件系统的逻辑实现"><a href="#组成：计算机硬件系统的逻辑实现" class="headerlink" title="组成：计算机硬件系统的逻辑实现"></a>组成：计算机硬件系统的逻辑实现</h2><p>organization：组成</p><p>用数字电路知识实现计算机硬件系统。</p><h2 id="原理：一般原理"><a href="#原理：一般原理" class="headerlink" title="原理：一般原理"></a>原理：一般原理</h2><p>数字电子计算机硬件系统逻辑实现的。</p><p>特色</p><ul><li>不以具体机型为依托</li><li>自顶向下、层层细化</li></ul><h1 id="课程讲授内容"><a href="#课程讲授内容" class="headerlink" title="课程讲授内容"></a>课程讲授内容</h1><h2 id="基本部件的结构和组织方式"><a href="#基本部件的结构和组织方式" class="headerlink" title="基本部件的结构和组织方式"></a>基本部件的结构和组织方式</h2><p>用数电知识对计算机基本部件进行逻辑实现。</p><h2 id="基本运算的操作原理"><a href="#基本运算的操作原理" class="headerlink" title="基本运算的操作原理"></a>基本运算的操作原理</h2><p>如何用数电知识实现计算机的基本功能：加减乘除等运算的硬件电路。</p><h2 id="基本部件和单元的设计思想"><a href="#基本部件和单元的设计思想" class="headerlink" title="基本部件和单元的设计思想"></a>基本部件和单元的设计思想</h2><p>基本部件和基本单元的设计思想以及如何将部件连接起来。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前看哈工大计组视频时的笔记。&lt;/p&gt;
&lt;h1 id=&quot;课程名称解释&quot;&gt;&lt;a href=&quot;#课程名称解释&quot; class=&quot;headerlink&quot; title=&quot;课程名称解释&quot;&gt;&lt;/a&gt;课程名称解释&lt;/h1&gt;&lt;h2 id=&quot;计算机：数字电子计算机&quot;&gt;&lt;a href=&quot;#计算机
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统概论</title>
    <link href="https://chouxianyu.github.io/2019/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    <id>https://chouxianyu.github.io/2019/05/02/计算机系统概论/</id>
    <published>2019-05-02T08:24:39.000Z</published>
    <updated>2019-05-02T08:26:18.070Z</updated>
    
    <content type="html"><![CDATA[<p>之前看哈工大计组视频时的笔记。</p><h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><h2 id="现代计算机由哪两部分组成？"><a href="#现代计算机由哪两部分组成？" class="headerlink" title="现代计算机由哪两部分组成？"></a>现代计算机由哪两部分组成？</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>计算机的实体，如主机、外设等。</p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>由具有各类特殊功能的信息（程序）组成。</p><p>硬件通过每条指令的有序执行发挥作用。</p><h4 id="系统软件"><a href="#系统软件" class="headerlink" title="系统软件"></a>系统软件</h4><p>管理整个计算机系统。</p><h4 id="语言处理程序"><a href="#语言处理程序" class="headerlink" title="语言处理程序"></a>语言处理程序</h4><p>编译环境</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>管理软硬件资源、提供人机交互等。</p><h4 id="服务性程序"><a href="#服务性程序" class="headerlink" title="服务性程序"></a>服务性程序</h4><p>比如数学库。</p><h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><h4 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h4><h4 id="应用软件"><a href="#应用软件" class="headerlink" title="应用软件"></a>应用软件</h4><p>按照某个任务的需要编制成的各种程序。</p><h3 id="硬件和软件逻辑关系"><a href="#硬件和软件逻辑关系" class="headerlink" title="硬件和软件逻辑关系"></a>硬件和软件逻辑关系</h3><p>硬件进行了相对的封装，为软件提供接口，比如指令集。</p><p>应用软件使用系统软件提供的接口，系统软件使用硬件提供的接口。</p><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><p><a href="https://www.bilibili.com/video/av15123338/?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/av15123338/?p=3</a> 11分55秒</p><p>物理抽象</p><p>程序员角度抽象</p><ol><li>机器语言-实际机器M1-</li><li>操作系统-虚拟机器M2-</li><li>汇编语言-虚拟机器M3-</li><li>高级语言-虚拟机器M4-用编译程序翻译成汇编语言程序</li><li><p>微指令系统-微程序机器M0-</p><p>一条机器语言指令也是很复杂的，将机器指令进行细化。</p></li></ol><h2 id="计算机组成和计算机系统结构的区别"><a href="#计算机组成和计算机系统结构的区别" class="headerlink" title="计算机组成和计算机系统结构的区别"></a>计算机组成和计算机系统结构的区别</h2><p>从研究内容上来说</p><h3 id="计算机系统结构"><a href="#计算机系统结构" class="headerlink" title="计算机系统结构"></a>计算机系统结构</h3><p>计算机系统结构定义了计算机系统软硬件的交界面，定义了哪些功能由软件来实现吗，哪些功能由硬件来实现，提供上层软件进行编写的时候和硬件进行交互的接口。</p><p>计算机系统结构指程序员（机器语言程序员）所见到的计算机系统的属性、概念性结构和功能特性。</p><p>计算机系统属性：编写成能在计算机硬件系统上正确执行的程序他所必须了解的计算机系统的属性，比如指令集、寄存器文件的组织等等。</p><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><p>计算机组成设计人员的任务是实现计算机系统结构所体现的属性，即具体指令的实现。</p><h1 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h1><h2 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h2><p>冯诺依曼计算机是存储程序型的计算机。</p><p>问题是运算器是瓶颈和各部分的组成不具有层次化特征。</p><h3 id="由五大部分组成"><a href="#由五大部分组成" class="headerlink" title="由五大部分组成"></a>由五大部分组成</h3><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h4><p>算数运算和逻辑运算。</p><p>计算机的功能主要是运算，比如加减乘除。</p><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>指挥程序的运行。</p><p>控制器控制做什么运算。</p><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>存放数据和程序。</p><p>指令和数据放在存储器中。（存储程序型的计算机）</p><h4 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h4><p>将信息转换成机器能识别的形式。</p><p>程序和数据输入到计算机中。</p><h4 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h4><p>将结果转换成人们熟悉的形式。</p><p>计算结果的输出。</p><h3 id="指令和数据以同等地位存于存储器，可按地址访问"><a href="#指令和数据以同等地位存于存储器，可按地址访问" class="headerlink" title="指令和数据以同等地位存于存储器，可按地址访问"></a>指令和数据以同等地位存于存储器，可按地址访问</h3><h3 id="指令和数据用二进制表示"><a href="#指令和数据用二进制表示" class="headerlink" title="指令和数据用二进制表示"></a>指令和数据用二进制表示</h3><h3 id="指令由操作码和地址码组成"><a href="#指令由操作码和地址码组成" class="headerlink" title="指令由操作码和地址码组成"></a>指令由操作码和地址码组成</h3><p>操作码：做什么操作，指出寻址方式、指出操作数类型等等</p><p>地址码：操作数在哪里</p><h3 id="存储程序"><a href="#存储程序" class="headerlink" title="存储程序"></a>存储程序</h3><p>这是核心特征。程序存储在存储器中，具有存储程序的计算机都称为冯诺依曼计算机。</p><h3 id="以运算器为中心"><a href="#以运算器为中心" class="headerlink" title="以运算器为中心"></a>以运算器为中心</h3><p>运算器非常地繁忙，成为计算机系统的瓶颈。</p><h2 id="改进：以存储器为中心"><a href="#改进：以存储器为中心" class="headerlink" title="改进：以存储器为中心"></a>改进：以存储器为中心</h2><h2 id="现代计算机硬件框图"><a href="#现代计算机硬件框图" class="headerlink" title="现代计算机硬件框图"></a>现代计算机硬件框图</h2><h2 id="计算机的解题过程"><a href="#计算机的解题过程" class="headerlink" title="计算机的解题过程"></a>计算机的解题过程</h2><h3 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h3><h4 id="存储体"><a href="#存储体" class="headerlink" title="存储体"></a>存储体</h4><p>存储体由若干个存储单元组成。</p><h5 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h5><p>存储单元由多个存储元件（0/1）组成。 </p><p>指令存储在存储单元中。</p><p>每个存储单元有个地址，存储单元按地址寻访。</p><p><strong>存储字</strong>：一个存储单元中二进制代码的组合。</p><h4 id="MAR"><a href="#MAR" class="headerlink" title="MAR"></a>MAR</h4><p>存储器地址寄存器：反映存储单元的个数，保存存储单元的地址（编号）。</p><h4 id="MDR"><a href="#MDR" class="headerlink" title="MDR"></a>MDR</h4><p>存储器数据寄存器：反映存储字长。</p><h5 id="存储字长"><a href="#存储字长" class="headerlink" title="存储字长"></a>存储字长</h5><p>存储单元中二进制代码的位数。</p><h3 id="运算器的基本组成及操作过程"><a href="#运算器的基本组成及操作过程" class="headerlink" title="运算器的基本组成及操作过程"></a>运算器的基本组成及操作过程</h3><p>视频P8。</p><h1 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h1><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前看哈工大计组视频时的笔记。&lt;/p&gt;
&lt;h1 id=&quot;计算机系统概论&quot;&gt;&lt;a href=&quot;#计算机系统概论&quot; class=&quot;headerlink&quot; title=&quot;计算机系统概论&quot;&gt;&lt;/a&gt;计算机系统概论&lt;/h1&gt;&lt;h2 id=&quot;现代计算机由哪两部分组成？&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="计算机组成原理" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之继承（二）</title>
    <link href="https://chouxianyu.github.io/2019/05/01/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%BB%A7%E6%89%BF%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2019/05/01/C-C-小课之继承（二）/</id>
    <published>2019-05-01T05:40:46.000Z</published>
    <updated>2019-05-11T10:28:22.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h1><ul><li><p>派生类只能在构造函数初始化列表中为基类或对象成员进行初始化。</p></li><li><p>当基类没有默认构造函数的情况下，派生类必须定义构造函数，并通过它为基类构造函数提供初始化值。（编译器合成的构造函数也算默认构造函数）</p></li><li><p>子类构造函数只负责直接基类的初始化。</p><p>  当存在虚基类时，所有虚基类都由最后的派生类负责初始化。如果没有，则报错。</p></li></ul><h2 id="子类继承基类的构造函数"><a href="#子类继承基类的构造函数" class="headerlink" title="子类继承基类的构造函数"></a>子类继承基类的构造函数</h2><p>C++11允许子类继承基类的构造函数，带来的方便是：</p><p>当基类构造函数有较多参数，而派生类没有数据成员需要初始化，但它必须提供构造函数，且唯一目的是为基类构造函数提供初始化值。在这种情况下，它只需要继承直接基类的构造函数就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">using</span> Base::Base;<span class="comment">//继承基类构造函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>using</code>不受访问权限的控制，放在<code>public</code>、<code>private</code>和<code>protected</code>区域中没有区别。</p><p>但这个<code>using</code>与另外两种用法（见继承第一讲）有不同之处：这个会使编译器在子类中生成代码，而用<code>using</code>声明基类成员时，并不生成代码。</p><h2 id="构造函数和析构函数的调用次序"><a href="#构造函数和析构函数的调用次序" class="headerlink" title="构造函数和析构函数的调用次序"></a>构造函数和析构函数的调用次序</h2><p>基类构造函数$\rightarrow$对象成员构造函数$\rightarrow$子类构造函数（体）</p><ul><li>多继承时，基类构造函数调用次序为继承方式中声明次序。</li><li>有多个对象成员时，按它们在子类中的声明次序调用其构造函数。</li></ul><p>析构函数与构造函数次序相反。</p><p>这个次序要和之后出现虚拟继承后构造函数的次序进行结合，例题可看课本P173。</p><h1 id="基类与继承类的使用"><a href="#基类与继承类的使用" class="headerlink" title="基类与继承类的使用"></a>基类与继承类的使用</h1><p>根据继承的定义，我们可知任何一个派生类对象的内部都包含一个基类子对象，所以可以通过<strong>截取</strong>的方法从派生类对象中<strong>复制</strong>其基类子对象并将之赋值给基类对象。</p><h2 id="子类对象对基类对象的赋值和初始化"><a href="#子类对象对基类对象的赋值和初始化" class="headerlink" title="子类对象对基类对象的赋值和初始化"></a>子类对象对基类对象的赋值和初始化</h2><p>有两种情况：赋值和初始化。如下：</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d1;</span><br><span class="line">Base b1;</span><br><span class="line">b1=d1;</span><br></pre></td></tr></table></figure><p>在把子类对象<strong>赋值</strong>给基类对象时调用基类的<strong>赋值运算符函数</strong>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived d1;</span><br><span class="line">Base b1(d1);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Base b)</span></span>;</span><br><span class="line"><span class="comment">//main中</span></span><br><span class="line">Derived d1;</span><br><span class="line">func(d1);</span><br></pre></td></tr></table></figure><p>以上两种情况，在用子类对象<strong>初始化</strong>基类对象时，会调用基类的<strong>拷贝构造函数</strong>。</p><h2 id="子类指针和基类指针"><a href="#子类指针和基类指针" class="headerlink" title="子类指针和基类指针"></a>子类指针和基类指针</h2><p>在这里，在逻辑上引用与指针等价。</p><h3 id="基类指针可以指向子类对象"><a href="#基类指针可以指向子类对象" class="headerlink" title="基类指针可以指向子类对象"></a>基类指针可以指向子类对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived d1;</span><br><span class="line">Base* pb=&amp;d1;</span><br></pre></td></tr></table></figure><h3 id="子类指针不能指向基类对象"><a href="#子类指针不能指向基类对象" class="headerlink" title="子类指针不能指向基类对象"></a>子类指针不能指向基类对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base b1;</span><br><span class="line">Derived* pd=&amp;b1;<span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><p>若想实现类似子类指针指向基类对象的功能，需要用强制类型转换，但也只能在逻辑上正确时才能使用，否则后续使用中绝对会出错的。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Derived d1;</span><br><span class="line">Base* pb=&amp;d1;</span><br><span class="line">Derived* pd=<span class="keyword">static_cast</span>&lt;Derived*&gt;(pb);<span class="comment">//这里是个模板函数</span></span><br></pre></td></tr></table></figure><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>多继承即一个类继承了多个类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> A, B,<span class="keyword">protected</span> C&#123;</span><br><span class="line">  ...  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="成员二义性"><a href="#成员二义性" class="headerlink" title="成员二义性"></a>成员二义性</h2><p>多继承情况下，当多个（1个以上）基类拥有同名成员时，会产生成员二义性。</p><p>可以通过<strong>类域限定符</strong>解决该问题，明确指出成员所属的基类。</p><h1 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h1><h2 id="虚拟继承引入的原因"><a href="#虚拟继承引入的原因" class="headerlink" title="虚拟继承引入的原因"></a>虚拟继承引入的原因</h2><p>解决多继承引出的二义性问题。</p><p>如<code>Student</code>、<code>Employee</code>继承<code>Person</code>，<code>StuEmployee</code>继承了<code>Student</code>、<code>Employee</code>，这样<code>StuEmployee</code>的对象中就有两份不同的<code>Person</code>的数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span> <span class="keyword">public</span> Person&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StuEmployee</span>:</span> <span class="keyword">public</span> Student,<span class="keyword">public</span> Employee,&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Person&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Person&#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StuEmployee</span>:</span> <span class="keyword">public</span> Student,<span class="keyword">public</span> Employee,&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数调用次序"><a href="#构造函数调用次序" class="headerlink" title="构造函数调用次序"></a>构造函数调用次序</h2><ol><li><p>先调用虚基类的构造函数，再调用非虚基类的构造函数。</p></li><li><p>同一继承层次中有多个虚基类时，就按照它们声明次序进行构造。</p><p> 若某个虚基类的构造函数已被调用，就不再调用。</p></li><li><p>若虚基类有非虚基类派生而来，则先调用该虚基类的构造函数，再调用该非虚基类的构造函数。</p></li></ol><h2 id="成员函数优先级"><a href="#成员函数优先级" class="headerlink" title="成员函数优先级"></a>成员函数优先级</h2><p>继承层次中越靠下优先级越高。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数与析构函数&quot;&gt;&lt;a href=&quot;#构造函数与析构函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数与析构函数&quot;&gt;&lt;/a&gt;构造函数与析构函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;派生类只能在构造函数初始化列表中为基类或对象成员进行初始化。&lt;/p
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="继承" scheme="https://chouxianyu.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="https://chouxianyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>浙江理工大学2019数学建模校赛B题记录</title>
    <link href="https://chouxianyu.github.io/2019/04/29/%E6%B5%99%E6%B1%9F%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A0%A1%E8%B5%9BB%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://chouxianyu.github.io/2019/04/29/浙江理工大学数学建模校赛B题记录/</id>
    <published>2019-04-29T14:21:10.000Z</published>
    <updated>2019-05-01T06:00:39.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">w=[...</span><br><span class="line">    <span class="number">0</span>,   <span class="number">80</span>, <span class="number">150</span>,   <span class="number">90</span>, <span class="number">140</span>, <span class="number">100</span>, <span class="number">120</span>; </span><br><span class="line"><span class="number">120</span>,     <span class="number">0</span>, <span class="number">180</span>, <span class="number">100</span>,   <span class="number">60</span>,   <span class="number">70</span>, <span class="number">110</span>; </span><br><span class="line"><span class="number">100</span>, <span class="number">160</span>,     <span class="number">0</span>,   <span class="number">80</span>,   <span class="number">90</span>,   <span class="number">50</span>,   <span class="number">70</span>;</span><br><span class="line">  inf,   inf,   inf,     <span class="number">0</span>,   <span class="number">40</span>,   <span class="number">70</span>, <span class="number">180</span>; </span><br><span class="line">  inf,   inf,   inf,   <span class="number">30</span>,     <span class="number">0</span>,   <span class="number">80</span>, <span class="number">150</span>; </span><br><span class="line">  inf,   inf,   inf,   <span class="number">80</span>,   <span class="number">90</span>,     <span class="number">0</span>,   <span class="number">50</span>;</span><br><span class="line">  inf,   inf,   inf, <span class="number">130</span>, <span class="number">140</span>,   <span class="number">60</span>,     <span class="number">0</span>; ];</span><br><span class="line"><span class="comment">% 设甲、乙、丙三个矿区为顶点v1，v2，v3，</span></span><br><span class="line"><span class="comment">% A、B、C、D 三个冶炼厂为v4、v5、v6、v7。</span></span><br><span class="line"><span class="comment">% 该矩阵表示7个顶点间的距离</span></span><br><span class="line"><span class="comment">% 由于不是对称矩阵，第一行第二行的元素表示甲到乙还是乙到甲是有区别的。题目不严谨，而老师PPT里是前者。有待区分(TODO)</span></span><br><span class="line"><span class="comment">% <span class="doctag">TODO:</span>graphallshortestpaths函数中的图参数 inf用0表示也可以？</span></span><br><span class="line"><span class="comment">% 该矩阵与题给数据是否完全一样，有待比较(TODO)</span></span><br></pre></td></tr></table></figure><h2 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h2><p>构造有向图，G=(V,E, W)，顶点、边、权重。甲、乙、丙三个矿区为顶点v1，v2，v3，<br>% A、B、C、D 三个冶炼厂为v4、v5、v6、v7。TODO:这部分可以参考骆桦PPT或者相关书籍与论文。</p><p>xij&gt;0，肯定大于0。即负数用表示同样含义的正数表示（TODO：怎么说呢）</p><p>由于可以转运：</p><p><strong>IMPORTANT</strong>：为什么不是用该矩阵中的值作为顶点之间的距离，而是根据此矩阵计算最短路径？（因为题中说可以转运，而最短路径即包括了转运的含义）</p><p>问题中<strong>最优</strong>的定义：</p><p>矿区的矿物产量刚好达到（即等于）冶炼厂矿物需求量（TODO：矿物产量和矿物需求量这两个词是否合适，应参照题目或统一规定用词），这是两个约束条件。</p><p><strong>IMPORTANT</strong>：因为题目是求<strong>矿区到各冶炼厂间</strong>矿石的最优调运方案，所以从最短路径中提取出两个矿区（甲乙）到四个冶炼厂（ABCD）的最短距离</p><p>分别用i =1, 2表示甲乙两个矿区，j =1，2，3，4表示A、B、C、D三个电厂，     cij表示第i个矿区到第j个冶炼厂的最短距离，xij表示第i个矿区到第j个冶炼厂的调运量，ai表示第i个矿区的产量，bj表示第j个冶炼厂的需求量。</p><p>这里是产量和需求平衡的运输问题</p><h2 id="一些假设"><a href="#一些假设" class="headerlink" title="一些假设"></a>一些假设</h2><ul><li>花费与路径长度和运送量相关，所以假设花费=路径长度*运送量。在这一点可以尝试讨论，优化？</li><li>假设调运方案中从矿区到各冶炼厂间调运吨数为整数，试试改成小数？</li></ul><h2 id="matlab程序"><a href="#matlab程序" class="headerlink" title="matlab程序"></a>matlab程序</h2><p>计算出的最短路径矩阵，前三行后四列是我们的结果，如下。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">90</span>   <span class="number">130</span>   <span class="number">100</span>   <span class="number">120</span></span><br><span class="line"><span class="number">90</span>     <span class="number">60</span>     <span class="number">70</span>   <span class="number">110</span></span><br><span class="line"><span class="number">80</span>     <span class="number">90</span>     <span class="number">50</span>     <span class="number">70</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line"></span><br><span class="line">w=[...</span><br><span class="line">    <span class="number">0</span>,   <span class="number">80</span>, <span class="number">150</span>,   <span class="number">90</span>, <span class="number">140</span>, <span class="number">100</span>, <span class="number">120</span>; </span><br><span class="line"><span class="number">120</span>,     <span class="number">0</span>, <span class="number">180</span>, <span class="number">100</span>,   <span class="number">60</span>,   <span class="number">70</span>, <span class="number">110</span>; </span><br><span class="line"><span class="number">100</span>, <span class="number">160</span>,     <span class="number">0</span>,   <span class="number">80</span>,   <span class="number">90</span>,   <span class="number">50</span>,   <span class="number">70</span>;</span><br><span class="line">  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,     <span class="number">0</span>,   <span class="number">40</span>,   <span class="number">70</span>, <span class="number">180</span>; </span><br><span class="line">  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">30</span>,     <span class="number">0</span>,   <span class="number">80</span>, <span class="number">150</span>; </span><br><span class="line">  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">80</span>,   <span class="number">90</span>,     <span class="number">0</span>,   <span class="number">50</span>;</span><br><span class="line">  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>, <span class="number">130</span>, <span class="number">140</span>,   <span class="number">60</span>,     <span class="number">0</span>; ];</span><br><span class="line"></span><br><span class="line">W = sparse(w);</span><br><span class="line">d = graphallshortestpaths(W)</span><br><span class="line">NodeIDs = &#123;<span class="string">'甲'</span>, <span class="string">'乙'</span>,<span class="string">'丙'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>&#125;; <span class="comment">% 节点标签，也就是h.Nodes(i).ID属性值</span></span><br><span class="line">h = view(biograph(w, NodeIDs, <span class="string">'ShowWeights'</span>, <span class="string">'on'</span>))</span><br><span class="line">set(h.Nodes, <span class="string">'shape'</span>, <span class="string">'circle'</span>); <span class="comment">% 顶点画成圆形</span></span><br><span class="line">h.EdgeType = <span class="string">'segmented'</span>; <span class="comment">% 边的连接为线段</span></span><br><span class="line">h.LayoutType = <span class="string">'radial'</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">dolayout(h) <span class="comment">% 刷新图形 会报错，故放在try块中，不影响结果，待深究</span></span><br><span class="line"><span class="keyword">catch</span> exception</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">h2 = view(biograph(d, NodeIDs, <span class="string">'ShowWeights'</span>, <span class="string">'on'</span>));</span><br><span class="line">h2.EdgeType =  <span class="string">'segmented'</span>; <span class="comment">% 边的连接为线段</span></span><br><span class="line">h2.LayoutType = <span class="string">'equilibrium'</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">dolayout(h2) <span class="comment">% 刷新图形 会报错，故放在try块中，不影响结果，待深究</span></span><br><span class="line"><span class="keyword">catch</span> exception</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>TODO:matlab的图不怎么样。修改matlab参数、图论工具箱、网络分析工具箱、NetworkX</p><h2 id="lingo程序"><a href="#lingo程序" class="headerlink" title="lingo程序"></a>lingo程序</h2><p>矩阵x和Objective Value是我们的最终结果：各矿区到各冶炼厂最优调度方案。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">kuang/<span class="number">1.</span><span class="number">.3</span> /:a; !甲乙丙矿区的产量;</span><br><span class="line">chang/<span class="number">1.</span><span class="number">.4</span> /:b; !ABCD四个冶炼厂的矿石用量;</span><br><span class="line">link(kuang,chang):c,x;</span><br><span class="line">endsets</span><br><span class="line">data:</span><br><span class="line">a = <span class="number">700</span> <span class="number">500</span> <span class="number">500</span>;</span><br><span class="line">b = <span class="number">400</span> <span class="number">300</span> <span class="number">400</span> <span class="number">600</span>;</span><br><span class="line">c = <span class="number">90</span>   <span class="number">130</span>   <span class="number">100</span>   <span class="number">120</span></span><br><span class="line"> <span class="number">90</span>     <span class="number">60</span>     <span class="number">70</span>   <span class="number">110</span></span><br><span class="line"> <span class="number">80</span>     <span class="number">90</span>     <span class="number">50</span>     <span class="number">70</span>;</span><br><span class="line">enddata</span><br><span class="line">min = @sum(link: c * x);</span><br><span class="line">@<span class="keyword">for</span>(kuang(<span class="built_in">i</span>):@sum(chang(<span class="built_in">j</span>):x(<span class="built_in">i</span>, <span class="built_in">j</span>)) = a(<span class="built_in">i</span>));</span><br><span class="line">@<span class="keyword">for</span>(chang(<span class="built_in">j</span>):@sum(kuang(<span class="built_in">i</span>):x(<span class="built_in">i</span>, <span class="built_in">j</span>)) = b(<span class="built_in">j</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>TODO：检验答案正确性</p><p>135000.0</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果：三个矿区到四个冶炼厂的调度方案</span><br><span class="line"><span class="number">400</span> <span class="number">0</span>  <span class="number">200</span> <span class="number">100</span></span><br><span class="line"><span class="number">0</span> <span class="number">300</span> <span class="number">200</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">500</span></span><br></pre></td></tr></table></figure><h2 id="待解决主要问题"><a href="#待解决主要问题" class="headerlink" title="待解决主要问题"></a>待解决主要问题</h2><p>图画的不行、论文（建立模型部分、假设部分），可能这只是第一题，不需要花太大精力。</p><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>几乎不用假设和建模，而且老师也给了两个lingo程序。但现在问题是老师给的第二个lingo程序看不太懂，不知道怎么把B题里的数据套进去。</p><p>我借的matlab书上都有直接给代码，但很长。</p><p>最大流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">nodes/s,1,2,3,t/;</span><br><span class="line">arcs(nodes,nodes):c,f;</span><br><span class="line">endsets</span><br><span class="line">data:</span><br><span class="line">c=0;</span><br><span class="line">@text(&apos;fdata.txt&apos;)=f;</span><br><span class="line">enddata</span><br><span class="line">calc:</span><br><span class="line">c(1,2)=20;c(1,3)=16;</span><br><span class="line">c(2,4)=4;c(2,5)=14;</span><br><span class="line">c(3,2)=10;c(3,4)=20;</span><br><span class="line">c(4,5)=8;</span><br><span class="line">endcalc</span><br><span class="line">n=@size(nodes);</span><br><span class="line">max=flow;</span><br><span class="line">@for(nodes(i)|i #ne# 1 #and# i #ne#n:@sum(nodes(j):f(i,j))=@sum(nodes(j):f(j,i)));    </span><br><span class="line">@sum(nodes(i):f(1,i))=flow;</span><br><span class="line">@sum(nodes(i):f(i,n))=flow;</span><br><span class="line">@for(arcs:@bnd(0,f,c));</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>最小费用最大流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">model:</span><br><span class="line">sets:</span><br><span class="line">nodes/s,1,2,3,t/:d;</span><br><span class="line">arcs(nodes,nodes):b,c,f;</span><br><span class="line">endsets</span><br><span class="line">data:</span><br><span class="line">d=22 0 0 0 -22;</span><br><span class="line">b=0;c=0;</span><br><span class="line">enddata</span><br><span class="line">calc:</span><br><span class="line">b(1,2)=12;b(1,3)=3;</span><br><span class="line">b(2,4)=18;b(2,5)=3;</span><br><span class="line">b(3,2)=6;b(3,4)=9;</span><br><span class="line">b(4,5)=6;</span><br><span class="line">c(1,2)=20;c(1,3)=16;</span><br><span class="line">c(2,4)=4;c(2,5)=14;</span><br><span class="line">c(3,2)=10;c(3,4)=20;</span><br><span class="line">c(4,5)=8;</span><br><span class="line">endcalc</span><br><span class="line">min=@sum(arcs:b*f);</span><br><span class="line">@for(nodes(i):@sum(nodes(j):f(i,j))-@sum(nodes(j):f(j,i))=d(i));   </span><br><span class="line">@for(arcs:@bnd(0,f,c));</span><br><span class="line">End</span><br></pre></td></tr></table></figure><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><h2 id="可选方法"><a href="#可选方法" class="headerlink" title="可选方法"></a>可选方法</h2><p><code>数学实验13-树算法08</code>PPT里的后三种方法：</p><p>改进的贪心</p><p>模拟退火</p><p>修改过的prim</p><h2 id="英文论文阅读"><a href="#英文论文阅读" class="headerlink" title="英文论文阅读"></a>英文论文阅读</h2><h3 id="s-commentary-the-outstanding-Steiner-tree-papers"><a href="#s-commentary-the-outstanding-Steiner-tree-papers" class="headerlink" title="s commentary the outstanding Steiner tree papers"></a>s commentary the outstanding Steiner tree papers</h3><h4 id="准确解"><a href="#准确解" class="headerlink" title="准确解"></a>准确解</h4><ul><li>暴力法</li></ul><p>直接暴力，890+个可能位置。</p><p>Hanan的一个理论，被三个队伍引用，说只需要考虑和一个已知站x坐标相同并且和另外一个已知站y坐标相同的steiner点。可能的steiner点位置减少到63个。</p><p>在此基础上可以，删除角落里的点，可能的位置减少到31个。</p><ul><li>动态规划</li></ul><p>虽然它还是要计算已知点的所有子集，但它避免测试所有steiner点的子集。</p><p>通过该这样的方法，几个小时可以找到50个可能位置，但似乎没有人这样做。</p><p>电脑芯片设计者通常喜欢近似解，因为网络的长度并不总是操作速度的限制条件。</p><h4 id="近似解"><a href="#近似解" class="headerlink" title="近似解"></a>近似解</h4><p>一个近似算法是不用虚设点，直接使用最小生成树，Hwang证明这个长度不超过steiner树的150%，但这当然不满足题目的要求。</p><p>某队找到一个最好的steiner点，然后把它加进已知站，之后重复这个策略直到加了7个点或者不可能优化了。这个方法找到了一个可能解，但并不是每次都可以这样。</p><p>某队用了多种不同的启发式算法，并且用另外四个样例对他们的方法进行了测试。另外，他们在评估他们的算法时做了一个好的决定。关于最小生成树他们还给了一个优化方案，因为他们通常不能计算准确的steiner树。他们的启发式算法都用了贪心策略。他们想出了一种改进的克鲁斯卡尔算法，模仿克鲁斯卡尔但如果有利的话会使用steiner点。这个启发式算法找到了一种可能解。虽然这个算法在速度上优于上一队，但面对更大规模的问题时它不一定能找到相当好的解。</p><p>某队(也就是下边的这个论文)用了<strong>模拟退火</strong>，模拟退火根据当地重新排列规则随机从某种解移向某种解。移向一个解的概率取决于这两个解的花费和一个叫做温度的控制变量。通过一个合适的冷却速率，这个启发式算法最终停在一个几乎最优解。他们模拟了100次这个程序都得到了最优解。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后简单总结一下，有两种方法：</p><ul><li><p>exact solution</p><p>  求确切的最优解，有两种方法。</p><ul><li><p>暴力枚举法</p><p>  通过减少steiner点可能的位置来节约时间，仍然是在用这种方法。</p></li><li><p>动态规划</p><p>  似乎没有人用这个。</p></li></ul></li><li><p>近似解</p><p>  通过启发式算法，求近似最优解，有几种方法。</p><ul><li><p>单点贪心</p><p>  每次先找到一个最好的steiner点，将其加入已知站，直至N-2或不可能有更好的解了。</p></li><li><p>改进克鲁斯卡尔算法</p><p>  模仿克鲁斯卡尔，但考虑了steiner点。</p></li><li><p><strong>模拟退火</strong>，这是最好的一个方法</p><p>  还未具体去看那篇论文(1991 B Finding optimal Steiner trees)</p></li></ul></li></ul><h3 id="1991-B-Finding-optimal-Steiner-trees"><a href="#1991-B-Finding-optimal-Steiner-trees" class="headerlink" title="1991 B Finding optimal Steiner trees"></a>1991 B Finding optimal Steiner trees</h3><h4 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h4><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>这是一种更有效的寻找所有可行的虚设点和已知点组合的方式。</p><p>我们从一个已给的虚设点和已知点组成的树开始，并且允许模拟退火程序创造一个新的配置。对每一个新配置来说，程序决定了最小生成树并且计算其长度。然后模拟退火程序在冷却计划的基础上决定是使用还是拒绝新配置。修改一个配置和评价这个修改方案都很简单。</p><p>这个方法很有普适性：任何初始配置都可能被使用，并且算法并不直接取决于固定的站点设置。</p><p>和暴力相反，模拟退火并不一定能产生绝对的最优解。然而，我们可以按照我们的希望控制其停在当前最小值（和绝对的最优解不同），同时与暴力相比，计算时间可得到很大的缩减。</p><p>虚设点有31个可能位置作为初始条件。该模拟退火程序的输入是已知点位置、steiner点的可能位置，还有一个初始路径。（我们手动找了一个最优解，并将其作为程序的输入。我们把已知网络按照三点一组的规则进行分组，每组添加一个虚设点使该组最优，然后使各组最优，得到的配置作为模拟退火的最小路径出现了几次。）</p><p>现在配置改变的方式随机从下边选择：</p><ul><li>随机在可能位置添加一个steiner点</li><li>移除一个已加入的虚设点</li><li>将一个已加入的steiner点随机移到一个新的位置</li></ul><p>（通过这三种方式，我们可以尝试所有可能的网络配置。如果是为了这样做，第三种方式并没有必要；但是为了给模拟退火步骤更大的自由性，我们包含了这种方法。）</p><p>使用存储起来的新配置，为了建立最小生成树和评价网络的花费，一个计算程序会被调用。这个花费然后会被程序的模拟退火部分（routine METROP from Press et al.）使用，以决定新的配置是否被保存或拒绝（根据一个意见一致的冷却计划）。</p><p>刚开始的前几次表明一个趋势：增加度为2的虚设点是没用的。虽然虚设点并不花费什么，我们决定在程序中排除这个多余，通过引入较小的虚设点花费，这个花费足够小，并不会影响在必要时加入虚设点，反而最终会处理没有必要的虚设点。</p><p>我们同时也添加了一个模拟退火中不经常出现的特点，借此这个程序可以存储测试出的最优解。（模拟退火一般只返回最终使用的配置）</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>平均迭代9800次退火，1.5min（在25-MHz 386-based PC）</p><p>用不同的种子形成不同的随机数生成器，给了5种不同的最优解，长度为94。</p><p>超过100个回合时，模拟退火总是收敛到5种中的1种，证明它适用于更大范围的steiner树的问题（当暴力是不可能的时候）。</p><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>如果所有站点是有花费的</p><p>如果想用模拟退火，我们可以：</p><ul><li>用一些暴力方法</li><li>模拟退火数量、位置、虚设点的度（嵌套退火）</li><li>修改最小生成树算法，找到花费最小（而不是路径长度最短）的树，并且用前边的模拟退火</li></ul><p>似乎前两种方法太费时间而且效率不高，我们选择第三种。</p><p>虽然模拟退火不一定能给出最优解，但它在100次试验之后，确实给了最优解（暴力检查过）。</p><h1 id="工作记录"><a href="#工作记录" class="headerlink" title="工作记录"></a>工作记录</h1><ul><li><p>2019.4.4</p><ul><li><p>工作</p><p>  尝试做第一题，写了一些假设，思路和需要注意的点等等。</p></li><li><p>感想</p><p>  平常还是要做好充足的准备，不要等着题发下来了才去详细了解某些知识和算法。比如这次校赛，昨天出的题，B题就是课上讲过的东西，如果当时抽时间具体研究了，现在不是就已经会了吗？（虽然现在刚学习建模不久，而且当时好像没时间……当然是选择原谅自己）</p></li></ul></li><li><p>2019.4.5</p><ul><li><p>工作</p><p>  实现第一题matlab程序，发现作的图好丑，不够清晰。寻求解决办法，了解到网络分析工具箱、NetWorkX等。</p></li><li><p>感想</p><p>  擒贼先擒王。最终目的是写一篇好的论文。现在应该把整个思路给定下来，大体上进行实现。不是能因为这个图花费太多时间，应该在后期优化。</p></li></ul></li><li><p>2019.4.6</p><ul><li><p>工作</p><p>  实现第一题lingo程序，得到答案。重新回顾第一题，整理思路、材料和之后需要做的相关工作。</p><p>  看第二题，最小费用最小流，好像得出答案比较简单。了解steiner树，查阅文献。</p></li><li><p>感想</p><p>  道阻且长，我应该对lingo、matlab极其熟悉吗？</p></li></ul></li><li><p>2019.4.7</p><ul><li><p>工作</p><p>  阅读英文论文点评并总结，着手查看比较好的一篇论文。</p></li><li><p>感想</p><p>  类似的问题，可以直接去看论文。另一方面，更好的是去看论文点评，能够站在顶层往下学习还是很不错的一种体验。</p><p>  问题让求steiner树，我们可能是要先证明每个图中steiner树是一定存在的？</p></li></ul></li><li><p>2019.4.8</p><ul><li><p>工作</p><p>  阅读英文论文模拟退火部分并总结，解决第二题最小费用最大流。</p></li></ul></li><li><p>2019.4.9</p><ul><li><p>工作</p><p>  上完建模课和队友讨论，知道了凸包..…突然发现题目要求很变态的一点，管道必须是平行于x轴或y轴的。这个是求出结果后不证自明，还是过程中就要求判断呢。</p></li></ul></li><li><p>2019.4.10</p><ul><li><p>工作</p><p>  知道凸包是什么了，知道了美赛91为什么用L距离，又了解了几种求近似解的方法。着手模拟退火算法</p></li><li><p>感想</p><p>  啊..……不会………..…..…不想说话</p></li></ul></li><li><p>2019.4.11</p><ul><li><p>工作</p><p>  学习模拟退火，学了一半吧</p></li></ul></li><li><p>2019.4.12</p><ul><li><p>工作</p><p>  继续学习模拟退火，学完了，知道是什么，大概知道怎么用。</p><p>  着手将题目与模拟退火结合，设计代码。</p></li></ul></li><li><p>2019.4.13</p><ul><li><p>工作</p><p>  敲代码，整体结构敲出来了，差一个扰动函数</p></li><li><p>感想</p><p>  matlab的基础还是不足，很多东西都需要搜着做</p></li></ul></li><li><p>2019.4.14</p><ul><li><p>工作</p><p>  写扰动函数，尝试调参。难呐..…</p></li></ul></li><li><p>2019.4.17</p><ul><li><p>工作</p><ul><li><p>通过暴力，发现这个题和普通的steiner树不一样，按普通的steiner树求解的话，是不符合题目要求的。</p><p>  <strong>核心呐</strong>：它要求边水平或竖直，这样目标函数就应该改成合法性了。</p></li><li><p>设想了目标函数为合法性的算法如何实现。</p></li></ul></li></ul></li><li><p>2019.4.20</p><ul><li><p>工作</p><p>  实现目标函数为合法性的程序，最终可以求得合法的steiner树。但无用的steiner点太多了，需要优化。</p></li></ul></li><li><p>2019.4.21</p><ul><li><p>工作</p><p>  在合法树的基础上进行长度和steiner点个数的优化。</p><p>  遗留了一个问题：自己写的一个函数总是出问题，不符预期。</p></li></ul></li><li><p>2019.4.22</p><ul><li><p>工作</p><p>  解决昨天遗留的问题，写函数优化无用的steiner点。（原因是在for循环中数组变小了，然后就越界了，python中也有这样的东西嘛我记得</p><p>  求得最终答案（不知道强迫症还是什么，总感觉有隐患..…，不过本来的思路就是求近似最优解..）</p><p>  整理代码，完善注释。</p><p>  那个无用的steiner点即使写了优化函数之后还是有，原因是去掉无用点之后，调用最小生成树算法，这个算法导致有多余的steiner点的产生。</p></li></ul></li><li><p>2019.4.23</p><ul><li><p>工作</p><p>  讨论结果和论文思路，分工</p></li></ul></li><li><p>2019.4.24</p><ul><li><p>工作</p><p>  中午下课吃完饭回来就写论文，晚上剪头，吃麻辣烫看了两集BigBang，回来继续写，写到现在11点半了，写了2500+字。主体部分已经写了有四分之三了，一些细节写在了注释里。耶</p></li></ul></li><li><p>2019.4.25</p><ul><li><p>工作</p><p>  上下午第四节都在写论文，算法设计与分析课上也在写论文..…整体上是写完了，剩下的工作是补充细节。</p></li></ul></li><li><p>2019.4.26</p><ul><li><p>工作</p><p>  快中午的时候开始补充论文细节，一直到晚上，效率挺低的，可能是分工问题，另外是还有一些讨论的工作。</p></li></ul></li><li><p>2019.4.27</p><ul><li><p>工作</p><p>  流程图、公式、标题、字体、程序代码等等都搞定了，差不多结束了，第一题代码太烂就先算了吧，那个不重要。</p></li></ul></li><li><p>2019.4.28</p><ul><li><p>工作</p><p>搞细节咯，还修改了个流程图。检查了几遍，结束咯~</p></li></ul></li></ul><p>整个过程想来还是挺艰辛的，大多都是在尝试，不断地试错然后改进，可能建模都这样吧。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;h2 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h2&gt;&lt;f
      
    
    </summary>
    
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-第五章作业</title>
    <link href="https://chouxianyu.github.io/2019/04/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E7%AC%AC%E4%BA%94%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
    <id>https://chouxianyu.github.io/2019/04/25/汇编语言-第五章作业/</id>
    <published>2019-04-25T12:49:43.000Z</published>
    <updated>2019-04-25T12:50:07.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写程序，将一个包含有20个数据的数组M分成两个数组：正数数组P和负数数组N，并分别把这两个数组中的数据个数显示出来。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">flow</span><br><span class="line">start=&gt;start: 开始</span><br><span class="line">getNum=&gt;operation: 取数组下个元素</span><br><span class="line">whetherNegative=&gt;condition: 是负数？</span><br><span class="line">isPositive=&gt;operation: 存入正数数组</span><br><span class="line">isNegative=&gt;operation: 存入负数数组</span><br><span class="line">whetherEnd=&gt;condition: 数组最后一个元素？</span><br><span class="line">showNegative=&gt;operation: 显示偶数个数</span><br><span class="line">showPositive=&gt;operation: 显示奇数个数</span><br><span class="line">end=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">start-&gt;getNum-&gt;whetherNegative</span><br><span class="line">whetherNegative(yes)-&gt;isNegative</span><br><span class="line">whetherNegative(no)-&gt;isPositive</span><br><span class="line">isNegative-&gt;whetherEnd</span><br><span class="line">isPositive-&gt;whetherEnd</span><br><span class="line">whetherEnd(no)-&gt;getNum</span><br><span class="line">whetherEnd(yes)-&gt;showPositive-&gt;showNegative-&gt;end</span><br></pre></td></tr></table></figure><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>初始数组中存放20个数字：<code>1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">separator0 dw &apos;A&apos;; 间隔符，方便查看内存内容</span><br><span class="line">array dw 1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10 ; 存放数组</span><br><span class="line">separator1 dw &apos;A&apos;; 间隔符，方便查看内存内容</span><br><span class="line">P dw 20 dup (?) ; 存放正数</span><br><span class="line">separator2 dw &apos;A&apos;; 间隔符，方便查看内存内容</span><br><span class="line">N dw 20 dup (?) ; 存放负数</span><br><span class="line">separator3 dw &apos;A&apos;; 间隔符，方便查看内存内容</span><br><span class="line">lenOfArray equ 20; 数组长度</span><br><span class="line">lenOfP db 0 ; 存放正数的个数</span><br><span class="line">lenOfN db 0 ; 存放负数的个数</span><br><span class="line">positive db 0dh, 0ah, &apos;the positive number is：&apos;, &apos;$&apos; ; 正数的个数是：</span><br><span class="line">negative db 0dh, 0ah, &apos;the negative number is：&apos;, &apos;$&apos; ; 负数的个数是：</span><br><span class="line">crlf db 0dh, 0ah, &apos;$&apos;;回车换行</span><br><span class="line">data ends</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">code segment</span><br><span class="line">main proc far</span><br><span class="line">assume cs: code, ds: data</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds ; ds入栈</span><br><span class="line">sub ax, ax ; ax置0</span><br><span class="line">push ax ; 0入栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; ds存储数据段地址</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax ; 给ds赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line">mov cx, lenOfArray; 遍历array，cx置为array的长度</span><br><span class="line">lea bx, array; 将array存入bx</span><br><span class="line">lea si, P; 将P存入si</span><br><span class="line">lea di, N; 将N存入di</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">begin1:</span><br><span class="line">mov ax, [bx]; ax指向array数组</span><br><span class="line">cmp ax, 0 ; 判断是否为负数</span><br><span class="line">js isnegative; 结果为负则转移至isnegative</span><br><span class="line">mov [si], ax ; 是正数，存入正数数组</span><br><span class="line">inc lenOfP ; 正数个数+1</span><br><span class="line">add si, 2; si后移</span><br><span class="line">jmp short next; 判断array数组的下一个元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">isnegative:</span><br><span class="line">mov [di], ax ; 是负数，存入负数数组</span><br><span class="line">inc lenOfN ; 负数个数+1</span><br><span class="line">add di, 2; di后移</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">add bx, 2; bx后移</span><br><span class="line">loop begin1; cx为0是跳出循环，运行后边的代码</span><br><span class="line"></span><br><span class="line">lea dx, positive ; 显示正数个数</span><br><span class="line">mov al, lenOfP</span><br><span class="line">call display ; 调显示子程序</span><br><span class="line"></span><br><span class="line">lea dx, negative ; 显示负数个数</span><br><span class="line">mov al, lenOfN</span><br><span class="line">call display ; 调显示子程序</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">display proc near ; 显示子程序</span><br><span class="line">mov ah, 9 ; 调用9号DOS功能，显示一个字符串</span><br><span class="line">int 21h; DOS系统功能调用</span><br><span class="line">aam ; 将(al)中的二进制数转换为二个非压缩bcd码</span><br><span class="line">add ah, ‘0’ ; 变为 0～9 的 ASCII 码</span><br><span class="line">mov dl, ah</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ah, 2 ; 调用2号DOS功能，显示一个字符</span><br><span class="line">int 21h</span><br><span class="line">add al, ‘0’ ; 变为 0～9 的ASCII码</span><br><span class="line">mov dl, al</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ah, 2 ; 调用2号DOS功能，显示一个字符</span><br><span class="line">int 21h</span><br><span class="line">lea dx, crlf ; 显示回车换行</span><br><span class="line">mov ah, 9 ; 调用9号DOS功能，显示一个字符串</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">display endp ; 显示子程序结束</span><br><span class="line">code ends ; 以上定义代码段</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://i.loli.net/2019/04/25/5cc1ac17759f4.png" alt="数组分正负1.png"></p><p><img src="https://i.loli.net/2019/04/25/5cc1ac17074fd.png" alt="数组分正负2.png"></p><h1 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>试编写一个汇编语言程序，求出首地址为array的100D字数组中的最小偶数，并把它存放在AX中。</p><h2 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">array dw 100 dup(?)</span><br><span class="line">data ends</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">code segment</span><br><span class="line">main proc far</span><br><span class="line">assume cs: code, ds: data</span><br><span class="line">start:</span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds ; ds入栈</span><br><span class="line">sub ax, ax ; ax置0</span><br><span class="line">push ax ; 0入栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; ds存储数据段地址</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax ; 给ds赋值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line">mov bx, 0</span><br><span class="line">mov cx, 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compare:</span><br><span class="line">mov ax, data[bx]; 取数组的第一个数</span><br><span class="line">add bx, 2</span><br><span class="line">test ax, 01h ; 是偶数吗？</span><br><span class="line">loopnz compare ; 不是，则比较下一个数</span><br><span class="line">jnz stop ; 没有偶数，退出</span><br><span class="line">jcxz stop ; 最后一个数是偶数，即为最小偶数，退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compare1:</span><br><span class="line">mov dx, data[bx]; 取数组的下一个数</span><br><span class="line">add bx, 2</span><br><span class="line">test dx, 01h ; 是偶数吗？</span><br><span class="line">jnz next ; 不是，比较下一个数</span><br><span class="line">cmp ax, dx ; (ax)&lt;(dx)吗？</span><br><span class="line">jle next</span><br><span class="line">mov ax, dx ; (ax)&lt;(dx)，则置换(ax)为最小偶数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">loop compare1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">code ends ; 以上定义代码段</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="5-12"><a href="#5-12" class="headerlink" title="5.12"></a>5.12</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>有一个首地址为MEM的100D字数组，试编制程序删除数组中所有为0的项，并将后续项向前压缩，最后将数组的剩余部分补上0。</p><h2 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">mem dw 100 dup (?)</span><br><span class="line">data ends</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">code segment</span><br><span class="line">main proc far</span><br><span class="line">assume cs: code, ds: data</span><br><span class="line">start:</span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds ; 设置返回 dos</span><br><span class="line">sub ax, ax</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">; ds指向代码段</span><br><span class="line">mov ax, data</span><br><span class="line">mov ds, ax ; 给ds赋值</span><br><span class="line"></span><br><span class="line">begin:</span><br><span class="line">mov si, (100-1)*2 ; (si)指向 mem 的末元素的首地址</span><br><span class="line">mov bx, -2 ; 地址指针的初值</span><br><span class="line">mov cx, 100</span><br><span class="line"></span><br><span class="line">comp: add bx, 2</span><br><span class="line">cmp mem [bx], 0</span><br><span class="line">jz cons</span><br><span class="line">loop comp</span><br><span class="line">jmp finish ; 比较结束，已无0，则结束</span><br><span class="line"></span><br><span class="line">cons:</span><br><span class="line">mov di, bx</span><br><span class="line"></span><br><span class="line">cons1:</span><br><span class="line">cmp di, si ; 到了最后单元吗？</span><br><span class="line">jae nomov</span><br><span class="line">mov ax, mem [di+2] ; 后面的元素向前移位</span><br><span class="line">mov mem [di], ax</span><br><span class="line">add di, 2</span><br><span class="line">jmp cons1</span><br><span class="line"></span><br><span class="line">nomov:</span><br><span class="line">mov word ptr [si], 0; 最后单元补 0</span><br><span class="line">loop comp</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">ret</span><br><span class="line">main endp</span><br><span class="line">code ends ; 以上定义代码段</span><br><span class="line">; --------------------------------------------------------------------------</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;5-6&quot;&gt;&lt;a href=&quot;#5-6&quot; class=&quot;headerlink&quot; title=&quot;5.6&quot;&gt;&lt;/a&gt;5.6&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火学习</title>
    <link href="https://chouxianyu.github.io/2019/04/25/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://chouxianyu.github.io/2019/04/25/模拟退火学习/</id>
    <published>2019-04-24T18:01:13.000Z</published>
    <updated>2019-05-21T07:50:07.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="与贪心的区别"><a href="#与贪心的区别" class="headerlink" title="与贪心的区别"></a>与贪心的区别</h1><p>出现较好的解就使用，发现不了就形成解。缺点：跳不出局部最优解</p><p>模拟退火：与贪心类似，但可以以一定的概率跳出局部最优解，通过两个式子实现，Metropolis准则。玻尔兹曼分布</p><h1 id="模拟退火算法和物理退火过程的对应"><a href="#模拟退火算法和物理退火过程的对应" class="headerlink" title="模拟退火算法和物理退火过程的对应"></a>模拟退火算法和物理退火过程的对应</h1><div class="table-container"><table><thead><tr><th style="text-align:center">模拟退火算法</th><th style="text-align:center">物理退火过程</th></tr></thead><tbody><tr><td style="text-align:center">解</td><td style="text-align:center">粒子状态</td></tr><tr><td style="text-align:center">目标函数</td><td style="text-align:center">能量</td></tr><tr><td style="text-align:center">最优解</td><td style="text-align:center">能量最低态</td></tr><tr><td style="text-align:center">设定初温</td><td style="text-align:center">设置加温到几度</td></tr><tr><td style="text-align:center">扰动</td><td style="text-align:center">热涨落</td></tr><tr><td style="text-align:center">metropolis采样过程</td><td style="text-align:center">热平衡，粒子状态满足玻尔兹曼分布</td></tr><tr><td style="text-align:center">控制参数的下降</td><td style="text-align:center">冷却</td></tr></tbody></table></div><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><p>缩进代表层级嵌套关系。</p><ul><li><p>构造一个初始解，令当前解为该解。</p></li><li><p>设置初始温度，初始温度要设得比较高。</p></li><li><p>主要算法，while循环：</p><p>  循环条件可以是温度的阈值或者是解不怎么变化了</p><ul><li><p>for循环</p><p>  平衡过程，在该温度下，使达到平衡（metropolis），恒温下1到$T_L$步</p><ul><li>根据当前解随机生成一个邻解，跟当前解非常接近（扰动，for循环就是多次扰动）</li><li><p>计算邻解的目标函数（花费、路程、大小、钱数等等），减去当前解的目标函数，求得目标函数变化量</p></li><li><p>如果变化量小于0（即优化了），使用该邻近解；如果没有优化，则用metropolis准    则，看是不是要跳出坑，跳出则使用该邻解。</p></li></ul></li><li><p>平衡后设置新温度，即降温。</p></li></ul></li></ul><h1 id="模拟退火算法设计要素"><a href="#模拟退火算法设计要素" class="headerlink" title="模拟退火算法设计要素"></a>模拟退火算法设计要素</h1><h2 id="初始解的生成"><a href="#初始解的生成" class="headerlink" title="初始解的生成"></a>初始解的生成</h2><p>如果初始解比较好的话，收敛得就很快。</p><p>通常以一个随机解作为初始解，并保证理论上能生成解空间中任意的解。（一般要多做几次模拟退火，即试用不同的初始解，再取最优的）</p><p>也可以是一个挑出来的比较好的解。这种情况下，初始温度应当设置得较低。</p><p>初始解不宜“太好”，否则很难从这个解的邻域中跳出。</p><h2 id="邻解生成函数"><a href="#邻解生成函数" class="headerlink" title="邻解生成函数"></a>邻解生成函数</h2><p>应尽可能保证产生的候选解能遍布整个解空间。</p><p>邻域应尽可能的小，能够在少量循环内充分探测，但每次的改变不应该引起太大的变化。</p><h2 id="初始温度如何设定"><a href="#初始温度如何设定" class="headerlink" title="初始温度如何设定"></a>初始温度如何设定</h2><p>初始应该尽可能的高，以确保最终解不受初始解影响，但过高又会增加计算时间。</p><p>均匀抽样一组状态，以各状态目标值的方差为初温。（随机生成一组解）</p><p>等等</p><p>※ 正式开始退火算法前，可进行一个升温过程确定初始温度：逐渐增加温度，直到所有尝试运动都被接受，将此时的温度设置为初始温度。</p><p>等等</p><h2 id="等温步数如何确定"><a href="#等温步数如何确定" class="headerlink" title="等温步数如何确定"></a>等温步数如何确定</h2><p>等温步数即同一个温度下，跑几个循环。</p><p>等温步数也称Metropolis抽样稳定准则，用于决定在各温度下产生候选解的数目，通常取决于解空间和邻域的大小。如果解空间小，步数可以小一点。</p><p>等温过程是为了让系统达到平衡，因此可通过检验目标函数的均值是否稳定（或连续若干步的目标值变化较小，这个可以写一个函数来检测）来确定等温步数。等温步数可以长，也就是多平衡一会而已。</p><p>等温步数受温度的影响。高温时，等温步数可以较小；温度较小时，等温步数要大。随着温度降低，增加等温步数。（因为高温的时候比较混乱， 温度小的时候就在不停地收敛了），可以将等温步数设置成一个温度的函数。</p><p>有时为了考虑方便，也可以直接按一定的步数抽样。不区分高温和低温时的等温步数，大一点就好啦。</p><h2 id="如何降温"><a href="#如何降温" class="headerlink" title="如何降温"></a>如何降温</h2><p>经典模拟退火算法降温方式</p><p>快速模拟退火算法降温方式</p><p>常用的其他降温方式</p><p>后边两种比较常用</p><h2 id="花费函数"><a href="#花费函数" class="headerlink" title="花费函数"></a>花费函数</h2><p>不要太复杂，应该能被快速的计算，花费函数的计算是程序的可能瓶颈。</p><p>一般用目标函数构造花费函数即可。目标函数、目标函数的倒数/相反数经常直接作为花费函数                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p><h2 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h2><p>理论上温度降为0才终止退火算法，因为此时没有概率跳出坑了。但实际温度较低时，尝试的接受概率就几乎为0了。</p><p>设置终止温度的阈值，或设置外循环循环迭代次数。</p><p>算法搜索到的最优值连续若干步保持不变。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>有人说这就是遗传算法+梯度下降。老师说这个算法属于一种蒙特卡洛算法，和蒙特卡洛算法类似。国赛和美赛几乎不会考TSP，太简单了，小比赛才有可能让选手练手。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;与贪心的区别&quot;&gt;&lt;a href=&quot;#与贪心的区别&quot; class=&quot;headerlink&quot; title=&quot;与贪心的区别&quot;&gt;&lt;/a&gt;与贪心的区别&lt;/h1&gt;&lt;p&gt;出现较好的解就使用，发现不了就形成解。缺点：跳不出局部最优解&lt;/p&gt;
&lt;p&gt;模拟退火：与贪心类似，但可以以一
      
    
    </summary>
    
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="模拟退火" scheme="https://chouxianyu.github.io/tags/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之继承（一）</title>
    <link href="https://chouxianyu.github.io/2019/04/16/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%BB%A7%E6%89%BF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2019/04/16/C-C-小课之继承（一）/</id>
    <published>2019-04-16T15:18:33.000Z</published>
    <updated>2019-05-01T03:51:47.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h1><p>继承源于生物界，指后代能够传承前代的特征和行为。</p><h2 id="基类和子类"><a href="#基类和子类" class="headerlink" title="基类和子类"></a>基类和子类</h2><p>继承使我们可以通过一个已有的类创建一个新类，新类自然获得已有类的全部功能。在<strong>某个继承关系</strong>中，已有的类在这个继承关系中作为<strong>基类</strong>、<strong>超类</strong>或<strong>父类</strong>，新类称为<strong>派生类</strong>或<strong>子类</strong>。</p><p>具体来讲，子类复制了基类的全体数据成员和成员函数。此外，子类还可以进行扩充、修改和重定义。</p><p>同一个类可以作为多个类的基类，一个子类也可以作为另一个类的基类。</p><p>基类和子类是继承关系中的概念，并不是本质的概念，而是关系上的概念。</p><h2 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h2><p>A作为基类，B作为子类时，我们称：</p><ul><li>B继承A</li><li>A派生B</li></ul><h2 id="单继承和多继承"><a href="#单继承和多继承" class="headerlink" title="单继承和多继承"></a>单继承和多继承</h2><p>只能从一个基类派生的继承称为<strong>单继承</strong>，即一个类一次最多继承一个基类。</p><p>可以从多个基类派生的继承称为<strong>多继承</strong>。</p><p>C++支持单继承和多继承。</p><p>Java只支持单继承，需要“多继承”时使用<strong>接口</strong>实现。（接口是什么，学了Java就知道了）</p><h1 id="类成员访问权限"><a href="#类成员访问权限" class="headerlink" title="类成员访问权限"></a>类成员访问权限</h1><p>C++类成员访问权限默认为<strong>private</strong>。</p><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><p>语法正确的条件下，访问不受控制，在哪里都可以访问。</p><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>只能在<strong>类内</strong>、<strong>友元函数</strong>访问。</p><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>只能在<strong>类内</strong>、<strong>子类内</strong>、<strong>友元函数</strong>访问。</p><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><p><strong>注意</strong>：继承方式决定的是<strong>子类如何继承基类成员的访问权限</strong>。</p><p>不同继承方式会不同程度地<strong>改变基类成员在派生类中的访问权限</strong>。（个人觉得这句话不好，易让人误解）</p><p>C++中继承方式默认为<code>private</code>。</p><h2 id="public-1"><a href="#public-1" class="headerlink" title="public"></a>public</h2><p>基类成员的访问权限在派生类中保持<strong>不变</strong>。</p><p>基类的<code>private</code>成员、<code>public</code>成员、<code>protected</code>成员在子类中保持他们在基类中相同的访问权限。</p><h2 id="private-1"><a href="#private-1" class="headerlink" title="private"></a>private</h2><p>基类成员的访问权限在派生类中全部变为<code>private</code>。</p><h2 id="protected-1"><a href="#protected-1" class="headerlink" title="protected"></a>protected</h2><p>基类的<code>public</code>成员的访问权限在派生类中变为<code>protected</code>。</p><p><code>private</code>成员和<code>protected</code>成员的访问权限不变。</p><h1 id="派生类对基类的扩展"><a href="#派生类对基类的扩展" class="headerlink" title="派生类对基类的扩展"></a>派生类对基类的扩展</h1><p>派生类<strong>可以</strong>：</p><ul><li><strong>增加</strong>新的数据成员和成员函数</li><li><strong>重载</strong>从基类继承到的成员函数</li><li>覆盖（<strong>重定义</strong>）从基类集成到的成员函数</li><li>改变基类成员在派生类中的访问属性（通过继承方式实现）</li></ul><p>派生类<strong>不能</strong>继承基类的以下内容：</p><ul><li>析构函数</li><li>基类的友元函数</li><li>静态成员<ul><li>静态数据成员</li><li>静态成员函数</li></ul></li></ul><p><strong>注意</strong>：</p><p>静态成员为整个继承体系公有。</p><p>C++11之前，派生类不能继承基类的构造函数，C++11之后可以，通过<code>using</code>实现。</p><h2 id="成员函数的重定义、重载及隐藏"><a href="#成员函数的重定义、重载及隐藏" class="headerlink" title="成员函数的重定义、重载及隐藏"></a>成员函数的重定义、重载及隐藏</h2><p>派生类对继承到的基类成员函数的<strong>重定义</strong>或<strong>重载</strong>都会影响它们在派生类中的可见性。</p><p>派生类对基类函数进行重定义或重载时，由于继承和类作用域的原因，导致了隐藏，解决隐藏有三种方法。</p><p><strong>影响可见性</strong>：</p><p>如果派生类<strong>重定义</strong>或者<strong>重载</strong>了基类中某个函数名为<code>func</code>的函数，则基类中的所有名字为<code>func</code>的函数都会被<strong>隐藏</strong>。（其中<strong>隐藏</strong>指的是在派生类中不能直接看到这个函数。）</p><p><strong>解决</strong>：</p><ol><li><p>通过基类名称访问被派生类<strong>重定义</strong>或<strong>重载</strong>隐藏的函数，</p><p> 如<code>基类::函数名(...)</code>。</p></li><li><p>重载基类的所有同名函数，这些重载函数的代码与基类完全相同。</p></li><li><p>使用<code>using</code>。</p></li></ol><p>前两种方法都很繁琐。</p><p>而C++11提供了<code>using</code>使基类中被隐藏的函数在派生类中可见，具体使用在后边的<code>using</code>部分讲解。</p><h3 id="重定义"><a href="#重定义" class="headerlink" title="重定义"></a>重定义</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><strong>覆盖</strong>也称为<strong>重定义</strong>、<strong>重写</strong>。</p><p>重定义是指派生类定义与基类<strong>具有相同参数列表</strong>的同名成员函数。</p><p>（关于重定义的定义，我个人认为书上P147的说法是错的。）</p><h4 id="隐藏及解决"><a href="#隐藏及解决" class="headerlink" title="隐藏及解决"></a>隐藏及解决</h4><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">()</span><span class="comment">//重定义Base类的void print()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b1;</span><br><span class="line">Derived d1;</span><br><span class="line"></span><br><span class="line">b1.print();<span class="comment">//Base类调用函数正常</span></span><br><span class="line">b1.print(<span class="number">1</span>);<span class="comment">//Base类调用函数正常</span></span><br><span class="line"></span><br><span class="line">d1.print();<span class="comment">//Base类中的print()被隐藏，调用Derived类的print()</span></span><br><span class="line">d1.print(<span class="number">1</span>);<span class="comment">//该行报错，编译不通过。原因是Derived类的int print()重定义了Base类的void print()，导致Base中所有同名函数被隐藏，即print(int)和print()被隐藏。</span></span><br><span class="line"></span><br><span class="line">d1.Base::print();<span class="comment">//调用Base类的print()</span></span><br><span class="line">d1.Base::print(<span class="number">1</span>);<span class="comment">//调用Base类的print(int)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将第34行注释后，输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base::print()</span><br><span class="line">Base::print().....<span class="number">.1</span></span><br><span class="line">Derived::print()</span><br><span class="line">Base::print()</span><br><span class="line">Base::print().....<span class="number">.1</span></span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>重载与重定义不同，重载要求成员函数名称相同，但<strong>具有不同的参数列表</strong>。</p><p>（关于重载的定义，我个人认为书上P147的说法是错的）</p><h4 id="隐藏及解决-1"><a href="#隐藏及解决-1" class="headerlink" title="隐藏及解决"></a>隐藏及解决</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> i)</span><span class="comment">//重载Base类的两个print函数，即print()、print(int i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int print(int i);//这个是重定义Base的void print(int i)，而非重载</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b1;</span><br><span class="line">Derived d1;</span><br><span class="line"></span><br><span class="line">b1.print();<span class="comment">//Base类调用函数正常</span></span><br><span class="line">b1.print(<span class="number">1</span>);<span class="comment">//Base类调用函数正常</span></span><br><span class="line"></span><br><span class="line">d1.print();<span class="comment">//该行报错，因为Derived的print(char i)重载了Base类的两个print函数，它们在Derived类中被隐藏了</span></span><br><span class="line">d1.print(<span class="string">'A'</span>);<span class="comment">//调用Derived类的print(char i)</span></span><br><span class="line"></span><br><span class="line">d1.Base::print();<span class="comment">//调用Base类的print()</span></span><br><span class="line">d1.Base::print(<span class="number">1</span>);<span class="comment">//调用Base类的print(int)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将第33行注释后，输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base::print()</span><br><span class="line">Base::print().....<span class="number">.1</span></span><br><span class="line">Derived::print()......A</span><br><span class="line">Base::print()</span><br><span class="line">Base::print().....<span class="number">.1</span></span><br></pre></td></tr></table></figure><h2 id="using"><a href="#using" class="headerlink" title="using"></a>using</h2><p>using有三个用途：</p><ul><li>使隐藏的函数重现</li><li>改变基类成员在派生类中的访问权限</li><li>使子类继承基类构造函数（在继承第二讲中讲解如何使用）</li></ul><h3 id="使隐藏函数重现"><a href="#使隐藏函数重现" class="headerlink" title="使隐藏函数重现"></a>使隐藏函数重现</h3><p><strong>方法</strong>：在派生类中用<code>using 基类::函数名;</code>声明基类的函数名，不需提供函数参数。</p><p>一条<code>using</code>可以把<strong>指定函数名</strong>的所有版本添加到派生类作用域中，它们的访问权限与using语句所在区域的访问权限相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> i)</span><span class="comment">//重载Base类的两个print函数，即print()、print(int i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Base::print;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Derived d1;</span><br><span class="line"></span><br><span class="line">d1.print();<span class="comment">//不加using的话该行报错</span></span><br><span class="line">d1.print(<span class="string">'A'</span>);<span class="comment">//调用Derived类的print(char i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改变基类成员在派生类中的访问权限"><a href="#改变基类成员在派生类中的访问权限" class="headerlink" title="改变基类成员在派生类中的访问权限"></a>改变基类成员在派生类中的访问权限</h3><p>在派生类的<code>public</code>、<code>protected</code>或<code>private</code>权限区域内，使用<code>using</code>再次声明基类的非<code>private</code>成员，就可以重新设置它们在派生类中的权限为<code>using</code>语句所在区域的权限。</p><h2 id="继承和类作用域"><a href="#继承和类作用域" class="headerlink" title="继承和类作用域"></a>继承和类作用域</h2><p>在存在继承关系时，派生类的作用域嵌套在基类作用域的内层。</p><p>因此，在解析类成员名称时，如果在本类的作用域内没有找到，编译器会接着在外层的基类作用域内继续寻找该成员名称的定义。</p><p>在这个寻找的过程中，一旦在某个作用域找到了，就停止查找，即使外层作用域内还有同名成员，也不找了。</p><p>形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    Derived &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码验证</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::print()......"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::print()......"</span>  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span> :</span><span class="keyword">public</span> Derived1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived2 d;</span><br><span class="line">d.print(<span class="number">1</span>);<span class="comment">//该行代码报错，因为在Derived1中找到同名函数void print()，不会再向外层找，又因为参数列表不匹配，所以报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;继承的概念&quot;&gt;&lt;a href=&quot;#继承的概念&quot; class=&quot;headerlink&quot; title=&quot;继承的概念&quot;&gt;&lt;/a&gt;继承的概念&lt;/h1&gt;&lt;p&gt;继承源于生物界，指后代能够传承前代的特征和行为。&lt;/p&gt;
&lt;h2 id=&quot;基类和子类&quot;&gt;&lt;a href=&quot;#基类和子
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="继承" scheme="https://chouxianyu.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="https://chouxianyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>项目开发记录</title>
    <link href="https://chouxianyu.github.io/2019/04/12/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://chouxianyu.github.io/2019/04/12/项目开发记录/</id>
    <published>2019-04-12T14:17:25.000Z</published>
    <updated>2019-04-24T17:52:17.067Z</updated>
    
    <content type="html"><![CDATA[<p>一段旅程算是结尾了吧，以下为本学期开发记录：</p><ul><li>2.26 晚上</li></ul><p>整理项目里的代码和注释</p><ul><li>2.27 中午至下午</li></ul><p>解决先登录问题</p><ul><li>2.28 下午</li></ul><p>解决先登录问题</p><ul><li>3.1   中午至下午</li></ul><p>解决先登录后续问题：控制台warning，路由重复</p><p>尝试数据持久化，redux-persist</p><ul><li>3.2   下午</li></ul><p>数据持久化 redux-persist。combineReducer？ persistCombineReducer?</p><ul><li>3.3   </li></ul><p>循环injectedReducers，发现有个root，还有动态的数据持久化配置不好实现，改用localStoreage</p><ul><li>3.11  晚上</li></ul><p>给后端分任务：规定用户名和密码格式要求，并检测其合法性，新的页面要显示什么内容，前后端交互</p><ul><li>3.19 下午</li></ul><p>总结项目，明确各自的任务</p><ul><li>3.23 下午</li></ul><p>和hyk讨论前后端合作。</p><ul><li>3.25 下午</li></ul><p>开发编辑/显示标准基本信息界面，定义与后端交互的接口内容</p><ul><li>3.27 早上、晚上</li></ul><p>开发修改密码页面，补充标准基本信息界面提交功能</p><ul><li>3.30 上午</li></ul><p>前后端交互测试成功。向老师汇报情况</p><ul><li>3.31</li></ul><p>项目上传至coding</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一段旅程算是结尾了吧，以下为本学期开发记录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.26 晚上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整理项目里的代码和注释&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.27 中午至下午&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决先登录问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2.28 下午&lt;
      
    
    </summary>
    
    
      <category term="React" scheme="https://chouxianyu.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-实验（二）常用网络指令</title>
    <link href="https://chouxianyu.github.io/2019/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E6%8C%87%E4%BB%A4/"/>
    <id>https://chouxianyu.github.io/2019/04/10/计算机网络-实验（二）常用网络指令/</id>
    <published>2019-04-10T12:34:44.000Z</published>
    <updated>2019-04-13T08:27:32.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ol><li>学会并掌握常用网络命令。</li><li>学会分析在不同参数下显示的数据。</li></ol><h1 id="实验仪器"><a href="#实验仪器" class="headerlink" title="实验仪器"></a>实验仪器</h1><p>PC机、局域网</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h2><p><strong>知识点扫盲</strong>：地址解析协议，即<em>ARP</em>（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。</p><p><strong>功能</strong>：显示和修改IP地址与物理地址之间的转换表</p><h3 id="a"><a href="#a" class="headerlink" title="-a"></a>-a</h3><p><strong>功能</strong>：（Windows下）显示当前的ARP信息，可以指定网络地址。</p><p>Linux系统中，使用<code>-g</code>。</p><p><strong>代码</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a<span class="comment"># 显示当前所有的ARP信息</span></span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Internet Address</th><th style="text-align:center">Physical Address</th><th style="text-align:center">Type</th></tr></thead><tbody><tr><td style="text-align:center">192.168.1.178</td><td style="text-align:center">00-16-ec-a0-42-fa</td><td style="text-align:center">dynamic</td></tr><tr><td style="text-align:center">..…</td><td style="text-align:center">..…</td><td style="text-align:center">..…</td></tr></tbody></table></div><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arp -a 192.168.1.178# 显示指定IP(即192.168.1.178)的ARP信息</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Internet Address</th><th style="text-align:center">Physical Address</th><th style="text-align:center">Type</th></tr></thead><tbody><tr><td style="text-align:center">192.168.1.178</td><td style="text-align:center">00-16-ec-a0-42-fa</td><td style="text-align:center">dynamic</td></tr></tbody></table></div><h3 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h3><p><strong>功能</strong>：添加主机，并将网络地址跟物理地址相对应，这一项是永久生效的。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arp -s 157.55.85.212 00-aa-00-62-c6-09 # 在IP和物理地址转换表中添加一项</span><br><span class="line">arp -a 157.55.85.212# 显示指定IP(即157.55.85.212)的ARP信息</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Internet Address</th><th style="text-align:center">Physical Address</th><th style="text-align:center">Type</th></tr></thead><tbody><tr><td style="text-align:center">157.55.85.212</td><td style="text-align:center">00-aa-00-62-c6-09</td><td style="text-align:center"><strong>static</strong></td></tr></tbody></table></div><p><strong>注意</strong>：这里添加的一个<code>Type</code>为<code>static</code>的。</p><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p><strong>功能</strong>：删除指定的主机，可以使用* 来删除所有主机。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arp -d 157.55.85.212# 删除指定IP(即157.55.85.212)</span><br><span class="line">arp -a 157.55.85.212# 显示指定IP(即157.55.85.212)的ARP信息</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NO ARP Entries Found</span><br></pre></td></tr></table></figure><h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p><strong>知识点扫盲</strong>：文件传输协议，即FTP(File Transfer Protocol)。是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议。</p><p>ftp也是一种服务。一旦启动，将创建在其中可以使用ftp命令的子环境，通过键入 <code>quit</code>子命令可以从子环境返回到Windows命令提示符。当 ftp 子环境运行时，它由ftp命令提示符代表。</p><p>下边的指令除了ftp是在Windows命令提示符，其他都是在ftp的子环境里。</p><p><strong>功能</strong>：控制文件的双向传输（老师说的..…）。</p><h3 id="ftp-1"><a href="#ftp-1" class="headerlink" title="ftp"></a>ftp</h3><p><strong>功能</strong>：启动ftp服务。</p><p>在命令提示符下，直接输入<code>ftp</code>即可。</p><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open 192.168.1.171# 连接指定的ftp服务器（这里是老师的电脑）</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connected to 192.168.1.171.</span><br><span class="line">220-Microsoft FTP Service</span><br><span class="line">220 张芳之家</span><br><span class="line">User (192.168.1.171:(none)): zf</span><br><span class="line">331 Password required for zf.</span><br><span class="line">Password:</span><br><span class="line">230-欢迎进入“张芳之家”</span><br><span class="line">230 User zf logged in.</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上边的第6行需要输入<strong>密码</strong>。我们输的时候，屏幕上并不会显示出来。</p><h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><p><strong>功能</strong>：查看本目录下的内容，目录可以理解成文件夹的意思。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir# 查看当前目录内容</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">200 PORT command successful.# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for /bin/ls.# ASCII传输方式连接/bin/ls</span><br><span class="line">04-26-1308:22AM&lt;DIR&gt;654# 有个文件夹，名字是654</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 44 字节，用时 0.00 Seconds 44000.00Kbyte/sec.</span><br></pre></td></tr></table></figure><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p><strong>功能</strong>：更换<strong>远程</strong>目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 654# 进入文件夹654</span><br><span class="line">dir# 查看当前目录内容</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">200 PORT command successful.# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for /bin/ls.# ASCII传输方式连接/bin/ls</span><br><span class="line">04-26-1308:22AM70qqq.txt# 有个文件，名字是qqq.txt</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 48 字节，用时 0.00 Seconds 44000.00Kbyte/sec.</span><br></pre></td></tr></table></figure><h3 id="lcd"><a href="#lcd" class="headerlink" title="lcd"></a>lcd</h3><p><strong>功能</strong>：更换<strong>本地</strong>目录，若无参数，将显示当前目录。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcd e:\</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local directory now E:\.</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><strong>功能</strong>：将远程文件复制到本地计算机。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get qqq.txt</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">200 PORT command successful.# 请求成功</span><br><span class="line">150 Opening ASCII mode data connection for qqq.txt(70 bytes)# ASCII传输方式连接/bin/ls</span><br><span class="line">226 Transfer complete.</span><br><span class="line">ftp: 收到 70 字节，用时 0.00 Seconds 70000.00Kbyte/sec.</span><br></pre></td></tr></table></figure><h3 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h3><p><strong>功能</strong>：退出ftp服务。ftp子环境下输入<code>quit</code>即可。</p><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">221 再见！欢迎下次“张芳之家”</span><br></pre></td></tr></table></figure><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p><strong>功能</strong>：显示当前的TCP/IP配置的设置值。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows IP Configuration</span><br><span class="line"></span><br><span class="line">Ethernet adapter 本地连接:</span><br><span class="line">        Connection-specific DNS Suffix  . :</span><br><span class="line">        IP Address. . . . . . . . . . . . : 192.168.1.95# IP地址</span><br><span class="line">        Subnet Mask . . . . . . . . . . . : 255.255.255.0# 子网掩码</span><br><span class="line">        Default Gateway . . . . . . . . . : 192.168.1.3# 缺省网关</span><br></pre></td></tr></table></figure><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p><strong>知识点扫盲</strong>：Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。</p><p><strong>功能</strong>：远程连接另一台计算机</p><h3 id="telnet-1"><a href="#telnet-1" class="headerlink" title="telnet"></a>telnet</h3><p><strong>功能</strong>：启动telnet。</p><p>在命令提示符下，直接输入<code>telnet</code>即可。</p><h3 id="open-1"><a href="#open-1" class="headerlink" title="open"></a>open</h3><p><strong>功能</strong>：连接指定计算机。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open 192.168.1.94# 连接我同桌..</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正在连接到192.168.1.94... </span><br><span class="line">您将要发送密码信息到 Internet 区域中的远程计算机。这可能不安全。是否还要发送(y/n</span><br><span class="line">): n</span><br><span class="line">login:ligong</span><br><span class="line">password:</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：第四行和第五行输入账号和密码，密码并不会显示出来。</p><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>功能</strong>：复制文件到自己电脑上</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy qqq.txt c:\# 复制其e盘qqq.txt到其c盘，前提是此时已在E盘，使用cd e:\实现</span><br></pre></td></tr></table></figure><h3 id="quit-1"><a href="#quit-1" class="headerlink" title="quit"></a>quit</h3><p>退出，直接输入<code>quit</code>即可。</p><h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p><strong>知识点扫盲</strong>：它包含了管理网络环境、服务、用户、登陆等Windows 98/NT/2000 中大部分重要的管理功能。</p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p><strong>功能</strong>：将消息发送到网络上的其他用户、计算机或消息名。必须运行信使服务以接收邮件。</p><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net send * 123# 给所有人发123</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息已经送到域 2HJF</span><br></pre></td></tr></table></figure><p><strong>代码</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net send s14 hello# 给s14机器发hello</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消息已经送到 S14</span><br></pre></td></tr></table></figure><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;学会并掌握常用网络命令。&lt;/li&gt;
&lt;li&gt;学会分析在不同参数下显示的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言-实验（一）</title>
    <link href="https://chouxianyu.github.io/2019/04/08/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://chouxianyu.github.io/2019/04/08/汇编语言-实验（一）/</id>
    <published>2019-04-08T03:18:40.000Z</published>
    <updated>2019-04-10T12:36:54.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在数据段DATA中有两个字数据X和Y, 假设X=1122H, Y=3344H, 编程求两个字的和,结果存放到Z单元中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;*********************************************************************</span><br><span class="line">data segment; 定义数据段</span><br><span class="line">x dw <span class="number">1122</span>h; 字 X</span><br><span class="line">y dw <span class="number">3344</span>h; 字 Y</span><br><span class="line">z dw ?; 字 Z</span><br><span class="line">data ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">code segment; 定义代码段</span><br><span class="line">assume cs:code,ds:data</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">main proc far; 程序的主部分</span><br><span class="line">start:</span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds; ds压栈</span><br><span class="line">xor ax,ax; (ax) &lt;- data</span><br><span class="line">push ax; ax压栈</span><br><span class="line"></span><br><span class="line">; ds设为data</span><br><span class="line">mov ax,data; (ax) &lt;- data</span><br><span class="line">mov ds,ax; (ds) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; z=x+y</span><br><span class="line">mov ax,x; (al) &lt;- x</span><br><span class="line">add ax,y; (al) &lt;- (al)+y</span><br><span class="line">mov z,ax; (z) &lt;- (al)</span><br><span class="line"></span><br><span class="line">; 返回DOS环境</span><br><span class="line">ret; 返回DOS环境</span><br><span class="line">main  endp</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">code  ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串传送到DEST_BUFFER开始的单元中。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">;*********************************************************************</span><br><span class="line">data segment; 定义数据段</span><br><span class="line">source_buffer db <span class="number">20</span> dup(<span class="string">'A'</span>); 串source_buffer，占<span class="number">20</span>个字节，内容是<span class="number">20</span>个字母A</span><br><span class="line">data ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">extra segment; 定义附加段</span><br><span class="line">dest_buffer db <span class="number">20</span> dup(?); 串dest_buffer，占<span class="number">20</span>个字节，内容未确定</span><br><span class="line">extra ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">code segment; 定义代码段</span><br><span class="line">assume cs:code,ds:data,es:extra</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">main proc far; 程序的主部分</span><br><span class="line">start: </span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds; ds压栈</span><br><span class="line">xor ax,ax; (ax) &lt;- data</span><br><span class="line">push ax; ax压栈</span><br><span class="line"></span><br><span class="line">; ds设为data</span><br><span class="line">mov ax,data; (ax) &lt;- data</span><br><span class="line">mov ds,ax; (ds) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; es设为extra</span><br><span class="line">mov ax,extra; (ax) &lt;- extra</span><br><span class="line">mov es,ax; (es) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; 准备工作</span><br><span class="line">lea si,source_buffer; 存储源串首地址</span><br><span class="line">lea di,dest_buffer; 存储目的串首地址</span><br><span class="line">cld; 建立方向标志</span><br><span class="line">mov cx,<span class="number">20</span>; <span class="number">20</span>个字符</span><br><span class="line">; 移动串</span><br><span class="line">rep movsb; 移动串至CX为<span class="number">0</span>，即移动整个串</span><br><span class="line"></span><br><span class="line">; 返回DOS环境</span><br><span class="line">ret; 返回DOS环境</span><br><span class="line">main  endp</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">code  ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h1><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>从SOURCE_BUFFER单元开始存放了20个字母A, 编程将这20个字母A的字符串向下移10个单元。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">;*********************************************************************</span><br><span class="line">extra segment; 定义附加段</span><br><span class="line">source_buffer db <span class="number">20</span> dup(<span class="string">'A'</span>); 串source_buffer，占<span class="number">20</span>个字节，内容是<span class="number">20</span>个字母A</span><br><span class="line">dest_buffer=source_buffer+<span class="number">10</span>; 串dest_buffer，结果串的首地址</span><br><span class="line">extra ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">code segment; 定义代码段</span><br><span class="line">assume cs:code,es:extra</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">main proc far; 程序的主部分</span><br><span class="line">start: </span><br><span class="line">; 为返回DOS做准备</span><br><span class="line">push ds; ds压栈</span><br><span class="line">xor ax,ax; (ax) &lt;- <span class="number">0</span></span><br><span class="line">push ax; ax压栈</span><br><span class="line"></span><br><span class="line">; es设为extra</span><br><span class="line">mov ax,extra; (ax) &lt;- extra</span><br><span class="line">mov es,ax; (es) &lt;- (ax)</span><br><span class="line"></span><br><span class="line">; 准备工作</span><br><span class="line">lea si,source_buffer+<span class="number">19</span>; 存储源串末地址</span><br><span class="line">lea di,dest_buffer+<span class="number">19</span>; 存储目的串末地址</span><br><span class="line"><span class="built_in">std</span>; 建立方向标志</span><br><span class="line">mov cx,<span class="number">20</span>; <span class="number">20</span>个字符</span><br><span class="line">; 移动串</span><br><span class="line">rep movs es:byte ptr[di],es:[di]; 移动串至CX为<span class="number">0</span>，即移动整个串</span><br><span class="line"></span><br><span class="line">; 返回DOS环境</span><br><span class="line">ret; 返回DOS环境</span><br><span class="line">main  endp</span><br><span class="line">;---------------------------------------------------------------------</span><br><span class="line">code  ends</span><br><span class="line">;*********************************************************************</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><p>不小心，上边代码写错了,<code>rep movs ds:byte ptr[di],ds:[di]</code>，源地址和目标地址不小心都用了di。</p><p>按说这样不能进行后移，但却得到了正确的结果。</p><p>经过调试，发现可能是编译环境自行将我的错误代码改成了正确代码，进行了优化。</p><p>同时也发现：<code>rep movs ds:byte ptr[si],ds:[di]</code>，这个代码也是错的，但也得到了正确的结果。</p><p>正确的代码应该是这样：<code>rep movs ds:byte ptr[di],ds:[si]</code>。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目一&quot;&gt;&lt;a href=&quot;#题目一&quot; class=&quot;headerlink&quot; title=&quot;题目一&quot;&gt;&lt;/a&gt;题目一&lt;/h1&gt;&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="汇编" scheme="https://chouxianyu.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="Bug" scheme="https://chouxianyu.github.io/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之指针悬挂</title>
    <link href="https://chouxianyu.github.io/2019/03/28/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E6%8C%87%E9%92%88%E6%82%AC%E6%8C%82/"/>
    <id>https://chouxianyu.github.io/2019/03/28/C-C-小课之指针悬挂/</id>
    <published>2019-03-28T15:44:06.000Z</published>
    <updated>2019-03-28T15:58:33.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是指针悬挂"><a href="#什么是指针悬挂" class="headerlink" title="什么是指针悬挂"></a>什么是指针悬挂</h1><p><strong>指向非法内存的指针，也叫野指针。</strong></p><p>非法内存即不能使用的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="number">12345</span>;</span><br><span class="line"><span class="comment">//int* p;//p未初始化，p的值随机，一般都会指向非法内存</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p;<span class="comment">//运行这行代码会出错</span></span><br></pre></td></tr></table></figure><p>随便让p指向一块内存（一般指向非法内存）。</p><p><strong>运行时使用非法内存，会报错。</strong></p><h1 id="一些指针悬挂的情况"><a href="#一些指针悬挂的情况" class="headerlink" title="一些指针悬挂的情况"></a>一些指针悬挂的情况</h1><p>课本中有两处提到指针悬挂，分别是：<strong>合成拷贝构造函数</strong>和<strong>合成赋值运算符函数</strong>。</p><p>如果类中有指针，这两个函数<strong>可能</strong>造成指针悬挂。（看完之后想想为什么只是可能？）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面给出这两种函数造成指针悬挂的代码及注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">MyClass()&#123;p = <span class="keyword">new</span> <span class="keyword">int</span>;&#125;</span><br><span class="line">~MyClass()&#123;<span class="keyword">delete</span> p;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass a;</span><br><span class="line"><span class="function">MyClass <span class="title">b</span><span class="params">(a)</span></span>;<span class="comment">//调用合成拷贝函数</span></span><br><span class="line"><span class="comment">//MyClass b = a;//调用合成赋值运算符</span></span><br><span class="line">a.print();</span><br><span class="line">b.print();<span class="comment">//据两行输出可知，两个指针指向同一块内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后，B会先析构，然后A析构。</span></span><br><span class="line"><span class="comment">//B析构会释放p指向的内存，同时这块内存变为非法内存，</span></span><br><span class="line"><span class="comment">//此时A的指针p指向非法内存，造成指针悬挂。</span></span><br><span class="line"><span class="comment">//A析构时delete p,使用了非法内存，这时出错</span></span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>如果这两个函数造成指针悬挂，应显式提供这两个函数，并将这两个合成函数的<strong>浅拷贝改为深拷贝</strong>。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是指针悬挂&quot;&gt;&lt;a href=&quot;#什么是指针悬挂&quot; class=&quot;headerlink&quot; title=&quot;什么是指针悬挂&quot;&gt;&lt;/a&gt;什么是指针悬挂&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;指向非法内存的指针，也叫野指针。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非法内存即不能使用
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="指针" scheme="https://chouxianyu.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>插值和线性回归</title>
    <link href="https://chouxianyu.github.io/2019/03/28/%E6%8F%92%E5%80%BC%E5%92%8C%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>https://chouxianyu.github.io/2019/03/28/插值和线性回归/</id>
    <published>2019-03-28T11:26:40.000Z</published>
    <updated>2019-03-28T11:29:20.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>根据现有数据，插的值一定在曲线上。</p><p><code>interpl</code>，一维插值函数。</p><h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><p><code>regress</code></p><p>$Y=b_0+b_1x_1+b_2x_2+\cdots+b_kx_k$</p><p>拟合$x_1\ x_2\ \cdots\ x_k$与$Y$的关系</p><p><code>[B, Bint, R, Rint, Status]=regress(Y, X)</code></p><p><code>B</code>：回归得到的自变量系数</p><p><code>Bint</code>：B的95%的置信区间矩阵</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插值&quot;&gt;&lt;a href=&quot;#插值&quot; class=&quot;headerlink&quot; title=&quot;插值&quot;&gt;&lt;/a&gt;插值&lt;/h1&gt;&lt;p&gt;根据现有数据，插的值一定在曲线上。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;interpl&lt;/code&gt;，一维插值函数。&lt;/p&gt;
&lt;h1 id=&quot;线性回归
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="插值" scheme="https://chouxianyu.github.io/tags/%E6%8F%92%E5%80%BC/"/>
    
      <category term="线性回归" scheme="https://chouxianyu.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>传染病模型</title>
    <link href="https://chouxianyu.github.io/2019/03/28/%E4%BC%A0%E6%9F%93%E7%97%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://chouxianyu.github.io/2019/03/28/传染病模型/</id>
    <published>2019-03-28T11:26:20.000Z</published>
    <updated>2019-03-28T11:28:31.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>该模型在数学建模中可以解决很多问题。</p><p>该模型由三个微分方程构成。</p><h1 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>假设系统中有三种人：</p><ul><li><p>易感染的人</p><p>  数量用$S$表示，刚开始所有人都是易感染的人</p></li><li><p>感染的人</p><p>  数量用$I$表示</p></li><li><p>康复的人</p><p>  数量用$R$表示（假设该传染病不致命）</p></li></ul><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><p>$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              \frac{dS}{dt}=-\beta SI\\<br>              \frac{dI}{dt}=\beta SI-\gamma I\\<br>              \frac{dR}{dt}=\gamma I\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><p>其中$\beta$是接触率，$\gamma$是康复率。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="函数odesir"><a href="#函数odesir" class="headerlink" title="函数odesir"></a>函数odesir</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dy</span> = <span class="title">odesir</span><span class="params">(t, y, beta, gamma)</span></span></span><br><span class="line"><span class="comment">% 根据传染病模型者中的y和t求出dy/dt</span></span><br><span class="line"><span class="comment">% y=[S; I; R]</span></span><br><span class="line">dy =</span><br><span class="line">[</span><br><span class="line">-beta*y(<span class="number">1</span>)*y(<span class="number">2</span>); % dS/dt</span><br><span class="line">beta*y(<span class="number">1</span>)*y(<span class="number">2</span>) - gamma*y(<span class="number">2</span>); % dS/dt</span><br><span class="line">gamma*y(<span class="number">2</span>); % dR/dt</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.01</span>;</span><br><span class="line"><span class="built_in">gamma</span> = <span class="number">0.1</span>;</span><br><span class="line">tspan = [<span class="number">0</span>,<span class="number">50</span>];</span><br><span class="line">y0 = [<span class="number">99</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">[t y] = ode45(@odesir, tspan, y0, [], bata, <span class="built_in">gamma</span>);</span><br><span class="line">plot(t,y);</span><br><span class="line">xlabel(<span class="string">'time'</span>);</span><br><span class="line">ylabel(<span class="string">'population'</span>);</span><br><span class="line">legend(<span class="string">'S'</span>, <span class="string">'I'</span>, <span class="string">'R'</span>);</span><br></pre></td></tr></table></figure><p><code>ode23</code>和<code>ode45</code>的区别：精度不一样，<code>ode45</code>精度高。</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><a href="https://i.loli.net/2019/03/28/5c9cae1f0f6be.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/28/5c9cae1f0f6be.png" alt="传染病.png"></a></p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;该模型在数学建模中可以解决很多问题。&lt;/p&gt;
&lt;p&gt;该模型由三个微分方程构成。&lt;/p&gt;
&lt;h1 id=&quot;建立模型&quot;&gt;&lt;a href=&quot;#建立
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="微分方程" scheme="https://chouxianyu.github.io/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Runge-Kutta法解微分方程</title>
    <link href="https://chouxianyu.github.io/2019/03/28/Runge-Kutta%E6%B3%95%E8%A7%A3%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    <id>https://chouxianyu.github.io/2019/03/28/Runge-Kutta法解微分方程/</id>
    <published>2019-03-28T11:25:59.000Z</published>
    <updated>2019-03-28T11:27:48.381Z</updated>
    
    <content type="html"><![CDATA[<p>连续问题，微分方程或偏微分方程一定能表示。比如疾病传染、新闻传播等。</p><p>离散问题，可以用差分方程或者类似于差分的算法。</p><h1 id="一阶微分方程求解"><a href="#一阶微分方程求解" class="headerlink" title="一阶微分方程求解"></a>一阶微分方程求解</h1><h2 id="方程"><a href="#方程" class="headerlink" title="方程"></a>方程</h2><p>$y’=cos\ t$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clear,clc;</span><br><span class="line"></span><br><span class="line">f = @(t,y) <span class="built_in">cos</span>(t);<span class="comment">% 定义函数 f(t,y) = cos(t) 表示的就是dy/dt=cos(t)</span></span><br><span class="line">tspan = [<span class="number">0</span>,<span class="number">2</span>*pi];<span class="comment">% 时间t范围</span></span><br><span class="line">y0 = <span class="number">2</span>;   <span class="comment">% y的初值，用来处理积分得到的C</span></span><br><span class="line">[t,y] = ode23(f,tspan,y0); <span class="comment">% 注意调用格式</span></span><br><span class="line">plot(t,y);</span><br><span class="line">xlabel(<span class="string">'t'</span>);</span><br><span class="line">ylabel(<span class="string">'y'</span>);</span><br></pre></td></tr></table></figure><p><code>@</code>表示句柄，当把一个函数作为参数传给另外一个函数，这时候必须要用句柄。这里是把函数<code>f</code>传给函数<code>ode23</code>。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><a href="https://i.loli.net/2019/03/28/5c9c9a965cc43.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/28/5c9c9a965cc43.png" alt="一阶微分方程.png"></a></p><h1 id="高阶微分方程求解"><a href="#高阶微分方程求解" class="headerlink" title="高阶微分方程求解"></a>高阶微分方程求解</h1><h2 id="方程-1"><a href="#方程-1" class="headerlink" title="方程"></a>方程</h2><p>$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              y’’=-sin\ y+sin\ 5t\\<br>              y(0)=1\\<br>              y’(0)=0\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><p>可以将该高阶微分方程转化为两个一阶的微分方程：$\begin{equation}<br>    \left\{<br>          \begin{array}{r1}<br>              y_1=y\\<br>              y_2=y’\\<br>              y’_1=y_2\\<br>              y’_2=-sin\ y_1+sin\ 5t\\<br>              y_1(0)=1\\<br>              y_2(0)=0\\<br>          \end{array}<br>    \right.<br>\end{equation}$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clear,clc;</span><br><span class="line"></span><br><span class="line">f = @(t, y) [ y(<span class="number">2</span>); -sin( y(<span class="number">1</span>) ) + sin( <span class="number">5</span>*t ) ]; <span class="comment">% 两个参数分别是y1和y2的导数</span></span><br><span class="line">tspan = [ <span class="number">0</span>, <span class="number">20</span> ]; <span class="comment">% 时间t范围</span></span><br><span class="line">y0 = [ <span class="number">1</span>; <span class="number">0</span> ]; <span class="comment">% 初值，分别对应y1，y2的初值</span></span><br><span class="line">[t, y] = ode23(f, tspan, y0); <span class="comment">% 注意调用格式</span></span><br><span class="line">plot(t,y);</span><br><span class="line">xlabel(<span class="string">'t'</span>);</span><br><span class="line">ylabel(<span class="string">'y'</span>);</span><br><span class="line">legend(<span class="string">'y1'</span>,<span class="string">'y2'</span>);</span><br></pre></td></tr></table></figure><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><a href="https://i.loli.net/2019/03/28/5c9c9a9662d63.png" target="_blank" rel="noopener">​<img src="https://i.loli.net/2019/03/28/5c9c9a9662d63.png" alt="高阶微分方程.png"></a></p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;连续问题，微分方程或偏微分方程一定能表示。比如疾病传染、新闻传播等。&lt;/p&gt;
&lt;p&gt;离散问题，可以用差分方程或者类似于差分的算法。&lt;/p&gt;
&lt;h1 id=&quot;一阶微分方程求解&quot;&gt;&lt;a href=&quot;#一阶微分方程求解&quot; class=&quot;headerlink&quot; title=&quot;一阶微
      
    
    </summary>
    
    
      <category term="Matlab" scheme="https://chouxianyu.github.io/tags/Matlab/"/>
    
      <category term="数学建模" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="微分方程" scheme="https://chouxianyu.github.io/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C/C++小课之类和对象</title>
    <link href="https://chouxianyu.github.io/2019/03/27/C-C-%E5%B0%8F%E8%AF%BE%E4%B9%8B%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>https://chouxianyu.github.io/2019/03/27/C-C-小课之类和对象/</id>
    <published>2019-03-27T08:38:04.000Z</published>
    <updated>2019-04-16T15:19:01.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>如何理解类和对象？</p><p>类是一种自定义数据类型，用<strong>类</strong>定义出来的变量就是<strong>对象</strong>。</p><p>格式：</p><ul><li><code>数据类型 数据;</code></li><li><code>int a;</code></li><li><code>A a();</code></li></ul><p>这一章的主要问题就是如何<strong>设计</strong>、<strong>实现</strong>和<strong>使用</strong>类。</p><p>设计和实现分别对应类的抽象和封装；使用即最后一步，用类实现功能。</p><p><strong>简单地说</strong>：面向对象就是将事物定义（包括抽象和封装）成类并使用。</p><h1 id="类的抽象和封装"><a href="#类的抽象和封装" class="headerlink" title="类的抽象和封装"></a>类的抽象和封装</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>计算机软件开发采用的抽象方法主要有两种：</p><ul><li><p>过程抽象</p><p>  结果给出了函数的名称、接收的参数和能够提供的功能。</p></li><li><p><strong>数据抽象</strong></p><p>  数据抽象是面向对象程序设计方法，<strong>以数据为中心</strong>。</p><p>  结果形成某事物的类，其中包括<strong>成员变量</strong>和<strong>成员函数</strong>。</p></li></ul><p>简单来说，就是找出一个类有哪些<strong>变量</strong>和<strong>功能</strong>，但不用<strong>封装</strong>。</p><p>比如这是一个点餐系统。</p><p><a href="https://i.loli.net/2019/03/27/5c9b35ca001e9.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/27/5c9b35ca001e9.png" alt="点餐系统类图.png"></a></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>分为两部分：</p><ul><li><p>接口</p><p>  使用者看到的东西</p></li><li><p>实现</p><p>  实现抽象出的类，写<code>.cpp</code>代码</p></li></ul><p>简单地说，就是写代码。</p><p>比如：对老师来说，课代表就是接口，课代表怎么收作业就是实现。</p><h1 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cxy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">growTaller</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"drinkMilk"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        height+=<span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cxy cbh;</span><br><span class="line">    cbh.growtaller();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请找出代码里的类、对象、抽象、封装。</p><h1 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h1><h2 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h2><p>C++中，为了禁止成员函数修改数据成员的值，可以使用常量成员函数。</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">f</span><span class="params">(T1, T1, ...)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>只有类的成员函数才能定义为常量函数，普通函数不能。</li><li>常量成员函数与const参数没有关系</li></ul><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul><li>每个对象的数据成员都有自己独立的存储空间。就像int变量一样。</li><li><strong>注意</strong>：一个类的成员函数只有一份，所有对象共用。</li><li><strong>注意</strong>：类的static成员只有一份，它并不算对象的数据成员。</li></ul><h1 id="构造函数设计"><a href="#构造函数设计" class="headerlink" title="构造函数设计"></a>构造函数设计</h1><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>书上P97下边给的定义是最准确的。</p><p>想想之前讲的默认的含义。</p><p>简单来说：如果用类定义对象时，我们没有给参数的话，调用的就是默认构造函数。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>默认构造函数有两种：</p><ul><li><p>不带参数的构造函数</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A();</span><br></pre></td></tr></table></figure><p>  可以是我们自己定义的，也可以是编译器合成的。</p></li><li><p>所有形参都提供了默认值的构造函数</p><p>  这个当然是我们自己定义的。</p></li></ul><h2 id="构造函数与初始化列表"><a href="#构造函数与初始化列表" class="headerlink" title="构造函数与初始化列表"></a>构造函数与初始化列表</h2><h3 id="初始化列表次序"><a href="#初始化列表次序" class="headerlink" title="初始化列表次序"></a>初始化列表次序</h3><p>初始化列表中的成员初始化次序与他们在类中的声明次序相同，与初始化列表中的次序无关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    A(<span class="keyword">int</span> aa,<span class="keyword">int</span> bb,<span class="keyword">int</span> cc):b(aa),a(bb),c(cc)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am a handsome constructor yo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提问：初始化次序是什么？</p><h3 id="初始化列表执行时间"><a href="#初始化列表执行时间" class="headerlink" title="初始化列表执行时间"></a>初始化列表执行时间</h3><p>类内初始值$\rightarrow$构造函数初始化列表$\rightarrow$构造函数体</p><h2 id="what必须采用初始化列表？"><a href="#what必须采用初始化列表？" class="headerlink" title="what必须采用初始化列表？"></a>what必须采用初始化列表？</h2><h3 id="C-11之前"><a href="#C-11之前" class="headerlink" title="C++11之前"></a>C++11之前</h3><p>一个类的</p><ul><li>常量成员</li><li>引用成员</li><li>类对象成员</li><li>子类构造函数对基类构造函数的调用</li><li>等等</li></ul><p>必须通过初始化列表进行初始化。</p><h3 id="C-11之后"><a href="#C-11之后" class="headerlink" title="C++11之后"></a>C++11之后</h3><p>除了初始化列表，可以用类内初始值yo。</p><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>若有几个对象同时结束生存期，析构函数调用顺序与构造函数顺序相反。</p><h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><p>关键字：<code>static</code>。</p><p>静态成员可以是变量，也可以是函数。</p><p><strong>注意</strong>：静态成员函数不可以访问非静态成员。think why？</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>表示这个成员是属于整个类的。</p><h2 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h2><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> boyNum;<span class="comment">//男孩的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Boy::boyNum；<span class="comment">//未初始化</span></span><br><span class="line"><span class="comment">//static int Boy::boyNum = 0；//初始化</span></span><br></pre></td></tr></table></figure><p>在类内<code>static int number；</code>，仅仅是<strong>声明</strong>，</p><p>原则上，<strong>定义</strong>必须写在类外：<code>static int Boy::boyNum;</code>，值默认为0，也可以进行初始化。</p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>两种方式：</p><ul><li><p>通过类名访问（<strong>非静态成员不能以这种这样访问</strong>）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; Boy::boyNum &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>通过对象访问</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Boy <span class="title">cbh</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cbhboyNum &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><p>看看下边的this？</p><h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>this用来标识一个对象，是该对象的地址，类型是<code>Boy* const</code>，隐含在非静态成员函数的参数里。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>静态成员函数没有this指针，所以不可以访问非静态成员。</p><p>常量成员函数的this，类型是<code>const Boy *</code>。</p><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>本文为作者原创，转载请注明出处：<a href="https://chouxianyu.github.io">https://chouxianyu.github.io</a></p><p>欢迎讨论和交流!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;如何理解类和对象？&lt;/p&gt;
&lt;p&gt;类是一种自定义数据类型，用&lt;strong&gt;类&lt;/strong&gt;定义出来的变量就是&lt;strong&gt;对象&lt;/s
      
    
    </summary>
    
    
      <category term="C/C++" scheme="https://chouxianyu.github.io/tags/C-C/"/>
    
      <category term="面向对象" scheme="https://chouxianyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
