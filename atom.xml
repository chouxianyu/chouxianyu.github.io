<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2020-08-10T14:13:42.107Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PAT甲级1153Decode Registration Card of PAT</title>
    <link href="https://chouxianyu.github.io/2020/08/10/PAT%E7%94%B2%E7%BA%A71153Decode-Registration-Card-of-PAT/"/>
    <id>https://chouxianyu.github.io/2020/08/10/PAT甲级1153Decode-Registration-Card-of-PAT/</id>
    <published>2020-08-10T14:11:51.000Z</published>
    <updated>2020-08-10T14:13:42.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785190929788928" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1071785190929788928</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求和思路"><a href="#题目要求和思路" class="headerlink" title="题目要求和思路"></a>题目要求和思路</h2><p>PAT注册号分4个部分：</p><ul><li>第1位字母代表考试等级</li><li>第2到4位数字是考试地点，大小从101到999</li><li>第5到10位数字为考试日期</li><li>第11到13位数字是考生号，大小从000到999</li></ul><ul><li><p>1：给定考试等级，要求输出该考试等级所有考生的注册号和分数（注册号升序，分数非升序）</p><p>  遍历找出指定考试等级的考生，然后排序输出</p></li><li><p>2：给定考试地点，要求输出该考试地点中考生数和考生分数之和</p><p>  遍历找出指定考试地点的考生，然后统计数据</p></li><li><p>3：给定考试时间，要求输出每个考试地点的考生数（考试地点升序，考生数非升序）</p><p>  遍历考生， 统计每个考试地点的考生数到unordered_map里（统计到map里会超时），键是考试地点，值是考生数，然后输出（我这里是先存入vector再输出）</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1153</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785190929788928</span></span><br><span class="line"><span class="comment">// Tags: map unordered_map sort</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存参试者的信息和最终要输出的结果</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nodeCmp</span><span class="params">(Node&amp; t1, Node&amp; t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.val == t2.val ? t1.str &lt; t2.str : t1.val &gt; t2.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取考生信息</span></span><br><span class="line">    <span class="keyword">int</span> n, m;  <span class="comment">// 输入和查询的数量</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; testees(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; testees[i].str &gt;&gt; testees[i].val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要求并求解</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="built_in">string</span> term;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> caseIndex = <span class="number">1</span>; caseIndex &lt;= m; caseIndex++)&#123;</span><br><span class="line">        <span class="comment">// 获取要求</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; type &gt;&gt; term;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %s\n"</span>, caseIndex, type, term.c_str());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// type为1和3时的结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; results;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : &#123;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                    <span class="keyword">if</span> (testees[i].str[<span class="number">0</span>] == term[<span class="number">0</span>])</span><br><span class="line">                        results.push_back(testees[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : &#123;</span><br><span class="line">                <span class="keyword">int</span> testeeNum = <span class="number">0</span>, testeeScoreSum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                    <span class="keyword">if</span> (testees[i].str.substr(<span class="number">1</span>, <span class="number">3</span>) == term)&#123;</span><br><span class="line">                        testeeNum += <span class="number">1</span>;</span><br><span class="line">                        testeeScoreSum += testees[i].val;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (testeeNum == <span class="number">0</span> &amp;&amp; testeeScoreSum == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, testeeNum, testeeScoreSum);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : &#123;</span><br><span class="line">                <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; statistics;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                    <span class="keyword">if</span> (testees[i].str.substr(<span class="number">4</span>, <span class="number">6</span>) == term)</span><br><span class="line">                        statistics[testees[i].str.substr(<span class="number">1</span>, <span class="number">3</span>)] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> it : statistics)</span><br><span class="line">                    results.push_back(&#123;it.first, it.second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span> || type == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (results.empty())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sort(results.begin(), results.end(), nodeCmp);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.size(); i++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, results[i].str.c_str(), results[i].val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>使用Python语言通过PyQt5和socket实现UDP服务器</title>
    <link href="https://chouxianyu.github.io/2020/08/10/%E4%BD%BF%E7%94%A8Python%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87PyQt5%E5%92%8Csocket%E5%AE%9E%E7%8E%B0UDP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://chouxianyu.github.io/2020/08/10/使用Python语言通过PyQt5和socket实现UDP服务器/</id>
    <published>2020-08-10T07:07:03.000Z</published>
    <updated>2020-08-10T07:12:19.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近做了一个小软件，记录一下相关内容。</p><h2 id="已有条件"><a href="#已有条件" class="headerlink" title="已有条件"></a>已有条件</h2><p>现在已有一个硬件设备作为客户端（暂称其为“电路”）。</p><p>基于SIM卡，电路可以通过UDP协议传输数据（程序已经内置在电路中），只需要修改配置文件（位于SD卡中，主要修改服务器端的IP和端口）即可。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我面向的需求是这样的：我需要开发一个服务器端的程序，接收多个客户端发来的数据并开发可视化界面。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从开发角度和技术角度来看，软件的基础和核心技术是使用<strong>UDP协议</strong>进行数据传输，并使用PyQt5和pyqtgraph做可视化界面（还用到了QThread和自定义的下拉复选框），开发过程中还涉及到了内网穿透和NATAPP。</p><h1 id="理论基础：运输层"><a href="#理论基础：运输层" class="headerlink" title="理论基础：运输层"></a>理论基础：运输层</h1><p>为使用UDP协议进行数据传输，我大致复习了一下计算机网络中的运输层。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>运输层实现两台主机中<strong>进程</strong>之间的通信，一个主机中的多个进程可以和另一台主机中的多个进程通信。</p><p>运输层实现上述功能的方案是端口（port）</p><h2 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h2><p>运输层有两个主要协议：</p><ul><li>传输控制协议TCP（Transmission Control Protocol）</li><li>用户数据报协议UDP（User Datagram Protocol）</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>TCP是<strong>面向连接</strong>的<ul><li>应用进程在传输数据前必须先建立连接，数据传送结束后要释放连接</li></ul></li><li>TCP连接是<strong>点对点</strong>的<ul><li>每一条TCP连接只能有两个端点</li><li>TCP不提供广播或多播服务</li></ul></li><li>TCP提供<strong>可靠交付</strong>的服务<ul><li>通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达</li></ul></li><li>TCP<strong>面向字节流</strong><ul><li>虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成一连串的无结构的字节流。</li><li>TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小</li><li>TCP保证接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样，同时接收方应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul></li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li>UDP是<strong>无连接</strong>的<ul><li>在传输数据前不需要先建立连接，主机在收到UDP报文后不需要给出任何确认</li></ul></li><li>UDP是<strong>面向报文</strong>的<ul><li>发送方：UDP对应用层交下来的报文，不合并也不拆分，添加首部后就交付给IP层</li><li>接收方：UDP对IP层交上来的UDP用户数据包，在去除首部后就直接交付给应用层的进程</li></ul></li><li>UDP<strong>尽最大努力交付</strong><ul><li>不保证可靠交付</li></ul></li><li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信</li></ul><h1 id="Python中的UDP编程"><a href="#Python中的UDP编程" class="headerlink" title="Python中的UDP编程"></a>Python中的UDP编程</h1><p>Python中的UDP编程可以通过<code>socket</code>来实现，下面是一个简单样例</p><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_ip = <span class="string">'127.0.0.1'</span></span><br><span class="line">server_port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="comment"># socket.SOCK_DGRAM代表是UDP通信</span></span><br><span class="line"><span class="comment"># 绑定IP和端口</span></span><br><span class="line">s.bind((server_ip, server_port))</span><br><span class="line">print(<span class="string">'Bind UDP Server on %s:%s'</span> % (server_ip, server_port))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(addr, <span class="string">"\t"</span>, data)</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    s.sendto(<span class="string">b'Received:%s'</span>%data, addr)</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_ip = <span class="string">'127.0.0.1'</span></span><br><span class="line">server_port = <span class="number">59955</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="comment"># socket.SOCK_DGRAM代表是UDP通信</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b'Michael'</span>, <span class="string">b'Tracy'</span>, <span class="string">b'Sarah'</span>]:</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    s.sendto(data, (server_ip, server_port))</span><br><span class="line">    <span class="comment"># 接收数据</span></span><br><span class="line">    <span class="comment"># print(s.recv(1024).decode('utf-8'))</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><h2 id="值得注意的问题：缓冲区机制"><a href="#值得注意的问题：缓冲区机制" class="headerlink" title="值得注意的问题：缓冲区机制"></a>值得注意的问题：缓冲区机制</h2><p>UDP通信时，两个主机都要建立一个socket。</p><p>我这里的情况是客户端会一直给服务器端发数据。</p><p>在服务器端我发现socket一旦建立（准确来讲是创建socket对象并绑定至本地端口），就会一直接收数据，而不是调用recvfrom等函数（这类函数用来接收数据）时才会接收。</p><p>估计这是缓冲区机制，UDP应该就是这么设计的。大概就是socket对象创建后，收到的内容就会放入缓冲区，如果调用了recvfrom等数据接收函数就从缓冲区中取出数据。</p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="为什么要用内网穿透"><a href="#为什么要用内网穿透" class="headerlink" title="为什么要用内网穿透"></a>为什么要用内网穿透</h2><p>先不讲内网穿透是什么，有兴趣的可以自己去查查，下面我大概讲讲我浅显的理解。</p><p>在开发服务器端程序的过程中，我用的是自己的电脑，连接的网络是手机热点（因为在宿舍），因此我的电脑是没有公网IP的。</p><p>客户端程序用的是SIM卡，用的是公网（外网）IP，我开发的服务器端程序用的是私网（内网）IP。</p><p>公网IP是无法访问私网IP的（因为NAT），所以<strong>我需要让我的服务器端程序能够被外网访问</strong>。</p><p>问了一下<a href="https://www.cnblogs.com/roadwide/" target="_blank" rel="noopener">@roadwide</a>，他说要用内网穿透，并推荐了<strong>NATAPP</strong>等软件。</p><h2 id="NATAPP的使用"><a href="#NATAPP的使用" class="headerlink" title="NATAPP的使用"></a>NATAPP的使用</h2><p>怎么用呢？看看官方教程就知道了，链接放在文章末尾了。</p><p>讲一个比较关键的点，以理解下NATAPP是干嘛的</p><p><img src="https://cdn.natapp.cn/uploads/ueditor/php/upload/image/20170118/1484723077222282.png" alt="NATAPP截图"></p><p>NATAPP运行起来后，就会将上图红框里的URL映射到本机（127.0.0.1）的80端口。</p><p>NATAPP会给我一个URL（作为我的外网IP），这样客户端程序通过访问NATAPP给我的URL就可以间接访问我在本机运行的服务器端程序。</p><h1 id="PyQt5"><a href="#PyQt5" class="headerlink" title="PyQt5"></a>PyQt5</h1><h2 id="QThread"><a href="#QThread" class="headerlink" title="QThread"></a>QThread</h2><p>服务器端程序的界面上有两个作用分别是开始接收数据和停止接收数据的按钮。</p><p>接收数据是通过一个while循环（循环体中接收一个数据）实现的，如果点击开始接收数据的按钮，那就运行while循环直到停止接收数据的按钮被点击。</p><p>刚开始实现数据接收功能时发现程序界面会崩溃、点击不动，因为直接把while循环写在<strong>软件主界面</strong>的代码中。</p><p>后来使用了PyQt5中的QThread（也有人说QThread并不是一个线程），在一个线程中实现while循环，然后就成功了。</p><p>在实现时我参考了其他网友的代码，参考链接放在文章末尾，注意一点是实现方式不止一种，比如说有些网友说用threading也可以，而且我也发现我的思路和参考的那份代码稍有不一样（我们实现的功能是相似的，但我只用了一个pyqtSignal，而那位网友用了两个）。</p><h2 id="下拉复选框"><a href="#下拉复选框" class="headerlink" title="下拉复选框"></a>下拉复选框</h2><p>这个软件需要有一个下拉复选框，而PyQt5中并没有这个东西，因此需要手动实现，这里我参考了其他网友的实现方式，参考链接见文章末尾。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><h2 id="Python中的UDP编程-1"><a href="#Python中的UDP编程-1" class="headerlink" title="Python中的UDP编程"></a>Python中的UDP编程</h2><p><a href="https://blog.csdn.net/vict_wang/article/details/81587093" target="_blank" rel="noopener">https://blog.csdn.net/vict_wang/article/details/81587093</a></p><p><a href="https://www.jb51.net/article/165933.htm" target="_blank" rel="noopener">https://www.jb51.net/article/165933.htm</a></p><h2 id="理解NAT和内网穿透"><a href="#理解NAT和内网穿透" class="headerlink" title="理解NAT和内网穿透"></a>理解NAT和内网穿透</h2><p><a href="https://baike.baidu.com/item/nat/320024" target="_blank" rel="noopener">https://baike.baidu.com/item/nat/320024</a></p><p><a href="https://baike.baidu.com/item/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F</a></p><h2 id="NATAPP"><a href="#NATAPP" class="headerlink" title="NATAPP"></a>NATAPP</h2><p><a href="https://natapp.cn/#" target="_blank" rel="noopener">https://natapp.cn/#</a></p><p><a href="https://natapp.cn/article/natapp_newbie" target="_blank" rel="noopener">https://natapp.cn/article/natapp_newbie</a></p><h2 id="PyQt5-1"><a href="#PyQt5-1" class="headerlink" title="PyQt5"></a>PyQt5</h2><ul><li><p>PyQt5下拉式复选框QComboCheckBox</p><p>  <a href="https://blog.csdn.net/LJX4ever/article/details/78039318" target="_blank" rel="noopener">https://blog.csdn.net/LJX4ever/article/details/78039318</a></p></li><li><p>QThread实现循环</p><p>  <a href="https://segmentfault.com/a/1190000020746912?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020746912?utm_source=tag-newest</a></p></li><li><p>AttributeError: ‘PyQt5.QtCore.pyqtSignal’ object has no attribute ‘connect’</p></li></ul><h2 id="pyqtgraph"><a href="#pyqtgraph" class="headerlink" title="pyqtgraph"></a>pyqtgraph</h2><ul><li><p>pyqtgraph中绘制多个线条（我实现这个功能时也看了pyqtgraph的example）</p><p>  <a href="https://zmister.com/archives/219.html#plot-2" target="_blank" rel="noopener">https://zmister.com/archives/219.html#plot-2</a></p></li><li><p>pyqtgraph中添加图例（legend）</p><p>  <a href="https://zmister.com/archives/220.html?replytocom=558" target="_blank" rel="noopener">https://zmister.com/archives/220.html?replytocom=558</a></p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近做了一个小软件，记录一下相关内容。&lt;/p&gt;
&lt;h2 id=&quot;已有条件&quot;&gt;&lt;a href=&quot;#已有条件&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
      <category term="计算机网络" scheme="https://chouxianyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="UDP" scheme="https://chouxianyu.github.io/tags/UDP/"/>
    
      <category term="PyQt5" scheme="https://chouxianyu.github.io/tags/PyQt5/"/>
    
      <category term="socket" scheme="https://chouxianyu.github.io/tags/socket/"/>
    
      <category term="pyqtgraph" scheme="https://chouxianyu.github.io/tags/pyqtgraph/"/>
    
      <category term="QThread" scheme="https://chouxianyu.github.io/tags/QThread/"/>
    
      <category term="内网穿透" scheme="https://chouxianyu.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="NATAPP" scheme="https://chouxianyu.github.io/tags/NATAPP/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1145Hashing - Average Search Time</title>
    <link href="https://chouxianyu.github.io/2020/08/07/PAT%E7%94%B2%E7%BA%A71145Hashing-Average-Search-Time/"/>
    <id>https://chouxianyu.github.io/2020/08/07/PAT甲级1145Hashing-Average-Search-Time/</id>
    <published>2020-08-07T15:23:04.000Z</published>
    <updated>2020-08-07T15:23:51.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343236767744" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805343236767744</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="基础知识：哈希"><a href="#基础知识：哈希" class="headerlink" title="基础知识：哈希"></a>基础知识：哈希</h2><p>为做这道题，我简单复习了一下<a href="https://www.cnblogs.com/chouxianyu/p/13455884.html" target="_blank" rel="noopener">哈希（点击查看）</a>。</p><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>往一个哈希表里插入n个正整数，然后从哈希表里查找m个正整数，请输出平均查找次数（即比较次数）</p><p>哈希函数定义为$H(key)= key \% TSize$，其中$TSize$是哈希表的最大容量，它最好是素数，如果输入的不是素数就必须找到大于输入的最小素数。</p><p>用二次探测（仅具有正增量）解决冲突。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li><p>distinct</p><p>  截然不同的, 完全分开的</p></li><li><p>sequence</p><p>  有关联的一组事物, 一连串</p></li><li><p>quadratic</p><p>  二次的，二次方程式</p></li><li><p>probe</p><p>  n. 探针；调查<br>  vi. 调查；探测<br>  vt. 探查；用探针探测</p></li><li><p>collision</p><p>  碰撞, 冲突, 抵触</p></li><li><p>Quadratic probing (with positive increments only) is used to solve the collisions.</p><p>  二次探测（仅具有正增量）用于解决冲突。</p></li><li><p>synonym</p><p>  同义词</p></li><li><p>accurate up to 1 decimal place</p><p>  精确到小数点后1位</p></li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>待查找的元素可能不存在</li><li>题目说了输入的关键字都是<strong>正</strong>整数，所以可以把0作为表中某个位置没有元素的标志</li><li>注意这里的二次探测再散列只有正增量</li><li>查找时间指查找时进行比较的次数，如果没有再探测（即一次就找到了），那比较次数就是1</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1145</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343236767744</span></span><br><span class="line"><span class="comment">// Tags: Hash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++)</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取输入的第一行</span></span><br><span class="line">    <span class="keyword">int</span> mSize, n, m; <span class="comment">// 哈希表最大容量、输入的整数的数量、待查找的整数的数量，都不超过1e4</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; mSize &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立哈希表</span></span><br><span class="line">    <span class="keyword">while</span> (!isPrime(mSize)) mSize++;  <span class="comment">// 使哈希表表长为大于等于输入的最小素数</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashTable(mSize); <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span> key, pos; <span class="comment">// 关键字、哈希地址</span></span><br><span class="line">    <span class="keyword">bool</span> posFound; <span class="comment">// 某个key的位置是否找到了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; key; <span class="comment">// 获取关键字</span></span><br><span class="line">        posFound = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mSize; j++)&#123; <span class="comment">// 二次探测再散列（只有正增量）</span></span><br><span class="line">            pos = (key + j * j) % mSize;</span><br><span class="line">            <span class="keyword">if</span> (hashTable[pos] == <span class="number">0</span>)&#123;  <span class="comment">// 这要求key不为0</span></span><br><span class="line">                hashTable[pos] = key;</span><br><span class="line">                posFound = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!posFound) <span class="built_in">printf</span>(<span class="string">"%d cannot be inserted.\n"</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素并统计平均查找次数</span></span><br><span class="line">    <span class="keyword">double</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; key;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= mSize; j++)&#123; <span class="comment">// 题目似乎有问题，应该是j&lt;mSize的，而不是&lt;=</span></span><br><span class="line">            pos = (key + j * j) % mSize;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (hashTable[pos] == key || hashTable[pos] == <span class="number">0</span>)  <span class="comment">// 注意待查找的元素可能不存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, count / m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="哈希" scheme="https://chouxianyu.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-哈希</title>
    <link href="https://chouxianyu.github.io/2020/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C/"/>
    <id>https://chouxianyu.github.io/2020/08/07/数据结构-哈希/</id>
    <published>2020-08-07T15:22:37.000Z</published>
    <updated>2020-08-07T15:25:05.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希函数、哈希表、哈希地址"><a href="#哈希函数、哈希表、哈希地址" class="headerlink" title="哈希函数、哈希表、哈希地址"></a>哈希函数、哈希表、哈希地址</h1><p>根据设定的<strong>哈希函数</strong>$H(key)$和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集上的“像”作为记录在表中的存储位置，这种表便称为<strong>哈希表</strong>，这一映像过程称为哈希造表或散列，所得存储位置成<strong>哈希地址</strong>或散列地址。</p><h1 id="冲突、同义词"><a href="#冲突、同义词" class="headerlink" title="冲突、同义词"></a>冲突、同义词</h1><p>不同的关键字经哈希函数映像后求得到的哈希地址可能相同，即$key1\neq key2\ and \ H(key1)=H(key2)$，这就是<strong>冲突（collision）</strong>；具有相同哈希地址的关键字对该哈希函数来说就是<strong>同义词（synonym）</strong>。</p><p>哈希函数选得合适可以减少冲突现象。</p><p>一般情况下，哈希函数是一个压缩映像（关键字集合到地址集合的映像，而关键字集合的大小远大于地址集合），因此冲突只能尽可能地少而不能完全避免。</p><h1 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h1><p>常用的构造哈希函数的方法有：</p><ol><li>直接定址法</li><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>除留余数法</li><li>随机数法</li></ol><h1 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h1><p>处理冲突过程中会有一个地址序列$H_i,i=1,2,\dots,k$，即如果发生冲突，就去找下一个地址。</p><p>通常用的处理冲突的方法有下列几种：</p><ol><li>开放定址法</li><li>再哈希法</li><li>链地址法</li><li>建立一个公共溢出区</li></ol><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><script type="math/tex; mode=display">H_i=(H(key)+d_i)\ MOD\ m \ ，\ i=1,2,\dots, k(k\leq m-1)</script><p>其中$H(key)$为哈希函数；$m$是哈希表表长；$d_i$为增量序列，可以有下面3种取法：</p><ol><li>$d_i=1,2,3\dots,m-1$，称为线性探测再散列</li><li>$d_i=1^2,-1^2,2^2,-2^2,3^2,\dots,\pm k^2,(k\leq m/2)$，称为二次探测再散列</li><li>$d_i=伪随机数序列$，称为伪随机探测再散列</li></ol><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希函数、哈希表、哈希地址&quot;&gt;&lt;a href=&quot;#哈希函数、哈希表、哈希地址&quot; class=&quot;headerlink&quot; title=&quot;哈希函数、哈希表、哈希地址&quot;&gt;&lt;/a&gt;哈希函数、哈希表、哈希地址&lt;/h1&gt;&lt;p&gt;根据设定的&lt;strong&gt;哈希函数&lt;/strong&gt;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="哈希" scheme="https://chouxianyu.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1133Splitting A Linked List</title>
    <link href="https://chouxianyu.github.io/2020/08/07/PAT%E7%94%B2%E7%BA%A71133Splitting-A-Linked-List/"/>
    <id>https://chouxianyu.github.io/2020/08/07/PAT甲级1133Splitting-A-Linked-List/</id>
    <published>2020-08-07T04:50:59.000Z</published>
    <updated>2020-08-07T04:52:33.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给1个有n（不超过1e5）个结点的单向链表和数字k（不超过1e3），链表的值属于[-1e5,1e5]要求将链表改为（或输出）：负数结点出现在正数结点之前，值属于[0,k]的结点出现在值大于k的结点之前，其余不变##</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>PAT中的这种链表适合用数组形式的链表</li><li>PAT里的链表和LeetCode里的链表（LeetCode里的链表是基于指针的）不太一样，因此操作也要适当调整</li><li>不一定要修改链表结构，能按要求输出就可以</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用数组表示链表，然后遍历将链表里的结点分成3类（小于0的、0到k的、大于k的）并存入3个数组，然后按顺序遍历3个数组并输出</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1133</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805346776760320</span></span><br><span class="line"><span class="comment">// Tags: Linked List</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListNode <span class="built_in">list</span>[<span class="keyword">int</span>(<span class="number">1e5</span>) + <span class="number">10</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parts[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    <span class="keyword">int</span> head, n, k; <span class="comment">// 头结点地址、结点数量、k</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; head &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; address;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">list</span>[address].val &gt;&gt; <span class="built_in">list</span>[address].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表将其中的结点分为3个部分</span></span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> partIndex = <span class="number">1</span>;  <span class="comment">// 默认为第2部分，即结点的值属于[0,k]</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>[p].val &lt; <span class="number">0</span>)</span><br><span class="line">            partIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">list</span>[p].val &gt; k)</span><br><span class="line">            partIndex = <span class="number">2</span>;</span><br><span class="line">        parts[partIndex].push_back(p);</span><br><span class="line">        p = <span class="built_in">list</span>[p].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将划分好的3部分结点输出</span></span><br><span class="line">    <span class="keyword">bool</span> isFirstLine = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; parts[i].size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isFirstLine)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%05d %d"</span>, parts[i][j], <span class="built_in">list</span>[parts[i][j]].val);</span><br><span class="line">                isFirstLine = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %05d\n%05d %d"</span>, parts[i][j], parts[i][j], <span class="built_in">list</span>[parts[i][j]].val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" -1"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1144The Missing Number</title>
    <link href="https://chouxianyu.github.io/2020/08/06/PAT%E7%94%B2%E7%BA%A71144The-Missing-Number/"/>
    <id>https://chouxianyu.github.io/2020/08/06/PAT甲级1144The-Missing-Number/</id>
    <published>2020-08-06T15:41:28.000Z</published>
    <updated>2020-08-06T15:42:51.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805343463260160" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805343463260160</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给n（小于1e5）个int，找到最小的不在这些数字里的正整数</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li><p>map未创建某元素时，如果直接访问，则其value是一个默认值</p></li><li><p>根据输入样例可知n个数字中可以有重复数字</p></li><li><p>map会按照key自动升序排列</p></li><li><p>这道题也可以暴力解，创建一个int数组，因为最后要求<strong>正</strong>整数，所以可以不统计负数</p><p>  如果这么做，要注意一个边界情况：不缺数字，比如输入了5个数字，分别是1 2 3 4 5</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1144</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805343463260160</span></span><br><span class="line"><span class="comment">// Tags: map</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numCount;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        numCount[num]++; <span class="comment">// 计数，根据输入样例可知n个数字中可以有重复数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (++num)</span><br><span class="line">        <span class="comment">// map未创建某元素时，如果直接访问，则其value是一个默认值</span></span><br><span class="line">        <span class="keyword">if</span> (numCount[num] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="map" scheme="https://chouxianyu.github.io/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1132Cut Integer</title>
    <link href="https://chouxianyu.github.io/2020/08/06/PAT%E7%94%B2%E7%BA%A71132Cut-Integer/"/>
    <id>https://chouxianyu.github.io/2020/08/06/PAT甲级1132Cut-Integer/</id>
    <published>2020-08-06T10:12:19.000Z</published>
    <updated>2020-08-06T10:13:19.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805347145859072" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805347145859072</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>给n个k位（k为偶数）的整数z，将其分成a和b，判断z/(a*b)是不是一个整数即可</p><p>这里要注意a和b是否为0，这是个<strong>边界情况</strong>，如果没有处理这个边界情况，有2个测试点不能过，只能得14分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1132</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805347145859072</span></span><br><span class="line"><span class="comment">// Tags: Math</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="built_in">string</span> z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; z;</span><br><span class="line">        <span class="built_in">string</span> a = z.substr(<span class="number">0</span>, z.length() / <span class="number">2</span>), b = z.substr(z.length() / <span class="number">2</span>, z.length() / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> mul = stoi(a) * stoi(b);</span><br><span class="line">        <span class="keyword">if</span> (mul != <span class="number">0</span> &amp;&amp; stoi(z) % mul == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Yes\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1148Werewolf - Simple Version</title>
    <link href="https://chouxianyu.github.io/2020/08/05/PAT%E7%94%B2%E7%BA%A71148Werewolf-Simple-Version/"/>
    <id>https://chouxianyu.github.io/2020/08/05/PAT甲级1148Werewolf-Simple-Version/</id>
    <published>2020-08-05T15:19:12.000Z</published>
    <updated>2020-08-05T15:20:20.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1038429808099098624" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1038429808099098624</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>N（5到100）个玩家，其中2个狼人，只有1个狼人在撒谎（题目里说至少有1个狼人在撒谎但不是所有狼人都在撒谎……直接讲只有1个狼人在撒谎不行吗……），共有2人撒谎，请找出两个狼人</p><p>描述中+则是人类，-则是狼人</p><p>如果有解，请按增序输出狼人</p><p>如果多个解，则输出最小的</p><p>没有讲解则输出”No Solution” </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>刚看完题时没啥思路……特别是有多个解的情况，让我以为要求出所有解，我似乎还想过枚举是谁在撒谎（得到谁在撒谎并不能很有效地得到答案……）</p><p>可以枚举狼人是谁的情况，如果与题目和输入相符（1个狼人和1个人在撒谎），则直接输出狼人（如果有多个解，从小到大枚举狼人求得的第一个解就是多个解中最小的解）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1148</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1038429808099098624</span></span><br><span class="line"><span class="comment">// Tags: Math</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取输入</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; statements(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; statements[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="comment">// 枚举2个狼人是i和j</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; identities(n+<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 玩家身份：1代表人类，-1代表狼人</span></span><br><span class="line">            identities[i] = identities[j] = <span class="number">-1</span>; <span class="comment">// i和j是狼人</span></span><br><span class="line">            <span class="comment">// 寻找撒谎的玩家</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; liars;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; statements.size(); k++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (statements[k] * identities[<span class="built_in">abs</span>(statements[k])] &lt; <span class="number">0</span>)</span><br><span class="line">                    liars.push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断当前枚举的狼人i和j是否符合题目要求和输入</span></span><br><span class="line">            <span class="keyword">if</span> (liars.size() == <span class="number">2</span> &amp;&amp; identities[liars[<span class="number">0</span>]] + identities[liars[<span class="number">1</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1136A Delayed Palindrome</title>
    <link href="https://chouxianyu.github.io/2020/08/05/PAT%E7%94%B2%E7%BA%A71136A-Delayed-Palindrome/"/>
    <id>https://chouxianyu.github.io/2020/08/05/PAT甲级1136A-Delayed-Palindrome/</id>
    <published>2020-08-05T07:49:08.000Z</published>
    <updated>2020-08-05T07:52:46.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li><p>notation</p><p>  标记法</p></li><li><p>palindromic</p><p>  回文的</p></li><li><p>palindrome</p><p>  回文</p></li><li><p>be paired with</p><p>  与……配对</p></li></ul><h2 id="思路、注意点和代码"><a href="#思路、注意点和代码" class="headerlink" title="思路、注意点和代码"></a>思路、注意点和代码</h2><ul><li>要实现回文数判断</li><li>要实现字符串逆序</li><li>整体思路就是题目描述的那样：判断是不是回文数，不是的话就逆序后和原数相加，重复这一过程直至得到回文数或者超过10次迭代</li></ul><p>下面是我刚开始时写的代码，结果是Partially Accepted，得了14分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1136</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624</span></span><br><span class="line"><span class="comment">// Tags: String</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[len<span class="number">-1</span>-i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a_str, b_str, c_str;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a_str;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        b_str = <span class="built_in">string</span>(a_str.rbegin(), a_str.rend());</span><br><span class="line">        c_str = to_string(stoi(a_str) + stoi(b_str));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a_str &lt;&lt; <span class="string">" + "</span> &lt;&lt; b_str &lt;&lt; <span class="string">" = "</span> &lt;&lt; c_str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (isPalindromic(c_str))&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c_str &lt;&lt; <span class="string">" is a palindromic number."</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a_str = c_str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found in 10 iterations."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><p>看了下柳婼的代码，和我写的题解一相比，她的代码有以下不同：</p><ul><li><p>她考虑了输入就是回文数的<strong>边界情况</strong>，我没有考虑，这个测试点占4分</p></li><li><p>回文数的判断方法不同，她是判断逆序后是否相等，我是遍历判断</p></li><li><p>她手动实现了字符串数字的加法，而我是将字符串转成数字进而相加，这里我忽略了<strong>数值范围</strong>，这个测试点占2分</p><p>  题目说不超过1000位，就算使用longlong也不行，所以必须手动实现字符串相加</p></li></ul><p>基于我刚开始写的题解一和上面分析的内容，正确代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1136</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805345732378624</span></span><br><span class="line"><span class="comment">// Tags: String Palindrome</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[len<span class="number">-1</span>-i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">addString</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum = a[i] - <span class="string">'0'</span> + b[i] - <span class="string">'0'</span> + carry;  <span class="comment">// 注意进位和'0'</span></span><br><span class="line">        a[i] = sum % <span class="number">10</span> + <span class="string">'0'</span>;  <span class="comment">// 注意'0'</span></span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">        a = <span class="string">"1"</span> + a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a_str, b_str, c_str;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a_str;</span><br><span class="line">    <span class="keyword">if</span> (isPalindromic(a_str))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a_str &lt;&lt; <span class="string">" is a palindromic number."</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (N--)&#123;</span><br><span class="line">        b_str = <span class="built_in">string</span>(a_str.rbegin(), a_str.rend());</span><br><span class="line">        c_str = addString(a_str, b_str);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a_str &lt;&lt; <span class="string">" + "</span> &lt;&lt; b_str &lt;&lt; <span class="string">" = "</span> &lt;&lt; c_str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (isPalindromic(c_str))&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; c_str &lt;&lt; <span class="string">" is a palindromic number."</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a_str = c_str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not found in 10 iterations."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="字符串" scheme="https://chouxianyu.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回文数" scheme="https://chouxianyu.github.io/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1140Look-and-say Sequence</title>
    <link href="https://chouxianyu.github.io/2020/08/04/PAT%E7%94%B2%E7%BA%A71140Look-and-say-Sequence/"/>
    <id>https://chouxianyu.github.io/2020/08/04/PAT甲级1140Look-and-say-Sequence/</id>
    <published>2020-08-04T13:47:41.000Z</published>
    <updated>2020-08-04T13:52:12.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805344490864640" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/994805344490864640</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li><p>corresponding to</p><p>  与…相一致，我之前似乎记成了“根据……”</p></li></ul><h2 id="思路、注意点和代码"><a href="#思路、注意点和代码" class="headerlink" title="思路、注意点和代码"></a>思路、注意点和代码</h2><ul><li>题目：第n+1个数字是第n个数字的一种描述<ul><li>第n+1个串是第n个串中各个数字的统计</li><li>统计规则是不好描述，我就不描述了。看样例或者代码就能看出来了</li></ul></li><li>注意点：<ul><li>按照我的解法的话，要注意处理一种情况：第3个字符串D111的情况</li><li>首先D出现了1次，得到D1；然后从第一个1开始统计，直到下标大于字符串长度，这时已经不用再遍历字符串，应保证遍历结束</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1140</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344490864640</span></span><br><span class="line"><span class="comment">// Tags: String</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">generateNext</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    <span class="comment">// 生成下一个字符串</span></span><br><span class="line">    <span class="built_in">stringstream</span> next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 获取key</span></span><br><span class="line">        <span class="keyword">char</span> key = str[i];</span><br><span class="line">        <span class="comment">// 统计key出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;  <span class="comment">// key出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;  <span class="comment">// 作为下标用来循环</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == str[j])</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 发现了和key不一样的字符str[j]，即该key的数量统计结束，且外层循环应接着从j开始</span></span><br><span class="line">                <span class="comment">// i=j-1而非i=j，是因为外层循环结束后i还要++</span></span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该key及其次数保存至新字符串</span></span><br><span class="line">        next &lt;&lt; key;</span><br><span class="line">        next &lt;&lt; count;</span><br><span class="line">        <span class="comment">// 处理样例中第3个字符串D111的情况，即内层循环不是通过break结束而是一直循环至j==len的情况</span></span><br><span class="line">        <span class="comment">// 这种情况则不用再进行外层循环了，因为最后一个key一直延续到了串的结尾</span></span><br><span class="line">        <span class="keyword">if</span> (j == len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// D是0到9</span></span><br><span class="line">    <span class="comment">// 第n+1个数字是第n个数字的一种描述</span></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    n -= <span class="number">1</span>; <span class="comment">// 用户输入的其实就是第1个串</span></span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">        s = generateNext(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><ul><li>参考了柳婼的代码，妙啊，她的代码和我上面写的题解一相比，有以下不同：<ul><li>用<code>j-i</code>实现计数功能，而非像我一样定义变量count进行计数</li><li>把<code>s[i]==s[j]</code>放在内层循环的判断条件中，而非像我一样使用<code>if+break</code>语句</li><li>外层循环结束后不是<code>i++</code>，而是直接<code>i=j</code>（前提是<code>j</code>此时是下一个待统计字符的下标）</li><li>内存循环<code>j</code>从<code>i</code>开始，而非像我一样从<code>i+1</code>开始。这一点是我的想法比较好</li></ul></li></ul><p>参考她的思路后，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1140</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/994805344490864640</span></span><br><span class="line"><span class="comment">// Tags: String</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;  <span class="comment">// 用户输入的数字，最终结果</span></span><br><span class="line">    <span class="keyword">int</span> n, j;  <span class="comment">// 第n个字符串，循环遍历</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    n -= <span class="number">1</span>; <span class="comment">// 用户输入的其实就是第1个串</span></span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i=j)&#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; s.length() &amp;&amp; s[i] == s[j]; j++);</span><br><span class="line">            t += s[i];</span><br><span class="line">            t += to_string(j - i);</span><br><span class="line">        &#125;</span><br><span class="line">        s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="字符串" scheme="https://chouxianyu.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>PAT甲级1152Google Recruitment</title>
    <link href="https://chouxianyu.github.io/2020/08/04/PAT%E7%94%B2%E7%BA%A71152Google-Recruitment/"/>
    <id>https://chouxianyu.github.io/2020/08/04/PAT甲级1152Google-Recruitment/</id>
    <published>2020-08-04T12:07:54.000Z</published>
    <updated>2020-08-04T12:09:26.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/1071785055080476672" target="_blank" rel="noopener">https://pintia.cn/problem-sets/994805342720868352/problems/1071785055080476672</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="涉及到的英语知识"><a href="#涉及到的英语知识" class="headerlink" title="涉及到的英语知识"></a>涉及到的英语知识</h2><ul><li><p>recruitment</p><p>  招聘</p></li><li><p>the first 10-digit prime found in consecutive digits of the natural constant <em>e</em></p><p>  由自然常数e的连续数字中的第一个10位素数</p></li><li><p>prime</p><p>  素数</p></li><li><p>consecutive</p><p>  连续的，连贯的</p></li><li><p>transcendental number</p><p>  超越数：在数论中，超越数是指任何一个不是代数数的无理数。只要它不是任何一个有理系数代数方程的根，它即是超越数。最著名的超越数是e以及π。</p></li></ul><h2 id="思路、代码以及注意点"><a href="#思路、代码以及注意点" class="headerlink" title="思路、代码以及注意点"></a>思路、代码以及注意点</h2><ul><li>题目要求<ul><li>题目给出L位的数字N，要求求出其中第一个K位的素数，如果不存在则输出404</li><li>提示：开头的0也算是素数的一部分，比如0002应和2等价</li></ul></li><li>思路<ul><li>遍历字符串并取子串，判断它是否为素数，找到第一个素数即可，找不到的话就输出404</li></ul></li><li>注意点<ul><li>如果找到了第一个素数，则输出结果时要输出字符串，方便处理<code>0002</code>这种情况</li><li>找不到第一个素数，以字符串或者数字形式输出404都可以</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: PAT Advanced 1152</span></span><br><span class="line"><span class="comment">// URL: https://pintia.cn/problem-sets/994805342720868352/problems/1071785055080476672</span></span><br><span class="line"><span class="comment">// Tags: String Prime</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 题目给出L位的数字N，要求求出其中第一个K位的素数，如果不存在则输出404</span></span><br><span class="line">    <span class="comment">// 提示：开头的0也算是素数的一部分，比如0002应和2等价</span></span><br><span class="line">    <span class="keyword">int</span> L, K;  <span class="comment">// 数字位数，所求素数位数</span></span><br><span class="line">    <span class="built_in">string</span> N;  <span class="comment">// 数字</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; L &gt;&gt; K &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L - K; i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> str = N.substr(i, K);</span><br><span class="line">        <span class="keyword">if</span> (isPrime(stoi(str)))&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">404</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++)</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/pro
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="https://chouxianyu.github.io/tags/PAT/"/>
    
      <category term="字符串" scheme="https://chouxianyu.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="素数" scheme="https://chouxianyu.github.io/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode230二叉搜索树中第K小的元素</title>
    <link href="https://chouxianyu.github.io/2020/08/01/LeetCode230%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>https://chouxianyu.github.io/2020/08/01/LeetCode230二叉搜索树中第K小的元素/</id>
    <published>2020-08-01T06:13:09.000Z</published>
    <updated>2020-08-01T06:17:25.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>递归解法</li><li>根据BST的性质，中序遍历BST得到的结点序列为结点的升序序列，序列中第k个元素就是第k小的元素。</li><li>所以可以中序遍历BST生成升序序列，找到第k个元素则停止遍历。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 230</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</span></span><br><span class="line"><span class="comment">// Tags: Tree BST Recursion DFS</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        <span class="comment">// 剪枝：如果已经遍历到第K个元素，则不用再遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;vals.size() &gt;= <span class="keyword">this</span>-&gt;k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 遍历当前根结点</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;vals.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取BST中第k小的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="comment">// 中序遍历生成元素的升序序列</span></span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="comment">// 结果为升序序列中的第k个元素，下面的两行代码都可以</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;vals[k - <span class="number">1</span>]; <span class="comment">// return this-&gt;vals.back();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/kth-smallest-element
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BST" scheme="https://chouxianyu.github.io/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode669修剪二叉搜索树</title>
    <link href="https://chouxianyu.github.io/2020/08/01/LeetCode669%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://chouxianyu.github.io/2020/08/01/LeetCode669修剪二叉搜索树/</id>
    <published>2020-08-01T02:25:34.000Z</published>
    <updated>2020-08-01T02:40:27.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/trim-a-binary-search-tree/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>递归解法</li><li>我看了题解写出来的，我分析题目的时候以为还要交换左右子树什么的……，其实不用</li><li>思路见代码注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 669</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/trim-a-binary-search-tree/</span></span><br><span class="line"><span class="comment">// Tags: Tree BST Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理空链表</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 如果根结点小于L，则根结点以及左子树会被剪掉，整个树的修剪结果是修剪后的右子树</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; L) <span class="keyword">return</span> trimBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="comment">// 如果根结点小于L，则根结点以及右子树会被剪掉，整个树的修剪结果是修剪后的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; R) <span class="keyword">return</span> trimBST(root-&gt;left, L, R);</span><br><span class="line">        <span class="comment">// 根结点不需要修剪，则修剪左右子树</span></span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="comment">// 修剪完成，返回根结点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/trim-a-binary-search
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="DFS" scheme="https://chouxianyu.github.io/tags/DFS/"/>
    
      <category term="BST" scheme="https://chouxianyu.github.io/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode328奇偶链表</title>
    <link href="https://chouxianyu.github.io/2020/07/31/LeetCode328%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>https://chouxianyu.github.io/2020/07/31/LeetCode328奇偶链表/</id>
    <published>2020-07-31T15:21:02.000Z</published>
    <updated>2020-08-01T02:38:41.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/odd-even-linked-list/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>我自己写的</li><li>思路是：首先建立两个链表（奇数号结点链表和偶数号结点链表），然后遍历整个链表并通过尾插法构造这两个链表，最后将偶数号结点链表连接到奇数号结点链表尾部即可。</li><li>时间复杂度是$O(n)$，空间复杂度是$O(1)$</li><li>具体思路见代码注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 328</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/odd-even-linked-list/</span></span><br><span class="line"><span class="comment">// Tags: Linked List</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理0个、1个或者2个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> || head-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 奇数号结点链表首尾</span></span><br><span class="line">        ListNode *oddHead = head, *oddTail = oddHead;</span><br><span class="line">        <span class="comment">// 偶数号结点链表首尾</span></span><br><span class="line">        ListNode *evenHead = head-&gt;next, *evenTail = evenHead;</span><br><span class="line">        <span class="comment">// 当前结点是第奇数个还是偶数个，true则为第奇数个，false则为第偶数个</span></span><br><span class="line">        <span class="keyword">bool</span> oddFlag = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 从第三个结点开始遍历</span></span><br><span class="line">        head = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 遍历链表，将链表分为奇数号结点链表和偶数号结点链表</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(oddFlag==<span class="literal">true</span>)&#123;</span><br><span class="line">                oddTail-&gt;next = head;</span><br><span class="line">                oddTail = oddTail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                evenTail-&gt;next = head;</span><br><span class="line">                evenTail = evenTail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            oddFlag = !oddFlag;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连接奇数号结点链表和偶数号结点链表</span></span><br><span class="line">        oddTail-&gt;next = evenHead;</span><br><span class="line">        evenTail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> oddHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/odd-even-linked-list
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode725分隔链表</title>
    <link href="https://chouxianyu.github.io/2020/07/31/LeetCode725%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <id>https://chouxianyu.github.io/2020/07/31/LeetCode725分隔链表/</id>
    <published>2020-07-31T10:19:17.000Z</published>
    <updated>2020-08-01T02:41:12.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-linked-list-in-parts/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>这题我做了好久</li><li>该题抽象出来的话，就是要将n个物体分成k组，要求每组物体数量的差异不超过1。</li><li>思路就是先均分成k组，每组n/k（忽略小数位）个元素，剩下了n%k个物体，就把剩下的n%k个物体均分放入n%k个组（在本题中是前n%k个组）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 725</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/split-linked-list-in-parts/</span></span><br><span class="line"><span class="comment">// Tags: Linked List</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(ListNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            root = root-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; splitListToParts(ListNode* root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode *&gt; result;</span><br><span class="line">        ListNode *temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 遍历求链表长度</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">this</span>-&gt;getLen(root);</span><br><span class="line">        <span class="comment">// 每个part至少quotient个结点</span></span><br><span class="line">        <span class="keyword">int</span> quotient = n / k;</span><br><span class="line">        <span class="comment">// 剩余remainder个结点，将其平均分配至前remainder个part</span></span><br><span class="line">        <span class="keyword">int</span> remainder = n % k;</span><br><span class="line">        <span class="comment">// 前remainder个part各quotient+1个结点，后k-remainder个结点各quotient个结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="comment">// 存储该part的头结点</span></span><br><span class="line">            result.push_back(root);</span><br><span class="line">            <span class="comment">// 该part中结点数量</span></span><br><span class="line">            <span class="keyword">int</span> partCount = remainder &gt; <span class="number">0</span> ? quotient + <span class="number">1</span> : quotient;</span><br><span class="line">            <span class="comment">// 通过遍历，将root移动到下一个part，同时用temp保存该part的尾结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; partCount; j++)&#123;</span><br><span class="line">                temp = root;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 断开该part中尾结点与下一part的连接</span></span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">nullptr</span>)</span><br><span class="line">                temp-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            remainder--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/split-linked-list-in
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode234回文链表</title>
    <link href="https://chouxianyu.github.io/2020/07/31/LeetCode234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <id>https://chouxianyu.github.io/2020/07/31/LeetCode234回文链表/</id>
    <published>2020-07-31T05:45:41.000Z</published>
    <updated>2020-08-01T02:38:41.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><ul><li>将链表元素存入数组，然后从首尾遍历</li><li>注意如果是空链表，结果也是true</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 234</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/palindrome-linked-list/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Two Pointers Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储链表中的结点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            vals.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从首尾两侧遍历</span></span><br><span class="line">        <span class="keyword">int</span> front = <span class="number">0</span>, back = vals.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(front &lt; back)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vals[front] != vals[back])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            front++;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><ul><li>递归写法，有点牛的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 234</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/palindrome-linked-list/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Two Pointers Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Easy</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* front;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ListNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 先检查尾部</span></span><br><span class="line">            <span class="keyword">if</span>(!check(node-&gt;next)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 检查当前结点</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;val != <span class="keyword">this</span>-&gt;front-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 该结点检查完了，递归使node从后往前，手动从前往后更新front</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;front = <span class="keyword">this</span>-&gt;front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;front = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;check(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-linked-li
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
      <category term="双指针" scheme="https://chouxianyu.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode445两数相加II</title>
    <link href="https://chouxianyu.github.io/2020/07/31/LeetCode445%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://chouxianyu.github.io/2020/07/31/LeetCode445两数相加II/</id>
    <published>2020-07-31T03:18:45.000Z</published>
    <updated>2020-08-01T02:38:41.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers-ii/</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><ul><li>使用了栈，遍历链表把结点存入栈中，然后弹栈将结点相加，注意进位</li><li>自己写的思路，代码有些长，应该有递归解法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 445</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/add-two-numbers-ii/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Stack Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x=<span class="number">0</span>) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addNode</span><span class="params">(ListNode* node1, ListNode* node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = node1-&gt;val + node2-&gt;val + <span class="keyword">this</span>-&gt;carry;</span><br><span class="line">        node1-&gt;val = sum%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">delete</span> node2;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s1;  <span class="comment">// 使用引用是为了避免不必要的内存开销</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;ListNode*&gt; s2;</span><br><span class="line">        <span class="comment">// 将两个链表中的结点存入栈中</span></span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s1.push(l1);</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s2.push(l2);</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newHead;</span><br><span class="line">        <span class="comment">// 将两个链表等长的部分相加</span></span><br><span class="line">        <span class="keyword">while</span> (!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">            newHead = <span class="keyword">this</span>-&gt;addNode(s1.top(), s2.top());</span><br><span class="line">            s1.pop();</span><br><span class="line">            s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果两个链表不等长，则处理两个链表因不等长而剩余的结点</span></span><br><span class="line">        <span class="keyword">if</span> (s1.empty()) s1 = s2;</span><br><span class="line">        ListNode *tempNode;</span><br><span class="line">        <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">            <span class="comment">// 取出一个结点</span></span><br><span class="line">            tempNode = s1.top();</span><br><span class="line">            s1.pop();</span><br><span class="line">            <span class="comment">// 考虑进位</span></span><br><span class="line">            <span class="keyword">int</span> sum = tempNode-&gt;val + <span class="keyword">this</span>-&gt;carry;</span><br><span class="line">            tempNode-&gt;val = sum%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;carry = sum/<span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 将该结点加入链表</span></span><br><span class="line">            tempNode-&gt;next = newHead;</span><br><span class="line">            newHead = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑最后一次进位</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 将该结点加入链表</span></span><br><span class="line">            tempNode = <span class="keyword">new</span> ListNode(<span class="keyword">this</span>-&gt;carry);</span><br><span class="line">            tempNode-&gt;next = newHead;</span><br><span class="line">            newHead = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><ul><li>递归解法</li><li>需要向短链表中添加结点使其与长链表长度一致，然后递归使链表相加</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 445</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/add-two-numbers-ii/description/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Stack Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x=<span class="number">0</span>) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历求出链表l有几个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">(ListNode* l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            l = l-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为链表l添加num个值为0的结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">addZeroNodes</span><span class="params">(ListNode* l, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">return</span> l;</span><br><span class="line">        ListNode* temp;</span><br><span class="line">        <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            temp-&gt;next = l;</span><br><span class="line">            l = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归函数</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="literal">nullptr</span> || l2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 先使后面的结点相加</span></span><br><span class="line">        addTwoLists(l1-&gt;next, l2-&gt;next);</span><br><span class="line">        <span class="comment">// 将两个结点相加</span></span><br><span class="line">        <span class="keyword">int</span> sum = l1-&gt;val + l2-&gt;val + <span class="keyword">this</span>-&gt;carry;</span><br><span class="line">        l1-&gt;val = sum%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;carry = sum/<span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 释放l2返回l1</span></span><br><span class="line">        <span class="keyword">delete</span> l2;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使两个链表等长</span></span><br><span class="line">        <span class="keyword">int</span> len1=<span class="keyword">this</span>-&gt;getLen(l1), len2=<span class="keyword">this</span>-&gt;getLen(l2);</span><br><span class="line">        l1 = <span class="keyword">this</span>-&gt;addZeroNodes(l1, len2 - len1);</span><br><span class="line">        l2 = <span class="keyword">this</span>-&gt;addZeroNodes(l2, len1 - len2);</span><br><span class="line">        <span class="comment">// 通过递归使链表相加</span></span><br><span class="line">        l1 = addTwoLists(l1, l2);</span><br><span class="line">        <span class="comment">// 考虑最后一个进位</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ListNode* temp = <span class="keyword">new</span> ListNode(<span class="keyword">this</span>-&gt;carry);</span><br><span class="line">            temp-&gt;next = l1;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers-ii/&quot;
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="栈" scheme="https://chouxianyu.github.io/tags/%E6%A0%88/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode24两两交换链表中的结点</title>
    <link href="https://chouxianyu.github.io/2020/07/30/LeetCode24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>https://chouxianyu.github.io/2020/07/30/LeetCode24两两交换链表中的节点/</id>
    <published>2020-07-30T13:12:01.000Z</published>
    <updated>2020-08-01T02:38:41.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>递归解法，我自己写的</li><li>要明确函数的功能</li><li>函数中需手动处理空链表和链表中只有1个结点的情况；多个结点时，先手动交换前两个结点，然后通过递归交换其它结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 24</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/swap-nodes-in-pairs/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空链表或只有1个结点</span></span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 取第2和3个结点</span></span><br><span class="line">        ListNode *newHead=head-&gt;next, *subHead = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 交换第1个结点和第2个结点，递归交换其它结点并进行连接</span></span><br><span class="line">        newHead-&gt;next = head;</span><br><span class="line">        head-&gt;next = swapPairs(subHead);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap-nodes-in-pairs/
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode19删除链表的倒数第N个结点</title>
    <link href="https://chouxianyu.github.io/2020/07/30/LeetCode19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://chouxianyu.github.io/2020/07/30/LeetCode19删除链表的倒数第N个节点/</id>
    <published>2020-07-30T12:42:27.000Z</published>
    <updated>2020-08-01T02:38:41.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><ul><li>双指针：一个“快”，一个“慢”</li><li>快指针先到达链表末尾</li><li>具体思路见代码及注释</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 19</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Two Pointers Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 删除链表的倒数第N个结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="comment">// 快指针先移动N+1步，慢指针不移动</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个if语句和上个while循环中的fast!=nullptr都是为了处理一种特殊情况：</span></span><br><span class="line">        <span class="comment">// 假如链表只有N个元素且要删除倒数第N个元素，则快指针不能移动N+1步，这时应直接删除头结点</span></span><br><span class="line">        <span class="keyword">if</span>(i!=n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 删除头结点并返回新链表</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> slow;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快指针和慢指针一起移动直至快指针为空</span></span><br><span class="line">        <span class="comment">// 因为快指针先移动了n+1步，所以循环结束后慢指针是指向待删除结点前面的那个结点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除待删除的结点并返回新链表</span></span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = fast-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> fast;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><ul><li>递归写法，很厉害，我参考了别人的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 19</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</span></span><br><span class="line"><span class="comment">// Tags: Linked List Two Pointers Recursion</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 删除链表的倒数第N个结点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 递归表达式</span></span><br><span class="line">        head-&gt;next = removeNthFromEnd(head-&gt;next, n);</span><br><span class="line">        <span class="comment">// 该变量用来标记是倒数第几个结点，这条语句写在了递归表达式之后，这很关键</span></span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">// 此时head即为待删除结点前边的那个结点</span></span><br><span class="line">        <span class="keyword">if</span>(index == n) <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://chouxianyu.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="单向链表" scheme="https://chouxianyu.github.io/tags/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
      <category term="双指针" scheme="https://chouxianyu.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode513找树左下角的值</title>
    <link href="https://chouxianyu.github.io/2020/07/30/LeetCode513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
    <id>https://chouxianyu.github.io/2020/07/30/LeetCode513找树左下角的值/</id>
    <published>2020-07-30T08:43:08.000Z</published>
    <updated>2020-08-01T02:38:41.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-bottom-left-tree-value/</a></p><h1 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h1><ul><li>层次遍历</li><li>求最后一层最左边的结点</li><li>我自己想的思路：层次遍历，保存每一层最左侧的结点，直到二叉树遍历结束</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 513</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/find-bottom-left-tree-value/</span></span><br><span class="line"><span class="comment">// Tags: Tree Queue BFS</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求最后一层最左边的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 空树，题目已说明树不会为空</span></span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 存储当前层中的结点</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; parentNodes;</span><br><span class="line">        parentNodes.push(root);</span><br><span class="line">        <span class="comment">// 按层遍历并保存每一层的第一个结点</span></span><br><span class="line">        TreeNode* leftBottomNode;</span><br><span class="line">        <span class="keyword">while</span>(!parentNodes.empty())&#123;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; childNodes;</span><br><span class="line">            <span class="comment">// 更新左下角结点指针</span></span><br><span class="line">            leftBottomNode = parentNodes.front();</span><br><span class="line">            <span class="comment">// 获取下一层结点</span></span><br><span class="line">            <span class="keyword">while</span>(!parentNodes.empty())&#123;</span><br><span class="line">                root = parentNodes.front();</span><br><span class="line">                parentNodes.pop();</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left!=<span class="literal">nullptr</span>) childNodes.push(root-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;right!=<span class="literal">nullptr</span>) childNodes.push(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新当前层</span></span><br><span class="line">            parentNodes = childNodes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftBottomNode-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h1><ul><li>其他人的思路</li><li>也是按层遍历，但是会先遍历右子结点再遍历左子结点，这样遍历二叉树时最后一个结点就是最后一层最左侧的结点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: LeetCode 513</span></span><br><span class="line"><span class="comment">// URL: https://leetcode-cn.com/problems/find-bottom-left-tree-value/</span></span><br><span class="line"><span class="comment">// Tags: Tree Queue BFS</span></span><br><span class="line"><span class="comment">// Difficulty: Medium</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 求最后一层最左边的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存储当前层中的结点</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        nodes.push(root);</span><br><span class="line">        <span class="comment">// 按层遍历，但先遍历右子结点再遍历左子结点</span></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            root = nodes.front();</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right!=<span class="literal">nullptr</span>) nodes.push(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left!=<span class="literal">nullptr</span>) nodes.push(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-bottom-left-tre
      
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://chouxianyu.github.io/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://chouxianyu.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="队列" scheme="https://chouxianyu.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="BFS" scheme="https://chouxianyu.github.io/tags/BFS/"/>
    
  </entry>
  
</feed>
