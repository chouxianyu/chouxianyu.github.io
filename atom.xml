<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>臭咸鱼的缺氧瓶</title>
  
  <subtitle>快给我氧气！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chouxianyu.github.io/"/>
  <updated>2020-04-20T09:37:30.827Z</updated>
  <id>https://chouxianyu.github.io/</id>
  
  <author>
    <name>臭咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>黑盒测试之因果图法</title>
    <link href="https://chouxianyu.github.io/2020/04/20/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95/"/>
    <id>https://chouxianyu.github.io/2020/04/20/黑盒测试之因果图法/</id>
    <published>2020-04-20T09:28:07.000Z</published>
    <updated>2020-04-20T09:37:30.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>设要对一个自动饮料售货机软件进行黑盒测试。该软件的规格说明如下：“有一个处理单价为1元5角的盒装饮料的自动售货机软件，若投入1元5角硬币，按下“可乐”、“雪碧”或“红茶”按钮，相应的饮料就送出来。若投入的是2元硬币，在送出饮料的同时退还5角硬币。“</p><ol><li>试利用因果图法，建立该软件的因果图；</li><li>设计测试该软件的全部测试用例。</li></ol><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="原因和结果"><a href="#原因和结果" class="headerlink" title="原因和结果"></a>原因和结果</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>原因</strong></th><th style="text-align:center"><strong>中间原因</strong></th><th style="text-align:center"><strong>结果</strong></th></tr></thead><tbody><tr><td style="text-align:center">c1：投入1元5角硬币</td><td style="text-align:center">m1：已投币</td><td style="text-align:center">e1：退还5角硬币</td></tr><tr><td style="text-align:center">c2：投入2元硬币</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">c3：按下“可乐”按钮</td><td style="text-align:center"></td><td style="text-align:center">e2：送出可乐</td></tr><tr><td style="text-align:center">c4：按下“雪碧”按钮</td><td style="text-align:center">m2：已按下按钮</td><td style="text-align:center">e3：送出雪碧</td></tr><tr><td style="text-align:center">c5：按下“红茶”按钮</td><td style="text-align:center"></td><td style="text-align:center">e4：送出红茶</td></tr></tbody></table></div><h2 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h2><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200420092644因果图.png" alt="因果图"></p><h2 id="决策表"><a href="#决策表" class="headerlink" title="决策表"></a>决策表</h2><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>1</strong></th><th style="text-align:center"><strong>2</strong></th><th style="text-align:center"><strong>3</strong></th><th style="text-align:center"><strong>4</strong></th><th style="text-align:center"><strong>5</strong></th><th style="text-align:center"><strong>6</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>c1</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>c2</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c3</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>c4</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c5</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>m1</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>m2</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>e1</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>e2</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr><tr><td style="text-align:center"><strong>e3</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>e4</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center"><strong>9</strong></td><td style="text-align:center"><strong>10</strong></td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center"><strong>12</strong></td></tr><tr><td style="text-align:center"><strong>c1</strong></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c2</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>c3</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c4</strong></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>c5</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>m1</strong></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>m2</strong></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><strong>e1</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center"><strong>e2</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>e3</strong></td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>e4</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">√</td></tr></tbody></table></div><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>测试用例编号</strong></th><th style="text-align:center"><strong>输入</strong></th><th style="text-align:center"><strong>预期输出</strong></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">不投币，不按按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">不投币，按下“可乐”按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">不投币，按下“雪碧”按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">不投币，按下“红茶”按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">投1元5角硬币，不按按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">投1元5角硬币，按下“可乐”按钮</td><td style="text-align:center">送出可乐</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">投1元5角硬币，按下“雪碧”按钮</td><td style="text-align:center">送出雪碧</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">投1元5角硬币，按下“红茶”按钮</td><td style="text-align:center">送出红茶</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">投2元硬币，不按按钮</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">投2元硬币，按下“可乐”按钮</td><td style="text-align:center">送出可乐并退还5角硬币</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">投2元硬币，按下“雪碧”按钮</td><td style="text-align:center">送出雪碧并退还5角硬币</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">投2元硬币，按下“红茶”按钮</td><td style="text-align:center">送出红茶并退还5角硬币</td></tr></tbody></table></div><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h1&gt;&lt;p&gt;设要对一个自动饮料售货机软件进行黑盒测试。该软件的规格说明如下：“有一个处理单价为1元5角的盒装饮料的自动售货机软件，若投入
      
    
    </summary>
    
    
      <category term="软件测试" scheme="https://chouxianyu.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="黑盒测试" scheme="https://chouxianyu.github.io/tags/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>黑盒测试之等价类划分</title>
    <link href="https://chouxianyu.github.io/2020/04/07/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86/"/>
    <id>https://chouxianyu.github.io/2020/04/07/黑盒测试之等价类划分/</id>
    <published>2020-04-07T11:40:18.000Z</published>
    <updated>2020-04-07T11:44:56.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>某城市电话号码由三部分组成。它们的名称和内容分别是：</p><ul><li><p><strong>地区码</strong>：空白或三位数字；</p></li><li><p><strong>前缀</strong>：非“0”或“1”的三位数字</p><p>  <strong>要求不是很明确，所以将其理解为不包括“0**</strong>”也不包括“1”的三位数字**</p></li><li><p><strong>后缀</strong>：4位数字。</p></li></ul><p>假定被测程序能接受一切符合上述规定的电话号码，拒绝所有不符合规定的电话号码。根据该程序的规格说明，做等价类的划分，并设计测试用例。（按照上课例子列表格）</p><h1 id="等价类表"><a href="#等价类表" class="headerlink" title="等价类表"></a>等价类表</h1><p>等价类的划分似乎没有统一的标准？比如我这里的无效等价类划分得挺简单的，可以划分得更细一些。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>输入数据</strong></th><th style="text-align:left"><strong>有效等价类</strong></th><th style="text-align:left"><strong>无效等价类</strong></th></tr></thead><tbody><tr><td style="text-align:center">地区码</td><td style="text-align:left">1空白</td><td style="text-align:left">3不是空白也不是三位数字</td></tr><tr><td style="text-align:center">地区码</td><td style="text-align:left">2三位的数字</td><td style="text-align:left">无</td></tr><tr><td style="text-align:center">前缀</td><td style="text-align:left">4不包含0且不包含1的三位数字</td><td style="text-align:left">5至少包含一个0或1</td></tr><tr><td style="text-align:center">前缀</td><td style="text-align:left">无</td><td style="text-align:left">6不是三位数字</td></tr><tr><td style="text-align:center">后缀</td><td style="text-align:left">7四位数字</td><td style="text-align:left">8不是四位数字</td></tr></tbody></table></div><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><h2 id="有效等价类测试用例"><a href="#有效等价类测试用例" class="headerlink" title="有效等价类测试用例"></a>有效等价类测试用例</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>测试数据</strong></th><th style="text-align:center"><strong>期望结果</strong></th><th style="text-align:center"><strong>覆盖范围</strong></th></tr></thead><tbody><tr><td style="text-align:center">地区码为空白  前缀为222  后缀为1234</td><td style="text-align:center">程序将该输入判定为有效输入</td><td style="text-align:center">1,4,7</td></tr><tr><td style="text-align:center">地区码为123  前缀为222  后缀为1234</td><td style="text-align:center">程序将该输入判定为有效输入</td><td style="text-align:center">2,4,7</td></tr></tbody></table></div><h2 id="无效等价类测试用例"><a href="#无效等价类测试用例" class="headerlink" title="无效等价类测试用例"></a>无效等价类测试用例</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>测试数据</strong></th><th style="text-align:center"><strong>期望结果</strong></th><th style="text-align:center"><strong>覆盖范围</strong></th></tr></thead><tbody><tr><td style="text-align:center">地区码为22  前缀为222  后缀为1234</td><td style="text-align:center">程序将该输入判定为无效输入</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">地区码为空白  前缀为123  后缀为1234</td><td style="text-align:center">程序将该输入判定为无效输入</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">地区码为空白  前缀为22  后缀为1234</td><td style="text-align:center">程序将该输入判定为无效输入</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">地区码为空白  前缀为222  后缀为123</td><td style="text-align:center">程序将该输入判定为无效输入</td><td style="text-align:center">8</td></tr></tbody></table></div><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h1&gt;&lt;p&gt;某城市电话号码由三部分组成。它们的名称和内容分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;地区码&lt;/strong
      
    
    </summary>
    
    
      <category term="软件测试" scheme="https://chouxianyu.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="黑盒测试" scheme="https://chouxianyu.github.io/tags/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java实现称重3次找到假球</title>
    <link href="https://chouxianyu.github.io/2020/04/07/Java%E5%AE%9E%E7%8E%B0%E7%A7%B0%E9%87%8D3%E6%AC%A1%E6%89%BE%E5%88%B0%E5%81%87%E7%90%83/"/>
    <id>https://chouxianyu.github.io/2020/04/07/Java实现称重3次找到假球/</id>
    <published>2020-04-07T05:38:29.000Z</published>
    <updated>2020-04-07T07:37:16.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前老师让写一个程序，就写了写，本文是我自己的写法。</p><p><a href="https://www.cnblogs.com/chouxianyu/p/12652784.html" target="_blank" rel="noopener">这里有老师的Java实现代码，请点击</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li><p>程序要求</p><p>  10个铅球中有一个假球（比其他铅球的重量要轻），用天平三次称出假球。</p></li><li><p>程序设计思路</p><p>  第一次使用天平分别称5个球，判断轻的一边有假球；拿出轻的5个球，取出其中4个第二次称，两边分别放2个球：如果两边同重，则剩下的球为假球；若两边不同重，拿出轻的两个球称第三次，轻的为假球。</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注释应该还算详细哈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数组中连续几个球的质量之和，区间是[startIndex,endIndex]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] balls,<span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex;i&lt;=endIndex;++i)&#123;</span><br><span class="line">            ret+=balls[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入balls是10个球的质量，该函数返回假球在该数组中的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFakeBall</span><span class="params">(<span class="keyword">int</span>[] balls)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一次称重，十个，五五分，默认左边五个球中有假球</span></span><br><span class="line">        <span class="keyword">int</span> fiveStartIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果右边五个球中有假球</span></span><br><span class="line">        <span class="keyword">if</span> (sum(balls,<span class="number">5</span>,<span class="number">9</span>)&lt;sum(balls,<span class="number">0</span>,<span class="number">4</span>))&#123;</span><br><span class="line">            fiveStartIndex = <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次称重，五个，二一二分，默认左边两个球中有假球</span></span><br><span class="line">        <span class="keyword">int</span> twoStartIndex = fiveStartIndex+<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 五个球中左边两个球的质量之和和右边两个球的质量之和</span></span><br><span class="line">        <span class="keyword">int</span> leftTwoSum = sum(balls,fiveStartIndex+<span class="number">0</span>,fiveStartIndex+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rightTwoSum = sum(balls,fiveStartIndex+<span class="number">3</span>,fiveStartIndex+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 如果右边两个球中有假球</span></span><br><span class="line">        <span class="keyword">if</span>(rightTwoSum&lt;leftTwoSum)&#123;</span><br><span class="line">            twoStartIndex = fiveStartIndex+<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 如果左右两边的四个球中没有假球，则中间的球是假球</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rightTwoSum==leftTwoSum)&#123;</span><br><span class="line">            <span class="keyword">return</span> fiveStartIndex+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三次称重</span></span><br><span class="line">        <span class="comment">// 如果两个球中左边是假球</span></span><br><span class="line">        <span class="keyword">if</span>(balls[twoStartIndex]&lt;balls[twoStartIndex+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> twoStartIndex;</span><br><span class="line">        <span class="comment">// 如果两个球中右边是假球</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> twoStartIndex+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对函数findFakeBall()进行测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] balls = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;   <span class="comment">// 所有球的质量</span></span><br><span class="line">        <span class="keyword">int</span> fakeIndex =findFakeBall(balls);</span><br><span class="line">        System.out.println(fakeIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前老师让写一个程序，就写了写，本文是我自己的写法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cho
      
    
    </summary>
    
    
      <category term="Java" scheme="https://chouxianyu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JUnit白盒测试之基本路径测试：称重3次找到假球</title>
    <link href="https://chouxianyu.github.io/2020/04/07/JUnit%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%EF%BC%9A%E7%A7%B0%E9%87%8D3%E6%AC%A1%E6%89%BE%E5%88%B0%E5%81%87%E7%90%83/"/>
    <id>https://chouxianyu.github.io/2020/04/07/JUnit白盒测试之基本路径测试：称重3次找到假球/</id>
    <published>2020-04-07T05:08:52.000Z</published>
    <updated>2020-04-07T07:36:18.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一次软件测试课程的课后作业，作业内容是白盒测试中的基本路径测试，步骤如下</p><ol><li>分析程序的控制流</li><li>计算环形复杂度</li><li>找出基本路径</li><li>设计测试用例</li><li>执行测试用例（要求使用JUnit）</li></ol><h1 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h1><p>使用白盒测试用例设计方法为下面的程序设计测试用例（基本路径测试）并用JUnit测试：</p><ul><li><p>程序要求</p><p>  10个铅球中有一个假球（比其他铅球的重量要轻），用天平三次称出假球。</p></li><li><p>程序设计思路</p><p>  第一次使用天平分别称5个球，判断轻的一边有假球；拿出轻的5个球，取出其中4个第二次称，两边分别放2个球：如果两边同重，则剩下的球为假球；若两边不同重，拿出轻的两个球称第三次，轻的为假球。</p></li><li><p>递交材料</p><p>  测试用例设计电子稿、源程序、JUnit测试截图。</p></li></ul><h1 id="程序代码及控制流图"><a href="#程序代码及控制流图" class="headerlink" title="程序代码及控制流图"></a>程序代码及控制流图</h1><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>文件<code>SearchBall.java</code>内容如下。</p><p>注意不要让代码的行号变动，程序流图中节点的编号是根据这份代码里每条执行语句里的行号对应的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> <span class="keyword">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchBall</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchBall</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBWeight</span><span class="params">(<span class="keyword">int</span> w[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;w.length;i++)&#123;</span><br><span class="line">             x[i]=w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">BeginSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[<span class="number">0</span>]+x[<span class="number">1</span>]+x[<span class="number">2</span>]+x[<span class="number">3</span>]+x[<span class="number">4</span>]&lt;x[<span class="number">5</span>]+x[<span class="number">6</span>]+x[<span class="number">7</span>]+x[<span class="number">8</span>]+x[<span class="number">9</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(x[<span class="number">1</span>]+x[<span class="number">2</span>]==x[<span class="number">3</span>]+x[<span class="number">4</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"1号是假球"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x[<span class="number">1</span>]+x[<span class="number">2</span>]&lt;x[<span class="number">3</span>]+x[<span class="number">4</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span> (x[<span class="number">1</span>]&lt;x[<span class="number">2</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"2号是假球"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"3号是假球"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x[<span class="number">3</span>]&lt;x[<span class="number">4</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"4号是假球"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"5号是假球"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(x[<span class="number">6</span>]+x[<span class="number">7</span>]==x[<span class="number">8</span>]+x[<span class="number">9</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"6号是假球"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x[<span class="number">6</span>]+x[<span class="number">7</span>]&lt;x[<span class="number">8</span>]+x[<span class="number">9</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[<span class="number">6</span>]&lt;x[<span class="number">7</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"7号是假球"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"8号是假球"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[<span class="number">8</span>]&lt;x[<span class="number">9</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"9号是假球"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"10号是假球"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序控制流图"><a href="#程序控制流图" class="headerlink" title="程序控制流图"></a>程序控制流图</h2><p>下图中<strong>节点</strong>中的数字是对应可执行语句在上面代码中的行号；<strong>边</strong>上的Y代表判定结果为真，N代表判定结果为假。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200407051334JUnit基本路径测试2.png" alt="程序控制流图"></p><h1 id="计算环形复杂度"><a href="#计算环形复杂度" class="headerlink" title="计算环形复杂度"></a>计算环形复杂度</h1><p>控制流图$G$的环形复杂度计算公式：$V(G)=E-N+2$，其中$E$为控制流图中边的数量，$N$是控制流图中的节点数量。</p><p>函数<code>BeginSearch()</code>的控制流图的环形复杂度为</p><script type="math/tex; mode=display">V(G)=18-19+2=1</script><h1 id="基本路径"><a href="#基本路径" class="headerlink" title="基本路径"></a>基本路径</h1><p>从程序流图中可知，共有10条基本路径，具体如下</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>路径编号</strong></th><th style="text-align:center"><strong>经过节点</strong></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">12-13-14</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">12-13-16-17-18</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">12-13-16-17-20</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">12-13-16-23-24</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">12-13-16-23-27</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">12-31-32</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">12-31-34-35-36</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">12-31-34-35-38</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">12-31-34-41-42</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">12-31-34-41-44</td></tr></tbody></table></div><h1 id="测试用例设计与执行"><a href="#测试用例设计与执行" class="headerlink" title="测试用例设计与执行"></a>测试用例设计与执行</h1><h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>路径编号</strong></th><th style="text-align:center"><strong>用例输入</strong></th><th style="text-align:center"><strong>期待输出</strong></th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">{5,  10, 10, 10, 10, 10, 10, 10, 10, 10}</td><td style="text-align:center">“1号是假球”</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">{10,  5, 10, 10, 10, 10, 10, 10, 10, 10}</td><td style="text-align:center">“2号是假球”</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">{10,  10, 5, 10, 10, 10, 10, 10, 10, 10}</td><td style="text-align:center">“3号是假球”</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">{10,  10, 10, 5, 10, 10, 10, 10, 10, 10}</td><td style="text-align:center">“4号是假球”</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">{10,  10, 10, 10, 5, 10, 10, 10, 10, 10}</td><td style="text-align:center">“5号是假球”</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">{10,  10, 10, 10, 10, 5, 10, 10, 10, 10}</td><td style="text-align:center">“6号是假球”</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">{10,  10, 10, 10, 10, 10, 5, 10, 10, 10}</td><td style="text-align:center">“7号是假球”</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">{10,  10, 10, 10, 10, 10, 10, 5, 10, 10}</td><td style="text-align:center">“8号是假球”</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">{10,  10, 10, 10, 10, 10, 10, 10, 5, 10}</td><td style="text-align:center">“9号是假球”</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">{10,  10, 10, 10, 10, 10, 10, 10, 10, 5}</td><td style="text-align:center">“10号是假球”</td></tr></tbody></table></div><h2 id="Junit执行测试用例"><a href="#Junit执行测试用例" class="headerlink" title="Junit执行测试用例"></a>Junit执行测试用例</h2><p>基于JUnit生成的测试代码，我补充了测试函数<code>BeginSearch()</code>的代码，文件<code>SearchBallTest.java</code>内容如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.<span class="keyword">module</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test; </span><br><span class="line"><span class="keyword">import</span> org.junit.Before; </span><br><span class="line"><span class="keyword">import</span> org.junit.After; </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">module</span>.SearchBall;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* SearchBall Tester. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> &lt;Authors name&gt; </span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> &lt;pre&gt;4月 7, 2020&lt;/pre&gt; </span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchBallTest</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Method: setBWeight(int w[]) </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSetBWeight</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Test goes here... </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* Method: BeginSearch() </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeginSearch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SearchBall obj = <span class="keyword">new</span> SearchBall();</span><br><span class="line">    <span class="keyword">int</span>[] input;</span><br><span class="line">    <span class="keyword">int</span> ballIndex;</span><br><span class="line">    <span class="comment">// 遍历测试各个基本路径</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="comment">// 生成用例输入</span></span><br><span class="line">        input = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        input[i]=<span class="number">5</span>;</span><br><span class="line">        obj.setBWeight(input);</span><br><span class="line">        <span class="comment">// 测试用例输出</span></span><br><span class="line">        ballIndex = i+<span class="number">1</span>;</span><br><span class="line">        assertEquals(ballIndex+<span class="string">"号是假球"</span>, obj.BeginSearch());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行函数<code>testBeginSearch()</code>，得到如下图所示的结果（从下图也可以看到项目的结构）</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200407051324JUnit基本路径测试1.jpg" alt="JUnit执行结果截图"></p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ul><li><a href="https://www.cnblogs.com/chouxianyu/p/12652969.html" target="_blank" rel="noopener">我自己实现的找到假球的程序</a></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记录一次软件测试课程的课后作业，作业内容是白盒测试中的基本路径测试，步骤如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分析程序的控制流&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="软件测试" scheme="https://chouxianyu.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="白盒测试" scheme="https://chouxianyu.github.io/tags/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/"/>
    
      <category term="基本路径测试" scheme="https://chouxianyu.github.io/tags/%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95/"/>
    
      <category term="JUnit" scheme="https://chouxianyu.github.io/tags/JUnit/"/>
    
      <category term="Java" scheme="https://chouxianyu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>用pymysql和Flask搭建后端，响应前端POST和GET请求，实现登录和注册功能</title>
    <link href="https://chouxianyu.github.io/2020/04/05/%E7%94%A8pymysql%E5%92%8CFlask%E6%90%AD%E5%BB%BA%E5%90%8E%E7%AB%AF%EF%BC%8C%E5%93%8D%E5%BA%94%E5%89%8D%E7%AB%AFPOST%E5%92%8CGET%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%92%8C%E6%B3%A8%E5%86%8C%E5%8A%9F%E8%83%BD/"/>
    <id>https://chouxianyu.github.io/2020/04/05/用pymysql和Flask搭建后端，响应前端POST和GET请求，实现登录和注册功能/</id>
    <published>2020-04-05T02:14:03.000Z</published>
    <updated>2020-04-06T02:50:44.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次作业不仅需要我<a href="https://www.cnblogs.com/chouxianyu/p/12634881.html" target="_blank" rel="noopener">建立一个数据库(详情请点击这里)</a>，还需要我基于这个数据库写后端接口（注册和登录）供前端访问，接收前端的POST和GET请求，并将登录、注册是否成功传给前端。</p><p>本文介绍如何用Flask搭建后端，其中使用了pymysql操作mysql数据库，也会做这个部分的介绍。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>需要为前端提供的接口有两个：注册和登录，为此我定义了四个函数，分别是</p><ul><li>select_user(userid, password)</li><li>insert_user(userid, password, phone, email, company)</li><li>on_register()</li><li>on_login()</li></ul><p>前两个函数是操作数据库，被后两个函数调用；后两个函数是给前端的接口。</p><h2 id="后端说明"><a href="#后端说明" class="headerlink" title="后端说明"></a>后端说明</h2><p>整个后端的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> flask_cors <span class="keyword">import</span> CORS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义app</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 设置跨域</span></span><br><span class="line">CORS(app, supports_credentials=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库，账号是root，密码是000，数据库名称是shopdata</span></span><br><span class="line">db = pymysql.connect(<span class="string">"localhost"</span>, <span class="string">"root"</span>, <span class="string">"000"</span>, <span class="string">"shopdata"</span>)  <span class="comment"># 连接数据库</span></span><br><span class="line">cursor = db.cursor()  <span class="comment"># 定义游标</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># select a user，根据userid和password获取一个用户是否存在，即判断登录是否成功</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_user</span><span class="params">(userid, password)</span>:</span></span><br><span class="line">    <span class="comment"># mysql语句</span></span><br><span class="line">    select_user_sql = <span class="string">'select * from userinfo where userid="%s" and password="%s";'</span> % (userid, password)</span><br><span class="line">    <span class="comment"># 执行mysql语句</span></span><br><span class="line">    result = cursor.execute(select_user_sql)</span><br><span class="line">    db.commit()</span><br><span class="line">    <span class="comment"># 如果返回了一条数据，则登录成功，否则登录失败</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span> == result:</span><br><span class="line">        result = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="keyword">False</span></span><br><span class="line">        print(<span class="string">'there is no user where userid="%s and password="%s"!!'</span> % (userid, password))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># insert a user，根据userid、password等信息，生成一个元组，将其插入数据库shopdata的userinfo表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_user</span><span class="params">(userid, password, phone, email, company)</span>:</span></span><br><span class="line">    <span class="comment"># mysql语句</span></span><br><span class="line">    insert_user_sql = <span class="string">'insert into userinfo(userid, password, phone, email, company)'</span> \</span><br><span class="line">                      <span class="string">'values("%s", "%s", "%s", "%s", "%s");'</span> % (userid, password, phone, email, company)</span><br><span class="line">    <span class="comment"># 执行mysql语句，如果插入成功，则注册成功，否则注册失败</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(insert_user_sql)</span><br><span class="line">        db.commit()</span><br><span class="line">        print(<span class="string">'insert user where userid="%s" and password="%s"!!'</span> % (userid, password))</span><br><span class="line">        result = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'can not insert user where userid="%s" and password="%s"!!'</span> % (userid, password))</span><br><span class="line">        result = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># on_register，提供给前端的注册接口</span></span><br><span class="line"><span class="meta">@app.route("/api/register", methods=['POST'])  # 路由，响应POST请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_register</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 默认的用户名和密码（该用户不存在且非法）</span></span><br><span class="line">    userid = <span class="string">''</span></span><br><span class="line">    password = <span class="string">''</span></span><br><span class="line">    phone = <span class="string">''</span></span><br><span class="line">    email = <span class="string">''</span></span><br><span class="line">    company = <span class="string">''</span></span><br><span class="line">    <span class="comment"># 判断传入的参数是否为空，并取出前端传来的参数</span></span><br><span class="line">    data = request.get_data()</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># 将bytes类型转化为字典。对应的，前端发过来的内容应该是JSON.stringify(一个对象)</span></span><br><span class="line">        data = json.loads(data)  <span class="comment"># 转化为字典对象</span></span><br><span class="line">        <span class="comment"># print(data)</span></span><br><span class="line">        userid = data.get(<span class="string">'userid'</span>)</span><br><span class="line">        password = data.get(<span class="string">'password'</span>)</span><br><span class="line">        phone = data.get(<span class="string">'phone'</span>)</span><br><span class="line">        email = data.get(<span class="string">'email'</span>)</span><br><span class="line">        company = data.get(<span class="string">'company'</span>)</span><br><span class="line">    <span class="comment"># 判断参数是否非法。若非法则直接判断出注册失败，若合法则尝试注册，再根据数据库操作结果判断。</span></span><br><span class="line">    <span class="keyword">if</span> len(userid) &gt; <span class="number">0</span> <span class="keyword">and</span> len(password) &gt; <span class="number">0</span> <span class="keyword">and</span> len(phone) &gt; <span class="number">0</span> <span class="keyword">and</span> len(email) &gt; <span class="number">0</span> <span class="keyword">and</span> len(password) &gt; <span class="number">0</span>:</span><br><span class="line">        return_dict = &#123;<span class="string">'success'</span>: insert_user(userid=userid, password=password, phone=phone,</span><br><span class="line">                                              email=email, company=company)&#125;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        return_dict = &#123;<span class="string">'success'</span>: <span class="keyword">False</span>&#125;</span><br><span class="line">    <span class="comment"># 返回结果（结果暂时简单点，只返回成功或失败）</span></span><br><span class="line">    <span class="keyword">return</span> json.dumps(return_dict)  <span class="comment"># 字典转json</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># on_login，提供给前端的登录接口</span></span><br><span class="line"><span class="meta">@app.route("/api/login", methods=['GET'])  # 路由，响应GET请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 默认的用户名和密码（数据库中不存在该用户）</span></span><br><span class="line">    userid = <span class="string">''</span></span><br><span class="line">    password = <span class="string">''</span></span><br><span class="line">    <span class="comment"># 判断传入的参数是否为空，获取前端传来的参数</span></span><br><span class="line">    <span class="keyword">if</span> request.args <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        print(request.args)</span><br><span class="line">        data = request.args.to_dict()</span><br><span class="line">        userid = data.get(<span class="string">'userid'</span>)</span><br><span class="line">        password = data.get(<span class="string">'password'</span>)</span><br><span class="line">    <span class="comment"># 查询数据库</span></span><br><span class="line">    result = select_user(userid=userid, password=password)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">        print(<span class="string">'user where userid="%s and password="%s" login!!'</span> % (userid, password))</span><br><span class="line">    <span class="comment"># 返回登录结果（暂时简单一点，成功或失败）</span></span><br><span class="line">    return_dict = &#123;<span class="string">'success'</span>: result&#125;</span><br><span class="line">    <span class="keyword">return</span> json.dumps(return_dict)  <span class="comment"># 字典转json</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 运行app</span></span><br><span class="line">    app.run()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 程序结束时释放数据库资源</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    db.close()  <span class="comment"># 关闭连接</span></span><br></pre></td></tr></table></figure><p><strong>值得注意的是</strong>，这里的两个接口分别响应POST请求和GET请求。</p><p>可以发现，两个接口获取前端传过来的参数的方式是不同的：</p><ul><li><p>GET</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = request.args.to_dict()  <span class="comment"># 需from flask import request</span></span><br></pre></td></tr></table></figure><p>  这样拿到的data是一个python的字典对象</p></li><li><p>POST</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = request.get_data()  <span class="comment"># 需from flask import request</span></span><br><span class="line">data = json.loads(data)  <span class="comment"># 转化为字典对象。需import json</span></span><br></pre></td></tr></table></figure><p>  这两行代码才拿到一个python的字典对象</p></li></ul><p><strong>接口获取前端传过来的参数的方式与其响应的请求类型（如POST、GET、POST和GET）是对应的。</strong></p><p>对应地，前端发过来的参数类型也需要和后端进行匹配。</p><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><p>这里给出前端处理用户登录和注册请求的函数。</p><ul><li><p>login</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">"http://127.0.0.1:5000/api/login"</span>;</span><br><span class="line">    <span class="keyword">var</span> userid = <span class="built_in">document</span>.getElementById(<span class="string">"userid"</span>);</span><br><span class="line">    <span class="keyword">var</span> password = <span class="built_in">document</span>.getElementById(<span class="string">"password"</span>);</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: url,</span><br><span class="line">        type: <span class="string">"GET"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            userid: userid.value,</span><br><span class="line">            password: password.value,</span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data1 = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">            <span class="comment">// console.log(data1);</span></span><br><span class="line">            <span class="keyword">if</span> (data1.success) &#123;</span><br><span class="line">                <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">"userid"</span>, userid.value);</span><br><span class="line">                alert(<span class="string">"登录成功！进入主页面！"</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.href = <span class="string">'index.html'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">"登录失败！请输入正确的账号和密码！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (textStatus === <span class="string">'timeout'</span>) &#123;</span><br><span class="line">                alert(<span class="string">'请求超时，请重试！'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>register</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> password1 = <span class="built_in">document</span>.getElementById(<span class="string">"password1"</span>).value;</span><br><span class="line">    <span class="keyword">var</span> password2 = <span class="built_in">document</span>.getElementById(<span class="string">"password2"</span>).value;</span><br><span class="line">    <span class="keyword">var</span> userid = <span class="built_in">document</span>.getElementById(<span class="string">"userid"</span>).value;</span><br><span class="line">    <span class="keyword">var</span> phone = <span class="built_in">document</span>.getElementById(<span class="string">"phone"</span>).value;</span><br><span class="line">    <span class="keyword">var</span> email = <span class="built_in">document</span>.getElementById(<span class="string">"email"</span>).value;</span><br><span class="line">    <span class="keyword">var</span> company = <span class="built_in">document</span>.getElementById(<span class="string">"company"</span>).value;</span><br><span class="line">    <span class="keyword">if</span> (password1 !== password2) &#123;</span><br><span class="line">        alert(<span class="string">"两次输入的密码不相同,请重新输入！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">"http://127.0.0.1:5000/api/register"</span>,</span><br><span class="line">        type: <span class="string">"POST"</span>,</span><br><span class="line">        <span class="comment">// 转成json</span></span><br><span class="line">        data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            userid: userid,</span><br><span class="line">            password: password1,</span><br><span class="line">            phone: phone,</span><br><span class="line">            email: email,</span><br><span class="line">            company: company</span><br><span class="line">        &#125;),</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> data1 = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">            <span class="keyword">if</span> (data1.success) &#123;</span><br><span class="line">                alert(<span class="string">"注册成功，请登录！"</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.href = <span class="string">'login.html'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">"注册失败，请检查您输入的信息是否正确！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (textStatus === <span class="string">'timeout'</span>) &#123;</span><br><span class="line">                alert(<span class="string">"请求超时！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>可以注意到，用ajax发送GET请求和PSOT请求时，我发的数据类型是不一样的。</strong></p><ul><li><p>login是GET请求，发送了json字符串</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(&#123;</span><br><span class="line">    userid: userid,</span><br><span class="line">    password: password1,</span><br><span class="line">    phone: phone,</span><br><span class="line">    email: email,</span><br><span class="line">    company: company</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>register是POST请求，发送了javascript的类的对象</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    userid: userid.value,</span><br><span class="line">    password: password.value,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>至此，本文对这次作业中后端搭建的介绍就结束了。</p><p>这次作业算是我第一次写后端，也是我第一次接触Flask，如果我有写错的地方，请在评论区指正！</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这次作业不仅需要我&lt;a href=&quot;https://www.cnblogs.com/chouxianyu/p/12634881.html&quot; 
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://chouxianyu.github.io/tags/mysql/"/>
    
      <category term="Flask" scheme="https://chouxianyu.github.io/tags/Flask/"/>
    
      <category term="Web" scheme="https://chouxianyu.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>作业过程及其问题的记录：mysql建立数据库、建表、查询和插入等</title>
    <link href="https://chouxianyu.github.io/2020/04/04/%E4%B8%80%E6%AC%A1%E4%BD%9C%E4%B8%9A%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%85%B6%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95%EF%BC%9Amysql%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E5%BB%BA%E8%A1%A8%E3%80%81%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8F%92%E5%85%A5%E7%AD%89/"/>
    <id>https://chouxianyu.github.io/2020/04/04/一次作业过程及其问题的记录：mysql建立数据库、建表、查询和插入等/</id>
    <published>2020-04-04T14:42:24.000Z</published>
    <updated>2020-04-05T03:02:02.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次的作业需要我建立一个小的数据库。</p><p>这次作业我使用了mysql，进行了建库、建表、查询、插入等操作。</p><p>本文是对本次作业相关的mysql操作过程及过程中出现的问题的记录。</p><p><a href="https://www.cnblogs.com/chouxianyu/p/12636231.html" target="_blank" rel="noopener">另一篇文章(详情请点击)</a>介绍了如何使用pymysql连接该数据库并使用Flask搭建后端接口，响应前端的GET和POST请求。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>作业中对数据库的要求是：</p><ul><li>建立一个用户信息表，其包括用户名、密码、手机号、邮箱和手机号等属性，并向其中插入几条测试数据。</li></ul><h2 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h2><p>因为挺久没用数据库，就先测试下自己之前装的mysql还能不能用，于是打开CMD运行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql</span><br></pre></td></tr></table></figure><p>出现如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1045 (28000): Access denied for user 'ODBC'@'localhost' (using password: NO)</span><br></pre></td></tr></table></figure><p>看起来是因为没输代码</p><p>所以输入密码，运行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><ul><li><code>-u</code>参数是指username、user之类的，即用户名，我的用户名是<code>root</code>；</li><li><code>-p</code>参数是指password，运行下面这条指令后，会要求输入密码，输入正确密码即成功登录。</li></ul><p>我的mysql环境还可以，直接登录成功。</p><h2 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h2><p>执行如下指令，创建名为shopdata的数据库，会得到<code>Query OK, 1 row affected (x.xx sec)</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database shopdata;</span><br></pre></td></tr></table></figure><h2 id="进入-选择数据库"><a href="#进入-选择数据库" class="headerlink" title="进入/选择数据库"></a>进入/选择数据库</h2><p>执行如下指令后，会看到<code>Database changed</code>的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use shopdata;</span><br></pre></td></tr></table></figure><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>执行如下指令，创建名为userinfo的表。</p><p>我这里对userinfo的定义是：</p><ul><li><p>主键是用户名userid</p></li><li><p>password是非NULL的</p></li><li><p>phone和email是unique的</p></li><li><p>这5个属性的类型都是varchar(15)</p><p>  最长15，对于email来说不太够用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table userinfo (</span><br><span class="line">    &apos;userid&apos; varchar(15) primary key,</span><br><span class="line">    &apos;password&apos; varchar(15) not null,</span><br><span class="line">    &apos;company&apos; varchar(15),</span><br><span class="line">    &apos;phone&apos; varchar(15) unique,</span><br><span class="line">    &apos;email&apos; varchar(15) unique</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>执行上边这条命令后，得到了一个错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''userid' varchar(15) primary key,</span><br><span class="line">    'password' varchar(15) not null,</span><br><span class="line">    'comp' at line 2</span><br></pre></td></tr></table></figure><p>经查询，发现属性名应该用反引号<strong>`</strong>而不是单引号<strong>‘</strong>，所以将单引号改成反引号，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table userinfo (</span><br><span class="line">    `userid` varchar(15) primary key,</span><br><span class="line">    `password` varchar(15) not null,</span><br><span class="line">    `company` varchar(15),</span><br><span class="line">    `phone` varchar(15) unique,</span><br><span class="line">    `email` varchar(15) unique</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这条命令执行成功，得到<code>Query OK, 0 rows affected (x.xx sec)</code>。</p><h2 id="查看userinfo表"><a href="#查看userinfo表" class="headerlink" title="查看userinfo表"></a>查看userinfo表</h2><p>执行如下命令，查看userinfo表的结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe userinfo;</span><br></pre></td></tr></table></figure><p>执行后，得到如下结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| userid   | varchar(15) | NO   | PRI | NULL    |       |</span><br><span class="line">| password | varchar(15) | NO   |     | NULL    |       |</span><br><span class="line">| company  | varchar(15) | YES  |     | NULL    |       |</span><br><span class="line">| phone    | varchar(15) | YES  | UNI | NULL    |       |</span><br><span class="line">| email    | varchar(15) | YES  | UNI | NULL    |       |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">5 rows in set (0.57 sec)</span><br></pre></td></tr></table></figure><h2 id="插入3条数据"><a href="#插入3条数据" class="headerlink" title="插入3条数据"></a>插入3条数据</h2><p>执行如下命令，插入3条数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into userinfo values</span><br><span class="line">(&apos;user1&apos;,&apos;0000&apos;,&apos;zstu&apos;,&apos;13777860000&apos;,&apos;7746@qq.com&apos;),</span><br><span class="line">(&apos;user2&apos;,&apos;0000&apos;,&apos;zstu&apos;,&apos;13777860001&apos;,&apos;7747@qq.com&apos;),</span><br><span class="line">(&apos;user3&apos;,&apos;0000&apos;,&apos;zstu&apos;,&apos;13777860002&apos;,&apos;7748@qq.com&apos;);</span><br></pre></td></tr></table></figure><p>执行后，得到如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Query OK, 3 rows affected (0.11 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>执行如下语句，查询所有元组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from userinfo;</span><br></pre></td></tr></table></figure><p>执行后，得到如下结果（在我做好作业后、写这篇博客前，我已经插入了一些其他的数据，所以有9条记录）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+------------+----------+---------+-------------+--------------+</span><br><span class="line">| userid     | password | company | phone       | email        |</span><br><span class="line">+------------+----------+---------+-------------+--------------+</span><br><span class="line">| 111        | 111      | 111     | 111         | 111          |</span><br><span class="line">| 112        | 000      | 111     | 000         | 000          |</span><br><span class="line">| aa         | 111      | 11      | 11          | 11           |</span><br><span class="line">| test_1     | 00       | NULL    | NULL        | NULL         |</span><br><span class="line">| user_test2 | 0000     | NULL    | NULL        | NULL         |</span><br><span class="line">| user1      | 0000     | zstu    | 13777860000 | 7746@qq.com  |</span><br><span class="line">| user2      | 0000     | zstu    | 13777860001 | 7747@qq.com  |</span><br><span class="line">| user3      | 0000     | zstu    | 13777860002 | 7748@qq.com  |</span><br><span class="line">| 232222     | 0000     | 城站    | 12306       | 12306@qq.com |</span><br><span class="line">+------------+----------+---------+-------------+--------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这次的作业需要我建立一个小的数据库。&lt;/p&gt;
&lt;p&gt;这次作业我使用了mysql，进行了建库、建表、查询、插入等操作。&lt;/p&gt;
&lt;p&gt;本文是对
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://chouxianyu.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于Python的TypeError not all arguments converted during string formatting</title>
    <link href="https://chouxianyu.github.io/2020/04/04/%E5%85%B3%E4%BA%8EPython%E7%9A%84TypeError-not-all-arguments-converted-during-string-formatting/"/>
    <id>https://chouxianyu.github.io/2020/04/04/关于Python的TypeError-not-all-arguments-converted-during-string-formatting/</id>
    <published>2020-04-04T02:38:36.000Z</published>
    <updated>2020-04-04T02:54:45.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在把yolov3的cfg文件转换为model_defs时，我忘记把str类型转换成int了，导致了一个错误，在此记录下来。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200404025426image-20200404104353866.png" alt="image-20200404104353866"></p><p>如上图所示，<code>&#39;32&#39;%2</code>就是错误发生的地方。</p><p>我以为我拿到的是一个int类型的<code>32</code>，想判断它是偶数还是奇数。</p><p>实际上我拿到的是一个str类型的<code>&#39;32&#39;</code>，这时python的解释器并没有把<code>%</code>理解成取余，而是理解成了这种东西。</p><p>我不知道“这种东西”的定义，但知道其用法和语法，其语法是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'cxy'</span></span><br><span class="line">print(<span class="string">'%s is handsome!'</span> % name)</span><br></pre></td></tr></table></figure><p>也就是说，解释器把<code>%</code>理解成了上面代码中print语句中的第二个<code>%</code>，因此出现了这个TypeError。</p><p>关于该<code>TypeError</code>，也有其他的原因，如<a href="https://blog.csdn.net/lvsehaiyang1993/article/details/80909984" target="_blank" rel="noopener">https://blog.csdn.net/lvsehaiyang1993/article/details/80909984</a>。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在把yolov3的cfg文件转换为model_defs时，我忘记把str类型转换成int了，导致了一个错误，在此记录下来。&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://chouxianyu.github.io/tags/Bug/"/>
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>解决GPU显存未释放问题</title>
    <link href="https://chouxianyu.github.io/2020/04/04/%E8%A7%A3%E5%86%B3GPU%E6%98%BE%E5%AD%98%E6%9C%AA%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98/"/>
    <id>https://chouxianyu.github.io/2020/04/04/解决GPU显存未释放问题/</id>
    <published>2020-04-04T00:02:21.000Z</published>
    <updated>2020-04-04T02:34:55.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今早我想用多块GPU测试模型，于是就用了PyTorch里的<code>torch.nn.parallel.DistributedDataParallel</code>来支持用多块GPU的同时使用（下面简称其为<strong>Dist</strong>）。</p><p>程序运行时，由于程序中其他部分的代码（与Dist无关的代码）出现了错误，导致程序退出。这次使用Dist时没有考虑和处理这种程序崩溃的情况，因此在程序退出前没有用Dist关闭生成的所有进程，最终导致本次进程运行后GPU显存未释放（经观察，发现是由于没有用Dist关闭所有进程，导致程序运行后还有一部分进程在运行）。</p><p>下面介绍这次我解决该问题的过程。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="MVE"><a href="#MVE" class="headerlink" title="MVE"></a>MVE</h2><p>Minimal Verifiable Examples，关于本问题的程序代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些代码：定义model等</span></span><br><span class="line">some code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化并行训练</span></span><br><span class="line">dist.init_process_group(xxxx)  <span class="comment"># 函数参数省略</span></span><br><span class="line">model = torch.nn.parallel.DistributedDataParallel(model, find_unused_parameters=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些代码：训练、测试模型等</span></span><br><span class="line">some code  <span class="comment"># 我的程序在这个部分出错且程序直接退出，导致下面的关闭进程的代码没有运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有进程</span></span><br><span class="line">dist.destroy_process_group()</span><br></pre></td></tr></table></figure><h2 id="问题的出现"><a href="#问题的出现" class="headerlink" title="问题的出现"></a>问题的出现</h2><p>如下图所示，程序退出后，并没有进程在使用0号GPU，但0号GPU的显存却被占用。原因是程序退出前没有用Dist关闭所有进程，一部分进程还在运行，这些进程占用0号GPU的显存。</p><p>占用7号GPU的进程是我的另外一个进程，与本文讨论的问题无关。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200404000440image-20200404070619631.png" alt="image-20200404070619631"></p><h2 id="定位占用GPU显存的PID"><a href="#定位占用GPU显存的PID" class="headerlink" title="定位占用GPU显存的PID"></a>定位占用GPU显存的PID</h2><p>执行下面的指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -v /dev/nvidia*</span><br></pre></td></tr></table></figure><p>该命令执行后得到下图所示的结果，可以看到是PID为285448的进程占用了0号GPU。</p><p>下面的图中忘记打了马赛克，后来用黑色遮挡了一下信息，所以USER这一列是看起来是空的。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200404000522image-20200404070704618.png" alt="image-20200404070704618"></p><p>执行下面这条命令，查看该进程的信息，可以发现该进程的PPID（其父进程的PID）是1，说明该进程不是我占用7号GPU的进程生成的，并且现在只有它在使用0号GPU。可以推断出这个进程是因为程序运行错误导致其没有被关闭，因此可以手动关闭该进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -f -p 285448</span><br></pre></td></tr></table></figure><p>下面的图中忘记打了马赛克，后来用黑色遮挡了一下信息，所以图中的路径不是很清晰。</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200404000606image-20200404070805983.png" alt="image-20200404070805983"></p><p>先后执行下面这两条命令，杀掉该进程，再查看GPU情况，可以看到0号GPU的显存已经被释放，现在的GPU显存占用情况是正常的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -9 2885448</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200404000642image-20200404070901921.png" alt="image-20200404070901921"></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今早我想用多块GPU测试模型，于是就用了PyTorch里的&lt;code&gt;torch.nn.parallel.DistributedDataPa
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://chouxianyu.github.io/tags/Bug/"/>
    
      <category term="PyTorch" scheme="https://chouxianyu.github.io/tags/PyTorch/"/>
    
      <category term="linux" scheme="https://chouxianyu.github.io/tags/linux/"/>
    
      <category term="GPU" scheme="https://chouxianyu.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>HostwindsVPS购买、支付宝支付相关</title>
    <link href="https://chouxianyu.github.io/2020/04/03/HostwindsVPS%E8%B4%AD%E4%B9%B0%E3%80%81%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3/"/>
    <id>https://chouxianyu.github.io/2020/04/03/HostwindsVPS购买、支付宝支付相关/</id>
    <published>2020-04-03T03:09:06.000Z</published>
    <updated>2020-04-03T03:22:43.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我前几天买了<a href="https://www.hostwinds.com/" target="_blank" rel="noopener">Hostwinds</a>的VPS，当时买的时候支付宝支付就出了问题，最近这两天用支付宝支付又出了问题。</p><p>所以想记录一下Hostwinds支付宝支付的相关问题及解决方法，顺便也记录一下关于Hostwinds VPS的更多内容。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="支付宝支付"><a href="#支付宝支付" class="headerlink" title="支付宝支付"></a>支付宝支付</h2><ul><li><p>我在第一次用支付宝支付（购买VPS）时的操作没有错误，但没有支付成功，最后发现原因是<strong>支付宝余额不足</strong>…暴露出自己的贫穷</p><ul><li><p>解决方法：支付宝充钱就行，然后再支付</p></li><li><p>当时是看了这篇文章才知道的</p><p>  <a href="https://www.vps234.com/usa-vps-hostwinds-alipay-paid-failed/" target="_blank" rel="noopener">https://www.vps234.com/usa-vps-hostwinds-alipay-paid-failed/</a></p><p>  这个网站中还是有很多关于VPS的知识的，挺好用的</p></li></ul></li><li><p>正常情况下，如果开通了支付宝自动支付，那之后每个月（其实是我们选择的付费周期，我选的是每月）到时间的话会自动支付，如果余额够，一般不会出问题的。</p></li><li><p>我们选了付费周期之后，比如说是按月付费，3月2日、4月2日……，这里的日期其实是最后期限（Due Date），我们是可以<strong>提前付款</strong>的</p><ul><li>在每一个付费周期内，大概中间的那天（比如3月19日）会生成Invoice（中文是发票、费用清单），订单生成后你就可以付费了。</li><li>这是后来和客服交流时才发现的，问客服之前我以为只能在3月2日、4月2日付费。</li></ul></li><li><p>这两天又遇到支付宝无法支付的问题，我的支付宝里是有钱的，暂时不知道真正原因（可能是由于我提前支付了）。</p><ul><li>然后我去问客服，客服说<strong>现在不要用支付宝的自动支付，而是手动支付</strong>，具体来说就是<strong>用Account Credits支付</strong>，在这个情景中的意思是存入金额，就像充Q币一样，然后用你充值后账号里的钱去支付。</li><li>很奇怪的是，充Account Credits时我也是用支付宝支付哈哈，这不是套娃了吗？<ul><li>虽然套娃了，但我用支付宝充值成功了，然后用Account Credits支付了这个无法用支付宝自动支付的Invoice。</li></ul></li></ul></li><li><p>Hostwinds中的<strong>支付宝不支持二次支付（Recurring Agreement），Alipay is unsupported for recurring payments</strong>，这是客服说的</p><ul><li><p>We do not support recurring Alipay payments. All invoices through Alipay must be manually processed each billing cycle.</p></li><li><p>这一点似乎可以比较合理地解释上一个事情</p><p>  不确定是什么原因（估计是因为我提前支付了）一个订单在用我的支付宝自动支付时出了问题。当我发现自动支付失败时，再去用支付宝支付，这就是二次支付了，客服说不支持。</p></li></ul></li><li><p>当账户里有余额，也开通了支付宝的自动付费的话。每个付费周期的付费会先使用账户里的余额。</p></li></ul><p><strong>总结来说，使用支付宝支付时注意以下几点</strong></p><ul><li>确保支付宝里余额充足</li><li>Hostwinds网站里显示的付费日期是最后期限（Due Date），可以在订单（Invoice）生成后手动支付</li><li>如果支付宝自动支付时付费失败，可以手动充值，然后用账户余额付费</li><li>当账户里有余额，也开通了支付宝的自动付费的话。每个付费周期的付费会先使用账户里的余额。</li></ul><h2 id="客服"><a href="#客服" class="headerlink" title="客服"></a>客服</h2><ul><li>Hostwinds的客服似乎是24小时在线的。我个人觉得客服质量和态度还不错，每次去问问题都会有人给我比较及时的回复。</li><li>如果我问的问题比较简单，客服会直接回答我；如果是稍难一点的问题，客服会Open一个Ticket，让对应部门的人解决我的问题</li></ul><h2 id="ISP-Block"><a href="#ISP-Block" class="headerlink" title="ISP Block"></a>ISP Block</h2><ul><li><p>客服说要想解决这个问题只能通过’Fix IP Block’，会给我们换一个IP</p><p>  出现ISP Block问题主要还是由于自己的操作不当</p></li><li><p>我刚开始使用<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">SS</a>时，VPS的IP和端口经常被封</p></li><li><p>后来经<a href="https://www.cnblogs.com/roadwide/" target="_blank" rel="noopener">@roadwide</a>推荐，使用了<a href="https://github.com/2dust/v2rayN" target="_blank" rel="noopener">v2RayN</a>，IP和端口就没有被封过</p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我前几天买了&lt;a href=&quot;https://www.hostwinds.com/&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="Hostwinds" scheme="https://chouxianyu.github.io/tags/Hostwinds/"/>
    
      <category term="VPS" scheme="https://chouxianyu.github.io/tags/VPS/"/>
    
      <category term="支付宝" scheme="https://chouxianyu.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/"/>
    
      <category term="ISP Block" scheme="https://chouxianyu.github.io/tags/ISP-Block/"/>
    
      <category term="v2rayN" scheme="https://chouxianyu.github.io/tags/v2rayN/"/>
    
      <category term="shadowsocks" scheme="https://chouxianyu.github.io/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>TensorBoard中HISTOGRAMS和DISTRIBUTIONS图形的含义</title>
    <link href="https://chouxianyu.github.io/2020/04/02/TensorBoard%E4%B8%ADHISTOGRAMS%E5%92%8CDISTRIBUTIONS%E5%9B%BE%E5%BD%A2%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <id>https://chouxianyu.github.io/2020/04/02/TensorBoard中HISTOGRAMS和DISTRIBUTIONS图形的含义/</id>
    <published>2020-04-02T12:50:25.000Z</published>
    <updated>2020-04-02T13:13:19.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前我都是用TensorBoard记录训练过程中的Loss、mAP等标量，很容易就知道TensorBoard里的SCALARS（标量）图是怎么看的（其中横纵轴的含义、Smoothing等）。</p><p>最近在尝试模型压缩，其中的一个步骤是对模型进行稀疏训练。</p><p>稀疏训练时需要记录模型中BN层的Gamma值的<strong>分布情况</strong>（取哪些值，这些值出现的次数/频度），这时用TensorBoard里的SCALARS之类的图就不合适了，而是应该用TensorBoard里的<strong>HISTOGRAMS</strong>（直方图）和<strong>DISTRIBUTIONS</strong>（暂未找到合适的译文）。</p><p>所以我昨天学习、了解了一点HISTOGRAMS和DISTRIBUTIONS，今天做了一部分简单记录，具体见下文。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>HISTOGRAMS和DISTRIBUTIONS这两种图的数据源是相同的，只是从不同的视角、以不同的方式来表示数据的分布情况。</p><p>下面先介绍HISTOGRAMS，再介绍DISTRIBUTIONS。</p><h2 id="HISTOGRAMS"><a href="#HISTOGRAMS" class="headerlink" title="HISTOGRAMS"></a>HISTOGRAMS</h2><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200402115112HISTOGRAMS.jpg" alt="HISTOGRAMS"></p><p>上图是TensorBoard生成的一个直方图（OFFEST模式），下面介绍图中几个元素的含义。</p><ul><li><strong>数据源</strong><ul><li>数据源是<strong>多</strong>个<strong>一维数组</strong><ul><li>也在别处看到有人说可以是多维数组，但会被压缩成一维数组，有兴趣的小伙伴可以具体研究一下</li><li>如果你只有1个数组，也是可以的</li></ul></li></ul></li><li><strong>当鼠标放在图上时出现的一条黑线和数字</strong><ul><li>鼠标放在图上出现的一条黑线，就对应数据源里的<strong>一个一维数组</strong></li><li>上图中显示的黑线对应我的第41个数组的所有元素（index为40，因为index从0开始计数的）的取值的分布情况</li></ul></li><li><strong>图下方的横轴</strong><ul><li>横轴的值和数组内元素的取值对应</li></ul></li><li><strong>图右方的纵轴</strong><ul><li>纵轴的值对应着是哪一个数组，或者说对应了数组的id、index（上边提到的40）</li></ul></li><li><strong>颜色</strong><ul><li>可以看到上图中的颜色是渐变的，靠上（id小）的颜色深，靠下（id大）的颜色浅</li></ul></li><li>上面的用词比较“学术化”，如果看不懂，就看下边的这个解释吧<ul><li>我的数据有99个数组，index从0到98，但右侧的纵轴值只标到了90</li><li>数组元素的分布范围是横轴上的数字，可以看出我的每个数组中的元素的取值大约集中在0到0.2，超过1.5的元素很少</li><li>我的第40个数组（说法不严谨，准确地说是id为40）中大约有505个元素的值为0.536左右</li></ul></li><li>如果还是不懂的话，建议先去看看直方图是什么</li></ul><h2 id="DISTRIBUTIONS"><a href="#DISTRIBUTIONS" class="headerlink" title="DISTRIBUTIONS"></a>DISTRIBUTIONS</h2><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200402115157DISTRIBUTIONS.jpg" alt="DISTRIBUTIONS"></p><p>把HISTOGRAMS搞懂后，这个图就很好懂的，因为这个图的数据源和HISTOGRAMS一样。</p><ul><li><strong>横轴</strong><ul><li>横轴是对应哪个数组</li></ul></li><li><strong>纵轴</strong><ul><li>数组中元素的取值</li></ul></li><li><strong>颜色</strong><ul><li>颜色深代表对应值出现的频数高</li></ul></li><li>如上图，我的99个数组从0到98，数组中元素的取值慢慢地趋近于0</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><h2 id="剪枝Github"><a href="#剪枝Github" class="headerlink" title="剪枝Github"></a>剪枝Github</h2><p><a href="https://github.com/tanluren/yolov3-channel-and-layer-pruning" target="_blank" rel="noopener">https://github.com/tanluren/yolov3-channel-and-layer-pruning</a></p><h2 id="HISTOGRAMS和DISTRIBUTIONS"><a href="#HISTOGRAMS和DISTRIBUTIONS" class="headerlink" title="HISTOGRAMS和DISTRIBUTIONS"></a>HISTOGRAMS和DISTRIBUTIONS</h2><p><a href="https://www.cnblogs.com/rainydayfmb/p/7944224.html" target="_blank" rel="noopener">https://www.cnblogs.com/rainydayfmb/p/7944224.html</a></p><p><a href="https://vimsky.com/article/3645.html" target="_blank" rel="noopener">https://vimsky.com/article/3645.html</a></p><p><a href="https://www.jianshu.com/p/8fdc43e48c86" target="_blank" rel="noopener">https://www.jianshu.com/p/8fdc43e48c86</a></p><p><a href="https://blog.csdn.net/wgj99991111/article/details/84708255" target="_blank" rel="noopener">https://blog.csdn.net/wgj99991111/article/details/84708255</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前我都是用TensorBoard记录训练过程中的Loss、mAP等标量，很容易就知道TensorBoard里的SCALARS（标量）图是怎
      
    
    </summary>
    
    
      <category term="深度学习" scheme="https://chouxianyu.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorBoard" scheme="https://chouxianyu.github.io/tags/TensorBoard/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu中百度网盘BaiduPCS-Go的安装及简单使用</title>
    <link href="https://chouxianyu.github.io/2020/04/01/Ubuntu%E4%B8%AD%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98BaiduPCS-Go%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://chouxianyu.github.io/2020/04/01/Ubuntu中百度网盘BaiduPCS-Go的安装及简单使用/</id>
    <published>2020-04-01T08:25:02.000Z</published>
    <updated>2020-04-02T12:57:18.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天用服务器训练模型时，服务器突然关机了，然后我的文件突然没了…昨天刚训练好的呀！</p><p>没办法，只能把数据再传到服务器上，但是文件很大，用Xftp传肯定很慢，所以用了百度云。（后来发现文件没有丢，重新挂载一下文件夹就好了，但我这个过程记录也写好了…）</p><p>下面记录了Ubuntu上如何安装<a href="https://github.com/iikira/BaiduPCS-Go" target="_blank" rel="noopener">BaiduPCS-Go</a>并用其下载百度网盘文件，安装成功后的具体使用方法请参考Github中的说明（Github里讲得比较详细了）。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ol><li><p>下载对应的<a href="https://github.com/iikira/BaiduPCS-Go/releases" target="_blank" rel="noopener">BaiduPCS-Go Release</a>，我用的下面这个，命令如下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/iikira/BaiduPCS-Go/releases/download/v3.6.1/BaiduPCS-Go-v3.6.1-linux-amd64.zip</span><br></pre></td></tr></table></figure><p> 注意是下载发行版，而不是git clone。</p></li><li><p>解压上一步下载到的zip到当前文件夹，命令如下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip BaiduPCS-Go-v3.6.1-linux-amd64.zip</span><br></pre></td></tr></table></figure></li><li><p>删除zip文件（也可以不删除该zip文件），命令如下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm BaiduPCS-Go-v3.6.1-linux-amd64.zip</span><br></pre></td></tr></table></figure></li><li><p>进入解压得到的文件夹，命令如下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd BaiduPCS-Go-v3.6.1-linux-amd64/</span><br></pre></td></tr></table></figure></li><li><p>查看文件夹中的内容（也可以不查看），命令如下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure></li><li><p><strong>运行BaiduPCS-Go，命令如下：</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaiduPCS-Go</span><br></pre></td></tr></table></figure></li><li><p>登录并进入百度云盘中的某个目录（步骤请参考Github中的说明）</p></li><li><p>下载文件<code>labels.zip</code>并保存至当前文件夹，命令如下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d labels.zip --saveto ./</span><br></pre></td></tr></table></figure></li></ol><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天用服务器训练模型时，服务器突然关机了，然后我的文件突然没了…昨天刚训练好的呀！&lt;/p&gt;
&lt;p&gt;没办法，只能把数据再传到服务器上，但是文件
      
    
    </summary>
    
    
      <category term="linux" scheme="https://chouxianyu.github.io/tags/linux/"/>
    
      <category term="BaiduPCS-Go" scheme="https://chouxianyu.github.io/tags/BaiduPCS-Go/"/>
    
  </entry>
  
  <entry>
    <title>IDEA滚轮控制字体大小</title>
    <link href="https://chouxianyu.github.io/2020/03/31/IDEA%E6%BB%9A%E8%BD%AE%E6%8E%A7%E5%88%B6%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/"/>
    <id>https://chouxianyu.github.io/2020/03/31/IDEA滚轮控制字体大小/</id>
    <published>2020-03-31T10:02:59.000Z</published>
    <updated>2020-03-31T10:03:47.028Z</updated>
    
    <content type="html"><![CDATA[<p>File-&gt;Setting-&gt;Editor-&gt;General，然后勾选Change font size (Zoom) with Ctrl+Mouse Wheel即可。</p><p>这个园子里洪<strong>水</strong>泛滥！</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;File-&amp;gt;Setting-&amp;gt;Editor-&amp;gt;General，然后勾选Change font size (Zoom) with Ctrl+Mouse Wheel即可。&lt;/p&gt;
&lt;p&gt;这个园子里洪&lt;strong&gt;水&lt;/strong&gt;泛滥！&lt;/p&gt;
&lt;hr&gt;

      
    
    </summary>
    
    
      <category term="IDEA" scheme="https://chouxianyu.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA插件搜索失败</title>
    <link href="https://chouxianyu.github.io/2020/03/31/IDEA%E6%8F%92%E4%BB%B6%E6%90%9C%E7%B4%A2%E5%A4%B1%E8%B4%A5/"/>
    <id>https://chouxianyu.github.io/2020/03/31/IDEA插件搜索失败/</id>
    <published>2020-03-31T04:30:14.000Z</published>
    <updated>2020-03-31T04:36:33.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天要做软件测试的实验：用JUnit做白盒测试，所以昨天想在IDEA里安装JUnitGenerator V2.0，遇到了<strong>在IDEA的插件库里搜不到任何插件</strong>的问题。</p><p>这个问题也有其他描述：</p><ul><li>Marketplace plugins are not loaded.</li><li>Search results are not loaded.Check the internet connection.</li><li>等等</li></ul><h1 id="问题详细描述"><a href="#问题详细描述" class="headerlink" title="问题详细描述"></a>问题详细描述</h1><p>IDEA搜索插件时搜不出结果，具体如下。</p><p>进入IDEA界面，点击File-&gt;Settings-&gt;Plugins-&gt;Marketplace。</p><p>（我的IDEA是IntelliJ IDEA Community Edition 2019.3.4 x64，其他版本可能界面不太一样，但不影响操作。）</p><p>不搜索时会出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Marketplace plugins are not loaded.</span><br></pre></td></tr></table></figure><p>搜索junit等任何插件，都会出现下面这个情况：</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200331041813IDEAMarketplaceFailed.jpg" alt="IDEAMarketplaceFailed"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Search results are not loaded.</span><br><span class="line">Check the internet connection.</span><br></pre></td></tr></table></figure><p>经查询和测试，可以通过以下步骤解决：</p><ol><li><p><strong>关闭电脑的防火墙</strong></p><p> 我的系统是Windows10，关闭了Windows Defender的所有防火墙。（怎么关闭防火墙应该不用讲吧）</p><p> <img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200331042012WindowsDefender防火墙.png" alt="WindowsDefender防火墙"></p></li><li><p><strong>在IDEA中添加Plugin Repository</strong></p><p> <img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200331041808IDEAManagePluginRepositories.jpg" alt="IDEAManagePluginRepositories"></p><p> 点击Manage Plugin Repositories，然后点击<code>+</code>按钮添加一个Plugin Repository，然后点击OK。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://plugins.jetbrains.com/</span><br></pre></td></tr></table></figure><p> <img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200331041800IDEAAddPluginRepository.jpg" alt="IDEAAddPluginRepository"></p><p> 然后就可以看到插件了。</p><p> <img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200331041819IDEAMarketplaceSucceeded.png" alt="IDEAMarketplaceSucceeded"></p></li></ol><p><strong>如果还是不行，试试重启IDEA或重启电脑。</strong></p><p><strong>如果再不行的话，试试下面的方法。</strong></p><h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><p>在昨天我这么做的时候，上面的方法是OK的。</p><p>在今天写博客重新尝试这个方法的时候，又发现这个方法不行。在研究的过程中，还是用这个方法的情况下，这个方法突然又可以了。</p><p><strong>也就是说，这个方法并不稳定……，原因..未知</strong></p><p>经过查询，还有其他方法，比如用管理员模式打开IDEA、关闭IDEA的版本更新提示和代理等方法，详细见参考链接吧。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><p><a href="https://blog.csdn.net/qq_33565047/article/details/89393432" target="_blank" rel="noopener">我参考的方法</a></p></li><li><p><a href="https://stackoverflow.com/questions/53599665/intellij-search-results-are-not-loaded-check-the-internet-connection?r=SearchResults" target="_blank" rel="noopener">用代理proxy</a></p><p>  应该是靠谱一点的方法。</p></li><li><p><a href="https://stackoverflow.com/questions/53599665/intellij-search-results-are-not-loaded-check-the-internet-connection?r=SearchResults" target="_blank" rel="noopener">管理员模式打开IDEA</a></p></li><li><p><a href="https://blog.csdn.net/itlijinping_zhang/article/details/104939089" target="_blank" rel="noopener">关闭IDEA的版本更新提示</a></p><p>  听起来不太靠谱。</p></li><li><p><a href="https://blog.csdn.net/shiwenbo1994/article/details/99193160?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">关闭User Secure Connection</a></p><p>  我这个版本的IDEA已经不能这样了</p><p>  这个链接里的第二个参考链接挺不错的，跟我讲的几个方法差不多。如果问题还没有解决，可以看看。</p></li></ul><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天要做软件测试的实验：用JUnit做白盒测试，所以昨天想在IDEA里安装JUnitGenerator V2.0，遇到了&lt;strong&gt;在I
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://chouxianyu.github.io/tags/Bug/"/>
    
      <category term="IDEA" scheme="https://chouxianyu.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>VSCode生成HTML代码模板</title>
    <link href="https://chouxianyu.github.io/2020/03/30/VSCode%E7%94%9F%E6%88%90HTML%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    <id>https://chouxianyu.github.io/2020/03/30/VSCode生成HTML代码模板/</id>
    <published>2020-03-30T10:30:53.000Z</published>
    <updated>2020-04-03T09:16:46.664Z</updated>
    
    <content type="html"><![CDATA[<p>用VSCode写HTML代码时，可以输入感叹号<code>!</code>，然后按<code>Tab</code>或<code>Enter</code>生成HTML代码的模板，估计SublimeText等编辑器也有这种功能。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用VSCode写HTML代码时，可以输入感叹号&lt;code&gt;!&lt;/code&gt;，然后按&lt;code&gt;Tab&lt;/code&gt;或&lt;code&gt;Enter&lt;/code&gt;生成HTML代码的模板，估计SublimeText等编辑器也有这种功能。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;作者：&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="VSCode" scheme="https://chouxianyu.github.io/tags/VSCode/"/>
    
      <category term="HTML" scheme="https://chouxianyu.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>linux中nohup运行python程序无后台输出</title>
    <link href="https://chouxianyu.github.io/2020/03/27/linux%E4%B8%ADnohup%E8%BF%90%E8%A1%8Cpython%E7%A8%8B%E5%BA%8F%E6%97%A0%E5%90%8E%E5%8F%B0%E8%BE%93%E5%87%BA/"/>
    <id>https://chouxianyu.github.io/2020/03/27/linux中nohup运行python程序无后台输出/</id>
    <published>2020-03-27T02:47:56.000Z</published>
    <updated>2020-03-27T02:48:36.857Z</updated>
    
    <content type="html"><![CDATA[<p>之前，我都是使用下面这条命令在linux上运行python程序，并将程序输出（print）的内容存放至文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python helloworld.py &gt; helloworld.log  2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>一般情况下，这条命令是可以将python程序的输出存放至指定文件的。</p><p>但我发现，用这条语句运行程序，偶尔会出现没有输出至指定文件（该文件被创建，但长时间不更新内容）的情况。</p><p>经过查询，我发现原因是：</p><p>默认情况下，python程序在执行时是有输出缓冲的（没有细究，个人理解是需要等输出的内容达到一定量才会输出，有兴趣的小伙伴可以研究一下）</p><p>解决该问题的一个方法是：使用python的<code>-u</code>参数，如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup python -u helloworld.py &gt; helloworld.log  2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前，我都是使用下面这条命令在linux上运行python程序，并将程序输出（print）的内容存放至文件。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
      <category term="linux" scheme="https://chouxianyu.github.io/tags/linux/"/>
    
      <category term="nohup" scheme="https://chouxianyu.github.io/tags/nohup/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch余弦学习率衰减</title>
    <link href="https://chouxianyu.github.io/2020/03/26/PyTorch%E4%BD%99%E5%BC%A6%E5%AD%A6%E4%B9%A0%E7%8E%87%E8%A1%B0%E5%87%8F/"/>
    <id>https://chouxianyu.github.io/2020/03/26/PyTorch余弦学习率衰减/</id>
    <published>2020-03-26T04:45:13.000Z</published>
    <updated>2020-03-26T04:51:45.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天用到了PyTorch里的CosineAnnealingLR，也就是用余弦函数进行学习率的衰减。</p><p>下面讲讲定义CosineAnnealingLR这个类的对象时输入的几个参数是什么，代码示例就不放了。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max, eta_min=<span class="number">0</span>, last_epoch=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><ul><li><p><code>optimizer</code></p><p>  需要进行学习率衰减的优化器变量</p></li><li><p><code>T_max</code></p><p>  Cosine是个周期函数嘛，这里的<code>T_max</code>就是这个周期的一半</p><p>  如果你将<code>T_max</code>设置为10，则学习率衰减的周期是20个epoch，其中前10个epoch从学习率的初值（也是最大值）下降到最低值，后10个epoch从学习率的最低值上升到最大值</p></li><li><p><code>eta_min</code></p><p>  学习率衰减时的最小值，默认值为0</p></li><li><p><code>last_epoch</code></p><p>  （上次训练）最后一个epoch的索引值，默认值为-1。</p><p>  我没有测试，猜测是：如果你将其设置为20，那定义出来的scheduler的第一次step就会到第21个epoch对应的学习率。</p></li></ul><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>我的参数是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># optimizer学习率初值为0.0005，100个epoch，从第1个epoch（索引为0）开始训练</span></span><br><span class="line">scheduler = lr_scheduler.CosineAnnealingLR(optimizer, T_max=<span class="number">10</span>, eta_min=<span class="number">5e-6</span>)</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://images.cnblogs.com/cnblogs_com/chouxianyu/1511971/o_200326042806CosineAnnealingLR.png" alt="CosineAnnealingLR"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://pytorch.org/docs/stable/optim.html?highlight=cosine#torch.optim.lr_scheduler.CosineAnnealingLR" target="_blank" rel="noopener">https://pytorch.org/docs/stable/optim.html?highlight=cosine#torch.optim.lr_scheduler.CosineAnnealingLR</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天用到了PyTorch里的CosineAnnealingLR，也就是用余弦函数进行学习率的衰减。&lt;/p&gt;
&lt;p&gt;下面讲讲定义CosineA
      
    
    </summary>
    
    
      <category term="PyTorch" scheme="https://chouxianyu.github.io/tags/PyTorch/"/>
    
      <category term="深度学习" scheme="https://chouxianyu.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>查看pip缓存路径</title>
    <link href="https://chouxianyu.github.io/2020/03/25/%E6%9F%A5%E7%9C%8Bpip%E7%BC%93%E5%AD%98%E8%B7%AF%E5%BE%84/"/>
    <id>https://chouxianyu.github.io/2020/03/25/查看pip缓存路径/</id>
    <published>2020-03-25T12:37:14.000Z</published>
    <updated>2020-03-25T12:53:52.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在安装python第三方库时，经常遇到下载速度慢的问题，即使换了源也不行。</p><p>好不容易下载到第三方库的文件（比如whl）后，我们可以把这些文件（比如whl）保存下来，然后可以发给同学、队友（团队开发时环境最好一致），还可以方便自己之后的重新安装。</p><p>那<code>pip</code>安装python第三方库时的缓存路径在哪呢？</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在安装一个库时，我注意到了<code>pip</code>的缓存路径，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Cxy\AppData\Local\pip\cache</span><br></pre></td></tr></table></figure><p>其中<code>Cxy</code>是我电脑的用户名，在你自己的电脑上的话需要改成你自己的用户名（比如<code>Administrator</code>）</p><p>这个路径应该是<code>pip</code>的默认缓存路径，这个路径应该也是可以修改的，有兴趣的小伙伴可以研究一下。</p><p>该路径下有两个文件夹，一个是<code>http</code>，一个是<code>wheels</code>；还有一个文件<code>selfcheck.json</code>。</p><p>我没研究文件夹<code>http</code>和文件<code>selfcheck.json</code>是什么，有兴趣的小伙伴可以研究一下。</p><p>经过查看，发现文件夹<code>wheels</code>里面是<code>.whl</code>文件，不过这个文件夹里面的目录结构和命名我们一般看不懂，我没有具体研究，有兴趣的小伙伴可以研究一下。</p><p>为了找到我们想要的<code>.whl</code>文件，我们在<code>wheels</code>文件夹里直接搜索就好了，不需要第三方库的全名，只需要输入第三方库名称中的一些词就行了。</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我们在安装python第三方库时，经常遇到下载速度慢的问题，即使换了源也不行。&lt;/p&gt;
&lt;p&gt;好不容易下载到第三方库的文件（比如whl）后，
      
    
    </summary>
    
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
      <category term="pip" scheme="https://chouxianyu.github.io/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>《算法笔记》阅读笔记</title>
    <link href="https://chouxianyu.github.io/2020/01/29/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>https://chouxianyu.github.io/2020/01/29/《算法笔记》阅读笔记/</id>
    <published>2020-01-29T05:46:25.000Z</published>
    <updated>2020-01-29T05:52:39.903Z</updated>
    
    <content type="html"><![CDATA[<p>这是之前刷PAT时看胡凡的《算法笔记》时做的一点笔记，后来没时间，就没看完。</p><p>emmm，刚开始看的内容都很基础。现在想想这样从头到尾地学确实没必要，可能当时的目标也和现在不一样吧。</p><h1 id="第一章-如何使用本书"><a href="#第一章-如何使用本书" class="headerlink" title="第一章 如何使用本书"></a>第一章 如何使用本书</h1><h2 id="在线评测系统"><a href="#在线评测系统" class="headerlink" title="在线评测系统"></a>在线评测系统</h2><p>PAT是“单点测试”。</p><h2 id="常见的评测结果"><a href="#常见的评测结果" class="headerlink" title="常见的评测结果"></a>常见的评测结果</h2><p>==整理常见的测评结果==</p><h1 id="第二章-C-C-快速入门"><a href="#第二章-C-C-快速入门" class="headerlink" title="第二章 C/C++快速入门"></a>第二章 C/C++快速入门</h1><p><code>cin</code>和<code>cout</code>消耗的时间比<code>scanf</code>和<code>printf</code>多得多，很多题目可能输入还没结束就超时了。……。请不要同时在一个程序中使用<code>cout</code>和<code>printf</code>，有时候会出问题。</p><p>头文件的<code>h</code>是<code>head</code>的缩写</p><p>C++向下兼容C</p><p>==整理一下向下兼容、向上兼容、向前、向后==</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><code>int</code>：$-2^{31}\sim+(2^{31}-1)$，大致范围是$-2\times10^9\sim2\times10^9$，绝对值在$10^9$以内的整数都可以定义成<code>int</code>型。</p><p><code>long long</code>：$-2^{63}\sim+(2^{63}-1)$，大致范围是$-9\times10^{18}\sim9\times10^{18}$。</p><p>浮点型都用<code>double</code>来存储。</p><p>小写字母比大写字母的ASCII码大32。</p><p><code>\0</code>代表空字符NULL，其ASCII码为0，请注意<code>\0</code>不是空格。</p><p>整型常量在赋值给布尔型变量时会自动转换为<code>true</code>（非零）和<code>false</code>（零）。</p><p>宏定义是直接将对应的部分替换，然后才进行编译和运行。</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>类似于<code>13:45:20</code>这种<code>hh:mm:ss</code>的时间需要输入，可以使用下边的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hh,mm,ss;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>,&amp;hh,&amp;mm,&amp;ss);</span><br></pre></td></tr></table></figure><p><code>scanf</code>的双引号内的内容其实就是整个输入，只不过把数据换成它们对应的格式符并把变量的地址按次序写在后面而已。</p><p>除了<code>%c</code>以外（<code>scanf</code>的<code>%c</code>格式是可以读入空格和换行的），<code>scanf</code>对其他格式符（如<code>%d</code>）的输入是以空白符（即空格、Tab）为结束判断标志的，字符数组使用<code>%s</code>读入的时候以空格和换行为读入结束的标志。</p><p><code>double</code>输出格式为<code>%f</code>，输入格式为<code>%lf</code>。</p><p><code>%.mf</code>保留$m$位小数，这个“保留”使用的是精度的“四舍六入五成双”规则。</p><p><code>getchar</code>可以识别换行符。</p><h2 id="常用数学函数"><a href="#常用数学函数" class="headerlink" title="常用数学函数"></a>常用数学函数</h2><p><code>round</code>函数，四舍五入。</p><p>==整理常用数学函数==</p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>条件判断中<code>n!=0</code>可以改为<code>n</code>，<code>n==0</code>可以改为<code>!n</code>。</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p><code>do...while</code>会先执行循环体一次，然后才去判断循环条件是否为真，这就使得<code>do...while</code>语句的实用性远不如<code>while</code>，因为用户碰到的大部分情况都需要能处理在某些数据下不允许进入循环的情况。</p><p>C语言中不允许随时定义临时变量，C++可以。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>数组大小必须是整数常量，不可以是变量。</p><p>如果只初始化了一维数组的一部分元素，后面未被初始化的元素将会由不同编译器内部实现的不同而被赋以不同的初值，而一般情况默认初值为0。所以可以通过下面的代码实现整个数组赋初值0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>递推可以分为顺推和逆推两种。</p><p>冒泡排序的本质在于交换，即<strong>每次通过交换的方式把当前剩余元素的最大值移动到一端，当剩余元素数量减少为0时，排序结束</strong>。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义含5个元素的数组</span></span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序（从小到大）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//5-1趟</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;<span class="comment">// 交换</span></span><br><span class="line">            <span class="keyword">int</span> temp=a[j];</span><br><span class="line">            a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">            a[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>可以把二维数组当作一维数组的每一个元素都是一个一维数组。</p><p>二维数组初始化（下面的代码中未被初始化的元素一般默认为0）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">6</span>]=&#123;&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">8</span>,<span class="number">4</span>&#125;,&#123;&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>如果数组大小较大（大概$10^6$级别），则需要定义在主函数外边。原因是函数内部申请的局部变量来自系统栈，允许申请的空间较小。而函数外部申请的全局变量来自静态存储区，允许申请的空间较大。</p><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><p>一般用函数<code>memset</code>和<code>fill</code>给数组中每一个元素赋相同的值。</p><p>使用<code>memset</code>需要使用头文件<code>string.h</code>，使用<code>fill</code>需要使用STL中的头文件<code>algorithm</code>。</p><p><code>memset</code>格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(数组名，值，<span class="keyword">sizeof</span>(数组名));</span><br></pre></td></tr></table></figure><p>只建议初学者使用<code>memset</code>赋0和-1，因为<code>memset</code>是按字节赋值，即对每个字节赋同样的值，0的二进制补码为全0，-1的二进制补码为全1，不容易弄错。如果要对数组赋其它值，请使用<code>fill</code>函数（但<code>memset</code>的执行速度快）。</p><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><p>可以使用字符串对字符数组进行初始化，但也仅限于初始化。</p><p><code>%c</code>能够识别空格和换行并将其输入，%s`通过空格或换行来识别一个字符串的结束。</p><p><code>gets</code>识别换行符作为输入结束（并会将其读取走），因此<code>scanf</code>完一个整数后，如果要用<code>gets</code>，需要用<code>getchar</code>接受整数后的换行符。</p><p>一维字符数组的末尾都会有一个<code>\0</code>，表示字符串的结束。使用<code>gets</code>和<code>scanf</code>时会自动在字符串后边添加<code>\0</code>，<code>puts</code>和<code>printf</code>也通过识别<code>\0</code>作为字符串的结尾来输出字符串。</p><h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><ul><li><p><code>strlen(字符数组1)</code></p><p>  得到字符数组<code>\0</code>前边的字符数</p></li><li><p><code>strcmp(字符数组1,字符数组2)</code></p><p>  按照字典序比较两个字符串的大小，返回一个整数（负数，0，正数），符号和<code>字符串1-字符串2</code>相同。</p></li><li><p><code>strcpy(字符数组1，字符数组2)</code></p><p>  把字符串2（第二个参数）赋值给字符串1（第一个参数）</p></li><li><p><code>strcat(字符数组1,字符数组2)</code></p><p>  把字符数组2接到字符数组1后边</p></li><li><p><code>sscanf(字符数组,&quot;%d&quot;,&amp;n)</code></p><p>  从字符数组中读</p></li><li><p><code>sprintf(字符数组,&quot;%d&quot;,n)</code></p><p>  往字符数组中写</p></li></ul><h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><p>数组作为参数时，参数中数组的第一维不需要填写长度（如果是二维数组，那么第二维需要填写长度），实际调用时</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一个<code>unsigned</code>类型的整数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1,p2;<span class="comment">//p1是int型指针 p2是int型变量</span></span><br><span class="line"><span class="keyword">int</span>* p1,*p2;<span class="comment">//p1和p2都是int型指针</span></span><br></pre></td></tr></table></figure><h2 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str1,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line">getline(<span class="built_in">cin</span>,str2);</span><br></pre></td></tr></table></figure><h2 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h2><p>由于计算机采用有限位的二进制编码，因此浮点数在计算机的存储并不总是精确的，于是需要引入一个极小的<strong>EPS</strong>来对这种误差进行修正。</p><p>==待补充：通过EPS进行浮点数的比较==</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li><p>时间复杂度</p><p>  <strong>在时间复杂度中，高等级的幂次会覆盖低等级的幂次。</strong>当有些算法实现较为复杂时，其常数会比较大，这时即便时间复杂度（一般讲时间复杂度是不带系数的）相同，其性能也会有较大差距。</p><p>  <strong>对一般的OJ系统来说，1秒能承受的运算次数大概是$10^7\sim10^8$</strong>，因此$O(n^2)$的算法当n的规模是1000时是可以承受的，而当n的规模为100000时则是不可承受的。</p></li><li><p>空间复杂度</p><p>  在一般的应用中，一般来说空间都是足够使用的（只要不开好几个$10^7$以上的数组即可，例如<code>int A[10000][10000]</code>的定义就是不合适的）。</p><p>  $O(1)$的空间复杂度指的是算法消耗的空间不随数据规模的增大而增大。</p><p>  考虑到空间一般够用，因此常常采用以空间换时间的策略。</p></li><li><p>编码复杂度</p><p>  编码复杂度是一个定性的概念，并没有什么量化的标准。</p></li></ul><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>黑盒测试是指：系统后台会准备若干组输入数据，然后将其输到提交的程序中，如果输出的结果与正确答案完全相同（字符串意义上的比较），那么就称通过了这道题的黑盒测试，否则会根据错误类型而返回不同的结果。</p><p>根据黑盒测试是否对每组输入数据都单独测试或是一次性测试所有测试数据，又可以分为<strong>单点测试</strong>和<strong>多点测试</strong>。</p><p>==整理多点测试的几种类型==</p><h1 id="第三章-入门篇（1）——入门模拟"><a href="#第三章-入门篇（1）——入门模拟" class="headerlink" title="第三章 入门篇（1）——入门模拟"></a>第三章 入门篇（1）——入门模拟</h1><p>无</p><h1 id="第四章-入门篇（2）——算法初步"><a href="#第四章-入门篇（2）——算法初步" class="headerlink" title="第四章 入门篇（2）——算法初步"></a>第四章 入门篇（2）——算法初步</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>选择排序是最简单的排序算法之一，本节介绍众多选择排序方法中最常用的<strong>简单选择排序</strong>。</p><p>将数组分为前后两部分：有序部分和无序部分。遍历数组，每次选择最小的值放在数组前边（有序部分），时间复杂度为$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义含5个元素的数组</span></span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序（从小到大）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> k=i;<span class="comment">// 默认当前待排序的第一个值是最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;<span class="comment">// 遍历之后的待排序的值，寻找最小值</span></span><br><span class="line">        <span class="keyword">if</span>(a[j]&lt;a[k])&#123;<span class="comment">// 更新待排序的最小值的下标</span></span><br><span class="line">            k=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="keyword">int</span> temp=a[i];</span><br><span class="line">    a[i]=a[k];</span><br><span class="line">    a[k]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序也是最简单的一类排序方法，本节主要介绍众多插入排序方法中最直观的<strong>直接插入排序</strong>。</p><p>把序列分为左右两部分：有序（左）和无序（右），从无序的部分取出元素，插入有序序列对应位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义含5个元素的数组</span></span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接插入排序（从小到大）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录要插入的值</span></span><br><span class="line"><span class="keyword">int</span> temp=a[i],j=i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有序元素后移</span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;temp&gt;a[j<span class="number">-1</span>])&#123;</span><br><span class="line">        a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出数组元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="散列的定义和整数散列"><a href="#散列的定义和整数散列" class="headerlink" title="散列的定义和整数散列"></a>散列的定义和整数散列</h2><p>散列（hash）是常见的算法思想之一，在很多程序中都会有意无意地使用到。</p><p>若给出$N$个正整数，再给出$M$个正整数，问这M个数中的每个数分别是在$N$个数出现过，其中$N,M\leq10^5$，且所有正整数均不超过$10^5$。</p><p>对这个问题，最直接的思路是：对每个欲查询的正整数$x$，遍历$N$个数，看是否有一个数与x相等。这种做法的时间复杂度是$O(NM)$，当$N$和$M$都很大（$10^5$级别）时，显然是无法承受的。</p><p>不妨用空间换时间，即设定一个<code>bool</code>型数组<code>hashTable[100010]</code>，其中<code>hashTable[x]==true</code>表示正整数$x$在$n$个正整数中出现过。这样就可以在一开始读入$N$个正整数时就对<code>hashTable</code>进行赋值，于是对于$M$个欲查询的数，就能直接通过<code>hashTable</code>判断出每个数是否出现过。显然这种做法的时间复杂度为$O(M+N)$。</p><p>同样的，如果题目要求统计次数而非是否出现，就把数组改成<code>int</code>型，这两个问题的解法都有一个特点，那就是直接把输入的数作为数组的下标来对这个数的性质进行统计（<strong>这种做法非常实用，请务必掌握</strong>）。这是一个很好的用空间换时间的策略，因为它将查询的复杂度降到了$O(1)$级别。</p><p>但这个策略暂时还有一个问题——上面的题目中出现的每个数都不会超过$10^5$，因此直接作为数组下标是可行的，但是如果输入可能是$10^9$大小的整数，或者甚至是一个字符串，就不能将它们直接作为数组下标了。</p><p>这时可以使用<strong>散列</strong>。一般来说，散列可以浓缩成“<strong>将元素通过一个函数转换为整数，使得改正数可以尽量唯一地代表这个元素</strong>”，其中把这个转换函数称为<strong>散列函数H</strong>，也就是说，如果元素在转换前为<code>key</code>，那么转换后就是一个整数<code>H(key)</code>。</p><p>对于<code>key</code>是整数的情况来说，<strong>常用的散列函数</strong>有直接定址法、平方取中法、除留余数法。</p><p><code>H(key1)==H(key2)</code>，这种情况叫作<strong>冲突</strong>。<strong>常用的解决冲突的方法</strong>有线性探查法、平方探查法和链地址法，其中前两种都计算了新的hash值，又称为开放定址法。</p><p>在写代码时，这种散列的功能可以用STL中的<code>map</code>代替。</p><h2 id="字符串hash初步"><a href="#字符串hash初步" class="headerlink" title="字符串hash初步"></a>字符串hash初步</h2><p>一个点$P$的坐标$(x,y)$可以用下面的散列函数进行处理：</p><p>$H(P)=x\times Range+y$，这样对数据范围内的任意两个整点$P_1$和$P_2$，$H(P_1)$都不会等于$H(P_2)$。</p><p><strong>字符串hash</strong>是指将一个字符串$S$转换为一个整数,使得该整数可以尽可能地唯一地代表字符串$S$。本节只讨论将字符串转换为唯一的整数。</p><p>假设字符串$S$由大写字母$A \sim Z$构成。在这个假设下，可以把26个大写字母视为$0\sim25$，进而转换为二十六进制，再转换为十进制，可得一唯一整数。只是$S$的长度并不可太长。</p><p>在上面的假设下，假如还可以由$a\sim z$组成，可以再把$a\sim z$对应为$26\sim51$，进而转换为五十二进制，再转换为十进制。</p><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治法（divide and conquer）将原问题划分成若干个规模较小而结构与原问题相同或相似的子问题，然后分别地解决这些子问题，最后合并子问题的解，即可得到原问题的解。</p><p>分治法的三个步骤：</p><ol><li><p>分解</p><p> 将原问题分解为若干和原问题拥有相同或相似结构的子问题</p></li><li><p>解决</p><p> 递归求解所有子问题。如果存在子问题的规模小到可以直接解决，就直接解决它。</p></li><li><p>合并</p><p> 将子问题的解合并成原问题的解。</p></li></ol><p>分治法分解出的子问题应当是相互独立、没有交叉的。如果存在两个子问题有相交部分，那么不应当使用分治法解决。</p><p>广义上来讲，分治法分解成的子问题个数只要大于0即可。从严格的定义上讲，一般把子问题的个数为1的情况称为<strong>减治</strong>，而把子问题个数大于1的情况称为分治。</p><p>分治法作为一种算法思想，既可以使用递归的手段去实现，也可以通过非递归的手段去实现。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归有两个重要概念：</p><ol><li>递归边界</li><li>递归式</li></ol><p>求$n$的阶乘体现了减治的思想，求$Fibonacci$数列的第$n$项体现了分治的思想。</p><p>一般把$1\sim n$这$n$个整数按某个顺序摆放的结果称为这$n$个整数的一个排列，而全排列指这$n$个整数能形成的所有排列。</p><p>$n$皇后问题就可以使用解决全排列问题的方法去解决。</p><p>如果在到达递归边界前的某层，由于一些事实导致已经不需要往任何一个子问题递归，就可以直接返回上一层。一般把这种做法称为<strong>回溯法</strong>。</p><h2 id="简单贪心"><a href="#简单贪心" class="headerlink" title="简单贪心"></a>简单贪心</h2><p><strong>贪心法</strong>是求解一类最优化问题的方法，它总是考虑当前状态下<strong>局部最优</strong>（或较优）的策略，来使全局的结果达到最优（或较优）。</p><p>可以使用贪心法的问题一定满足<strong>最优子结构</strong>性质，即一个问题的最优解可以由它的子问题的最优解构造出来。</p><p>要获得全局最优解，则要求中间的每步策略都是最优的，因此严谨使用贪心法来求解最优哈问题需要对采取的策略进行证明。证明的一般思路是使用反证法及数学归纳法，即假设策略不能导致最优解，然后通过一系列推导来得到矛盾，以此证明策略是最优的，最后用数学归纳法保证全局最优。不过对于平常来说，不太容易对想到的策略进行严谨的证明（贪心的证明往往比贪心本身更难），<strong>如果在想到某个似乎可行的策略，并且自己无法举出反例，那就勇敢地实现它。</strong></p><h2 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h2><p>区间不相交问题和区间选点</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找是基于有序序列的查找算法，二分查找的高效之处在于，每一步都可以去除当前区间中的一半元素，因此其时间复杂度是$O(logn)$。</p><p><strong>如果序列是严格递增</strong>：</p><ul><li>递归方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义含10个元素的升序数组</span></span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询key</span></span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">15</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, binarySearch(a, <span class="number">0</span>, n<span class="number">-1</span>, key));</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组arr的[left,right]中寻找key，找到则返回key在数组中的位置，否则返回-1</span></span><br><span class="line"><span class="comment">// 初始区间一般是[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区间正确</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="comment">// 设置区间中间下标</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到</span></span><br><span class="line">        <span class="keyword">if</span> (key == arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左半区间查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; arr[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右半区间查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid+<span class="number">1</span>,right, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区间错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>非递归方法</li></ul><p>在程序设计时，更多采用的是非递归的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义含10个元素的升序数组</span></span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询key</span></span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">19</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, binarySearch(a, <span class="number">0</span>, n<span class="number">-1</span>, key));</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组arr的[left,right]中寻找key，找到则返回key在数组中的位置，否则返回-1</span></span><br><span class="line"><span class="comment">// 初始区间一般是[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当可以形成区间时，进行查找</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="comment">// 设置区间中间下标</span></span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到，返回对应位置</span></span><br><span class="line">        <span class="keyword">if</span> (key==arr[mid])&#123;</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key在左半区间，更新right</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;arr[mid])&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key在右半区间，更新left</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未寻找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果序列是严格递减</strong>：</p><p>只需要把<code>if(key&lt;arr[mid])</code>语句中的<code>&lt;</code>改成<code>&gt;</code>就好了。</p><p><strong>如果序列是非严格递增（即递增，但元素可能重复）</strong>：</p><p>如何求出序列中第一个大于等于<code>key</code>的元素的位置<code>L</code>和第一个大于<code>key</code>的元素的位置<code>R</code>，这样元素<code>key</code>在序列中的存在区间就是左闭右开区间$[L,R)$。显然，如果序列中没有<code>key</code>，那么<code>L</code>和<code>R</code>可以理解为假设序列中存在<code>key</code>，<code>key</code>应该在的位置。</p><p>上面有两个问题：</p><ul><li>求<code>L</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义含10个元素的升序数组</span></span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询key</span></span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lowerBound(a, <span class="number">0</span>, n, key));</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在非严格递增数组arr的[left,right]中寻找第一个大于等于key的值的位置，如果不存在则返回该值应该在的位置（即最后一个元素后边）</span></span><br><span class="line"><span class="comment">// 初始区间一般是[0,n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当left==right时，刚好求出大于等于key的第一个数字的位置</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="comment">// 设置区间中间下标</span></span><br><span class="line">        <span class="comment">//mid = (left + right) / 2;</span></span><br><span class="line">        mid=left+(right-left)/<span class="number">2</span>;    <span class="comment">// 避免溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// key在左半区间，更新right</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;=arr[mid])&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key在右半区间，更新left</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未寻找到</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>求<code>R</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upperBound</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义含10个元素的升序数组</span></span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询key</span></span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, upperBound(a, <span class="number">0</span>, n, key));</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在非严格递增数组arr的[left,right]中寻找第一个大于key的值的位置，如果不存在则返回该值应该在的位置（即最后一个元素后边）</span></span><br><span class="line"><span class="comment">// 初始区间一般是[0,n]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upperBound</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当left==right时，刚好求出大于等于key的第一个数字的位置</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="comment">// 设置区间中间下标</span></span><br><span class="line">        <span class="comment">//mid = (left + right) / 2;</span></span><br><span class="line">        mid=left+(right-left)/<span class="number">2</span>;    <span class="comment">// 避免溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// key在左半区间，更新right</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;arr[mid])&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key在右半区间，更新left</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未寻找到</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比<code>lowerBound</code>和<code>upperBound</code>的代码可知，<code>upperBound</code>函数只是把代码中的<code>if(key&lt;=arr[mid])</code>改成<code>if(key&lt;arr[mid])</code>，其他完全相同，这启发我们去寻找它们的共同点。</p><p>可以发现，两者都在解决这样一个问题：寻找有序序列中第一个满足某条件<code>C</code>的元素的位置。这是一个非常重要且经典的问题，平常能碰到的大部分二分法问题都可以归结于这个问题。显然，所谓的条件<code>C</code>在序列中一定是从左到右先不满足，然后满足的。该类问题代码模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(C成立)&#123;</span><br><span class="line">        right=mid;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若想寻找<strong>最后一个</strong>满足条件<code>C</code>的元素的位置，则可以先求第一个满足条件<code>!c</code>的元素的位置，然后将该位置减1即可。</p><p>如果目的是判断有序序列中是否存在满足某条件的元素，使用刚开始的二分最合适。</p><h2 id="二分法的其他应用"><a href="#二分法的其他应用" class="headerlink" title="二分法的其他应用"></a>二分法的其他应用</h2><p>上面讲了二分查找，事实上二分法的应用远不止如此。</p><h3 id="估算-sqrt-2"><a href="#估算-sqrt-2" class="headerlink" title="估算$\sqrt{2}$"></a>估算$\sqrt{2}$</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 误差</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">10e-5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">double</span> left=<span class="number">1</span>,right=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逼近2^0.5</span></span><br><span class="line">    <span class="keyword">while</span>(right-left&gt;eps)&#123;</span><br><span class="line">        <span class="comment">// 计算mid</span></span><br><span class="line">        mid = left+(right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>&gt;mid * mid)&#123;</span><br><span class="line">            left=mid;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">2</span>&lt;mid*mid)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    mid = left+(right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>,mid);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装水问题"><a href="#装水问题" class="headerlink" title="装水问题"></a>装水问题</h3><p>有一个侧面看上去是半圆的储水装置，该半圆的半径是$R$，要求往里面装入高度为$h$的水，使其在侧面看去的面积与半圆面积的比例恰好为$r$。已知$r$，求$h$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一些常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">10e-5</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> r=<span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> R=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.1415926535</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">double</span> left=<span class="number">0</span>,right=R;</span><br><span class="line">    <span class="keyword">double</span> mid,alpha,L,S1,S2=pi*R*R/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逼近</span></span><br><span class="line">    <span class="keyword">while</span>(right-left&gt;eps)&#123;</span><br><span class="line">        <span class="comment">// 计算mid</span></span><br><span class="line">        mid = left+(right - left) / <span class="number">2</span>;</span><br><span class="line">        alpha=<span class="number">2</span>*<span class="built_in">acos</span>((R-mid)/R);</span><br><span class="line">        L = <span class="number">2</span> * <span class="built_in">sqrt</span>(R * R - (R - mid) * (R - mid));</span><br><span class="line">        S1 = alpha*R*R/<span class="number">2</span>-L*(R-mid)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r&gt;S1/S2)&#123;</span><br><span class="line">            left=mid;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; S1 / S2)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>,mid);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="木棒切割"><a href="#木棒切割" class="headerlink" title="木棒切割"></a>木棒切割</h3><p>给出$N$根木棒，长度均已知，现在希望通过切割它们来得到至少$K$段长度相等的木棒（长度必须是整数），问这些长度相等的木棒最长能有多长。例如对于三根长度分别为10、24、15的木棒来说，假设$K=7$，即至少需要7段长度相等的木棒，那么可以得到的最大长度为6（$(10+24+15)/7=7$），在这种情况下，第一根木棒可以提供$10/6=1$段、第二根木棒可以提供$24/6=4$根、第三根木棒可以提供$15/6=2$根，达到了7根的要求。</p><p>对于这道题，我们可以注意到一个结论：如果长度相等的木棒的长度$L$越长，那么热可以得到的木棒段数$k$越小。</p><p>==P142==</p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是之前刷PAT时看胡凡的《算法笔记》时做的一点笔记，后来没时间，就没看完。&lt;/p&gt;
&lt;p&gt;emmm，刚开始看的内容都很基础。现在想想这样从头到尾地学确实没必要，可能当时的目标也和现在不一样吧。&lt;/p&gt;
&lt;h1 id=&quot;第一章-如何使用本书&quot;&gt;&lt;a href=&quot;#第一章-如
      
    
    </summary>
    
    
      <category term="算法" scheme="https://chouxianyu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LOAD DATA INFILE读取CSV中一千万条数据至mysql</title>
    <link href="https://chouxianyu.github.io/2019/11/02/LOAD-DATA-INFILE%E8%AF%BB%E5%8F%96CSV%E4%B8%AD%E4%B8%80%E5%8D%83%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E8%87%B3mysql/"/>
    <id>https://chouxianyu.github.io/2019/11/02/LOAD-DATA-INFILE读取CSV中一千万条数据至mysql/</id>
    <published>2019-11-01T16:00:34.000Z</published>
    <updated>2019-11-10T08:51:19.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h1><p>构建一个关系模式和课本中的关系<code>movies(title,year,length,movietype,studioname,producerC)</code>一样的关系，名称自定，在这个关系中插入1000万条记录。</p><p>注：关系<code>movies</code>的主键为<code>(title,year)</code>。</p><p>要求如下：</p><ol><li>在尽可能短的时间内完成；</li><li>只允许使用原生的SQL，不允许将SQL作为嵌入语言，也不允许使用其他语言如C#、Python等来完成；</li><li>提交你的详细解决方案和结果。</li></ol><p>本文利用<code>LOAD DATA INFILE</code>将包含一千万条数据的CSV文件存入mysql。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>除了<code>newcsv.py</code>，其他命令均为cmd命令。</p><h2 id="生成包含1千万条数据的CSV文件"><a href="#生成包含1千万条数据的CSV文件" class="headerlink" title="生成包含1千万条数据的CSV文件"></a>生成包含1千万条数据的CSV文件</h2><p>用python生成与关系movies结构相同的包含1千万条数据的CSV文件。</p><p><code>newcsv.py</code>如下：</p><p>该程序大概耗时18秒。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># num_value条数据</span></span><br><span class="line">num_value = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始计时</span></span><br><span class="line">time_start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r'C:\ProgramData\MySQL\MySQL Server 8.0\Uploads\bigdata.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow([<span class="string">'title'</span>, <span class="string">'year'</span>, <span class="string">'length'</span>, <span class="string">'movieType'</span>, <span class="string">'studioName'</span>, <span class="string">'producerC'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num_value+<span class="number">1</span>):</span><br><span class="line">        f_csv.writerow([<span class="string">'GoGoGo'</span>, i, <span class="number">120</span>, <span class="string">'sicFic'</span>, <span class="string">'MGM'</span>, <span class="number">100</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束计时</span></span><br><span class="line">time_end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出耗费时间（秒）</span></span><br><span class="line">print(<span class="string">'Time Cost：'</span>, time_end - time_start)</span><br></pre></td></tr></table></figure><h2 id="登录mysql"><a href="#登录mysql" class="headerlink" title="登录mysql"></a>登录mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure><p>上面<code>root</code>是我的mysql用户名，<code>123456</code>是我的mysql密码。</p><h2 id="进入数据库moviesdb"><a href="#进入数据库moviesdb" class="headerlink" title="进入数据库moviesdb"></a>进入数据库moviesdb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use moviesdb;</span><br></pre></td></tr></table></figure><h2 id="创建关系mymovies"><a href="#创建关系mymovies" class="headerlink" title="创建关系mymovies"></a>创建关系mymovies</h2><p>只复制关系movies的结构，并不复制其数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mymovies LIKE movies;</span><br></pre></td></tr></table></figure><h2 id="将CSV文件存入数据库"><a href="#将CSV文件存入数据库" class="headerlink" title="将CSV文件存入数据库"></a>将CSV文件存入数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE &apos;C:/ProgramData/MySQL/MySQL Server 8.0/Uploads/bigdata.csv&apos; INTO TABLE mymovies FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\n&apos; IGNORE 1 ROWS;</span><br></pre></td></tr></table></figure><p>我的电脑上，该文件存入mysql耗时862.646秒，大概14分钟，如下图所示：</p><p><img src="https://img2018.cnblogs.com/blog/1478490/201911/1478490-20191101235840939-2109334428.jpg" alt="LOADDATAINFILE插入一千万条数据结果"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/freefei/p/7679991.html" target="_blank" rel="noopener">https://www.cnblogs.com/freefei/p/7679991.html</a></p><p><a href="https://blog.csdn.net/qq_22855325/article/details/76087138" target="_blank" rel="noopener">https://blog.csdn.net/qq_22855325/article/details/76087138</a></p><p><a href="https://blog.csdn.net/weixin_44595372/article/details/88723191" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44595372/article/details/88723191</a></p><p><a href="https://zhidao.baidu.com/question/185665472.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/185665472.html</a></p><p><a href="https://www.cnblogs.com/zhangjpn/p/6231662.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangjpn/p/6231662.html</a></p><p><a href="https://www.cnblogs.com/wangcp-2014/p/8038683.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangcp-2014/p/8038683.html</a></p><p><a href="https://blog.csdn.net/gb4215287/article/details/82669785" target="_blank" rel="noopener">https://blog.csdn.net/gb4215287/article/details/82669785</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;作业要求&quot;&gt;&lt;a href=&quot;#作业要求&quot; class=&quot;headerlink&quot; title=&quot;作业要求&quot;&gt;&lt;/a&gt;作业要求&lt;/h1&gt;&lt;p&gt;构建一个关系模式和课本中的关系&lt;code&gt;movies(title,year,length,movietype,studio
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://chouxianyu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="python" scheme="https://chouxianyu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>L1与L2正则化</title>
    <link href="https://chouxianyu.github.io/2019/10/22/L1%E4%B8%8EL2%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>https://chouxianyu.github.io/2019/10/22/L1与L2正则化/</id>
    <published>2019-10-21T17:06:13.000Z</published>
    <updated>2019-10-21T17:06:59.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><p>机器学习中，如果参数过多、模型过于复杂，容易造成过拟合。</p><h1 id="结构风险最小化原理"><a href="#结构风险最小化原理" class="headerlink" title="结构风险最小化原理"></a>结构风险最小化原理</h1><p>在经验风险最小化（训练误差最小化）的基础上，尽可能采用简单的模型，以提高模型泛化预测精度。</p><h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><p>为了避免过拟合，最常用的一种方法是使用正则化，例如L1和L2正则化。</p><p>所谓的正则化，就是在原来损失函数的基础上，加了一些正则化项，或者叫做模型复杂度惩罚项。</p><h1 id="L2正则化"><a href="#L2正则化" class="headerlink" title="L2正则化"></a>L2正则化</h1><p>L2正则化即：$L=E_{in}+\lambda\sum_j\omega^2_j$，其中，$E_{in}$是原来的损失函数；$\lambda$是正则化参数，可调整；$\omega_j$是参数。</p><p>由上可知，正则化是为了限制参数过多，避免模型过于复杂。因此，我们可以令高阶部分的权重$\omega$为0，这样就相当于从高阶转换为低阶。然而，这是个NP难问题，将其适度简化为：$\sum_j\omega_j^2≤C$，令$\omega_j$的平方和小于$C$。这时，我们的目标就转换为：令$E_{in}$最小，但是要遵循$w$平方和小于$C$的条件，如下图所示：</p><p><img src="https://img-blog.csdn.net/20180621085848886?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlZF9zdG9uZTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h1 id="L1正则化"><a href="#L1正则化" class="headerlink" title="L1正则化"></a>L1正则化</h1><p>L1正则化和L2正则化相似：$L=E_{in}+\lambda\sum_j|\omega_j|$，同样地，图形如下：</p><p><img src="https://img-blog.csdn.net/20180621090333882?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3JlZF9zdG9uZTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h1 id="L1与L2正则化"><a href="#L1与L2正则化" class="headerlink" title="L1与L2正则化"></a>L1与L2正则化</h1><p>满足正则化条件，实际上是求解上面图中红色形状与蓝色椭圆的交点，即同时满足限定条件和$E_{in}$最小化。</p><p>对于L2来说，限定区域是圆，这样得到的解$\omega_1$或$\omega_2$（以二元为例）为0的概率很小，且很大概率是非零的。</p><p>对于L1来说，限定区域是正方形，方形与蓝色区域相交的交点是顶点的概率很大，这从视觉和常识上来看是很容易理解的。也就是说，正方形的凸点会更接近 $E_{in}$最优解对应的$\omega$位置，而凸点处必有$\omega_1$或$\omega_2$为0。这样，得到的解$\omega_1$或$\omega_2$为零的概率就很大了。所以，L1正则化的解具有稀疏性。</p><p>扩展到高维，同样的道理，L2的限定区域是平滑的，与中心点等距；而 L1 的限定区域是包含凸点的，尖锐的。这些凸点更接近$E_{in}$的最优解位置，而在这些凸点上，很多$\omega_j$为0。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.jianshu.com/p/76368eba9c90" target="_blank" rel="noopener">https://www.jianshu.com/p/76368eba9c90</a></p><p><a href="https://segmentfault.com/a/1190000014680167?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014680167?utm_source=tag-newest</a></p><p><a href="https://blog.csdn.net/red_stone1/article/details/80755144" target="_blank" rel="noopener">https://blog.csdn.net/red_stone1/article/details/80755144</a></p><hr><p>作者：<a href="https://github.com/chouxianyu" target="_blank" rel="noopener">@臭咸鱼</a></p><p>转载请注明出处：<a href="https://www.cnblogs.com/chouxianyu/" target="_blank" rel="noopener">https://www.cnblogs.com/chouxianyu/</a></p><p>欢迎讨论和交流!</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;过拟合&quot;&gt;&lt;a href=&quot;#过拟合&quot; class=&quot;headerlink&quot; title=&quot;过拟合&quot;&gt;&lt;/a&gt;过拟合&lt;/h1&gt;&lt;p&gt;机器学习中，如果参数过多、模型过于复杂，容易造成过拟合。&lt;/p&gt;
&lt;h1 id=&quot;结构风险最小化原理&quot;&gt;&lt;a href=&quot;#结构风险
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://chouxianyu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
